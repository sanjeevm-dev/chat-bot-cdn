(function () {
  "use strict";
  var commonjsGlobal =
    typeof globalThis < "u"
      ? globalThis
      : typeof window < "u"
      ? window
      : typeof global < "u"
      ? global
      : typeof self < "u"
      ? self
      : {};
  function getDefaultExportFromCjs$1(U) {
    return U &&
      U.__esModule &&
      Object.prototype.hasOwnProperty.call(U, "default")
      ? U.default
      : U;
  }
  var jsxRuntime = { exports: {} },
    reactJsxRuntime_production = {};
  /**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var hasRequiredReactJsxRuntime_production;
  function requireReactJsxRuntime_production() {
    if (hasRequiredReactJsxRuntime_production)
      return reactJsxRuntime_production;
    hasRequiredReactJsxRuntime_production = 1;
    var U = Symbol.for("react.transitional.element"),
      j = Symbol.for("react.fragment");
    function V(B, q, $) {
      var H = null;
      if (
        ($ !== void 0 && (H = "" + $),
        q.key !== void 0 && (H = "" + q.key),
        "key" in q)
      ) {
        $ = {};
        for (var G in q) G !== "key" && ($[G] = q[G]);
      } else $ = q;
      return (
        (q = $.ref),
        { $$typeof: U, type: B, key: H, ref: q !== void 0 ? q : null, props: $ }
      );
    }
    return (
      (reactJsxRuntime_production.Fragment = j),
      (reactJsxRuntime_production.jsx = V),
      (reactJsxRuntime_production.jsxs = V),
      reactJsxRuntime_production
    );
  }
  var hasRequiredJsxRuntime;
  function requireJsxRuntime() {
    return (
      hasRequiredJsxRuntime ||
        ((hasRequiredJsxRuntime = 1),
        (jsxRuntime.exports = requireReactJsxRuntime_production())),
      jsxRuntime.exports
    );
  }
  var jsxRuntimeExports = requireJsxRuntime(),
    client = { exports: {} },
    reactDomClient_production = {},
    scheduler = { exports: {} },
    scheduler_production = {};
  /**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var hasRequiredScheduler_production;
  function requireScheduler_production() {
    return (
      hasRequiredScheduler_production ||
        ((hasRequiredScheduler_production = 1),
        (function (U) {
          function j(Te, xe) {
            var He = Te.length;
            Te.push(xe);
            e: for (; 0 < He; ) {
              var Je = (He - 1) >>> 1,
                oe = Te[Je];
              if (0 < q(oe, xe)) (Te[Je] = xe), (Te[He] = oe), (He = Je);
              else break e;
            }
          }
          function V(Te) {
            return Te.length === 0 ? null : Te[0];
          }
          function B(Te) {
            if (Te.length === 0) return null;
            var xe = Te[0],
              He = Te.pop();
            if (He !== xe) {
              Te[0] = He;
              e: for (var Je = 0, oe = Te.length, De = oe >>> 1; Je < De; ) {
                var Ge = 2 * (Je + 1) - 1,
                  pe = Te[Ge],
                  Ye = Ge + 1,
                  Qe = Te[Ye];
                if (0 > q(pe, He))
                  Ye < oe && 0 > q(Qe, pe)
                    ? ((Te[Je] = Qe), (Te[Ye] = He), (Je = Ye))
                    : ((Te[Je] = pe), (Te[Ge] = He), (Je = Ge));
                else if (Ye < oe && 0 > q(Qe, He))
                  (Te[Je] = Qe), (Te[Ye] = He), (Je = Ye);
                else break e;
              }
            }
            return xe;
          }
          function q(Te, xe) {
            var He = Te.sortIndex - xe.sortIndex;
            return He !== 0 ? He : Te.id - xe.id;
          }
          if (
            ((U.unstable_now = void 0),
            typeof performance == "object" &&
              typeof performance.now == "function")
          ) {
            var $ = performance;
            U.unstable_now = function () {
              return $.now();
            };
          } else {
            var H = Date,
              G = H.now();
            U.unstable_now = function () {
              return H.now() - G;
            };
          }
          var Y = [],
            Q = [],
            X = 1,
            Z = null,
            te = 3,
            ne = !1,
            ae = !1,
            se = !1,
            fe = !1,
            ce = typeof setTimeout == "function" ? setTimeout : null,
            ue = typeof clearTimeout == "function" ? clearTimeout : null,
            he = typeof setImmediate < "u" ? setImmediate : null;
          function me(Te) {
            for (var xe = V(Q); xe !== null; ) {
              if (xe.callback === null) B(Q);
              else if (xe.startTime <= Te)
                B(Q), (xe.sortIndex = xe.expirationTime), j(Y, xe);
              else break;
              xe = V(Q);
            }
          }
          function ve(Te) {
            if (((se = !1), me(Te), !ae))
              if (V(Y) !== null) (ae = !0), ge || ((ge = !0), Le());
              else {
                var xe = V(Q);
                xe !== null && je(ve, xe.startTime - Te);
              }
          }
          var ge = !1,
            Ee = -1,
            Ce = 5,
            Re = -1;
          function Ae() {
            return fe ? !0 : !(U.unstable_now() - Re < Ce);
          }
          function be() {
            if (((fe = !1), ge)) {
              var Te = U.unstable_now();
              Re = Te;
              var xe = !0;
              try {
                e: {
                  (ae = !1), se && ((se = !1), ue(Ee), (Ee = -1)), (ne = !0);
                  var He = te;
                  try {
                    t: {
                      for (
                        me(Te), Z = V(Y);
                        Z !== null && !(Z.expirationTime > Te && Ae());

                      ) {
                        var Je = Z.callback;
                        if (typeof Je == "function") {
                          (Z.callback = null), (te = Z.priorityLevel);
                          var oe = Je(Z.expirationTime <= Te);
                          if (
                            ((Te = U.unstable_now()), typeof oe == "function")
                          ) {
                            (Z.callback = oe), me(Te), (xe = !0);
                            break t;
                          }
                          Z === V(Y) && B(Y), me(Te);
                        } else B(Y);
                        Z = V(Y);
                      }
                      if (Z !== null) xe = !0;
                      else {
                        var De = V(Q);
                        De !== null && je(ve, De.startTime - Te), (xe = !1);
                      }
                    }
                    break e;
                  } finally {
                    (Z = null), (te = He), (ne = !1);
                  }
                  xe = void 0;
                }
              } finally {
                xe ? Le() : (ge = !1);
              }
            }
          }
          var Le;
          if (typeof he == "function")
            Le = function () {
              he(be);
            };
          else if (typeof MessageChannel < "u") {
            var Fe = new MessageChannel(),
              Me = Fe.port2;
            (Fe.port1.onmessage = be),
              (Le = function () {
                Me.postMessage(null);
              });
          } else
            Le = function () {
              ce(be, 0);
            };
          function je(Te, xe) {
            Ee = ce(function () {
              Te(U.unstable_now());
            }, xe);
          }
          (U.unstable_IdlePriority = 5),
            (U.unstable_ImmediatePriority = 1),
            (U.unstable_LowPriority = 4),
            (U.unstable_NormalPriority = 3),
            (U.unstable_Profiling = null),
            (U.unstable_UserBlockingPriority = 2),
            (U.unstable_cancelCallback = function (Te) {
              Te.callback = null;
            }),
            (U.unstable_forceFrameRate = function (Te) {
              0 > Te || 125 < Te
                ? console.error(
                    "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                  )
                : (Ce = 0 < Te ? Math.floor(1e3 / Te) : 5);
            }),
            (U.unstable_getCurrentPriorityLevel = function () {
              return te;
            }),
            (U.unstable_next = function (Te) {
              switch (te) {
                case 1:
                case 2:
                case 3:
                  var xe = 3;
                  break;
                default:
                  xe = te;
              }
              var He = te;
              te = xe;
              try {
                return Te();
              } finally {
                te = He;
              }
            }),
            (U.unstable_requestPaint = function () {
              fe = !0;
            }),
            (U.unstable_runWithPriority = function (Te, xe) {
              switch (Te) {
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                  break;
                default:
                  Te = 3;
              }
              var He = te;
              te = Te;
              try {
                return xe();
              } finally {
                te = He;
              }
            }),
            (U.unstable_scheduleCallback = function (Te, xe, He) {
              var Je = U.unstable_now();
              switch (
                (typeof He == "object" && He !== null
                  ? ((He = He.delay),
                    (He = typeof He == "number" && 0 < He ? Je + He : Je))
                  : (He = Je),
                Te)
              ) {
                case 1:
                  var oe = -1;
                  break;
                case 2:
                  oe = 250;
                  break;
                case 5:
                  oe = 1073741823;
                  break;
                case 4:
                  oe = 1e4;
                  break;
                default:
                  oe = 5e3;
              }
              return (
                (oe = He + oe),
                (Te = {
                  id: X++,
                  callback: xe,
                  priorityLevel: Te,
                  startTime: He,
                  expirationTime: oe,
                  sortIndex: -1,
                }),
                He > Je
                  ? ((Te.sortIndex = He),
                    j(Q, Te),
                    V(Y) === null &&
                      Te === V(Q) &&
                      (se ? (ue(Ee), (Ee = -1)) : (se = !0), je(ve, He - Je)))
                  : ((Te.sortIndex = oe),
                    j(Y, Te),
                    ae || ne || ((ae = !0), ge || ((ge = !0), Le()))),
                Te
              );
            }),
            (U.unstable_shouldYield = Ae),
            (U.unstable_wrapCallback = function (Te) {
              var xe = te;
              return function () {
                var He = te;
                te = xe;
                try {
                  return Te.apply(this, arguments);
                } finally {
                  te = He;
                }
              };
            });
        })(scheduler_production)),
      scheduler_production
    );
  }
  var hasRequiredScheduler;
  function requireScheduler() {
    return (
      hasRequiredScheduler ||
        ((hasRequiredScheduler = 1),
        (scheduler.exports = requireScheduler_production())),
      scheduler.exports
    );
  }
  var react = { exports: {} },
    react_production = {};
  /**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var hasRequiredReact_production;
  function requireReact_production() {
    if (hasRequiredReact_production) return react_production;
    hasRequiredReact_production = 1;
    var U = Symbol.for("react.transitional.element"),
      j = Symbol.for("react.portal"),
      V = Symbol.for("react.fragment"),
      B = Symbol.for("react.strict_mode"),
      q = Symbol.for("react.profiler"),
      $ = Symbol.for("react.consumer"),
      H = Symbol.for("react.context"),
      G = Symbol.for("react.forward_ref"),
      Y = Symbol.for("react.suspense"),
      Q = Symbol.for("react.memo"),
      X = Symbol.for("react.lazy"),
      Z = Symbol.iterator;
    function te(oe) {
      return oe === null || typeof oe != "object"
        ? null
        : ((oe = (Z && oe[Z]) || oe["@@iterator"]),
          typeof oe == "function" ? oe : null);
    }
    var ne = {
        isMounted: function () {
          return !1;
        },
        enqueueForceUpdate: function () {},
        enqueueReplaceState: function () {},
        enqueueSetState: function () {},
      },
      ae = Object.assign,
      se = {};
    function fe(oe, De, Ge) {
      (this.props = oe),
        (this.context = De),
        (this.refs = se),
        (this.updater = Ge || ne);
    }
    (fe.prototype.isReactComponent = {}),
      (fe.prototype.setState = function (oe, De) {
        if (typeof oe != "object" && typeof oe != "function" && oe != null)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, oe, De, "setState");
      }),
      (fe.prototype.forceUpdate = function (oe) {
        this.updater.enqueueForceUpdate(this, oe, "forceUpdate");
      });
    function ce() {}
    ce.prototype = fe.prototype;
    function ue(oe, De, Ge) {
      (this.props = oe),
        (this.context = De),
        (this.refs = se),
        (this.updater = Ge || ne);
    }
    var he = (ue.prototype = new ce());
    (he.constructor = ue), ae(he, fe.prototype), (he.isPureReactComponent = !0);
    var me = Array.isArray,
      ve = { H: null, A: null, T: null, S: null, V: null },
      ge = Object.prototype.hasOwnProperty;
    function Ee(oe, De, Ge, pe, Ye, Qe) {
      return (
        (Ge = Qe.ref),
        {
          $$typeof: U,
          type: oe,
          key: De,
          ref: Ge !== void 0 ? Ge : null,
          props: Qe,
        }
      );
    }
    function Ce(oe, De) {
      return Ee(oe.type, De, void 0, void 0, void 0, oe.props);
    }
    function Re(oe) {
      return typeof oe == "object" && oe !== null && oe.$$typeof === U;
    }
    function Ae(oe) {
      var De = { "=": "=0", ":": "=2" };
      return (
        "$" +
        oe.replace(/[=:]/g, function (Ge) {
          return De[Ge];
        })
      );
    }
    var be = /\/+/g;
    function Le(oe, De) {
      return typeof oe == "object" && oe !== null && oe.key != null
        ? Ae("" + oe.key)
        : De.toString(36);
    }
    function Fe() {}
    function Me(oe) {
      switch (oe.status) {
        case "fulfilled":
          return oe.value;
        case "rejected":
          throw oe.reason;
        default:
          switch (
            (typeof oe.status == "string"
              ? oe.then(Fe, Fe)
              : ((oe.status = "pending"),
                oe.then(
                  function (De) {
                    oe.status === "pending" &&
                      ((oe.status = "fulfilled"), (oe.value = De));
                  },
                  function (De) {
                    oe.status === "pending" &&
                      ((oe.status = "rejected"), (oe.reason = De));
                  }
                )),
            oe.status)
          ) {
            case "fulfilled":
              return oe.value;
            case "rejected":
              throw oe.reason;
          }
      }
      throw oe;
    }
    function je(oe, De, Ge, pe, Ye) {
      var Qe = typeof oe;
      (Qe === "undefined" || Qe === "boolean") && (oe = null);
      var Ie = !1;
      if (oe === null) Ie = !0;
      else
        switch (Qe) {
          case "bigint":
          case "string":
          case "number":
            Ie = !0;
            break;
          case "object":
            switch (oe.$$typeof) {
              case U:
              case j:
                Ie = !0;
                break;
              case X:
                return (Ie = oe._init), je(Ie(oe._payload), De, Ge, pe, Ye);
            }
        }
      if (Ie)
        return (
          (Ye = Ye(oe)),
          (Ie = pe === "" ? "." + Le(oe, 0) : pe),
          me(Ye)
            ? ((Ge = ""),
              Ie != null && (Ge = Ie.replace(be, "$&/") + "/"),
              je(Ye, De, Ge, "", function (We) {
                return We;
              }))
            : Ye != null &&
              (Re(Ye) &&
                (Ye = Ce(
                  Ye,
                  Ge +
                    (Ye.key == null || (oe && oe.key === Ye.key)
                      ? ""
                      : ("" + Ye.key).replace(be, "$&/") + "/") +
                    Ie
                )),
              De.push(Ye)),
          1
        );
      Ie = 0;
      var pt = pe === "" ? "." : pe + ":";
      if (me(oe))
        for (var ct = 0; ct < oe.length; ct++)
          (pe = oe[ct]), (Qe = pt + Le(pe, ct)), (Ie += je(pe, De, Ge, Qe, Ye));
      else if (((ct = te(oe)), typeof ct == "function"))
        for (oe = ct.call(oe), ct = 0; !(pe = oe.next()).done; )
          (pe = pe.value),
            (Qe = pt + Le(pe, ct++)),
            (Ie += je(pe, De, Ge, Qe, Ye));
      else if (Qe === "object") {
        if (typeof oe.then == "function") return je(Me(oe), De, Ge, pe, Ye);
        throw (
          ((De = String(oe)),
          Error(
            "Objects are not valid as a React child (found: " +
              (De === "[object Object]"
                ? "object with keys {" + Object.keys(oe).join(", ") + "}"
                : De) +
              "). If you meant to render a collection of children, use an array instead."
          ))
        );
      }
      return Ie;
    }
    function Te(oe, De, Ge) {
      if (oe == null) return oe;
      var pe = [],
        Ye = 0;
      return (
        je(oe, pe, "", "", function (Qe) {
          return De.call(Ge, Qe, Ye++);
        }),
        pe
      );
    }
    function xe(oe) {
      if (oe._status === -1) {
        var De = oe._result;
        (De = De()),
          De.then(
            function (Ge) {
              (oe._status === 0 || oe._status === -1) &&
                ((oe._status = 1), (oe._result = Ge));
            },
            function (Ge) {
              (oe._status === 0 || oe._status === -1) &&
                ((oe._status = 2), (oe._result = Ge));
            }
          ),
          oe._status === -1 && ((oe._status = 0), (oe._result = De));
      }
      if (oe._status === 1) return oe._result.default;
      throw oe._result;
    }
    var He =
      typeof reportError == "function"
        ? reportError
        : function (oe) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var De = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof oe == "object" &&
                  oe !== null &&
                  typeof oe.message == "string"
                    ? String(oe.message)
                    : String(oe),
                error: oe,
              });
              if (!window.dispatchEvent(De)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", oe);
              return;
            }
            console.error(oe);
          };
    function Je() {}
    return (
      (react_production.Children = {
        map: Te,
        forEach: function (oe, De, Ge) {
          Te(
            oe,
            function () {
              De.apply(this, arguments);
            },
            Ge
          );
        },
        count: function (oe) {
          var De = 0;
          return (
            Te(oe, function () {
              De++;
            }),
            De
          );
        },
        toArray: function (oe) {
          return (
            Te(oe, function (De) {
              return De;
            }) || []
          );
        },
        only: function (oe) {
          if (!Re(oe))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return oe;
        },
      }),
      (react_production.Component = fe),
      (react_production.Fragment = V),
      (react_production.Profiler = q),
      (react_production.PureComponent = ue),
      (react_production.StrictMode = B),
      (react_production.Suspense = Y),
      (react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
        ve),
      (react_production.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function (oe) {
          return ve.H.useMemoCache(oe);
        },
      }),
      (react_production.cache = function (oe) {
        return function () {
          return oe.apply(null, arguments);
        };
      }),
      (react_production.cloneElement = function (oe, De, Ge) {
        if (oe == null)
          throw Error(
            "The argument must be a React element, but you passed " + oe + "."
          );
        var pe = ae({}, oe.props),
          Ye = oe.key,
          Qe = void 0;
        if (De != null)
          for (Ie in (De.ref !== void 0 && (Qe = void 0),
          De.key !== void 0 && (Ye = "" + De.key),
          De))
            !ge.call(De, Ie) ||
              Ie === "key" ||
              Ie === "__self" ||
              Ie === "__source" ||
              (Ie === "ref" && De.ref === void 0) ||
              (pe[Ie] = De[Ie]);
        var Ie = arguments.length - 2;
        if (Ie === 1) pe.children = Ge;
        else if (1 < Ie) {
          for (var pt = Array(Ie), ct = 0; ct < Ie; ct++)
            pt[ct] = arguments[ct + 2];
          pe.children = pt;
        }
        return Ee(oe.type, Ye, void 0, void 0, Qe, pe);
      }),
      (react_production.createContext = function (oe) {
        return (
          (oe = {
            $$typeof: H,
            _currentValue: oe,
            _currentValue2: oe,
            _threadCount: 0,
            Provider: null,
            Consumer: null,
          }),
          (oe.Provider = oe),
          (oe.Consumer = { $$typeof: $, _context: oe }),
          oe
        );
      }),
      (react_production.createElement = function (oe, De, Ge) {
        var pe,
          Ye = {},
          Qe = null;
        if (De != null)
          for (pe in (De.key !== void 0 && (Qe = "" + De.key), De))
            ge.call(De, pe) &&
              pe !== "key" &&
              pe !== "__self" &&
              pe !== "__source" &&
              (Ye[pe] = De[pe]);
        var Ie = arguments.length - 2;
        if (Ie === 1) Ye.children = Ge;
        else if (1 < Ie) {
          for (var pt = Array(Ie), ct = 0; ct < Ie; ct++)
            pt[ct] = arguments[ct + 2];
          Ye.children = pt;
        }
        if (oe && oe.defaultProps)
          for (pe in ((Ie = oe.defaultProps), Ie))
            Ye[pe] === void 0 && (Ye[pe] = Ie[pe]);
        return Ee(oe, Qe, void 0, void 0, null, Ye);
      }),
      (react_production.createRef = function () {
        return { current: null };
      }),
      (react_production.forwardRef = function (oe) {
        return { $$typeof: G, render: oe };
      }),
      (react_production.isValidElement = Re),
      (react_production.lazy = function (oe) {
        return {
          $$typeof: X,
          _payload: { _status: -1, _result: oe },
          _init: xe,
        };
      }),
      (react_production.memo = function (oe, De) {
        return { $$typeof: Q, type: oe, compare: De === void 0 ? null : De };
      }),
      (react_production.startTransition = function (oe) {
        var De = ve.T,
          Ge = {};
        ve.T = Ge;
        try {
          var pe = oe(),
            Ye = ve.S;
          Ye !== null && Ye(Ge, pe),
            typeof pe == "object" &&
              pe !== null &&
              typeof pe.then == "function" &&
              pe.then(Je, He);
        } catch (Qe) {
          He(Qe);
        } finally {
          ve.T = De;
        }
      }),
      (react_production.unstable_useCacheRefresh = function () {
        return ve.H.useCacheRefresh();
      }),
      (react_production.use = function (oe) {
        return ve.H.use(oe);
      }),
      (react_production.useActionState = function (oe, De, Ge) {
        return ve.H.useActionState(oe, De, Ge);
      }),
      (react_production.useCallback = function (oe, De) {
        return ve.H.useCallback(oe, De);
      }),
      (react_production.useContext = function (oe) {
        return ve.H.useContext(oe);
      }),
      (react_production.useDebugValue = function () {}),
      (react_production.useDeferredValue = function (oe, De) {
        return ve.H.useDeferredValue(oe, De);
      }),
      (react_production.useEffect = function (oe, De, Ge) {
        var pe = ve.H;
        if (typeof Ge == "function")
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return pe.useEffect(oe, De);
      }),
      (react_production.useId = function () {
        return ve.H.useId();
      }),
      (react_production.useImperativeHandle = function (oe, De, Ge) {
        return ve.H.useImperativeHandle(oe, De, Ge);
      }),
      (react_production.useInsertionEffect = function (oe, De) {
        return ve.H.useInsertionEffect(oe, De);
      }),
      (react_production.useLayoutEffect = function (oe, De) {
        return ve.H.useLayoutEffect(oe, De);
      }),
      (react_production.useMemo = function (oe, De) {
        return ve.H.useMemo(oe, De);
      }),
      (react_production.useOptimistic = function (oe, De) {
        return ve.H.useOptimistic(oe, De);
      }),
      (react_production.useReducer = function (oe, De, Ge) {
        return ve.H.useReducer(oe, De, Ge);
      }),
      (react_production.useRef = function (oe) {
        return ve.H.useRef(oe);
      }),
      (react_production.useState = function (oe) {
        return ve.H.useState(oe);
      }),
      (react_production.useSyncExternalStore = function (oe, De, Ge) {
        return ve.H.useSyncExternalStore(oe, De, Ge);
      }),
      (react_production.useTransition = function () {
        return ve.H.useTransition();
      }),
      (react_production.version = "19.1.0"),
      react_production
    );
  }
  var hasRequiredReact;
  function requireReact() {
    return (
      hasRequiredReact ||
        ((hasRequiredReact = 1), (react.exports = requireReact_production())),
      react.exports
    );
  }
  var reactDom = { exports: {} },
    reactDom_production = {};
  /**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var hasRequiredReactDom_production;
  function requireReactDom_production() {
    if (hasRequiredReactDom_production) return reactDom_production;
    hasRequiredReactDom_production = 1;
    var U = requireReact();
    function j(Y) {
      var Q = "https://react.dev/errors/" + Y;
      if (1 < arguments.length) {
        Q += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var X = 2; X < arguments.length; X++)
          Q += "&args[]=" + encodeURIComponent(arguments[X]);
      }
      return (
        "Minified React error #" +
        Y +
        "; visit " +
        Q +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      );
    }
    function V() {}
    var B = {
        d: {
          f: V,
          r: function () {
            throw Error(j(522));
          },
          D: V,
          C: V,
          L: V,
          m: V,
          X: V,
          S: V,
          M: V,
        },
        p: 0,
        findDOMNode: null,
      },
      q = Symbol.for("react.portal");
    function $(Y, Q, X) {
      var Z =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: q,
        key: Z == null ? null : "" + Z,
        children: Y,
        containerInfo: Q,
        implementation: X,
      };
    }
    var H = U.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function G(Y, Q) {
      if (Y === "font") return "";
      if (typeof Q == "string") return Q === "use-credentials" ? Q : "";
    }
    return (
      (reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =
        B),
      (reactDom_production.createPortal = function (Y, Q) {
        var X =
          2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!Q || (Q.nodeType !== 1 && Q.nodeType !== 9 && Q.nodeType !== 11))
          throw Error(j(299));
        return $(Y, Q, null, X);
      }),
      (reactDom_production.flushSync = function (Y) {
        var Q = H.T,
          X = B.p;
        try {
          if (((H.T = null), (B.p = 2), Y)) return Y();
        } finally {
          (H.T = Q), (B.p = X), B.d.f();
        }
      }),
      (reactDom_production.preconnect = function (Y, Q) {
        typeof Y == "string" &&
          (Q
            ? ((Q = Q.crossOrigin),
              (Q =
                typeof Q == "string"
                  ? Q === "use-credentials"
                    ? Q
                    : ""
                  : void 0))
            : (Q = null),
          B.d.C(Y, Q));
      }),
      (reactDom_production.prefetchDNS = function (Y) {
        typeof Y == "string" && B.d.D(Y);
      }),
      (reactDom_production.preinit = function (Y, Q) {
        if (typeof Y == "string" && Q && typeof Q.as == "string") {
          var X = Q.as,
            Z = G(X, Q.crossOrigin),
            te = typeof Q.integrity == "string" ? Q.integrity : void 0,
            ne = typeof Q.fetchPriority == "string" ? Q.fetchPriority : void 0;
          X === "style"
            ? B.d.S(
                Y,
                typeof Q.precedence == "string" ? Q.precedence : void 0,
                { crossOrigin: Z, integrity: te, fetchPriority: ne }
              )
            : X === "script" &&
              B.d.X(Y, {
                crossOrigin: Z,
                integrity: te,
                fetchPriority: ne,
                nonce: typeof Q.nonce == "string" ? Q.nonce : void 0,
              });
        }
      }),
      (reactDom_production.preinitModule = function (Y, Q) {
        if (typeof Y == "string")
          if (typeof Q == "object" && Q !== null) {
            if (Q.as == null || Q.as === "script") {
              var X = G(Q.as, Q.crossOrigin);
              B.d.M(Y, {
                crossOrigin: X,
                integrity:
                  typeof Q.integrity == "string" ? Q.integrity : void 0,
                nonce: typeof Q.nonce == "string" ? Q.nonce : void 0,
              });
            }
          } else Q == null && B.d.M(Y);
      }),
      (reactDom_production.preload = function (Y, Q) {
        if (
          typeof Y == "string" &&
          typeof Q == "object" &&
          Q !== null &&
          typeof Q.as == "string"
        ) {
          var X = Q.as,
            Z = G(X, Q.crossOrigin);
          B.d.L(Y, X, {
            crossOrigin: Z,
            integrity: typeof Q.integrity == "string" ? Q.integrity : void 0,
            nonce: typeof Q.nonce == "string" ? Q.nonce : void 0,
            type: typeof Q.type == "string" ? Q.type : void 0,
            fetchPriority:
              typeof Q.fetchPriority == "string" ? Q.fetchPriority : void 0,
            referrerPolicy:
              typeof Q.referrerPolicy == "string" ? Q.referrerPolicy : void 0,
            imageSrcSet:
              typeof Q.imageSrcSet == "string" ? Q.imageSrcSet : void 0,
            imageSizes: typeof Q.imageSizes == "string" ? Q.imageSizes : void 0,
            media: typeof Q.media == "string" ? Q.media : void 0,
          });
        }
      }),
      (reactDom_production.preloadModule = function (Y, Q) {
        if (typeof Y == "string")
          if (Q) {
            var X = G(Q.as, Q.crossOrigin);
            B.d.m(Y, {
              as: typeof Q.as == "string" && Q.as !== "script" ? Q.as : void 0,
              crossOrigin: X,
              integrity: typeof Q.integrity == "string" ? Q.integrity : void 0,
            });
          } else B.d.m(Y);
      }),
      (reactDom_production.requestFormReset = function (Y) {
        B.d.r(Y);
      }),
      (reactDom_production.unstable_batchedUpdates = function (Y, Q) {
        return Y(Q);
      }),
      (reactDom_production.useFormState = function (Y, Q, X) {
        return H.H.useFormState(Y, Q, X);
      }),
      (reactDom_production.useFormStatus = function () {
        return H.H.useHostTransitionStatus();
      }),
      (reactDom_production.version = "19.1.0"),
      reactDom_production
    );
  }
  var hasRequiredReactDom;
  function requireReactDom() {
    if (hasRequiredReactDom) return reactDom.exports;
    hasRequiredReactDom = 1;
    function U() {
      if (
        !(
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
        )
      )
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(U);
        } catch (j) {
          console.error(j);
        }
    }
    return (
      U(), (reactDom.exports = requireReactDom_production()), reactDom.exports
    );
  }
  /**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */ var hasRequiredReactDomClient_production;
  function requireReactDomClient_production() {
    if (hasRequiredReactDomClient_production) return reactDomClient_production;
    hasRequiredReactDomClient_production = 1;
    var U = requireScheduler(),
      j = requireReact(),
      V = requireReactDom();
    function B(F) {
      var z = "https://react.dev/errors/" + F;
      if (1 < arguments.length) {
        z += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var K = 2; K < arguments.length; K++)
          z += "&args[]=" + encodeURIComponent(arguments[K]);
      }
      return (
        "Minified React error #" +
        F +
        "; visit " +
        z +
        " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
      );
    }
    function q(F) {
      return !(
        !F ||
        (F.nodeType !== 1 && F.nodeType !== 9 && F.nodeType !== 11)
      );
    }
    function $(F) {
      var z = F,
        K = F;
      if (F.alternate) for (; z.return; ) z = z.return;
      else {
        F = z;
        do (z = F), (z.flags & 4098) !== 0 && (K = z.return), (F = z.return);
        while (F);
      }
      return z.tag === 3 ? K : null;
    }
    function H(F) {
      if (F.tag === 13) {
        var z = F.memoizedState;
        if (
          (z === null &&
            ((F = F.alternate), F !== null && (z = F.memoizedState)),
          z !== null)
        )
          return z.dehydrated;
      }
      return null;
    }
    function G(F) {
      if ($(F) !== F) throw Error(B(188));
    }
    function Y(F) {
      var z = F.alternate;
      if (!z) {
        if (((z = $(F)), z === null)) throw Error(B(188));
        return z !== F ? null : F;
      }
      for (var K = F, W = z; ; ) {
        var ee = K.return;
        if (ee === null) break;
        var ie = ee.alternate;
        if (ie === null) {
          if (((W = ee.return), W !== null)) {
            K = W;
            continue;
          }
          break;
        }
        if (ee.child === ie.child) {
          for (ie = ee.child; ie; ) {
            if (ie === K) return G(ee), F;
            if (ie === W) return G(ee), z;
            ie = ie.sibling;
          }
          throw Error(B(188));
        }
        if (K.return !== W.return) (K = ee), (W = ie);
        else {
          for (var le = !1, de = ee.child; de; ) {
            if (de === K) {
              (le = !0), (K = ee), (W = ie);
              break;
            }
            if (de === W) {
              (le = !0), (W = ee), (K = ie);
              break;
            }
            de = de.sibling;
          }
          if (!le) {
            for (de = ie.child; de; ) {
              if (de === K) {
                (le = !0), (K = ie), (W = ee);
                break;
              }
              if (de === W) {
                (le = !0), (W = ie), (K = ee);
                break;
              }
              de = de.sibling;
            }
            if (!le) throw Error(B(189));
          }
        }
        if (K.alternate !== W) throw Error(B(190));
      }
      if (K.tag !== 3) throw Error(B(188));
      return K.stateNode.current === K ? F : z;
    }
    function Q(F) {
      var z = F.tag;
      if (z === 5 || z === 26 || z === 27 || z === 6) return F;
      for (F = F.child; F !== null; ) {
        if (((z = Q(F)), z !== null)) return z;
        F = F.sibling;
      }
      return null;
    }
    var X = Object.assign,
      Z = Symbol.for("react.element"),
      te = Symbol.for("react.transitional.element"),
      ne = Symbol.for("react.portal"),
      ae = Symbol.for("react.fragment"),
      se = Symbol.for("react.strict_mode"),
      fe = Symbol.for("react.profiler"),
      ce = Symbol.for("react.provider"),
      ue = Symbol.for("react.consumer"),
      he = Symbol.for("react.context"),
      me = Symbol.for("react.forward_ref"),
      ve = Symbol.for("react.suspense"),
      ge = Symbol.for("react.suspense_list"),
      Ee = Symbol.for("react.memo"),
      Ce = Symbol.for("react.lazy"),
      Re = Symbol.for("react.activity"),
      Ae = Symbol.for("react.memo_cache_sentinel"),
      be = Symbol.iterator;
    function Le(F) {
      return F === null || typeof F != "object"
        ? null
        : ((F = (be && F[be]) || F["@@iterator"]),
          typeof F == "function" ? F : null);
    }
    var Fe = Symbol.for("react.client.reference");
    function Me(F) {
      if (F == null) return null;
      if (typeof F == "function")
        return F.$$typeof === Fe ? null : F.displayName || F.name || null;
      if (typeof F == "string") return F;
      switch (F) {
        case ae:
          return "Fragment";
        case fe:
          return "Profiler";
        case se:
          return "StrictMode";
        case ve:
          return "Suspense";
        case ge:
          return "SuspenseList";
        case Re:
          return "Activity";
      }
      if (typeof F == "object")
        switch (F.$$typeof) {
          case ne:
            return "Portal";
          case he:
            return (F.displayName || "Context") + ".Provider";
          case ue:
            return (F._context.displayName || "Context") + ".Consumer";
          case me:
            var z = F.render;
            return (
              (F = F.displayName),
              F ||
                ((F = z.displayName || z.name || ""),
                (F = F !== "" ? "ForwardRef(" + F + ")" : "ForwardRef")),
              F
            );
          case Ee:
            return (
              (z = F.displayName || null), z !== null ? z : Me(F.type) || "Memo"
            );
          case Ce:
            (z = F._payload), (F = F._init);
            try {
              return Me(F(z));
            } catch {}
        }
      return null;
    }
    var je = Array.isArray,
      Te = j.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      xe = V.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      He = { pending: !1, data: null, method: null, action: null },
      Je = [],
      oe = -1;
    function De(F) {
      return { current: F };
    }
    function Ge(F) {
      0 > oe || ((F.current = Je[oe]), (Je[oe] = null), oe--);
    }
    function pe(F, z) {
      oe++, (Je[oe] = F.current), (F.current = z);
    }
    var Ye = De(null),
      Qe = De(null),
      Ie = De(null),
      pt = De(null);
    function ct(F, z) {
      switch ((pe(Ie, z), pe(Qe, F), pe(Ye, null), z.nodeType)) {
        case 9:
        case 11:
          F = (F = z.documentElement) && (F = F.namespaceURI) ? lf(F) : 0;
          break;
        default:
          if (((F = z.tagName), (z = z.namespaceURI)))
            (z = lf(z)), (F = cf(z, F));
          else
            switch (F) {
              case "svg":
                F = 1;
                break;
              case "math":
                F = 2;
                break;
              default:
                F = 0;
            }
      }
      Ge(Ye), pe(Ye, F);
    }
    function We() {
      Ge(Ye), Ge(Qe), Ge(Ie);
    }
    function tt(F) {
      F.memoizedState !== null && pe(pt, F);
      var z = Ye.current,
        K = cf(z, F.type);
      z !== K && (pe(Qe, F), pe(Ye, K));
    }
    function gt(F) {
      Qe.current === F && (Ge(Ye), Ge(Qe)),
        pt.current === F && (Ge(pt), (Sa._currentValue = He));
    }
    var Jt = Object.prototype.hasOwnProperty,
      nn = U.unstable_scheduleCallback,
      gn = U.unstable_cancelCallback,
      Bi = U.unstable_shouldYield,
      Wn = U.unstable_requestPaint,
      At = U.unstable_now,
      Fi = U.unstable_getCurrentPriorityLevel,
      qt = U.unstable_ImmediatePriority,
      Ti = U.unstable_UserBlockingPriority,
      Xn = U.unstable_NormalPriority,
      Ar = U.unstable_LowPriority,
      ki = U.unstable_IdlePriority,
      Pr = U.log,
      Zt = U.unstable_setDisableYieldValue,
      Ne = null,
      Ke = null;
    function it(F) {
      if (
        (typeof Pr == "function" && Zt(F),
        Ke && typeof Ke.setStrictMode == "function")
      )
        try {
          Ke.setStrictMode(Ne, F);
        } catch {}
    }
    var rt = Math.clz32 ? Math.clz32 : Rn,
      bt = Math.log,
      en = Math.LN2;
    function Rn(F) {
      return (F >>>= 0), F === 0 ? 32 : (31 - ((bt(F) / en) | 0)) | 0;
    }
    var vt = 256,
      Be = 4194304;
    function Ue(F) {
      var z = F & 42;
      if (z !== 0) return z;
      switch (F & -F) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return F & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return F & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return F;
      }
    }
    function qe(F, z, K) {
      var W = F.pendingLanes;
      if (W === 0) return 0;
      var ee = 0,
        ie = F.suspendedLanes,
        le = F.pingedLanes;
      F = F.warmLanes;
      var de = W & 134217727;
      return (
        de !== 0
          ? ((W = de & ~ie),
            W !== 0
              ? (ee = Ue(W))
              : ((le &= de),
                le !== 0
                  ? (ee = Ue(le))
                  : K || ((K = de & ~F), K !== 0 && (ee = Ue(K)))))
          : ((de = W & ~ie),
            de !== 0
              ? (ee = Ue(de))
              : le !== 0
              ? (ee = Ue(le))
              : K || ((K = W & ~F), K !== 0 && (ee = Ue(K)))),
        ee === 0
          ? 0
          : z !== 0 &&
            z !== ee &&
            (z & ie) === 0 &&
            ((ie = ee & -ee),
            (K = z & -z),
            ie >= K || (ie === 32 && (K & 4194048) !== 0))
          ? z
          : ee
      );
    }
    function Xe(F, z) {
      return (F.pendingLanes & ~(F.suspendedLanes & ~F.pingedLanes) & z) === 0;
    }
    function Ze(F, z) {
      switch (F) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return z + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return z + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function lt() {
      var F = vt;
      return (vt <<= 1), (vt & 4194048) === 0 && (vt = 256), F;
    }
    function Rt() {
      var F = Be;
      return (Be <<= 1), (Be & 62914560) === 0 && (Be = 4194304), F;
    }
    function jt(F) {
      for (var z = [], K = 0; 31 > K; K++) z.push(F);
      return z;
    }
    function It(F, z) {
      (F.pendingLanes |= z),
        z !== 268435456 &&
          ((F.suspendedLanes = 0), (F.pingedLanes = 0), (F.warmLanes = 0));
    }
    function qi(F, z, K, W, ee, ie) {
      var le = F.pendingLanes;
      (F.pendingLanes = K),
        (F.suspendedLanes = 0),
        (F.pingedLanes = 0),
        (F.warmLanes = 0),
        (F.expiredLanes &= K),
        (F.entangledLanes &= K),
        (F.errorRecoveryDisabledLanes &= K),
        (F.shellSuspendCounter = 0);
      var de = F.entanglements,
        ye = F.expirationTimes,
        we = F.hiddenUpdates;
      for (K = le & ~K; 0 < K; ) {
        var Ve = 31 - rt(K),
          $e = 1 << Ve;
        (de[Ve] = 0), (ye[Ve] = -1);
        var Pe = we[Ve];
        if (Pe !== null)
          for (we[Ve] = null, Ve = 0; Ve < Pe.length; Ve++) {
            var Oe = Pe[Ve];
            Oe !== null && (Oe.lane &= -536870913);
          }
        K &= ~$e;
      }
      W !== 0 && Ls(F, W, 0),
        ie !== 0 &&
          ee === 0 &&
          F.tag !== 0 &&
          (F.suspendedLanes |= ie & ~(le & ~z));
    }
    function Ls(F, z, K) {
      (F.pendingLanes |= z), (F.suspendedLanes &= ~z);
      var W = 31 - rt(z);
      (F.entangledLanes |= z),
        (F.entanglements[W] = F.entanglements[W] | 1073741824 | (K & 4194090));
    }
    function zi(F, z) {
      var K = (F.entangledLanes |= z);
      for (F = F.entanglements; K; ) {
        var W = 31 - rt(K),
          ee = 1 << W;
        (ee & z) | (F[W] & z) && (F[W] |= z), (K &= ~ee);
      }
    }
    function Ns(F) {
      switch (F) {
        case 2:
          F = 1;
          break;
        case 8:
          F = 4;
          break;
        case 32:
          F = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          F = 128;
          break;
        case 268435456:
          F = 134217728;
          break;
        default:
          F = 0;
      }
      return F;
    }
    function js(F) {
      return (
        (F &= -F),
        2 < F ? (8 < F ? ((F & 134217727) !== 0 ? 32 : 268435456) : 8) : 2
      );
    }
    function Kl() {
      var F = xe.p;
      return F !== 0 ? F : ((F = window.event), F === void 0 ? 32 : wf(F.type));
    }
    function If(F, z) {
      var K = xe.p;
      try {
        return (xe.p = F), z();
      } finally {
        xe.p = K;
      }
    }
    var Jn = Math.random().toString(36).slice(2),
      Wt = "__reactFiber$" + Jn,
      rn = "__reactProps$" + Jn,
      $i = "__reactContainer$" + Jn,
      Us = "__reactEvents$" + Jn,
      Lf = "__reactListeners$" + Jn,
      Nf = "__reactHandles$" + Jn,
      Yl = "__reactResources$" + Jn,
      Dr = "__reactMarker$" + Jn;
    function Vs(F) {
      delete F[Wt], delete F[rn], delete F[Us], delete F[Lf], delete F[Nf];
    }
    function Hi(F) {
      var z = F[Wt];
      if (z) return z;
      for (var K = F.parentNode; K; ) {
        if ((z = K[$i] || K[Wt])) {
          if (
            ((K = z.alternate),
            z.child !== null || (K !== null && K.child !== null))
          )
            for (F = hf(F); F !== null; ) {
              if ((K = F[Wt])) return K;
              F = hf(F);
            }
          return z;
        }
        (F = K), (K = F.parentNode);
      }
      return null;
    }
    function Gi(F) {
      if ((F = F[Wt] || F[$i])) {
        var z = F.tag;
        if (z === 5 || z === 6 || z === 13 || z === 26 || z === 27 || z === 3)
          return F;
      }
      return null;
    }
    function Or(F) {
      var z = F.tag;
      if (z === 5 || z === 26 || z === 27 || z === 6) return F.stateNode;
      throw Error(B(33));
    }
    function Ki(F) {
      var z = F[Yl];
      return (
        z ||
          (z = F[Yl] =
            { hoistableStyles: new Map(), hoistableScripts: new Map() }),
        z
      );
    }
    function zt(F) {
      F[Dr] = !0;
    }
    var Ql = new Set(),
      Wl = {};
    function Ci(F, z) {
      Yi(F, z), Yi(F + "Capture", z);
    }
    function Yi(F, z) {
      for (Wl[F] = z, F = 0; F < z.length; F++) Ql.add(z[F]);
    }
    var jf = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      ),
      Xl = {},
      Jl = {};
    function Uf(F) {
      return Jt.call(Jl, F)
        ? !0
        : Jt.call(Xl, F)
        ? !1
        : jf.test(F)
        ? (Jl[F] = !0)
        : ((Xl[F] = !0), !1);
    }
    function xa(F, z, K) {
      if (Uf(z))
        if (K === null) F.removeAttribute(z);
        else {
          switch (typeof K) {
            case "undefined":
            case "function":
            case "symbol":
              F.removeAttribute(z);
              return;
            case "boolean":
              var W = z.toLowerCase().slice(0, 5);
              if (W !== "data-" && W !== "aria-") {
                F.removeAttribute(z);
                return;
              }
          }
          F.setAttribute(z, "" + K);
        }
    }
    function Ra(F, z, K) {
      if (K === null) F.removeAttribute(z);
      else {
        switch (typeof K) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            F.removeAttribute(z);
            return;
        }
        F.setAttribute(z, "" + K);
      }
    }
    function Ln(F, z, K, W) {
      if (W === null) F.removeAttribute(K);
      else {
        switch (typeof W) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            F.removeAttribute(K);
            return;
        }
        F.setAttributeNS(z, K, "" + W);
      }
    }
    var Bs, Zl;
    function Qi(F) {
      if (Bs === void 0)
        try {
          throw Error();
        } catch (K) {
          var z = K.stack.trim().match(/\n( *(at )?)/);
          (Bs = (z && z[1]) || ""),
            (Zl =
              -1 <
              K.stack.indexOf(`
    at`)
                ? " (<anonymous>)"
                : -1 < K.stack.indexOf("@")
                ? "@unknown:0:0"
                : "");
        }
      return (
        `
` +
        Bs +
        F +
        Zl
      );
    }
    var Fs = !1;
    function qs(F, z) {
      if (!F || Fs) return "";
      Fs = !0;
      var K = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var W = {
          DetermineComponentFrameRoot: function () {
            try {
              if (z) {
                var $e = function () {
                  throw Error();
                };
                if (
                  (Object.defineProperty($e.prototype, "props", {
                    set: function () {
                      throw Error();
                    },
                  }),
                  typeof Reflect == "object" && Reflect.construct)
                ) {
                  try {
                    Reflect.construct($e, []);
                  } catch (Oe) {
                    var Pe = Oe;
                  }
                  Reflect.construct(F, [], $e);
                } else {
                  try {
                    $e.call();
                  } catch (Oe) {
                    Pe = Oe;
                  }
                  F.call($e.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (Oe) {
                  Pe = Oe;
                }
                ($e = F()) &&
                  typeof $e.catch == "function" &&
                  $e.catch(function () {});
              }
            } catch (Oe) {
              if (Oe && Pe && typeof Oe.stack == "string")
                return [Oe.stack, Pe.stack];
            }
            return [null, null];
          },
        };
        W.DetermineComponentFrameRoot.displayName =
          "DetermineComponentFrameRoot";
        var ee = Object.getOwnPropertyDescriptor(
          W.DetermineComponentFrameRoot,
          "name"
        );
        ee &&
          ee.configurable &&
          Object.defineProperty(W.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot",
          });
        var ie = W.DetermineComponentFrameRoot(),
          le = ie[0],
          de = ie[1];
        if (le && de) {
          var ye = le.split(`
`),
            we = de.split(`
`);
          for (
            ee = W = 0;
            W < ye.length && !ye[W].includes("DetermineComponentFrameRoot");

          )
            W++;
          for (
            ;
            ee < we.length && !we[ee].includes("DetermineComponentFrameRoot");

          )
            ee++;
          if (W === ye.length || ee === we.length)
            for (
              W = ye.length - 1, ee = we.length - 1;
              1 <= W && 0 <= ee && ye[W] !== we[ee];

            )
              ee--;
          for (; 1 <= W && 0 <= ee; W--, ee--)
            if (ye[W] !== we[ee]) {
              if (W !== 1 || ee !== 1)
                do
                  if ((W--, ee--, 0 > ee || ye[W] !== we[ee])) {
                    var Ve =
                      `
` + ye[W].replace(" at new ", " at ");
                    return (
                      F.displayName &&
                        Ve.includes("<anonymous>") &&
                        (Ve = Ve.replace("<anonymous>", F.displayName)),
                      Ve
                    );
                  }
                while (1 <= W && 0 <= ee);
              break;
            }
        }
      } finally {
        (Fs = !1), (Error.prepareStackTrace = K);
      }
      return (K = F ? F.displayName || F.name : "") ? Qi(K) : "";
    }
    function Vf(F) {
      switch (F.tag) {
        case 26:
        case 27:
        case 5:
          return Qi(F.type);
        case 16:
          return Qi("Lazy");
        case 13:
          return Qi("Suspense");
        case 19:
          return Qi("SuspenseList");
        case 0:
        case 15:
          return qs(F.type, !1);
        case 11:
          return qs(F.type.render, !1);
        case 1:
          return qs(F.type, !0);
        case 31:
          return Qi("Activity");
        default:
          return "";
      }
    }
    function ec(F) {
      try {
        var z = "";
        do (z += Vf(F)), (F = F.return);
        while (F);
        return z;
      } catch (K) {
        return (
          `
Error generating stack: ` +
          K.message +
          `
` +
          K.stack
        );
      }
    }
    function vn(F) {
      switch (typeof F) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return F;
        case "object":
          return F;
        default:
          return "";
      }
    }
    function tc(F) {
      var z = F.type;
      return (
        (F = F.nodeName) &&
        F.toLowerCase() === "input" &&
        (z === "checkbox" || z === "radio")
      );
    }
    function Bf(F) {
      var z = tc(F) ? "checked" : "value",
        K = Object.getOwnPropertyDescriptor(F.constructor.prototype, z),
        W = "" + F[z];
      if (
        !F.hasOwnProperty(z) &&
        typeof K < "u" &&
        typeof K.get == "function" &&
        typeof K.set == "function"
      ) {
        var ee = K.get,
          ie = K.set;
        return (
          Object.defineProperty(F, z, {
            configurable: !0,
            get: function () {
              return ee.call(this);
            },
            set: function (le) {
              (W = "" + le), ie.call(this, le);
            },
          }),
          Object.defineProperty(F, z, { enumerable: K.enumerable }),
          {
            getValue: function () {
              return W;
            },
            setValue: function (le) {
              W = "" + le;
            },
            stopTracking: function () {
              (F._valueTracker = null), delete F[z];
            },
          }
        );
      }
    }
    function _a(F) {
      F._valueTracker || (F._valueTracker = Bf(F));
    }
    function nc(F) {
      if (!F) return !1;
      var z = F._valueTracker;
      if (!z) return !0;
      var K = z.getValue(),
        W = "";
      return (
        F && (W = tc(F) ? (F.checked ? "true" : "false") : F.value),
        (F = W),
        F !== K ? (z.setValue(F), !0) : !1
      );
    }
    function wa(F) {
      if (
        ((F = F || (typeof document < "u" ? document : void 0)), typeof F > "u")
      )
        return null;
      try {
        return F.activeElement || F.body;
      } catch {
        return F.body;
      }
    }
    var Ff = /[\n"\\]/g;
    function yn(F) {
      return F.replace(Ff, function (z) {
        return "\\" + z.charCodeAt(0).toString(16) + " ";
      });
    }
    function zs(F, z, K, W, ee, ie, le, de) {
      (F.name = ""),
        le != null &&
        typeof le != "function" &&
        typeof le != "symbol" &&
        typeof le != "boolean"
          ? (F.type = le)
          : F.removeAttribute("type"),
        z != null
          ? le === "number"
            ? ((z === 0 && F.value === "") || F.value != z) &&
              (F.value = "" + vn(z))
            : F.value !== "" + vn(z) && (F.value = "" + vn(z))
          : (le !== "submit" && le !== "reset") || F.removeAttribute("value"),
        z != null
          ? $s(F, le, vn(z))
          : K != null
          ? $s(F, le, vn(K))
          : W != null && F.removeAttribute("value"),
        ee == null && ie != null && (F.defaultChecked = !!ie),
        ee != null &&
          (F.checked = ee && typeof ee != "function" && typeof ee != "symbol"),
        de != null &&
        typeof de != "function" &&
        typeof de != "symbol" &&
        typeof de != "boolean"
          ? (F.name = "" + vn(de))
          : F.removeAttribute("name");
    }
    function ic(F, z, K, W, ee, ie, le, de) {
      if (
        (ie != null &&
          typeof ie != "function" &&
          typeof ie != "symbol" &&
          typeof ie != "boolean" &&
          (F.type = ie),
        z != null || K != null)
      ) {
        if (!((ie !== "submit" && ie !== "reset") || z != null)) return;
        (K = K != null ? "" + vn(K) : ""),
          (z = z != null ? "" + vn(z) : K),
          de || z === F.value || (F.value = z),
          (F.defaultValue = z);
      }
      (W = W ?? ee),
        (W = typeof W != "function" && typeof W != "symbol" && !!W),
        (F.checked = de ? F.checked : !!W),
        (F.defaultChecked = !!W),
        le != null &&
          typeof le != "function" &&
          typeof le != "symbol" &&
          typeof le != "boolean" &&
          (F.name = le);
    }
    function $s(F, z, K) {
      (z === "number" && wa(F.ownerDocument) === F) ||
        F.defaultValue === "" + K ||
        (F.defaultValue = "" + K);
    }
    function Wi(F, z, K, W) {
      if (((F = F.options), z)) {
        z = {};
        for (var ee = 0; ee < K.length; ee++) z["$" + K[ee]] = !0;
        for (K = 0; K < F.length; K++)
          (ee = z.hasOwnProperty("$" + F[K].value)),
            F[K].selected !== ee && (F[K].selected = ee),
            ee && W && (F[K].defaultSelected = !0);
      } else {
        for (K = "" + vn(K), z = null, ee = 0; ee < F.length; ee++) {
          if (F[ee].value === K) {
            (F[ee].selected = !0), W && (F[ee].defaultSelected = !0);
            return;
          }
          z !== null || F[ee].disabled || (z = F[ee]);
        }
        z !== null && (z.selected = !0);
      }
    }
    function rc(F, z, K) {
      if (
        z != null &&
        ((z = "" + vn(z)), z !== F.value && (F.value = z), K == null)
      ) {
        F.defaultValue !== z && (F.defaultValue = z);
        return;
      }
      F.defaultValue = K != null ? "" + vn(K) : "";
    }
    function ac(F, z, K, W) {
      if (z == null) {
        if (W != null) {
          if (K != null) throw Error(B(92));
          if (je(W)) {
            if (1 < W.length) throw Error(B(93));
            W = W[0];
          }
          K = W;
        }
        K == null && (K = ""), (z = K);
      }
      (K = vn(z)),
        (F.defaultValue = K),
        (W = F.textContent),
        W === K && W !== "" && W !== null && (F.value = W);
    }
    function Xi(F, z) {
      if (z) {
        var K = F.firstChild;
        if (K && K === F.lastChild && K.nodeType === 3) {
          K.nodeValue = z;
          return;
        }
      }
      F.textContent = z;
    }
    var qf = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function sc(F, z, K) {
      var W = z.indexOf("--") === 0;
      K == null || typeof K == "boolean" || K === ""
        ? W
          ? F.setProperty(z, "")
          : z === "float"
          ? (F.cssFloat = "")
          : (F[z] = "")
        : W
        ? F.setProperty(z, K)
        : typeof K != "number" || K === 0 || qf.has(z)
        ? z === "float"
          ? (F.cssFloat = K)
          : (F[z] = ("" + K).trim())
        : (F[z] = K + "px");
    }
    function oc(F, z, K) {
      if (z != null && typeof z != "object") throw Error(B(62));
      if (((F = F.style), K != null)) {
        for (var W in K)
          !K.hasOwnProperty(W) ||
            (z != null && z.hasOwnProperty(W)) ||
            (W.indexOf("--") === 0
              ? F.setProperty(W, "")
              : W === "float"
              ? (F.cssFloat = "")
              : (F[W] = ""));
        for (var ee in z)
          (W = z[ee]), z.hasOwnProperty(ee) && K[ee] !== W && sc(F, ee, W);
      } else for (var ie in z) z.hasOwnProperty(ie) && sc(F, ie, z[ie]);
    }
    function Hs(F) {
      if (F.indexOf("-") === -1) return !1;
      switch (F) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var zf = new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"],
      ]),
      $f =
        /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Aa(F) {
      return $f.test("" + F)
        ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')"
        : F;
    }
    var Gs = null;
    function Ks(F) {
      return (
        (F = F.target || F.srcElement || window),
        F.correspondingUseElement && (F = F.correspondingUseElement),
        F.nodeType === 3 ? F.parentNode : F
      );
    }
    var Ji = null,
      Zi = null;
    function lc(F) {
      var z = Gi(F);
      if (z && (F = z.stateNode)) {
        var K = F[rn] || null;
        e: switch (((F = z.stateNode), z.type)) {
          case "input":
            if (
              (zs(
                F,
                K.value,
                K.defaultValue,
                K.defaultValue,
                K.checked,
                K.defaultChecked,
                K.type,
                K.name
              ),
              (z = K.name),
              K.type === "radio" && z != null)
            ) {
              for (K = F; K.parentNode; ) K = K.parentNode;
              for (
                K = K.querySelectorAll(
                  'input[name="' + yn("" + z) + '"][type="radio"]'
                ),
                  z = 0;
                z < K.length;
                z++
              ) {
                var W = K[z];
                if (W !== F && W.form === F.form) {
                  var ee = W[rn] || null;
                  if (!ee) throw Error(B(90));
                  zs(
                    W,
                    ee.value,
                    ee.defaultValue,
                    ee.defaultValue,
                    ee.checked,
                    ee.defaultChecked,
                    ee.type,
                    ee.name
                  );
                }
              }
              for (z = 0; z < K.length; z++)
                (W = K[z]), W.form === F.form && nc(W);
            }
            break e;
          case "textarea":
            rc(F, K.value, K.defaultValue);
            break e;
          case "select":
            (z = K.value), z != null && Wi(F, !!K.multiple, z, !1);
        }
      }
    }
    var Ys = !1;
    function cc(F, z, K) {
      if (Ys) return F(z, K);
      Ys = !0;
      try {
        var W = F(z);
        return W;
      } finally {
        if (
          ((Ys = !1),
          (Ji !== null || Zi !== null) &&
            (ps(), Ji && ((z = Ji), (F = Zi), (Zi = Ji = null), lc(z), F)))
        )
          for (z = 0; z < F.length; z++) lc(F[z]);
      }
    }
    function Mr(F, z) {
      var K = F.stateNode;
      if (K === null) return null;
      var W = K[rn] || null;
      if (W === null) return null;
      K = W[z];
      e: switch (z) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (W = !W.disabled) ||
            ((F = F.type),
            (W = !(
              F === "button" ||
              F === "input" ||
              F === "select" ||
              F === "textarea"
            ))),
            (F = !W);
          break e;
        default:
          F = !1;
      }
      if (F) return null;
      if (K && typeof K != "function") throw Error(B(231, z, typeof K));
      return K;
    }
    var Nn = !(
        typeof window > "u" ||
        typeof window.document > "u" ||
        typeof window.document.createElement > "u"
      ),
      Qs = !1;
    if (Nn)
      try {
        var Ir = {};
        Object.defineProperty(Ir, "passive", {
          get: function () {
            Qs = !0;
          },
        }),
          window.addEventListener("test", Ir, Ir),
          window.removeEventListener("test", Ir, Ir);
      } catch {
        Qs = !1;
      }
    var Zn = null,
      Ws = null,
      Pa = null;
    function uc() {
      if (Pa) return Pa;
      var F,
        z = Ws,
        K = z.length,
        W,
        ee = "value" in Zn ? Zn.value : Zn.textContent,
        ie = ee.length;
      for (F = 0; F < K && z[F] === ee[F]; F++);
      var le = K - F;
      for (W = 1; W <= le && z[K - W] === ee[ie - W]; W++);
      return (Pa = ee.slice(F, 1 < W ? 1 - W : void 0));
    }
    function Da(F) {
      var z = F.keyCode;
      return (
        "charCode" in F
          ? ((F = F.charCode), F === 0 && z === 13 && (F = 13))
          : (F = z),
        F === 10 && (F = 13),
        32 <= F || F === 13 ? F : 0
      );
    }
    function Oa() {
      return !0;
    }
    function dc() {
      return !1;
    }
    function an(F) {
      function z(K, W, ee, ie, le) {
        (this._reactName = K),
          (this._targetInst = ee),
          (this.type = W),
          (this.nativeEvent = ie),
          (this.target = le),
          (this.currentTarget = null);
        for (var de in F)
          F.hasOwnProperty(de) &&
            ((K = F[de]), (this[de] = K ? K(ie) : ie[de]));
        return (
          (this.isDefaultPrevented = (
            ie.defaultPrevented != null
              ? ie.defaultPrevented
              : ie.returnValue === !1
          )
            ? Oa
            : dc),
          (this.isPropagationStopped = dc),
          this
        );
      }
      return (
        X(z.prototype, {
          preventDefault: function () {
            this.defaultPrevented = !0;
            var K = this.nativeEvent;
            K &&
              (K.preventDefault
                ? K.preventDefault()
                : typeof K.returnValue != "unknown" && (K.returnValue = !1),
              (this.isDefaultPrevented = Oa));
          },
          stopPropagation: function () {
            var K = this.nativeEvent;
            K &&
              (K.stopPropagation
                ? K.stopPropagation()
                : typeof K.cancelBubble != "unknown" && (K.cancelBubble = !0),
              (this.isPropagationStopped = Oa));
          },
          persist: function () {},
          isPersistent: Oa,
        }),
        z
      );
    }
    var Ei = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function (F) {
          return F.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0,
      },
      Ma = an(Ei),
      Lr = X({}, Ei, { view: 0, detail: 0 }),
      Hf = an(Lr),
      Xs,
      Js,
      Nr,
      Ia = X({}, Lr, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: eo,
        button: 0,
        buttons: 0,
        relatedTarget: function (F) {
          return F.relatedTarget === void 0
            ? F.fromElement === F.srcElement
              ? F.toElement
              : F.fromElement
            : F.relatedTarget;
        },
        movementX: function (F) {
          return "movementX" in F
            ? F.movementX
            : (F !== Nr &&
                (Nr && F.type === "mousemove"
                  ? ((Xs = F.screenX - Nr.screenX),
                    (Js = F.screenY - Nr.screenY))
                  : (Js = Xs = 0),
                (Nr = F)),
              Xs);
        },
        movementY: function (F) {
          return "movementY" in F ? F.movementY : Js;
        },
      }),
      fc = an(Ia),
      Gf = X({}, Ia, { dataTransfer: 0 }),
      Kf = an(Gf),
      Yf = X({}, Lr, { relatedTarget: 0 }),
      Zs = an(Yf),
      Qf = X({}, Ei, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
      Wf = an(Qf),
      Xf = X({}, Ei, {
        clipboardData: function (F) {
          return "clipboardData" in F ? F.clipboardData : window.clipboardData;
        },
      }),
      Jf = an(Xf),
      Zf = X({}, Ei, { data: 0 }),
      hc = an(Zf),
      eh = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified",
      },
      th = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta",
      },
      nh = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey",
      };
    function ih(F) {
      var z = this.nativeEvent;
      return z.getModifierState
        ? z.getModifierState(F)
        : (F = nh[F])
        ? !!z[F]
        : !1;
    }
    function eo() {
      return ih;
    }
    var rh = X({}, Lr, {
        key: function (F) {
          if (F.key) {
            var z = eh[F.key] || F.key;
            if (z !== "Unidentified") return z;
          }
          return F.type === "keypress"
            ? ((F = Da(F)), F === 13 ? "Enter" : String.fromCharCode(F))
            : F.type === "keydown" || F.type === "keyup"
            ? th[F.keyCode] || "Unidentified"
            : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: eo,
        charCode: function (F) {
          return F.type === "keypress" ? Da(F) : 0;
        },
        keyCode: function (F) {
          return F.type === "keydown" || F.type === "keyup" ? F.keyCode : 0;
        },
        which: function (F) {
          return F.type === "keypress"
            ? Da(F)
            : F.type === "keydown" || F.type === "keyup"
            ? F.keyCode
            : 0;
        },
      }),
      ah = an(rh),
      sh = X({}, Ia, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0,
      }),
      pc = an(sh),
      oh = X({}, Lr, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: eo,
      }),
      lh = an(oh),
      ch = X({}, Ei, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
      uh = an(ch),
      dh = X({}, Ia, {
        deltaX: function (F) {
          return "deltaX" in F
            ? F.deltaX
            : "wheelDeltaX" in F
            ? -F.wheelDeltaX
            : 0;
        },
        deltaY: function (F) {
          return "deltaY" in F
            ? F.deltaY
            : "wheelDeltaY" in F
            ? -F.wheelDeltaY
            : "wheelDelta" in F
            ? -F.wheelDelta
            : 0;
        },
        deltaZ: 0,
        deltaMode: 0,
      }),
      fh = an(dh),
      hh = X({}, Ei, { newState: 0, oldState: 0 }),
      ph = an(hh),
      mh = [9, 13, 27, 32],
      to = Nn && "CompositionEvent" in window,
      jr = null;
    Nn && "documentMode" in document && (jr = document.documentMode);
    var gh = Nn && "TextEvent" in window && !jr,
      mc = Nn && (!to || (jr && 8 < jr && 11 >= jr)),
      gc = " ",
      vc = !1;
    function yc(F, z) {
      switch (F) {
        case "keyup":
          return mh.indexOf(z.keyCode) !== -1;
        case "keydown":
          return z.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function bc(F) {
      return (
        (F = F.detail), typeof F == "object" && "data" in F ? F.data : null
      );
    }
    var er = !1;
    function yh(F, z) {
      switch (F) {
        case "compositionend":
          return bc(z);
        case "keypress":
          return z.which !== 32 ? null : ((vc = !0), gc);
        case "textInput":
          return (F = z.data), F === gc && vc ? null : F;
        default:
          return null;
      }
    }
    function bh(F, z) {
      if (er)
        return F === "compositionend" || (!to && yc(F, z))
          ? ((F = uc()), (Pa = Ws = Zn = null), (er = !1), F)
          : null;
      switch (F) {
        case "paste":
          return null;
        case "keypress":
          if (
            !(z.ctrlKey || z.altKey || z.metaKey) ||
            (z.ctrlKey && z.altKey)
          ) {
            if (z.char && 1 < z.char.length) return z.char;
            if (z.which) return String.fromCharCode(z.which);
          }
          return null;
        case "compositionend":
          return mc && z.locale !== "ko" ? null : z.data;
        default:
          return null;
      }
    }
    var Sh = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0,
    };
    function Sc(F) {
      var z = F && F.nodeName && F.nodeName.toLowerCase();
      return z === "input" ? !!Sh[F.type] : z === "textarea";
    }
    function Tc(F, z, K, W) {
      Ji ? (Zi ? Zi.push(W) : (Zi = [W])) : (Ji = W),
        (z = Ss(z, "onChange")),
        0 < z.length &&
          ((K = new Ma("onChange", "change", null, K, W)),
          F.push({ event: K, listeners: z }));
    }
    var Ur = null,
      Vr = null;
    function Th(F) {
      nf(F, 0);
    }
    function La(F) {
      var z = Or(F);
      if (nc(z)) return F;
    }
    function kc(F, z) {
      if (F === "change") return z;
    }
    var Cc = !1;
    if (Nn) {
      var no;
      if (Nn) {
        var io = "oninput" in document;
        if (!io) {
          var Ec = document.createElement("div");
          Ec.setAttribute("oninput", "return;"),
            (io = typeof Ec.oninput == "function");
        }
        no = io;
      } else no = !1;
      Cc = no && (!document.documentMode || 9 < document.documentMode);
    }
    function xc() {
      Ur && (Ur.detachEvent("onpropertychange", Rc), (Vr = Ur = null));
    }
    function Rc(F) {
      if (F.propertyName === "value" && La(Vr)) {
        var z = [];
        Tc(z, Vr, F, Ks(F)), cc(Th, z);
      }
    }
    function kh(F, z, K) {
      F === "focusin"
        ? (xc(), (Ur = z), (Vr = K), Ur.attachEvent("onpropertychange", Rc))
        : F === "focusout" && xc();
    }
    function Ch(F) {
      if (F === "selectionchange" || F === "keyup" || F === "keydown")
        return La(Vr);
    }
    function Eh(F, z) {
      if (F === "click") return La(z);
    }
    function xh(F, z) {
      if (F === "input" || F === "change") return La(z);
    }
    function Rh(F, z) {
      return (F === z && (F !== 0 || 1 / F === 1 / z)) || (F !== F && z !== z);
    }
    var cn = typeof Object.is == "function" ? Object.is : Rh;
    function Br(F, z) {
      if (cn(F, z)) return !0;
      if (
        typeof F != "object" ||
        F === null ||
        typeof z != "object" ||
        z === null
      )
        return !1;
      var K = Object.keys(F),
        W = Object.keys(z);
      if (K.length !== W.length) return !1;
      for (W = 0; W < K.length; W++) {
        var ee = K[W];
        if (!Jt.call(z, ee) || !cn(F[ee], z[ee])) return !1;
      }
      return !0;
    }
    function _c(F) {
      for (; F && F.firstChild; ) F = F.firstChild;
      return F;
    }
    function wc(F, z) {
      var K = _c(F);
      F = 0;
      for (var W; K; ) {
        if (K.nodeType === 3) {
          if (((W = F + K.textContent.length), F <= z && W >= z))
            return { node: K, offset: z - F };
          F = W;
        }
        e: {
          for (; K; ) {
            if (K.nextSibling) {
              K = K.nextSibling;
              break e;
            }
            K = K.parentNode;
          }
          K = void 0;
        }
        K = _c(K);
      }
    }
    function Ac(F, z) {
      return F && z
        ? F === z
          ? !0
          : F && F.nodeType === 3
          ? !1
          : z && z.nodeType === 3
          ? Ac(F, z.parentNode)
          : "contains" in F
          ? F.contains(z)
          : F.compareDocumentPosition
          ? !!(F.compareDocumentPosition(z) & 16)
          : !1
        : !1;
    }
    function Pc(F) {
      F =
        F != null &&
        F.ownerDocument != null &&
        F.ownerDocument.defaultView != null
          ? F.ownerDocument.defaultView
          : window;
      for (var z = wa(F.document); z instanceof F.HTMLIFrameElement; ) {
        try {
          var K = typeof z.contentWindow.location.href == "string";
        } catch {
          K = !1;
        }
        if (K) F = z.contentWindow;
        else break;
        z = wa(F.document);
      }
      return z;
    }
    function ro(F) {
      var z = F && F.nodeName && F.nodeName.toLowerCase();
      return (
        z &&
        ((z === "input" &&
          (F.type === "text" ||
            F.type === "search" ||
            F.type === "tel" ||
            F.type === "url" ||
            F.type === "password")) ||
          z === "textarea" ||
          F.contentEditable === "true")
      );
    }
    var _h = Nn && "documentMode" in document && 11 >= document.documentMode,
      tr = null,
      ao = null,
      Fr = null,
      so = !1;
    function Dc(F, z, K) {
      var W =
        K.window === K ? K.document : K.nodeType === 9 ? K : K.ownerDocument;
      so ||
        tr == null ||
        tr !== wa(W) ||
        ((W = tr),
        "selectionStart" in W && ro(W)
          ? (W = { start: W.selectionStart, end: W.selectionEnd })
          : ((W = (
              (W.ownerDocument && W.ownerDocument.defaultView) ||
              window
            ).getSelection()),
            (W = {
              anchorNode: W.anchorNode,
              anchorOffset: W.anchorOffset,
              focusNode: W.focusNode,
              focusOffset: W.focusOffset,
            })),
        (Fr && Br(Fr, W)) ||
          ((Fr = W),
          (W = Ss(ao, "onSelect")),
          0 < W.length &&
            ((z = new Ma("onSelect", "select", null, z, K)),
            F.push({ event: z, listeners: W }),
            (z.target = tr))));
    }
    function xi(F, z) {
      var K = {};
      return (
        (K[F.toLowerCase()] = z.toLowerCase()),
        (K["Webkit" + F] = "webkit" + z),
        (K["Moz" + F] = "moz" + z),
        K
      );
    }
    var nr = {
        animationend: xi("Animation", "AnimationEnd"),
        animationiteration: xi("Animation", "AnimationIteration"),
        animationstart: xi("Animation", "AnimationStart"),
        transitionrun: xi("Transition", "TransitionRun"),
        transitionstart: xi("Transition", "TransitionStart"),
        transitioncancel: xi("Transition", "TransitionCancel"),
        transitionend: xi("Transition", "TransitionEnd"),
      },
      oo = {},
      Oc = {};
    Nn &&
      ((Oc = document.createElement("div").style),
      "AnimationEvent" in window ||
        (delete nr.animationend.animation,
        delete nr.animationiteration.animation,
        delete nr.animationstart.animation),
      "TransitionEvent" in window || delete nr.transitionend.transition);
    function Ri(F) {
      if (oo[F]) return oo[F];
      if (!nr[F]) return F;
      var z = nr[F],
        K;
      for (K in z) if (z.hasOwnProperty(K) && K in Oc) return (oo[F] = z[K]);
      return F;
    }
    var Mc = Ri("animationend"),
      Ic = Ri("animationiteration"),
      Lc = Ri("animationstart"),
      wh = Ri("transitionrun"),
      Ah = Ri("transitionstart"),
      Ph = Ri("transitioncancel"),
      Nc = Ri("transitionend"),
      jc = new Map(),
      lo =
        "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
          " "
        );
    lo.push("scrollEnd");
    function _n(F, z) {
      jc.set(F, z), Ci(z, [F]);
    }
    var Uc = new WeakMap();
    function bn(F, z) {
      if (typeof F == "object" && F !== null) {
        var K = Uc.get(F);
        return K !== void 0
          ? K
          : ((z = { value: F, source: z, stack: ec(z) }), Uc.set(F, z), z);
      }
      return { value: F, source: z, stack: ec(z) };
    }
    var Sn = [],
      ir = 0,
      co = 0;
    function Na() {
      for (var F = ir, z = (co = ir = 0); z < F; ) {
        var K = Sn[z];
        Sn[z++] = null;
        var W = Sn[z];
        Sn[z++] = null;
        var ee = Sn[z];
        Sn[z++] = null;
        var ie = Sn[z];
        if (((Sn[z++] = null), W !== null && ee !== null)) {
          var le = W.pending;
          le === null ? (ee.next = ee) : ((ee.next = le.next), (le.next = ee)),
            (W.pending = ee);
        }
        ie !== 0 && Vc(K, ee, ie);
      }
    }
    function ja(F, z, K, W) {
      (Sn[ir++] = F),
        (Sn[ir++] = z),
        (Sn[ir++] = K),
        (Sn[ir++] = W),
        (co |= W),
        (F.lanes |= W),
        (F = F.alternate),
        F !== null && (F.lanes |= W);
    }
    function uo(F, z, K, W) {
      return ja(F, z, K, W), Ua(F);
    }
    function rr(F, z) {
      return ja(F, null, null, z), Ua(F);
    }
    function Vc(F, z, K) {
      F.lanes |= K;
      var W = F.alternate;
      W !== null && (W.lanes |= K);
      for (var ee = !1, ie = F.return; ie !== null; )
        (ie.childLanes |= K),
          (W = ie.alternate),
          W !== null && (W.childLanes |= K),
          ie.tag === 22 &&
            ((F = ie.stateNode), F === null || F._visibility & 1 || (ee = !0)),
          (F = ie),
          (ie = ie.return);
      return F.tag === 3
        ? ((ie = F.stateNode),
          ee &&
            z !== null &&
            ((ee = 31 - rt(K)),
            (F = ie.hiddenUpdates),
            (W = F[ee]),
            W === null ? (F[ee] = [z]) : W.push(z),
            (z.lane = K | 536870912)),
          ie)
        : null;
    }
    function Ua(F) {
      if (50 < fa) throw ((fa = 0), (vl = null), Error(B(185)));
      for (var z = F.return; z !== null; ) (F = z), (z = F.return);
      return F.tag === 3 ? F.stateNode : null;
    }
    var ar = {};
    function Dh(F, z, K, W) {
      (this.tag = F),
        (this.key = K),
        (this.sibling =
          this.child =
          this.return =
          this.stateNode =
          this.type =
          this.elementType =
            null),
        (this.index = 0),
        (this.refCleanup = this.ref = null),
        (this.pendingProps = z),
        (this.dependencies =
          this.memoizedState =
          this.updateQueue =
          this.memoizedProps =
            null),
        (this.mode = W),
        (this.subtreeFlags = this.flags = 0),
        (this.deletions = null),
        (this.childLanes = this.lanes = 0),
        (this.alternate = null);
    }
    function un(F, z, K, W) {
      return new Dh(F, z, K, W);
    }
    function fo(F) {
      return (F = F.prototype), !(!F || !F.isReactComponent);
    }
    function jn(F, z) {
      var K = F.alternate;
      return (
        K === null
          ? ((K = un(F.tag, z, F.key, F.mode)),
            (K.elementType = F.elementType),
            (K.type = F.type),
            (K.stateNode = F.stateNode),
            (K.alternate = F),
            (F.alternate = K))
          : ((K.pendingProps = z),
            (K.type = F.type),
            (K.flags = 0),
            (K.subtreeFlags = 0),
            (K.deletions = null)),
        (K.flags = F.flags & 65011712),
        (K.childLanes = F.childLanes),
        (K.lanes = F.lanes),
        (K.child = F.child),
        (K.memoizedProps = F.memoizedProps),
        (K.memoizedState = F.memoizedState),
        (K.updateQueue = F.updateQueue),
        (z = F.dependencies),
        (K.dependencies =
          z === null ? null : { lanes: z.lanes, firstContext: z.firstContext }),
        (K.sibling = F.sibling),
        (K.index = F.index),
        (K.ref = F.ref),
        (K.refCleanup = F.refCleanup),
        K
      );
    }
    function Bc(F, z) {
      F.flags &= 65011714;
      var K = F.alternate;
      return (
        K === null
          ? ((F.childLanes = 0),
            (F.lanes = z),
            (F.child = null),
            (F.subtreeFlags = 0),
            (F.memoizedProps = null),
            (F.memoizedState = null),
            (F.updateQueue = null),
            (F.dependencies = null),
            (F.stateNode = null))
          : ((F.childLanes = K.childLanes),
            (F.lanes = K.lanes),
            (F.child = K.child),
            (F.subtreeFlags = 0),
            (F.deletions = null),
            (F.memoizedProps = K.memoizedProps),
            (F.memoizedState = K.memoizedState),
            (F.updateQueue = K.updateQueue),
            (F.type = K.type),
            (z = K.dependencies),
            (F.dependencies =
              z === null
                ? null
                : { lanes: z.lanes, firstContext: z.firstContext })),
        F
      );
    }
    function Va(F, z, K, W, ee, ie) {
      var le = 0;
      if (((W = F), typeof F == "function")) fo(F) && (le = 1);
      else if (typeof F == "string")
        le = Mp(F, K, Ye.current)
          ? 26
          : F === "html" || F === "head" || F === "body"
          ? 27
          : 5;
      else
        e: switch (F) {
          case Re:
            return (
              (F = un(31, K, z, ee)), (F.elementType = Re), (F.lanes = ie), F
            );
          case ae:
            return _i(K.children, ee, ie, z);
          case se:
            (le = 8), (ee |= 24);
            break;
          case fe:
            return (
              (F = un(12, K, z, ee | 2)),
              (F.elementType = fe),
              (F.lanes = ie),
              F
            );
          case ve:
            return (
              (F = un(13, K, z, ee)), (F.elementType = ve), (F.lanes = ie), F
            );
          case ge:
            return (
              (F = un(19, K, z, ee)), (F.elementType = ge), (F.lanes = ie), F
            );
          default:
            if (typeof F == "object" && F !== null)
              switch (F.$$typeof) {
                case ce:
                case he:
                  le = 10;
                  break e;
                case ue:
                  le = 9;
                  break e;
                case me:
                  le = 11;
                  break e;
                case Ee:
                  le = 14;
                  break e;
                case Ce:
                  (le = 16), (W = null);
                  break e;
              }
            (le = 29),
              (K = Error(B(130, F === null ? "null" : typeof F, ""))),
              (W = null);
        }
      return (
        (z = un(le, K, z, ee)),
        (z.elementType = F),
        (z.type = W),
        (z.lanes = ie),
        z
      );
    }
    function _i(F, z, K, W) {
      return (F = un(7, F, W, z)), (F.lanes = K), F;
    }
    function ho(F, z, K) {
      return (F = un(6, F, null, z)), (F.lanes = K), F;
    }
    function po(F, z, K) {
      return (
        (z = un(4, F.children !== null ? F.children : [], F.key, z)),
        (z.lanes = K),
        (z.stateNode = {
          containerInfo: F.containerInfo,
          pendingChildren: null,
          implementation: F.implementation,
        }),
        z
      );
    }
    var sr = [],
      or = 0,
      Ba = null,
      Fa = 0,
      Tn = [],
      kn = 0,
      wi = null,
      Un = 1,
      Vn = "";
    function Ai(F, z) {
      (sr[or++] = Fa), (sr[or++] = Ba), (Ba = F), (Fa = z);
    }
    function Fc(F, z, K) {
      (Tn[kn++] = Un), (Tn[kn++] = Vn), (Tn[kn++] = wi), (wi = F);
      var W = Un;
      F = Vn;
      var ee = 32 - rt(W) - 1;
      (W &= ~(1 << ee)), (K += 1);
      var ie = 32 - rt(z) + ee;
      if (30 < ie) {
        var le = ee - (ee % 5);
        (ie = (W & ((1 << le) - 1)).toString(32)),
          (W >>= le),
          (ee -= le),
          (Un = (1 << (32 - rt(z) + ee)) | (K << ee) | W),
          (Vn = ie + F);
      } else (Un = (1 << ie) | (K << ee) | W), (Vn = F);
    }
    function mo(F) {
      F.return !== null && (Ai(F, 1), Fc(F, 1, 0));
    }
    function go(F) {
      for (; F === Ba; )
        (Ba = sr[--or]), (sr[or] = null), (Fa = sr[--or]), (sr[or] = null);
      for (; F === wi; )
        (wi = Tn[--kn]),
          (Tn[kn] = null),
          (Vn = Tn[--kn]),
          (Tn[kn] = null),
          (Un = Tn[--kn]),
          (Tn[kn] = null);
    }
    var tn = null,
      Ot = null,
      St = !1,
      Pi = null,
      Pn = !1,
      vo = Error(B(519));
    function Di(F) {
      var z = Error(B(418, ""));
      throw ($r(bn(z, F)), vo);
    }
    function qc(F) {
      var z = F.stateNode,
        K = F.type,
        W = F.memoizedProps;
      switch (((z[Wt] = F), (z[rn] = W), K)) {
        case "dialog":
          ht("cancel", z), ht("close", z);
          break;
        case "iframe":
        case "object":
        case "embed":
          ht("load", z);
          break;
        case "video":
        case "audio":
          for (K = 0; K < pa.length; K++) ht(pa[K], z);
          break;
        case "source":
          ht("error", z);
          break;
        case "img":
        case "image":
        case "link":
          ht("error", z), ht("load", z);
          break;
        case "details":
          ht("toggle", z);
          break;
        case "input":
          ht("invalid", z),
            ic(
              z,
              W.value,
              W.defaultValue,
              W.checked,
              W.defaultChecked,
              W.type,
              W.name,
              !0
            ),
            _a(z);
          break;
        case "select":
          ht("invalid", z);
          break;
        case "textarea":
          ht("invalid", z), ac(z, W.value, W.defaultValue, W.children), _a(z);
      }
      (K = W.children),
        (typeof K != "string" &&
          typeof K != "number" &&
          typeof K != "bigint") ||
        z.textContent === "" + K ||
        W.suppressHydrationWarning === !0 ||
        of(z.textContent, K)
          ? (W.popover != null && (ht("beforetoggle", z), ht("toggle", z)),
            W.onScroll != null && ht("scroll", z),
            W.onScrollEnd != null && ht("scrollend", z),
            W.onClick != null && (z.onclick = Ts),
            (z = !0))
          : (z = !1),
        z || Di(F);
    }
    function zc(F) {
      for (tn = F.return; tn; )
        switch (tn.tag) {
          case 5:
          case 13:
            Pn = !1;
            return;
          case 27:
          case 3:
            Pn = !0;
            return;
          default:
            tn = tn.return;
        }
    }
    function qr(F) {
      if (F !== tn) return !1;
      if (!St) return zc(F), (St = !0), !1;
      var z = F.tag,
        K;
      if (
        ((K = z !== 3 && z !== 27) &&
          ((K = z === 5) &&
            ((K = F.type),
            (K =
              !(K !== "form" && K !== "button") ||
              Ml(F.type, F.memoizedProps))),
          (K = !K)),
        K && Ot && Di(F),
        zc(F),
        z === 13)
      ) {
        if (((F = F.memoizedState), (F = F !== null ? F.dehydrated : null), !F))
          throw Error(B(317));
        e: {
          for (F = F.nextSibling, z = 0; F; ) {
            if (F.nodeType === 8)
              if (((K = F.data), K === "/$")) {
                if (z === 0) {
                  Ot = An(F.nextSibling);
                  break e;
                }
                z--;
              } else (K !== "$" && K !== "$!" && K !== "$?") || z++;
            F = F.nextSibling;
          }
          Ot = null;
        }
      } else
        z === 27
          ? ((z = Ot),
            mi(F.type) ? ((F = jl), (jl = null), (Ot = F)) : (Ot = z))
          : (Ot = tn ? An(F.stateNode.nextSibling) : null);
      return !0;
    }
    function zr() {
      (Ot = tn = null), (St = !1);
    }
    function $c() {
      var F = Pi;
      return (
        F !== null &&
          (ln === null ? (ln = F) : ln.push.apply(ln, F), (Pi = null)),
        F
      );
    }
    function $r(F) {
      Pi === null ? (Pi = [F]) : Pi.push(F);
    }
    var yo = De(null),
      Oi = null,
      Bn = null;
    function ei(F, z, K) {
      pe(yo, z._currentValue), (z._currentValue = K);
    }
    function Fn(F) {
      (F._currentValue = yo.current), Ge(yo);
    }
    function bo(F, z, K) {
      for (; F !== null; ) {
        var W = F.alternate;
        if (
          ((F.childLanes & z) !== z
            ? ((F.childLanes |= z), W !== null && (W.childLanes |= z))
            : W !== null && (W.childLanes & z) !== z && (W.childLanes |= z),
          F === K)
        )
          break;
        F = F.return;
      }
    }
    function So(F, z, K, W) {
      var ee = F.child;
      for (ee !== null && (ee.return = F); ee !== null; ) {
        var ie = ee.dependencies;
        if (ie !== null) {
          var le = ee.child;
          ie = ie.firstContext;
          e: for (; ie !== null; ) {
            var de = ie;
            ie = ee;
            for (var ye = 0; ye < z.length; ye++)
              if (de.context === z[ye]) {
                (ie.lanes |= K),
                  (de = ie.alternate),
                  de !== null && (de.lanes |= K),
                  bo(ie.return, K, F),
                  W || (le = null);
                break e;
              }
            ie = de.next;
          }
        } else if (ee.tag === 18) {
          if (((le = ee.return), le === null)) throw Error(B(341));
          (le.lanes |= K),
            (ie = le.alternate),
            ie !== null && (ie.lanes |= K),
            bo(le, K, F),
            (le = null);
        } else le = ee.child;
        if (le !== null) le.return = ee;
        else
          for (le = ee; le !== null; ) {
            if (le === F) {
              le = null;
              break;
            }
            if (((ee = le.sibling), ee !== null)) {
              (ee.return = le.return), (le = ee);
              break;
            }
            le = le.return;
          }
        ee = le;
      }
    }
    function Hr(F, z, K, W) {
      F = null;
      for (var ee = z, ie = !1; ee !== null; ) {
        if (!ie) {
          if ((ee.flags & 524288) !== 0) ie = !0;
          else if ((ee.flags & 262144) !== 0) break;
        }
        if (ee.tag === 10) {
          var le = ee.alternate;
          if (le === null) throw Error(B(387));
          if (((le = le.memoizedProps), le !== null)) {
            var de = ee.type;
            cn(ee.pendingProps.value, le.value) ||
              (F !== null ? F.push(de) : (F = [de]));
          }
        } else if (ee === pt.current) {
          if (((le = ee.alternate), le === null)) throw Error(B(387));
          le.memoizedState.memoizedState !== ee.memoizedState.memoizedState &&
            (F !== null ? F.push(Sa) : (F = [Sa]));
        }
        ee = ee.return;
      }
      F !== null && So(z, F, K, W), (z.flags |= 262144);
    }
    function qa(F) {
      for (F = F.firstContext; F !== null; ) {
        if (!cn(F.context._currentValue, F.memoizedValue)) return !0;
        F = F.next;
      }
      return !1;
    }
    function Mi(F) {
      (Oi = F),
        (Bn = null),
        (F = F.dependencies),
        F !== null && (F.firstContext = null);
    }
    function Xt(F) {
      return Hc(Oi, F);
    }
    function za(F, z) {
      return Oi === null && Mi(F), Hc(F, z);
    }
    function Hc(F, z) {
      var K = z._currentValue;
      if (((z = { context: z, memoizedValue: K, next: null }), Bn === null)) {
        if (F === null) throw Error(B(308));
        (Bn = z),
          (F.dependencies = { lanes: 0, firstContext: z }),
          (F.flags |= 524288);
      } else Bn = Bn.next = z;
      return K;
    }
    var Oh =
        typeof AbortController < "u"
          ? AbortController
          : function () {
              var F = [],
                z = (this.signal = {
                  aborted: !1,
                  addEventListener: function (K, W) {
                    F.push(W);
                  },
                });
              this.abort = function () {
                (z.aborted = !0),
                  F.forEach(function (K) {
                    return K();
                  });
              };
            },
      Mh = U.unstable_scheduleCallback,
      Ih = U.unstable_NormalPriority,
      Bt = {
        $$typeof: he,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0,
      };
    function To() {
      return { controller: new Oh(), data: new Map(), refCount: 0 };
    }
    function Gr(F) {
      F.refCount--,
        F.refCount === 0 &&
          Mh(Ih, function () {
            F.controller.abort();
          });
    }
    var Kr = null,
      ko = 0,
      lr = 0,
      cr = null;
    function Lh(F, z) {
      if (Kr === null) {
        var K = (Kr = []);
        (ko = 0),
          (lr = El()),
          (cr = {
            status: "pending",
            value: void 0,
            then: function (W) {
              K.push(W);
            },
          });
      }
      return ko++, z.then(Gc, Gc), z;
    }
    function Gc() {
      if (--ko === 0 && Kr !== null) {
        cr !== null && (cr.status = "fulfilled");
        var F = Kr;
        (Kr = null), (lr = 0), (cr = null);
        for (var z = 0; z < F.length; z++) (0, F[z])();
      }
    }
    function Nh(F, z) {
      var K = [],
        W = {
          status: "pending",
          value: null,
          reason: null,
          then: function (ee) {
            K.push(ee);
          },
        };
      return (
        F.then(
          function () {
            (W.status = "fulfilled"), (W.value = z);
            for (var ee = 0; ee < K.length; ee++) (0, K[ee])(z);
          },
          function (ee) {
            for (
              W.status = "rejected", W.reason = ee, ee = 0;
              ee < K.length;
              ee++
            )
              (0, K[ee])(void 0);
          }
        ),
        W
      );
    }
    var Kc = Te.S;
    Te.S = function (F, z) {
      typeof z == "object" &&
        z !== null &&
        typeof z.then == "function" &&
        Lh(F, z),
        Kc !== null && Kc(F, z);
    };
    var Ii = De(null);
    function Co() {
      var F = Ii.current;
      return F !== null ? F : wt.pooledCache;
    }
    function $a(F, z) {
      z === null ? pe(Ii, Ii.current) : pe(Ii, z.pool);
    }
    function Yc() {
      var F = Co();
      return F === null ? null : { parent: Bt._currentValue, pool: F };
    }
    var Yr = Error(B(460)),
      Qc = Error(B(474)),
      Ha = Error(B(542)),
      Eo = { then: function () {} };
    function Wc(F) {
      return (F = F.status), F === "fulfilled" || F === "rejected";
    }
    function Ga() {}
    function Xc(F, z, K) {
      switch (
        ((K = F[K]),
        K === void 0 ? F.push(z) : K !== z && (z.then(Ga, Ga), (z = K)),
        z.status)
      ) {
        case "fulfilled":
          return z.value;
        case "rejected":
          throw ((F = z.reason), Zc(F), F);
        default:
          if (typeof z.status == "string") z.then(Ga, Ga);
          else {
            if (((F = wt), F !== null && 100 < F.shellSuspendCounter))
              throw Error(B(482));
            (F = z),
              (F.status = "pending"),
              F.then(
                function (W) {
                  if (z.status === "pending") {
                    var ee = z;
                    (ee.status = "fulfilled"), (ee.value = W);
                  }
                },
                function (W) {
                  if (z.status === "pending") {
                    var ee = z;
                    (ee.status = "rejected"), (ee.reason = W);
                  }
                }
              );
          }
          switch (z.status) {
            case "fulfilled":
              return z.value;
            case "rejected":
              throw ((F = z.reason), Zc(F), F);
          }
          throw ((Qr = z), Yr);
      }
    }
    var Qr = null;
    function Jc() {
      if (Qr === null) throw Error(B(459));
      var F = Qr;
      return (Qr = null), F;
    }
    function Zc(F) {
      if (F === Yr || F === Ha) throw Error(B(483));
    }
    var ti = !1;
    function xo(F) {
      F.updateQueue = {
        baseState: F.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null,
      };
    }
    function Ro(F, z) {
      (F = F.updateQueue),
        z.updateQueue === F &&
          (z.updateQueue = {
            baseState: F.baseState,
            firstBaseUpdate: F.firstBaseUpdate,
            lastBaseUpdate: F.lastBaseUpdate,
            shared: F.shared,
            callbacks: null,
          });
    }
    function ni(F) {
      return { lane: F, tag: 0, payload: null, callback: null, next: null };
    }
    function ii(F, z, K) {
      var W = F.updateQueue;
      if (W === null) return null;
      if (((W = W.shared), (Tt & 2) !== 0)) {
        var ee = W.pending;
        return (
          ee === null ? (z.next = z) : ((z.next = ee.next), (ee.next = z)),
          (W.pending = z),
          (z = Ua(F)),
          Vc(F, null, K),
          z
        );
      }
      return ja(F, W, z, K), Ua(F);
    }
    function Wr(F, z, K) {
      if (
        ((z = z.updateQueue),
        z !== null && ((z = z.shared), (K & 4194048) !== 0))
      ) {
        var W = z.lanes;
        (W &= F.pendingLanes), (K |= W), (z.lanes = K), zi(F, K);
      }
    }
    function _o(F, z) {
      var K = F.updateQueue,
        W = F.alternate;
      if (W !== null && ((W = W.updateQueue), K === W)) {
        var ee = null,
          ie = null;
        if (((K = K.firstBaseUpdate), K !== null)) {
          do {
            var le = {
              lane: K.lane,
              tag: K.tag,
              payload: K.payload,
              callback: null,
              next: null,
            };
            ie === null ? (ee = ie = le) : (ie = ie.next = le), (K = K.next);
          } while (K !== null);
          ie === null ? (ee = ie = z) : (ie = ie.next = z);
        } else ee = ie = z;
        (K = {
          baseState: W.baseState,
          firstBaseUpdate: ee,
          lastBaseUpdate: ie,
          shared: W.shared,
          callbacks: W.callbacks,
        }),
          (F.updateQueue = K);
        return;
      }
      (F = K.lastBaseUpdate),
        F === null ? (K.firstBaseUpdate = z) : (F.next = z),
        (K.lastBaseUpdate = z);
    }
    var wo = !1;
    function Xr() {
      if (wo) {
        var F = cr;
        if (F !== null) throw F;
      }
    }
    function Jr(F, z, K, W) {
      wo = !1;
      var ee = F.updateQueue;
      ti = !1;
      var ie = ee.firstBaseUpdate,
        le = ee.lastBaseUpdate,
        de = ee.shared.pending;
      if (de !== null) {
        ee.shared.pending = null;
        var ye = de,
          we = ye.next;
        (ye.next = null), le === null ? (ie = we) : (le.next = we), (le = ye);
        var Ve = F.alternate;
        Ve !== null &&
          ((Ve = Ve.updateQueue),
          (de = Ve.lastBaseUpdate),
          de !== le &&
            (de === null ? (Ve.firstBaseUpdate = we) : (de.next = we),
            (Ve.lastBaseUpdate = ye)));
      }
      if (ie !== null) {
        var $e = ee.baseState;
        (le = 0), (Ve = we = ye = null), (de = ie);
        do {
          var Pe = de.lane & -536870913,
            Oe = Pe !== de.lane;
          if (Oe ? (mt & Pe) === Pe : (W & Pe) === Pe) {
            Pe !== 0 && Pe === lr && (wo = !0),
              Ve !== null &&
                (Ve = Ve.next =
                  {
                    lane: 0,
                    tag: de.tag,
                    payload: de.payload,
                    callback: null,
                    next: null,
                  });
            e: {
              var ot = F,
                at = de;
              Pe = z;
              var xt = K;
              switch (at.tag) {
                case 1:
                  if (((ot = at.payload), typeof ot == "function")) {
                    $e = ot.call(xt, $e, Pe);
                    break e;
                  }
                  $e = ot;
                  break e;
                case 3:
                  ot.flags = (ot.flags & -65537) | 128;
                case 0:
                  if (
                    ((ot = at.payload),
                    (Pe = typeof ot == "function" ? ot.call(xt, $e, Pe) : ot),
                    Pe == null)
                  )
                    break e;
                  $e = X({}, $e, Pe);
                  break e;
                case 2:
                  ti = !0;
              }
            }
            (Pe = de.callback),
              Pe !== null &&
                ((F.flags |= 64),
                Oe && (F.flags |= 8192),
                (Oe = ee.callbacks),
                Oe === null ? (ee.callbacks = [Pe]) : Oe.push(Pe));
          } else
            (Oe = {
              lane: Pe,
              tag: de.tag,
              payload: de.payload,
              callback: de.callback,
              next: null,
            }),
              Ve === null ? ((we = Ve = Oe), (ye = $e)) : (Ve = Ve.next = Oe),
              (le |= Pe);
          if (((de = de.next), de === null)) {
            if (((de = ee.shared.pending), de === null)) break;
            (Oe = de),
              (de = Oe.next),
              (Oe.next = null),
              (ee.lastBaseUpdate = Oe),
              (ee.shared.pending = null);
          }
        } while (!0);
        Ve === null && (ye = $e),
          (ee.baseState = ye),
          (ee.firstBaseUpdate = we),
          (ee.lastBaseUpdate = Ve),
          ie === null && (ee.shared.lanes = 0),
          (di |= le),
          (F.lanes = le),
          (F.memoizedState = $e);
      }
    }
    function eu(F, z) {
      if (typeof F != "function") throw Error(B(191, F));
      F.call(z);
    }
    function tu(F, z) {
      var K = F.callbacks;
      if (K !== null)
        for (F.callbacks = null, F = 0; F < K.length; F++) eu(K[F], z);
    }
    var ur = De(null),
      Ka = De(0);
    function nu(F, z) {
      (F = Yn), pe(Ka, F), pe(ur, z), (Yn = F | z.baseLanes);
    }
    function Ao() {
      pe(Ka, Yn), pe(ur, ur.current);
    }
    function Po() {
      (Yn = Ka.current), Ge(ur), Ge(Ka);
    }
    var ri = 0,
      ut = null,
      Ct = null,
      Ut = null,
      Ya = !1,
      dr = !1,
      Li = !1,
      Qa = 0,
      Zr = 0,
      fr = null,
      jh = 0;
    function Lt() {
      throw Error(B(321));
    }
    function Do(F, z) {
      if (z === null) return !1;
      for (var K = 0; K < z.length && K < F.length; K++)
        if (!cn(F[K], z[K])) return !1;
      return !0;
    }
    function Oo(F, z, K, W, ee, ie) {
      return (
        (ri = ie),
        (ut = z),
        (z.memoizedState = null),
        (z.updateQueue = null),
        (z.lanes = 0),
        (Te.H = F === null || F.memoizedState === null ? Vu : Bu),
        (Li = !1),
        (ie = K(W, ee)),
        (Li = !1),
        dr && (ie = ru(z, K, W, ee)),
        iu(F),
        ie
      );
    }
    function iu(F) {
      Te.H = ts;
      var z = Ct !== null && Ct.next !== null;
      if (
        ((ri = 0), (Ut = Ct = ut = null), (Ya = !1), (Zr = 0), (fr = null), z)
      )
        throw Error(B(300));
      F === null ||
        $t ||
        ((F = F.dependencies), F !== null && qa(F) && ($t = !0));
    }
    function ru(F, z, K, W) {
      ut = F;
      var ee = 0;
      do {
        if ((dr && (fr = null), (Zr = 0), (dr = !1), 25 <= ee))
          throw Error(B(301));
        if (((ee += 1), (Ut = Ct = null), F.updateQueue != null)) {
          var ie = F.updateQueue;
          (ie.lastEffect = null),
            (ie.events = null),
            (ie.stores = null),
            ie.memoCache != null && (ie.memoCache.index = 0);
        }
        (Te.H = $h), (ie = z(K, W));
      } while (dr);
      return ie;
    }
    function Uh() {
      var F = Te.H,
        z = F.useState()[0];
      return (
        (z = typeof z.then == "function" ? ea(z) : z),
        (F = F.useState()[0]),
        (Ct !== null ? Ct.memoizedState : null) !== F && (ut.flags |= 1024),
        z
      );
    }
    function Mo() {
      var F = Qa !== 0;
      return (Qa = 0), F;
    }
    function Io(F, z, K) {
      (z.updateQueue = F.updateQueue), (z.flags &= -2053), (F.lanes &= ~K);
    }
    function Lo(F) {
      if (Ya) {
        for (F = F.memoizedState; F !== null; ) {
          var z = F.queue;
          z !== null && (z.pending = null), (F = F.next);
        }
        Ya = !1;
      }
      (ri = 0), (Ut = Ct = ut = null), (dr = !1), (Zr = Qa = 0), (fr = null);
    }
    function sn() {
      var F = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null,
      };
      return Ut === null ? (ut.memoizedState = Ut = F) : (Ut = Ut.next = F), Ut;
    }
    function Vt() {
      if (Ct === null) {
        var F = ut.alternate;
        F = F !== null ? F.memoizedState : null;
      } else F = Ct.next;
      var z = Ut === null ? ut.memoizedState : Ut.next;
      if (z !== null) (Ut = z), (Ct = F);
      else {
        if (F === null)
          throw ut.alternate === null ? Error(B(467)) : Error(B(310));
        (Ct = F),
          (F = {
            memoizedState: Ct.memoizedState,
            baseState: Ct.baseState,
            baseQueue: Ct.baseQueue,
            queue: Ct.queue,
            next: null,
          }),
          Ut === null ? (ut.memoizedState = Ut = F) : (Ut = Ut.next = F);
      }
      return Ut;
    }
    function No() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function ea(F) {
      var z = Zr;
      return (
        (Zr += 1),
        fr === null && (fr = []),
        (F = Xc(fr, F, z)),
        (z = ut),
        (Ut === null ? z.memoizedState : Ut.next) === null &&
          ((z = z.alternate),
          (Te.H = z === null || z.memoizedState === null ? Vu : Bu)),
        F
      );
    }
    function Wa(F) {
      if (F !== null && typeof F == "object") {
        if (typeof F.then == "function") return ea(F);
        if (F.$$typeof === he) return Xt(F);
      }
      throw Error(B(438, String(F)));
    }
    function jo(F) {
      var z = null,
        K = ut.updateQueue;
      if ((K !== null && (z = K.memoCache), z == null)) {
        var W = ut.alternate;
        W !== null &&
          ((W = W.updateQueue),
          W !== null &&
            ((W = W.memoCache),
            W != null &&
              (z = {
                data: W.data.map(function (ee) {
                  return ee.slice();
                }),
                index: 0,
              })));
      }
      if (
        (z == null && (z = { data: [], index: 0 }),
        K === null && ((K = No()), (ut.updateQueue = K)),
        (K.memoCache = z),
        (K = z.data[z.index]),
        K === void 0)
      )
        for (K = z.data[z.index] = Array(F), W = 0; W < F; W++) K[W] = Ae;
      return z.index++, K;
    }
    function qn(F, z) {
      return typeof z == "function" ? z(F) : z;
    }
    function Xa(F) {
      var z = Vt();
      return Uo(z, Ct, F);
    }
    function Uo(F, z, K) {
      var W = F.queue;
      if (W === null) throw Error(B(311));
      W.lastRenderedReducer = K;
      var ee = F.baseQueue,
        ie = W.pending;
      if (ie !== null) {
        if (ee !== null) {
          var le = ee.next;
          (ee.next = ie.next), (ie.next = le);
        }
        (z.baseQueue = ee = ie), (W.pending = null);
      }
      if (((ie = F.baseState), ee === null)) F.memoizedState = ie;
      else {
        z = ee.next;
        var de = (le = null),
          ye = null,
          we = z,
          Ve = !1;
        do {
          var $e = we.lane & -536870913;
          if ($e !== we.lane ? (mt & $e) === $e : (ri & $e) === $e) {
            var Pe = we.revertLane;
            if (Pe === 0)
              ye !== null &&
                (ye = ye.next =
                  {
                    lane: 0,
                    revertLane: 0,
                    action: we.action,
                    hasEagerState: we.hasEagerState,
                    eagerState: we.eagerState,
                    next: null,
                  }),
                $e === lr && (Ve = !0);
            else if ((ri & Pe) === Pe) {
              (we = we.next), Pe === lr && (Ve = !0);
              continue;
            } else
              ($e = {
                lane: 0,
                revertLane: we.revertLane,
                action: we.action,
                hasEagerState: we.hasEagerState,
                eagerState: we.eagerState,
                next: null,
              }),
                ye === null ? ((de = ye = $e), (le = ie)) : (ye = ye.next = $e),
                (ut.lanes |= Pe),
                (di |= Pe);
            ($e = we.action),
              Li && K(ie, $e),
              (ie = we.hasEagerState ? we.eagerState : K(ie, $e));
          } else
            (Pe = {
              lane: $e,
              revertLane: we.revertLane,
              action: we.action,
              hasEagerState: we.hasEagerState,
              eagerState: we.eagerState,
              next: null,
            }),
              ye === null ? ((de = ye = Pe), (le = ie)) : (ye = ye.next = Pe),
              (ut.lanes |= $e),
              (di |= $e);
          we = we.next;
        } while (we !== null && we !== z);
        if (
          (ye === null ? (le = ie) : (ye.next = de),
          !cn(ie, F.memoizedState) && (($t = !0), Ve && ((K = cr), K !== null)))
        )
          throw K;
        (F.memoizedState = ie),
          (F.baseState = le),
          (F.baseQueue = ye),
          (W.lastRenderedState = ie);
      }
      return ee === null && (W.lanes = 0), [F.memoizedState, W.dispatch];
    }
    function Vo(F) {
      var z = Vt(),
        K = z.queue;
      if (K === null) throw Error(B(311));
      K.lastRenderedReducer = F;
      var W = K.dispatch,
        ee = K.pending,
        ie = z.memoizedState;
      if (ee !== null) {
        K.pending = null;
        var le = (ee = ee.next);
        do (ie = F(ie, le.action)), (le = le.next);
        while (le !== ee);
        cn(ie, z.memoizedState) || ($t = !0),
          (z.memoizedState = ie),
          z.baseQueue === null && (z.baseState = ie),
          (K.lastRenderedState = ie);
      }
      return [ie, W];
    }
    function au(F, z, K) {
      var W = ut,
        ee = Vt(),
        ie = St;
      if (ie) {
        if (K === void 0) throw Error(B(407));
        K = K();
      } else K = z();
      var le = !cn((Ct || ee).memoizedState, K);
      le && ((ee.memoizedState = K), ($t = !0)), (ee = ee.queue);
      var de = lu.bind(null, W, ee, F);
      if (
        (ta(2048, 8, de, [F]),
        ee.getSnapshot !== z || le || (Ut !== null && Ut.memoizedState.tag & 1))
      ) {
        if (
          ((W.flags |= 2048),
          hr(9, Ja(), ou.bind(null, W, ee, K, z), null),
          wt === null)
        )
          throw Error(B(349));
        ie || (ri & 124) !== 0 || su(W, z, K);
      }
      return K;
    }
    function su(F, z, K) {
      (F.flags |= 16384),
        (F = { getSnapshot: z, value: K }),
        (z = ut.updateQueue),
        z === null
          ? ((z = No()), (ut.updateQueue = z), (z.stores = [F]))
          : ((K = z.stores), K === null ? (z.stores = [F]) : K.push(F));
    }
    function ou(F, z, K, W) {
      (z.value = K), (z.getSnapshot = W), cu(z) && uu(F);
    }
    function lu(F, z, K) {
      return K(function () {
        cu(z) && uu(F);
      });
    }
    function cu(F) {
      var z = F.getSnapshot;
      F = F.value;
      try {
        var K = z();
        return !cn(F, K);
      } catch {
        return !0;
      }
    }
    function uu(F) {
      var z = rr(F, 2);
      z !== null && mn(z, F, 2);
    }
    function Bo(F) {
      var z = sn();
      if (typeof F == "function") {
        var K = F;
        if (((F = K()), Li)) {
          it(!0);
          try {
            K();
          } finally {
            it(!1);
          }
        }
      }
      return (
        (z.memoizedState = z.baseState = F),
        (z.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: qn,
          lastRenderedState: F,
        }),
        z
      );
    }
    function du(F, z, K, W) {
      return (F.baseState = K), Uo(F, Ct, typeof W == "function" ? W : qn);
    }
    function Vh(F, z, K, W, ee) {
      if (es(F)) throw Error(B(485));
      if (((F = z.action), F !== null)) {
        var ie = {
          payload: ee,
          action: F,
          next: null,
          isTransition: !0,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function (le) {
            ie.listeners.push(le);
          },
        };
        Te.T !== null ? K(!0) : (ie.isTransition = !1),
          W(ie),
          (K = z.pending),
          K === null
            ? ((ie.next = z.pending = ie), fu(z, ie))
            : ((ie.next = K.next), (z.pending = K.next = ie));
      }
    }
    function fu(F, z) {
      var K = z.action,
        W = z.payload,
        ee = F.state;
      if (z.isTransition) {
        var ie = Te.T,
          le = {};
        Te.T = le;
        try {
          var de = K(ee, W),
            ye = Te.S;
          ye !== null && ye(le, de), hu(F, z, de);
        } catch (we) {
          Fo(F, z, we);
        } finally {
          Te.T = ie;
        }
      } else
        try {
          (ie = K(ee, W)), hu(F, z, ie);
        } catch (we) {
          Fo(F, z, we);
        }
    }
    function hu(F, z, K) {
      K !== null && typeof K == "object" && typeof K.then == "function"
        ? K.then(
            function (W) {
              pu(F, z, W);
            },
            function (W) {
              return Fo(F, z, W);
            }
          )
        : pu(F, z, K);
    }
    function pu(F, z, K) {
      (z.status = "fulfilled"),
        (z.value = K),
        mu(z),
        (F.state = K),
        (z = F.pending),
        z !== null &&
          ((K = z.next),
          K === z
            ? (F.pending = null)
            : ((K = K.next), (z.next = K), fu(F, K)));
    }
    function Fo(F, z, K) {
      var W = F.pending;
      if (((F.pending = null), W !== null)) {
        W = W.next;
        do (z.status = "rejected"), (z.reason = K), mu(z), (z = z.next);
        while (z !== W);
      }
      F.action = null;
    }
    function mu(F) {
      F = F.listeners;
      for (var z = 0; z < F.length; z++) (0, F[z])();
    }
    function gu(F, z) {
      return z;
    }
    function vu(F, z) {
      if (St) {
        var K = wt.formState;
        if (K !== null) {
          e: {
            var W = ut;
            if (St) {
              if (Ot) {
                t: {
                  for (var ee = Ot, ie = Pn; ee.nodeType !== 8; ) {
                    if (!ie) {
                      ee = null;
                      break t;
                    }
                    if (((ee = An(ee.nextSibling)), ee === null)) {
                      ee = null;
                      break t;
                    }
                  }
                  (ie = ee.data), (ee = ie === "F!" || ie === "F" ? ee : null);
                }
                if (ee) {
                  (Ot = An(ee.nextSibling)), (W = ee.data === "F!");
                  break e;
                }
              }
              Di(W);
            }
            W = !1;
          }
          W && (z = K[0]);
        }
      }
      return (
        (K = sn()),
        (K.memoizedState = K.baseState = z),
        (W = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: gu,
          lastRenderedState: z,
        }),
        (K.queue = W),
        (K = Nu.bind(null, ut, W)),
        (W.dispatch = K),
        (W = Bo(!1)),
        (ie = Go.bind(null, ut, !1, W.queue)),
        (W = sn()),
        (ee = { state: z, dispatch: null, action: F, pending: null }),
        (W.queue = ee),
        (K = Vh.bind(null, ut, ee, ie, K)),
        (ee.dispatch = K),
        (W.memoizedState = F),
        [z, K, !1]
      );
    }
    function yu(F) {
      var z = Vt();
      return bu(z, Ct, F);
    }
    function bu(F, z, K) {
      if (
        ((z = Uo(F, z, gu)[0]),
        (F = Xa(qn)[0]),
        typeof z == "object" && z !== null && typeof z.then == "function")
      )
        try {
          var W = ea(z);
        } catch (le) {
          throw le === Yr ? Ha : le;
        }
      else W = z;
      z = Vt();
      var ee = z.queue,
        ie = ee.dispatch;
      return (
        K !== z.memoizedState &&
          ((ut.flags |= 2048), hr(9, Ja(), Bh.bind(null, ee, K), null)),
        [W, ie, F]
      );
    }
    function Bh(F, z) {
      F.action = z;
    }
    function Su(F) {
      var z = Vt(),
        K = Ct;
      if (K !== null) return bu(z, K, F);
      Vt(), (z = z.memoizedState), (K = Vt());
      var W = K.queue.dispatch;
      return (K.memoizedState = F), [z, W, !1];
    }
    function hr(F, z, K, W) {
      return (
        (F = { tag: F, create: K, deps: W, inst: z, next: null }),
        (z = ut.updateQueue),
        z === null && ((z = No()), (ut.updateQueue = z)),
        (K = z.lastEffect),
        K === null
          ? (z.lastEffect = F.next = F)
          : ((W = K.next), (K.next = F), (F.next = W), (z.lastEffect = F)),
        F
      );
    }
    function Ja() {
      return { destroy: void 0, resource: void 0 };
    }
    function Tu() {
      return Vt().memoizedState;
    }
    function Za(F, z, K, W) {
      var ee = sn();
      (W = W === void 0 ? null : W),
        (ut.flags |= F),
        (ee.memoizedState = hr(1 | z, Ja(), K, W));
    }
    function ta(F, z, K, W) {
      var ee = Vt();
      W = W === void 0 ? null : W;
      var ie = ee.memoizedState.inst;
      Ct !== null && W !== null && Do(W, Ct.memoizedState.deps)
        ? (ee.memoizedState = hr(z, ie, K, W))
        : ((ut.flags |= F), (ee.memoizedState = hr(1 | z, ie, K, W)));
    }
    function ku(F, z) {
      Za(8390656, 8, F, z);
    }
    function Cu(F, z) {
      ta(2048, 8, F, z);
    }
    function Eu(F, z) {
      return ta(4, 2, F, z);
    }
    function xu(F, z) {
      return ta(4, 4, F, z);
    }
    function Ru(F, z) {
      if (typeof z == "function") {
        F = F();
        var K = z(F);
        return function () {
          typeof K == "function" ? K() : z(null);
        };
      }
      if (z != null)
        return (
          (F = F()),
          (z.current = F),
          function () {
            z.current = null;
          }
        );
    }
    function _u(F, z, K) {
      (K = K != null ? K.concat([F]) : null), ta(4, 4, Ru.bind(null, z, F), K);
    }
    function qo() {}
    function wu(F, z) {
      var K = Vt();
      z = z === void 0 ? null : z;
      var W = K.memoizedState;
      return z !== null && Do(z, W[1]) ? W[0] : ((K.memoizedState = [F, z]), F);
    }
    function Au(F, z) {
      var K = Vt();
      z = z === void 0 ? null : z;
      var W = K.memoizedState;
      if (z !== null && Do(z, W[1])) return W[0];
      if (((W = F()), Li)) {
        it(!0);
        try {
          F();
        } finally {
          it(!1);
        }
      }
      return (K.memoizedState = [W, z]), W;
    }
    function zo(F, z, K) {
      return K === void 0 || (ri & 1073741824) !== 0
        ? (F.memoizedState = z)
        : ((F.memoizedState = K), (F = Md()), (ut.lanes |= F), (di |= F), K);
    }
    function Pu(F, z, K, W) {
      return cn(K, z)
        ? K
        : ur.current !== null
        ? ((F = zo(F, K, W)), cn(F, z) || ($t = !0), F)
        : (ri & 42) === 0
        ? (($t = !0), (F.memoizedState = K))
        : ((F = Md()), (ut.lanes |= F), (di |= F), z);
    }
    function Du(F, z, K, W, ee) {
      var ie = xe.p;
      xe.p = ie !== 0 && 8 > ie ? ie : 8;
      var le = Te.T,
        de = {};
      (Te.T = de), Go(F, !1, z, K);
      try {
        var ye = ee(),
          we = Te.S;
        if (
          (we !== null && we(de, ye),
          ye !== null && typeof ye == "object" && typeof ye.then == "function")
        ) {
          var Ve = Nh(ye, W);
          na(F, z, Ve, pn(F));
        } else na(F, z, W, pn(F));
      } catch ($e) {
        na(
          F,
          z,
          { then: function () {}, status: "rejected", reason: $e },
          pn()
        );
      } finally {
        (xe.p = ie), (Te.T = le);
      }
    }
    function Fh() {}
    function $o(F, z, K, W) {
      if (F.tag !== 5) throw Error(B(476));
      var ee = Ou(F).queue;
      Du(
        F,
        ee,
        z,
        He,
        K === null
          ? Fh
          : function () {
              return Mu(F), K(W);
            }
      );
    }
    function Ou(F) {
      var z = F.memoizedState;
      if (z !== null) return z;
      z = {
        memoizedState: He,
        baseState: He,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: qn,
          lastRenderedState: He,
        },
        next: null,
      };
      var K = {};
      return (
        (z.next = {
          memoizedState: K,
          baseState: K,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: qn,
            lastRenderedState: K,
          },
          next: null,
        }),
        (F.memoizedState = z),
        (F = F.alternate),
        F !== null && (F.memoizedState = z),
        z
      );
    }
    function Mu(F) {
      var z = Ou(F).next.queue;
      na(F, z, {}, pn());
    }
    function Ho() {
      return Xt(Sa);
    }
    function Iu() {
      return Vt().memoizedState;
    }
    function Lu() {
      return Vt().memoizedState;
    }
    function qh(F) {
      for (var z = F.return; z !== null; ) {
        switch (z.tag) {
          case 24:
          case 3:
            var K = pn();
            F = ni(K);
            var W = ii(z, F, K);
            W !== null && (mn(W, z, K), Wr(W, z, K)),
              (z = { cache: To() }),
              (F.payload = z);
            return;
        }
        z = z.return;
      }
    }
    function zh(F, z, K) {
      var W = pn();
      (K = {
        lane: W,
        revertLane: 0,
        action: K,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      }),
        es(F)
          ? ju(z, K)
          : ((K = uo(F, z, K, W)), K !== null && (mn(K, F, W), Uu(K, z, W)));
    }
    function Nu(F, z, K) {
      var W = pn();
      na(F, z, K, W);
    }
    function na(F, z, K, W) {
      var ee = {
        lane: W,
        revertLane: 0,
        action: K,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
      if (es(F)) ju(z, ee);
      else {
        var ie = F.alternate;
        if (
          F.lanes === 0 &&
          (ie === null || ie.lanes === 0) &&
          ((ie = z.lastRenderedReducer), ie !== null)
        )
          try {
            var le = z.lastRenderedState,
              de = ie(le, K);
            if (((ee.hasEagerState = !0), (ee.eagerState = de), cn(de, le)))
              return ja(F, z, ee, 0), wt === null && Na(), !1;
          } catch {
          } finally {
          }
        if (((K = uo(F, z, ee, W)), K !== null))
          return mn(K, F, W), Uu(K, z, W), !0;
      }
      return !1;
    }
    function Go(F, z, K, W) {
      if (
        ((W = {
          lane: 2,
          revertLane: El(),
          action: W,
          hasEagerState: !1,
          eagerState: null,
          next: null,
        }),
        es(F))
      ) {
        if (z) throw Error(B(479));
      } else (z = uo(F, K, W, 2)), z !== null && mn(z, F, 2);
    }
    function es(F) {
      var z = F.alternate;
      return F === ut || (z !== null && z === ut);
    }
    function ju(F, z) {
      dr = Ya = !0;
      var K = F.pending;
      K === null ? (z.next = z) : ((z.next = K.next), (K.next = z)),
        (F.pending = z);
    }
    function Uu(F, z, K) {
      if ((K & 4194048) !== 0) {
        var W = z.lanes;
        (W &= F.pendingLanes), (K |= W), (z.lanes = K), zi(F, K);
      }
    }
    var ts = {
        readContext: Xt,
        use: Wa,
        useCallback: Lt,
        useContext: Lt,
        useEffect: Lt,
        useImperativeHandle: Lt,
        useLayoutEffect: Lt,
        useInsertionEffect: Lt,
        useMemo: Lt,
        useReducer: Lt,
        useRef: Lt,
        useState: Lt,
        useDebugValue: Lt,
        useDeferredValue: Lt,
        useTransition: Lt,
        useSyncExternalStore: Lt,
        useId: Lt,
        useHostTransitionStatus: Lt,
        useFormState: Lt,
        useActionState: Lt,
        useOptimistic: Lt,
        useMemoCache: Lt,
        useCacheRefresh: Lt,
      },
      Vu = {
        readContext: Xt,
        use: Wa,
        useCallback: function (F, z) {
          return (sn().memoizedState = [F, z === void 0 ? null : z]), F;
        },
        useContext: Xt,
        useEffect: ku,
        useImperativeHandle: function (F, z, K) {
          (K = K != null ? K.concat([F]) : null),
            Za(4194308, 4, Ru.bind(null, z, F), K);
        },
        useLayoutEffect: function (F, z) {
          return Za(4194308, 4, F, z);
        },
        useInsertionEffect: function (F, z) {
          Za(4, 2, F, z);
        },
        useMemo: function (F, z) {
          var K = sn();
          z = z === void 0 ? null : z;
          var W = F();
          if (Li) {
            it(!0);
            try {
              F();
            } finally {
              it(!1);
            }
          }
          return (K.memoizedState = [W, z]), W;
        },
        useReducer: function (F, z, K) {
          var W = sn();
          if (K !== void 0) {
            var ee = K(z);
            if (Li) {
              it(!0);
              try {
                K(z);
              } finally {
                it(!1);
              }
            }
          } else ee = z;
          return (
            (W.memoizedState = W.baseState = ee),
            (F = {
              pending: null,
              lanes: 0,
              dispatch: null,
              lastRenderedReducer: F,
              lastRenderedState: ee,
            }),
            (W.queue = F),
            (F = F.dispatch = zh.bind(null, ut, F)),
            [W.memoizedState, F]
          );
        },
        useRef: function (F) {
          var z = sn();
          return (F = { current: F }), (z.memoizedState = F);
        },
        useState: function (F) {
          F = Bo(F);
          var z = F.queue,
            K = Nu.bind(null, ut, z);
          return (z.dispatch = K), [F.memoizedState, K];
        },
        useDebugValue: qo,
        useDeferredValue: function (F, z) {
          var K = sn();
          return zo(K, F, z);
        },
        useTransition: function () {
          var F = Bo(!1);
          return (
            (F = Du.bind(null, ut, F.queue, !0, !1)),
            (sn().memoizedState = F),
            [!1, F]
          );
        },
        useSyncExternalStore: function (F, z, K) {
          var W = ut,
            ee = sn();
          if (St) {
            if (K === void 0) throw Error(B(407));
            K = K();
          } else {
            if (((K = z()), wt === null)) throw Error(B(349));
            (mt & 124) !== 0 || su(W, z, K);
          }
          ee.memoizedState = K;
          var ie = { value: K, getSnapshot: z };
          return (
            (ee.queue = ie),
            ku(lu.bind(null, W, ie, F), [F]),
            (W.flags |= 2048),
            hr(9, Ja(), ou.bind(null, W, ie, K, z), null),
            K
          );
        },
        useId: function () {
          var F = sn(),
            z = wt.identifierPrefix;
          if (St) {
            var K = Vn,
              W = Un;
            (K = (W & ~(1 << (32 - rt(W) - 1))).toString(32) + K),
              (z = "«" + z + "R" + K),
              (K = Qa++),
              0 < K && (z += "H" + K.toString(32)),
              (z += "»");
          } else (K = jh++), (z = "«" + z + "r" + K.toString(32) + "»");
          return (F.memoizedState = z);
        },
        useHostTransitionStatus: Ho,
        useFormState: vu,
        useActionState: vu,
        useOptimistic: function (F) {
          var z = sn();
          z.memoizedState = z.baseState = F;
          var K = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null,
          };
          return (
            (z.queue = K),
            (z = Go.bind(null, ut, !0, K)),
            (K.dispatch = z),
            [F, z]
          );
        },
        useMemoCache: jo,
        useCacheRefresh: function () {
          return (sn().memoizedState = qh.bind(null, ut));
        },
      },
      Bu = {
        readContext: Xt,
        use: Wa,
        useCallback: wu,
        useContext: Xt,
        useEffect: Cu,
        useImperativeHandle: _u,
        useInsertionEffect: Eu,
        useLayoutEffect: xu,
        useMemo: Au,
        useReducer: Xa,
        useRef: Tu,
        useState: function () {
          return Xa(qn);
        },
        useDebugValue: qo,
        useDeferredValue: function (F, z) {
          var K = Vt();
          return Pu(K, Ct.memoizedState, F, z);
        },
        useTransition: function () {
          var F = Xa(qn)[0],
            z = Vt().memoizedState;
          return [typeof F == "boolean" ? F : ea(F), z];
        },
        useSyncExternalStore: au,
        useId: Iu,
        useHostTransitionStatus: Ho,
        useFormState: yu,
        useActionState: yu,
        useOptimistic: function (F, z) {
          var K = Vt();
          return du(K, Ct, F, z);
        },
        useMemoCache: jo,
        useCacheRefresh: Lu,
      },
      $h = {
        readContext: Xt,
        use: Wa,
        useCallback: wu,
        useContext: Xt,
        useEffect: Cu,
        useImperativeHandle: _u,
        useInsertionEffect: Eu,
        useLayoutEffect: xu,
        useMemo: Au,
        useReducer: Vo,
        useRef: Tu,
        useState: function () {
          return Vo(qn);
        },
        useDebugValue: qo,
        useDeferredValue: function (F, z) {
          var K = Vt();
          return Ct === null ? zo(K, F, z) : Pu(K, Ct.memoizedState, F, z);
        },
        useTransition: function () {
          var F = Vo(qn)[0],
            z = Vt().memoizedState;
          return [typeof F == "boolean" ? F : ea(F), z];
        },
        useSyncExternalStore: au,
        useId: Iu,
        useHostTransitionStatus: Ho,
        useFormState: Su,
        useActionState: Su,
        useOptimistic: function (F, z) {
          var K = Vt();
          return Ct !== null
            ? du(K, Ct, F, z)
            : ((K.baseState = F), [F, K.queue.dispatch]);
        },
        useMemoCache: jo,
        useCacheRefresh: Lu,
      },
      pr = null,
      ia = 0;
    function ns(F) {
      var z = ia;
      return (ia += 1), pr === null && (pr = []), Xc(pr, F, z);
    }
    function ra(F, z) {
      (z = z.props.ref), (F.ref = z !== void 0 ? z : null);
    }
    function is(F, z) {
      throw z.$$typeof === Z
        ? Error(B(525))
        : ((F = Object.prototype.toString.call(z)),
          Error(
            B(
              31,
              F === "[object Object]"
                ? "object with keys {" + Object.keys(z).join(", ") + "}"
                : F
            )
          ));
    }
    function Fu(F) {
      var z = F._init;
      return z(F._payload);
    }
    function qu(F) {
      function z(ke, Se) {
        if (F) {
          var _e = ke.deletions;
          _e === null ? ((ke.deletions = [Se]), (ke.flags |= 16)) : _e.push(Se);
        }
      }
      function K(ke, Se) {
        if (!F) return null;
        for (; Se !== null; ) z(ke, Se), (Se = Se.sibling);
        return null;
      }
      function W(ke) {
        for (var Se = new Map(); ke !== null; )
          ke.key !== null ? Se.set(ke.key, ke) : Se.set(ke.index, ke),
            (ke = ke.sibling);
        return Se;
      }
      function ee(ke, Se) {
        return (ke = jn(ke, Se)), (ke.index = 0), (ke.sibling = null), ke;
      }
      function ie(ke, Se, _e) {
        return (
          (ke.index = _e),
          F
            ? ((_e = ke.alternate),
              _e !== null
                ? ((_e = _e.index), _e < Se ? ((ke.flags |= 67108866), Se) : _e)
                : ((ke.flags |= 67108866), Se))
            : ((ke.flags |= 1048576), Se)
        );
      }
      function le(ke) {
        return F && ke.alternate === null && (ke.flags |= 67108866), ke;
      }
      function de(ke, Se, _e, ze) {
        return Se === null || Se.tag !== 6
          ? ((Se = ho(_e, ke.mode, ze)), (Se.return = ke), Se)
          : ((Se = ee(Se, _e)), (Se.return = ke), Se);
      }
      function ye(ke, Se, _e, ze) {
        var et = _e.type;
        return et === ae
          ? Ve(ke, Se, _e.props.children, ze, _e.key)
          : Se !== null &&
            (Se.elementType === et ||
              (typeof et == "object" &&
                et !== null &&
                et.$$typeof === Ce &&
                Fu(et) === Se.type))
          ? ((Se = ee(Se, _e.props)), ra(Se, _e), (Se.return = ke), Se)
          : ((Se = Va(_e.type, _e.key, _e.props, null, ke.mode, ze)),
            ra(Se, _e),
            (Se.return = ke),
            Se);
      }
      function we(ke, Se, _e, ze) {
        return Se === null ||
          Se.tag !== 4 ||
          Se.stateNode.containerInfo !== _e.containerInfo ||
          Se.stateNode.implementation !== _e.implementation
          ? ((Se = po(_e, ke.mode, ze)), (Se.return = ke), Se)
          : ((Se = ee(Se, _e.children || [])), (Se.return = ke), Se);
      }
      function Ve(ke, Se, _e, ze, et) {
        return Se === null || Se.tag !== 7
          ? ((Se = _i(_e, ke.mode, ze, et)), (Se.return = ke), Se)
          : ((Se = ee(Se, _e)), (Se.return = ke), Se);
      }
      function $e(ke, Se, _e) {
        if (
          (typeof Se == "string" && Se !== "") ||
          typeof Se == "number" ||
          typeof Se == "bigint"
        )
          return (Se = ho("" + Se, ke.mode, _e)), (Se.return = ke), Se;
        if (typeof Se == "object" && Se !== null) {
          switch (Se.$$typeof) {
            case te:
              return (
                (_e = Va(Se.type, Se.key, Se.props, null, ke.mode, _e)),
                ra(_e, Se),
                (_e.return = ke),
                _e
              );
            case ne:
              return (Se = po(Se, ke.mode, _e)), (Se.return = ke), Se;
            case Ce:
              var ze = Se._init;
              return (Se = ze(Se._payload)), $e(ke, Se, _e);
          }
          if (je(Se) || Le(Se))
            return (Se = _i(Se, ke.mode, _e, null)), (Se.return = ke), Se;
          if (typeof Se.then == "function") return $e(ke, ns(Se), _e);
          if (Se.$$typeof === he) return $e(ke, za(ke, Se), _e);
          is(ke, Se);
        }
        return null;
      }
      function Pe(ke, Se, _e, ze) {
        var et = Se !== null ? Se.key : null;
        if (
          (typeof _e == "string" && _e !== "") ||
          typeof _e == "number" ||
          typeof _e == "bigint"
        )
          return et !== null ? null : de(ke, Se, "" + _e, ze);
        if (typeof _e == "object" && _e !== null) {
          switch (_e.$$typeof) {
            case te:
              return _e.key === et ? ye(ke, Se, _e, ze) : null;
            case ne:
              return _e.key === et ? we(ke, Se, _e, ze) : null;
            case Ce:
              return (
                (et = _e._init), (_e = et(_e._payload)), Pe(ke, Se, _e, ze)
              );
          }
          if (je(_e) || Le(_e))
            return et !== null ? null : Ve(ke, Se, _e, ze, null);
          if (typeof _e.then == "function") return Pe(ke, Se, ns(_e), ze);
          if (_e.$$typeof === he) return Pe(ke, Se, za(ke, _e), ze);
          is(ke, _e);
        }
        return null;
      }
      function Oe(ke, Se, _e, ze, et) {
        if (
          (typeof ze == "string" && ze !== "") ||
          typeof ze == "number" ||
          typeof ze == "bigint"
        )
          return (ke = ke.get(_e) || null), de(Se, ke, "" + ze, et);
        if (typeof ze == "object" && ze !== null) {
          switch (ze.$$typeof) {
            case te:
              return (
                (ke = ke.get(ze.key === null ? _e : ze.key) || null),
                ye(Se, ke, ze, et)
              );
            case ne:
              return (
                (ke = ke.get(ze.key === null ? _e : ze.key) || null),
                we(Se, ke, ze, et)
              );
            case Ce:
              var dt = ze._init;
              return (ze = dt(ze._payload)), Oe(ke, Se, _e, ze, et);
          }
          if (je(ze) || Le(ze))
            return (ke = ke.get(_e) || null), Ve(Se, ke, ze, et, null);
          if (typeof ze.then == "function") return Oe(ke, Se, _e, ns(ze), et);
          if (ze.$$typeof === he) return Oe(ke, Se, _e, za(Se, ze), et);
          is(Se, ze);
        }
        return null;
      }
      function ot(ke, Se, _e, ze) {
        for (
          var et = null, dt = null, nt = Se, st = (Se = 0), Gt = null;
          nt !== null && st < _e.length;
          st++
        ) {
          nt.index > st ? ((Gt = nt), (nt = null)) : (Gt = nt.sibling);
          var yt = Pe(ke, nt, _e[st], ze);
          if (yt === null) {
            nt === null && (nt = Gt);
            break;
          }
          F && nt && yt.alternate === null && z(ke, nt),
            (Se = ie(yt, Se, st)),
            dt === null ? (et = yt) : (dt.sibling = yt),
            (dt = yt),
            (nt = Gt);
        }
        if (st === _e.length) return K(ke, nt), St && Ai(ke, st), et;
        if (nt === null) {
          for (; st < _e.length; st++)
            (nt = $e(ke, _e[st], ze)),
              nt !== null &&
                ((Se = ie(nt, Se, st)),
                dt === null ? (et = nt) : (dt.sibling = nt),
                (dt = nt));
          return St && Ai(ke, st), et;
        }
        for (nt = W(nt); st < _e.length; st++)
          (Gt = Oe(nt, ke, st, _e[st], ze)),
            Gt !== null &&
              (F &&
                Gt.alternate !== null &&
                nt.delete(Gt.key === null ? st : Gt.key),
              (Se = ie(Gt, Se, st)),
              dt === null ? (et = Gt) : (dt.sibling = Gt),
              (dt = Gt));
        return (
          F &&
            nt.forEach(function (Si) {
              return z(ke, Si);
            }),
          St && Ai(ke, st),
          et
        );
      }
      function at(ke, Se, _e, ze) {
        if (_e == null) throw Error(B(151));
        for (
          var et = null,
            dt = null,
            nt = Se,
            st = (Se = 0),
            Gt = null,
            yt = _e.next();
          nt !== null && !yt.done;
          st++, yt = _e.next()
        ) {
          nt.index > st ? ((Gt = nt), (nt = null)) : (Gt = nt.sibling);
          var Si = Pe(ke, nt, yt.value, ze);
          if (Si === null) {
            nt === null && (nt = Gt);
            break;
          }
          F && nt && Si.alternate === null && z(ke, nt),
            (Se = ie(Si, Se, st)),
            dt === null ? (et = Si) : (dt.sibling = Si),
            (dt = Si),
            (nt = Gt);
        }
        if (yt.done) return K(ke, nt), St && Ai(ke, st), et;
        if (nt === null) {
          for (; !yt.done; st++, yt = _e.next())
            (yt = $e(ke, yt.value, ze)),
              yt !== null &&
                ((Se = ie(yt, Se, st)),
                dt === null ? (et = yt) : (dt.sibling = yt),
                (dt = yt));
          return St && Ai(ke, st), et;
        }
        for (nt = W(nt); !yt.done; st++, yt = _e.next())
          (yt = Oe(nt, ke, st, yt.value, ze)),
            yt !== null &&
              (F &&
                yt.alternate !== null &&
                nt.delete(yt.key === null ? st : yt.key),
              (Se = ie(yt, Se, st)),
              dt === null ? (et = yt) : (dt.sibling = yt),
              (dt = yt));
        return (
          F &&
            nt.forEach(function (Hp) {
              return z(ke, Hp);
            }),
          St && Ai(ke, st),
          et
        );
      }
      function xt(ke, Se, _e, ze) {
        if (
          (typeof _e == "object" &&
            _e !== null &&
            _e.type === ae &&
            _e.key === null &&
            (_e = _e.props.children),
          typeof _e == "object" && _e !== null)
        ) {
          switch (_e.$$typeof) {
            case te:
              e: {
                for (var et = _e.key; Se !== null; ) {
                  if (Se.key === et) {
                    if (((et = _e.type), et === ae)) {
                      if (Se.tag === 7) {
                        K(ke, Se.sibling),
                          (ze = ee(Se, _e.props.children)),
                          (ze.return = ke),
                          (ke = ze);
                        break e;
                      }
                    } else if (
                      Se.elementType === et ||
                      (typeof et == "object" &&
                        et !== null &&
                        et.$$typeof === Ce &&
                        Fu(et) === Se.type)
                    ) {
                      K(ke, Se.sibling),
                        (ze = ee(Se, _e.props)),
                        ra(ze, _e),
                        (ze.return = ke),
                        (ke = ze);
                      break e;
                    }
                    K(ke, Se);
                    break;
                  } else z(ke, Se);
                  Se = Se.sibling;
                }
                _e.type === ae
                  ? ((ze = _i(_e.props.children, ke.mode, ze, _e.key)),
                    (ze.return = ke),
                    (ke = ze))
                  : ((ze = Va(_e.type, _e.key, _e.props, null, ke.mode, ze)),
                    ra(ze, _e),
                    (ze.return = ke),
                    (ke = ze));
              }
              return le(ke);
            case ne:
              e: {
                for (et = _e.key; Se !== null; ) {
                  if (Se.key === et)
                    if (
                      Se.tag === 4 &&
                      Se.stateNode.containerInfo === _e.containerInfo &&
                      Se.stateNode.implementation === _e.implementation
                    ) {
                      K(ke, Se.sibling),
                        (ze = ee(Se, _e.children || [])),
                        (ze.return = ke),
                        (ke = ze);
                      break e;
                    } else {
                      K(ke, Se);
                      break;
                    }
                  else z(ke, Se);
                  Se = Se.sibling;
                }
                (ze = po(_e, ke.mode, ze)), (ze.return = ke), (ke = ze);
              }
              return le(ke);
            case Ce:
              return (
                (et = _e._init), (_e = et(_e._payload)), xt(ke, Se, _e, ze)
              );
          }
          if (je(_e)) return ot(ke, Se, _e, ze);
          if (Le(_e)) {
            if (((et = Le(_e)), typeof et != "function")) throw Error(B(150));
            return (_e = et.call(_e)), at(ke, Se, _e, ze);
          }
          if (typeof _e.then == "function") return xt(ke, Se, ns(_e), ze);
          if (_e.$$typeof === he) return xt(ke, Se, za(ke, _e), ze);
          is(ke, _e);
        }
        return (typeof _e == "string" && _e !== "") ||
          typeof _e == "number" ||
          typeof _e == "bigint"
          ? ((_e = "" + _e),
            Se !== null && Se.tag === 6
              ? (K(ke, Se.sibling),
                (ze = ee(Se, _e)),
                (ze.return = ke),
                (ke = ze))
              : (K(ke, Se),
                (ze = ho(_e, ke.mode, ze)),
                (ze.return = ke),
                (ke = ze)),
            le(ke))
          : K(ke, Se);
      }
      return function (ke, Se, _e, ze) {
        try {
          ia = 0;
          var et = xt(ke, Se, _e, ze);
          return (pr = null), et;
        } catch (nt) {
          if (nt === Yr || nt === Ha) throw nt;
          var dt = un(29, nt, null, ke.mode);
          return (dt.lanes = ze), (dt.return = ke), dt;
        } finally {
        }
      };
    }
    var mr = qu(!0),
      zu = qu(!1),
      Cn = De(null),
      Dn = null;
    function ai(F) {
      var z = F.alternate;
      pe(Ft, Ft.current & 1),
        pe(Cn, F),
        Dn === null &&
          (z === null || ur.current !== null || z.memoizedState !== null) &&
          (Dn = F);
    }
    function $u(F) {
      if (F.tag === 22) {
        if ((pe(Ft, Ft.current), pe(Cn, F), Dn === null)) {
          var z = F.alternate;
          z !== null && z.memoizedState !== null && (Dn = F);
        }
      } else si();
    }
    function si() {
      pe(Ft, Ft.current), pe(Cn, Cn.current);
    }
    function zn(F) {
      Ge(Cn), Dn === F && (Dn = null), Ge(Ft);
    }
    var Ft = De(0);
    function rs(F) {
      for (var z = F; z !== null; ) {
        if (z.tag === 13) {
          var K = z.memoizedState;
          if (
            K !== null &&
            ((K = K.dehydrated), K === null || K.data === "$?" || Nl(K))
          )
            return z;
        } else if (z.tag === 19 && z.memoizedProps.revealOrder !== void 0) {
          if ((z.flags & 128) !== 0) return z;
        } else if (z.child !== null) {
          (z.child.return = z), (z = z.child);
          continue;
        }
        if (z === F) break;
        for (; z.sibling === null; ) {
          if (z.return === null || z.return === F) return null;
          z = z.return;
        }
        (z.sibling.return = z.return), (z = z.sibling);
      }
      return null;
    }
    function Ko(F, z, K, W) {
      (z = F.memoizedState),
        (K = K(W, z)),
        (K = K == null ? z : X({}, z, K)),
        (F.memoizedState = K),
        F.lanes === 0 && (F.updateQueue.baseState = K);
    }
    var Yo = {
      enqueueSetState: function (F, z, K) {
        F = F._reactInternals;
        var W = pn(),
          ee = ni(W);
        (ee.payload = z),
          K != null && (ee.callback = K),
          (z = ii(F, ee, W)),
          z !== null && (mn(z, F, W), Wr(z, F, W));
      },
      enqueueReplaceState: function (F, z, K) {
        F = F._reactInternals;
        var W = pn(),
          ee = ni(W);
        (ee.tag = 1),
          (ee.payload = z),
          K != null && (ee.callback = K),
          (z = ii(F, ee, W)),
          z !== null && (mn(z, F, W), Wr(z, F, W));
      },
      enqueueForceUpdate: function (F, z) {
        F = F._reactInternals;
        var K = pn(),
          W = ni(K);
        (W.tag = 2),
          z != null && (W.callback = z),
          (z = ii(F, W, K)),
          z !== null && (mn(z, F, K), Wr(z, F, K));
      },
    };
    function Hu(F, z, K, W, ee, ie, le) {
      return (
        (F = F.stateNode),
        typeof F.shouldComponentUpdate == "function"
          ? F.shouldComponentUpdate(W, ie, le)
          : z.prototype && z.prototype.isPureReactComponent
          ? !Br(K, W) || !Br(ee, ie)
          : !0
      );
    }
    function Gu(F, z, K, W) {
      (F = z.state),
        typeof z.componentWillReceiveProps == "function" &&
          z.componentWillReceiveProps(K, W),
        typeof z.UNSAFE_componentWillReceiveProps == "function" &&
          z.UNSAFE_componentWillReceiveProps(K, W),
        z.state !== F && Yo.enqueueReplaceState(z, z.state, null);
    }
    function Ni(F, z) {
      var K = z;
      if ("ref" in z) {
        K = {};
        for (var W in z) W !== "ref" && (K[W] = z[W]);
      }
      if ((F = F.defaultProps)) {
        K === z && (K = X({}, K));
        for (var ee in F) K[ee] === void 0 && (K[ee] = F[ee]);
      }
      return K;
    }
    var as =
      typeof reportError == "function"
        ? reportError
        : function (F) {
            if (
              typeof window == "object" &&
              typeof window.ErrorEvent == "function"
            ) {
              var z = new window.ErrorEvent("error", {
                bubbles: !0,
                cancelable: !0,
                message:
                  typeof F == "object" &&
                  F !== null &&
                  typeof F.message == "string"
                    ? String(F.message)
                    : String(F),
                error: F,
              });
              if (!window.dispatchEvent(z)) return;
            } else if (
              typeof process == "object" &&
              typeof process.emit == "function"
            ) {
              process.emit("uncaughtException", F);
              return;
            }
            console.error(F);
          };
    function Ku(F) {
      as(F);
    }
    function Yu(F) {
      console.error(F);
    }
    function Qu(F) {
      as(F);
    }
    function ss(F, z) {
      try {
        var K = F.onUncaughtError;
        K(z.value, { componentStack: z.stack });
      } catch (W) {
        setTimeout(function () {
          throw W;
        });
      }
    }
    function Wu(F, z, K) {
      try {
        var W = F.onCaughtError;
        W(K.value, {
          componentStack: K.stack,
          errorBoundary: z.tag === 1 ? z.stateNode : null,
        });
      } catch (ee) {
        setTimeout(function () {
          throw ee;
        });
      }
    }
    function Qo(F, z, K) {
      return (
        (K = ni(K)),
        (K.tag = 3),
        (K.payload = { element: null }),
        (K.callback = function () {
          ss(F, z);
        }),
        K
      );
    }
    function Xu(F) {
      return (F = ni(F)), (F.tag = 3), F;
    }
    function Ju(F, z, K, W) {
      var ee = K.type.getDerivedStateFromError;
      if (typeof ee == "function") {
        var ie = W.value;
        (F.payload = function () {
          return ee(ie);
        }),
          (F.callback = function () {
            Wu(z, K, W);
          });
      }
      var le = K.stateNode;
      le !== null &&
        typeof le.componentDidCatch == "function" &&
        (F.callback = function () {
          Wu(z, K, W),
            typeof ee != "function" &&
              (fi === null ? (fi = new Set([this])) : fi.add(this));
          var de = W.stack;
          this.componentDidCatch(W.value, {
            componentStack: de !== null ? de : "",
          });
        });
    }
    function Hh(F, z, K, W, ee) {
      if (
        ((K.flags |= 32768),
        W !== null && typeof W == "object" && typeof W.then == "function")
      ) {
        if (
          ((z = K.alternate),
          z !== null && Hr(z, K, ee, !0),
          (K = Cn.current),
          K !== null)
        ) {
          switch (K.tag) {
            case 13:
              return (
                Dn === null
                  ? bl()
                  : K.alternate === null && Mt === 0 && (Mt = 3),
                (K.flags &= -257),
                (K.flags |= 65536),
                (K.lanes = ee),
                W === Eo
                  ? (K.flags |= 16384)
                  : ((z = K.updateQueue),
                    z === null ? (K.updateQueue = new Set([W])) : z.add(W),
                    Tl(F, W, ee)),
                !1
              );
            case 22:
              return (
                (K.flags |= 65536),
                W === Eo
                  ? (K.flags |= 16384)
                  : ((z = K.updateQueue),
                    z === null
                      ? ((z = {
                          transitions: null,
                          markerInstances: null,
                          retryQueue: new Set([W]),
                        }),
                        (K.updateQueue = z))
                      : ((K = z.retryQueue),
                        K === null ? (z.retryQueue = new Set([W])) : K.add(W)),
                    Tl(F, W, ee)),
                !1
              );
          }
          throw Error(B(435, K.tag));
        }
        return Tl(F, W, ee), bl(), !1;
      }
      if (St)
        return (
          (z = Cn.current),
          z !== null
            ? ((z.flags & 65536) === 0 && (z.flags |= 256),
              (z.flags |= 65536),
              (z.lanes = ee),
              W !== vo && ((F = Error(B(422), { cause: W })), $r(bn(F, K))))
            : (W !== vo && ((z = Error(B(423), { cause: W })), $r(bn(z, K))),
              (F = F.current.alternate),
              (F.flags |= 65536),
              (ee &= -ee),
              (F.lanes |= ee),
              (W = bn(W, K)),
              (ee = Qo(F.stateNode, W, ee)),
              _o(F, ee),
              Mt !== 4 && (Mt = 2)),
          !1
        );
      var ie = Error(B(520), { cause: W });
      if (
        ((ie = bn(ie, K)),
        da === null ? (da = [ie]) : da.push(ie),
        Mt !== 4 && (Mt = 2),
        z === null)
      )
        return !0;
      (W = bn(W, K)), (K = z);
      do {
        switch (K.tag) {
          case 3:
            return (
              (K.flags |= 65536),
              (F = ee & -ee),
              (K.lanes |= F),
              (F = Qo(K.stateNode, W, F)),
              _o(K, F),
              !1
            );
          case 1:
            if (
              ((z = K.type),
              (ie = K.stateNode),
              (K.flags & 128) === 0 &&
                (typeof z.getDerivedStateFromError == "function" ||
                  (ie !== null &&
                    typeof ie.componentDidCatch == "function" &&
                    (fi === null || !fi.has(ie)))))
            )
              return (
                (K.flags |= 65536),
                (ee &= -ee),
                (K.lanes |= ee),
                (ee = Xu(ee)),
                Ju(ee, F, K, W),
                _o(K, ee),
                !1
              );
        }
        K = K.return;
      } while (K !== null);
      return !1;
    }
    var Zu = Error(B(461)),
      $t = !1;
    function Kt(F, z, K, W) {
      z.child = F === null ? zu(z, null, K, W) : mr(z, F.child, K, W);
    }
    function ed(F, z, K, W, ee) {
      K = K.render;
      var ie = z.ref;
      if ("ref" in W) {
        var le = {};
        for (var de in W) de !== "ref" && (le[de] = W[de]);
      } else le = W;
      return (
        Mi(z),
        (W = Oo(F, z, K, le, ie, ee)),
        (de = Mo()),
        F !== null && !$t
          ? (Io(F, z, ee), $n(F, z, ee))
          : (St && de && mo(z), (z.flags |= 1), Kt(F, z, W, ee), z.child)
      );
    }
    function td(F, z, K, W, ee) {
      if (F === null) {
        var ie = K.type;
        return typeof ie == "function" &&
          !fo(ie) &&
          ie.defaultProps === void 0 &&
          K.compare === null
          ? ((z.tag = 15), (z.type = ie), nd(F, z, ie, W, ee))
          : ((F = Va(K.type, null, W, z, z.mode, ee)),
            (F.ref = z.ref),
            (F.return = z),
            (z.child = F));
      }
      if (((ie = F.child), !il(F, ee))) {
        var le = ie.memoizedProps;
        if (
          ((K = K.compare),
          (K = K !== null ? K : Br),
          K(le, W) && F.ref === z.ref)
        )
          return $n(F, z, ee);
      }
      return (
        (z.flags |= 1),
        (F = jn(ie, W)),
        (F.ref = z.ref),
        (F.return = z),
        (z.child = F)
      );
    }
    function nd(F, z, K, W, ee) {
      if (F !== null) {
        var ie = F.memoizedProps;
        if (Br(ie, W) && F.ref === z.ref)
          if ((($t = !1), (z.pendingProps = W = ie), il(F, ee)))
            (F.flags & 131072) !== 0 && ($t = !0);
          else return (z.lanes = F.lanes), $n(F, z, ee);
      }
      return Wo(F, z, K, W, ee);
    }
    function rd(F, z, K) {
      var W = z.pendingProps,
        ee = W.children,
        ie = F !== null ? F.memoizedState : null;
      if (W.mode === "hidden") {
        if ((z.flags & 128) !== 0) {
          if (((W = ie !== null ? ie.baseLanes | K : K), F !== null)) {
            for (ee = z.child = F.child, ie = 0; ee !== null; )
              (ie = ie | ee.lanes | ee.childLanes), (ee = ee.sibling);
            z.childLanes = ie & ~W;
          } else (z.childLanes = 0), (z.child = null);
          return ad(F, z, W, K);
        }
        if ((K & 536870912) !== 0)
          (z.memoizedState = { baseLanes: 0, cachePool: null }),
            F !== null && $a(z, ie !== null ? ie.cachePool : null),
            ie !== null ? nu(z, ie) : Ao(),
            $u(z);
        else
          return (
            (z.lanes = z.childLanes = 536870912),
            ad(F, z, ie !== null ? ie.baseLanes | K : K, K)
          );
      } else
        ie !== null
          ? ($a(z, ie.cachePool), nu(z, ie), si(), (z.memoizedState = null))
          : (F !== null && $a(z, null), Ao(), si());
      return Kt(F, z, ee, K), z.child;
    }
    function ad(F, z, K, W) {
      var ee = Co();
      return (
        (ee = ee === null ? null : { parent: Bt._currentValue, pool: ee }),
        (z.memoizedState = { baseLanes: K, cachePool: ee }),
        F !== null && $a(z, null),
        Ao(),
        $u(z),
        F !== null && Hr(F, z, W, !0),
        null
      );
    }
    function os(F, z) {
      var K = z.ref;
      if (K === null) F !== null && F.ref !== null && (z.flags |= 4194816);
      else {
        if (typeof K != "function" && typeof K != "object") throw Error(B(284));
        (F === null || F.ref !== K) && (z.flags |= 4194816);
      }
    }
    function Wo(F, z, K, W, ee) {
      return (
        Mi(z),
        (K = Oo(F, z, K, W, void 0, ee)),
        (W = Mo()),
        F !== null && !$t
          ? (Io(F, z, ee), $n(F, z, ee))
          : (St && W && mo(z), (z.flags |= 1), Kt(F, z, K, ee), z.child)
      );
    }
    function sd(F, z, K, W, ee, ie) {
      return (
        Mi(z),
        (z.updateQueue = null),
        (K = ru(z, W, K, ee)),
        iu(F),
        (W = Mo()),
        F !== null && !$t
          ? (Io(F, z, ie), $n(F, z, ie))
          : (St && W && mo(z), (z.flags |= 1), Kt(F, z, K, ie), z.child)
      );
    }
    function od(F, z, K, W, ee) {
      if ((Mi(z), z.stateNode === null)) {
        var ie = ar,
          le = K.contextType;
        typeof le == "object" && le !== null && (ie = Xt(le)),
          (ie = new K(W, ie)),
          (z.memoizedState =
            ie.state !== null && ie.state !== void 0 ? ie.state : null),
          (ie.updater = Yo),
          (z.stateNode = ie),
          (ie._reactInternals = z),
          (ie = z.stateNode),
          (ie.props = W),
          (ie.state = z.memoizedState),
          (ie.refs = {}),
          xo(z),
          (le = K.contextType),
          (ie.context = typeof le == "object" && le !== null ? Xt(le) : ar),
          (ie.state = z.memoizedState),
          (le = K.getDerivedStateFromProps),
          typeof le == "function" &&
            (Ko(z, K, le, W), (ie.state = z.memoizedState)),
          typeof K.getDerivedStateFromProps == "function" ||
            typeof ie.getSnapshotBeforeUpdate == "function" ||
            (typeof ie.UNSAFE_componentWillMount != "function" &&
              typeof ie.componentWillMount != "function") ||
            ((le = ie.state),
            typeof ie.componentWillMount == "function" &&
              ie.componentWillMount(),
            typeof ie.UNSAFE_componentWillMount == "function" &&
              ie.UNSAFE_componentWillMount(),
            le !== ie.state && Yo.enqueueReplaceState(ie, ie.state, null),
            Jr(z, W, ie, ee),
            Xr(),
            (ie.state = z.memoizedState)),
          typeof ie.componentDidMount == "function" && (z.flags |= 4194308),
          (W = !0);
      } else if (F === null) {
        ie = z.stateNode;
        var de = z.memoizedProps,
          ye = Ni(K, de);
        ie.props = ye;
        var we = ie.context,
          Ve = K.contextType;
        (le = ar), typeof Ve == "object" && Ve !== null && (le = Xt(Ve));
        var $e = K.getDerivedStateFromProps;
        (Ve =
          typeof $e == "function" ||
          typeof ie.getSnapshotBeforeUpdate == "function"),
          (de = z.pendingProps !== de),
          Ve ||
            (typeof ie.UNSAFE_componentWillReceiveProps != "function" &&
              typeof ie.componentWillReceiveProps != "function") ||
            ((de || we !== le) && Gu(z, ie, W, le)),
          (ti = !1);
        var Pe = z.memoizedState;
        (ie.state = Pe),
          Jr(z, W, ie, ee),
          Xr(),
          (we = z.memoizedState),
          de || Pe !== we || ti
            ? (typeof $e == "function" &&
                (Ko(z, K, $e, W), (we = z.memoizedState)),
              (ye = ti || Hu(z, K, ye, W, Pe, we, le))
                ? (Ve ||
                    (typeof ie.UNSAFE_componentWillMount != "function" &&
                      typeof ie.componentWillMount != "function") ||
                    (typeof ie.componentWillMount == "function" &&
                      ie.componentWillMount(),
                    typeof ie.UNSAFE_componentWillMount == "function" &&
                      ie.UNSAFE_componentWillMount()),
                  typeof ie.componentDidMount == "function" &&
                    (z.flags |= 4194308))
                : (typeof ie.componentDidMount == "function" &&
                    (z.flags |= 4194308),
                  (z.memoizedProps = W),
                  (z.memoizedState = we)),
              (ie.props = W),
              (ie.state = we),
              (ie.context = le),
              (W = ye))
            : (typeof ie.componentDidMount == "function" &&
                (z.flags |= 4194308),
              (W = !1));
      } else {
        (ie = z.stateNode),
          Ro(F, z),
          (le = z.memoizedProps),
          (Ve = Ni(K, le)),
          (ie.props = Ve),
          ($e = z.pendingProps),
          (Pe = ie.context),
          (we = K.contextType),
          (ye = ar),
          typeof we == "object" && we !== null && (ye = Xt(we)),
          (de = K.getDerivedStateFromProps),
          (we =
            typeof de == "function" ||
            typeof ie.getSnapshotBeforeUpdate == "function") ||
            (typeof ie.UNSAFE_componentWillReceiveProps != "function" &&
              typeof ie.componentWillReceiveProps != "function") ||
            ((le !== $e || Pe !== ye) && Gu(z, ie, W, ye)),
          (ti = !1),
          (Pe = z.memoizedState),
          (ie.state = Pe),
          Jr(z, W, ie, ee),
          Xr();
        var Oe = z.memoizedState;
        le !== $e ||
        Pe !== Oe ||
        ti ||
        (F !== null && F.dependencies !== null && qa(F.dependencies))
          ? (typeof de == "function" &&
              (Ko(z, K, de, W), (Oe = z.memoizedState)),
            (Ve =
              ti ||
              Hu(z, K, Ve, W, Pe, Oe, ye) ||
              (F !== null && F.dependencies !== null && qa(F.dependencies)))
              ? (we ||
                  (typeof ie.UNSAFE_componentWillUpdate != "function" &&
                    typeof ie.componentWillUpdate != "function") ||
                  (typeof ie.componentWillUpdate == "function" &&
                    ie.componentWillUpdate(W, Oe, ye),
                  typeof ie.UNSAFE_componentWillUpdate == "function" &&
                    ie.UNSAFE_componentWillUpdate(W, Oe, ye)),
                typeof ie.componentDidUpdate == "function" && (z.flags |= 4),
                typeof ie.getSnapshotBeforeUpdate == "function" &&
                  (z.flags |= 1024))
              : (typeof ie.componentDidUpdate != "function" ||
                  (le === F.memoizedProps && Pe === F.memoizedState) ||
                  (z.flags |= 4),
                typeof ie.getSnapshotBeforeUpdate != "function" ||
                  (le === F.memoizedProps && Pe === F.memoizedState) ||
                  (z.flags |= 1024),
                (z.memoizedProps = W),
                (z.memoizedState = Oe)),
            (ie.props = W),
            (ie.state = Oe),
            (ie.context = ye),
            (W = Ve))
          : (typeof ie.componentDidUpdate != "function" ||
              (le === F.memoizedProps && Pe === F.memoizedState) ||
              (z.flags |= 4),
            typeof ie.getSnapshotBeforeUpdate != "function" ||
              (le === F.memoizedProps && Pe === F.memoizedState) ||
              (z.flags |= 1024),
            (W = !1));
      }
      return (
        (ie = W),
        os(F, z),
        (W = (z.flags & 128) !== 0),
        ie || W
          ? ((ie = z.stateNode),
            (K =
              W && typeof K.getDerivedStateFromError != "function"
                ? null
                : ie.render()),
            (z.flags |= 1),
            F !== null && W
              ? ((z.child = mr(z, F.child, null, ee)),
                (z.child = mr(z, null, K, ee)))
              : Kt(F, z, K, ee),
            (z.memoizedState = ie.state),
            (F = z.child))
          : (F = $n(F, z, ee)),
        F
      );
    }
    function ld(F, z, K, W) {
      return zr(), (z.flags |= 256), Kt(F, z, K, W), z.child;
    }
    var Xo = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null,
    };
    function Jo(F) {
      return { baseLanes: F, cachePool: Yc() };
    }
    function Zo(F, z, K) {
      return (F = F !== null ? F.childLanes & ~K : 0), z && (F |= En), F;
    }
    function cd(F, z, K) {
      var W = z.pendingProps,
        ee = !1,
        ie = (z.flags & 128) !== 0,
        le;
      if (
        ((le = ie) ||
          (le =
            F !== null && F.memoizedState === null
              ? !1
              : (Ft.current & 2) !== 0),
        le && ((ee = !0), (z.flags &= -129)),
        (le = (z.flags & 32) !== 0),
        (z.flags &= -33),
        F === null)
      ) {
        if (St) {
          if ((ee ? ai(z) : si(), St)) {
            var de = Ot,
              ye;
            if ((ye = de)) {
              e: {
                for (ye = de, de = Pn; ye.nodeType !== 8; ) {
                  if (!de) {
                    de = null;
                    break e;
                  }
                  if (((ye = An(ye.nextSibling)), ye === null)) {
                    de = null;
                    break e;
                  }
                }
                de = ye;
              }
              de !== null
                ? ((z.memoizedState = {
                    dehydrated: de,
                    treeContext: wi !== null ? { id: Un, overflow: Vn } : null,
                    retryLane: 536870912,
                    hydrationErrors: null,
                  }),
                  (ye = un(18, null, null, 0)),
                  (ye.stateNode = de),
                  (ye.return = z),
                  (z.child = ye),
                  (tn = z),
                  (Ot = null),
                  (ye = !0))
                : (ye = !1);
            }
            ye || Di(z);
          }
          if (
            ((de = z.memoizedState),
            de !== null && ((de = de.dehydrated), de !== null))
          )
            return Nl(de) ? (z.lanes = 32) : (z.lanes = 536870912), null;
          zn(z);
        }
        return (
          (de = W.children),
          (W = W.fallback),
          ee
            ? (si(),
              (ee = z.mode),
              (de = ls({ mode: "hidden", children: de }, ee)),
              (W = _i(W, ee, K, null)),
              (de.return = z),
              (W.return = z),
              (de.sibling = W),
              (z.child = de),
              (ee = z.child),
              (ee.memoizedState = Jo(K)),
              (ee.childLanes = Zo(F, le, K)),
              (z.memoizedState = Xo),
              W)
            : (ai(z), el(z, de))
        );
      }
      if (
        ((ye = F.memoizedState),
        ye !== null && ((de = ye.dehydrated), de !== null))
      ) {
        if (ie)
          z.flags & 256
            ? (ai(z), (z.flags &= -257), (z = tl(F, z, K)))
            : z.memoizedState !== null
            ? (si(), (z.child = F.child), (z.flags |= 128), (z = null))
            : (si(),
              (ee = W.fallback),
              (de = z.mode),
              (W = ls({ mode: "visible", children: W.children }, de)),
              (ee = _i(ee, de, K, null)),
              (ee.flags |= 2),
              (W.return = z),
              (ee.return = z),
              (W.sibling = ee),
              (z.child = W),
              mr(z, F.child, null, K),
              (W = z.child),
              (W.memoizedState = Jo(K)),
              (W.childLanes = Zo(F, le, K)),
              (z.memoizedState = Xo),
              (z = ee));
        else if ((ai(z), Nl(de))) {
          if (((le = de.nextSibling && de.nextSibling.dataset), le))
            var we = le.dgst;
          (le = we),
            (W = Error(B(419))),
            (W.stack = ""),
            (W.digest = le),
            $r({ value: W, source: null, stack: null }),
            (z = tl(F, z, K));
        } else if (
          ($t || Hr(F, z, K, !1), (le = (K & F.childLanes) !== 0), $t || le)
        ) {
          if (
            ((le = wt),
            le !== null &&
              ((W = K & -K),
              (W = (W & 42) !== 0 ? 1 : Ns(W)),
              (W = (W & (le.suspendedLanes | K)) !== 0 ? 0 : W),
              W !== 0 && W !== ye.retryLane))
          )
            throw ((ye.retryLane = W), rr(F, W), mn(le, F, W), Zu);
          de.data === "$?" || bl(), (z = tl(F, z, K));
        } else
          de.data === "$?"
            ? ((z.flags |= 192), (z.child = F.child), (z = null))
            : ((F = ye.treeContext),
              (Ot = An(de.nextSibling)),
              (tn = z),
              (St = !0),
              (Pi = null),
              (Pn = !1),
              F !== null &&
                ((Tn[kn++] = Un),
                (Tn[kn++] = Vn),
                (Tn[kn++] = wi),
                (Un = F.id),
                (Vn = F.overflow),
                (wi = z)),
              (z = el(z, W.children)),
              (z.flags |= 4096));
        return z;
      }
      return ee
        ? (si(),
          (ee = W.fallback),
          (de = z.mode),
          (ye = F.child),
          (we = ye.sibling),
          (W = jn(ye, { mode: "hidden", children: W.children })),
          (W.subtreeFlags = ye.subtreeFlags & 65011712),
          we !== null
            ? (ee = jn(we, ee))
            : ((ee = _i(ee, de, K, null)), (ee.flags |= 2)),
          (ee.return = z),
          (W.return = z),
          (W.sibling = ee),
          (z.child = W),
          (W = ee),
          (ee = z.child),
          (de = F.child.memoizedState),
          de === null
            ? (de = Jo(K))
            : ((ye = de.cachePool),
              ye !== null
                ? ((we = Bt._currentValue),
                  (ye = ye.parent !== we ? { parent: we, pool: we } : ye))
                : (ye = Yc()),
              (de = { baseLanes: de.baseLanes | K, cachePool: ye })),
          (ee.memoizedState = de),
          (ee.childLanes = Zo(F, le, K)),
          (z.memoizedState = Xo),
          W)
        : (ai(z),
          (K = F.child),
          (F = K.sibling),
          (K = jn(K, { mode: "visible", children: W.children })),
          (K.return = z),
          (K.sibling = null),
          F !== null &&
            ((le = z.deletions),
            le === null ? ((z.deletions = [F]), (z.flags |= 16)) : le.push(F)),
          (z.child = K),
          (z.memoizedState = null),
          K);
    }
    function el(F, z) {
      return (
        (z = ls({ mode: "visible", children: z }, F.mode)),
        (z.return = F),
        (F.child = z)
      );
    }
    function ls(F, z) {
      return (
        (F = un(22, F, null, z)),
        (F.lanes = 0),
        (F.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null,
        }),
        F
      );
    }
    function tl(F, z, K) {
      return (
        mr(z, F.child, null, K),
        (F = el(z, z.pendingProps.children)),
        (F.flags |= 2),
        (z.memoizedState = null),
        F
      );
    }
    function ud(F, z, K) {
      F.lanes |= z;
      var W = F.alternate;
      W !== null && (W.lanes |= z), bo(F.return, z, K);
    }
    function nl(F, z, K, W, ee) {
      var ie = F.memoizedState;
      ie === null
        ? (F.memoizedState = {
            isBackwards: z,
            rendering: null,
            renderingStartTime: 0,
            last: W,
            tail: K,
            tailMode: ee,
          })
        : ((ie.isBackwards = z),
          (ie.rendering = null),
          (ie.renderingStartTime = 0),
          (ie.last = W),
          (ie.tail = K),
          (ie.tailMode = ee));
    }
    function dd(F, z, K) {
      var W = z.pendingProps,
        ee = W.revealOrder,
        ie = W.tail;
      if ((Kt(F, z, W.children, K), (W = Ft.current), (W & 2) !== 0))
        (W = (W & 1) | 2), (z.flags |= 128);
      else {
        if (F !== null && (F.flags & 128) !== 0)
          e: for (F = z.child; F !== null; ) {
            if (F.tag === 13) F.memoizedState !== null && ud(F, K, z);
            else if (F.tag === 19) ud(F, K, z);
            else if (F.child !== null) {
              (F.child.return = F), (F = F.child);
              continue;
            }
            if (F === z) break e;
            for (; F.sibling === null; ) {
              if (F.return === null || F.return === z) break e;
              F = F.return;
            }
            (F.sibling.return = F.return), (F = F.sibling);
          }
        W &= 1;
      }
      switch ((pe(Ft, W), ee)) {
        case "forwards":
          for (K = z.child, ee = null; K !== null; )
            (F = K.alternate),
              F !== null && rs(F) === null && (ee = K),
              (K = K.sibling);
          (K = ee),
            K === null
              ? ((ee = z.child), (z.child = null))
              : ((ee = K.sibling), (K.sibling = null)),
            nl(z, !1, ee, K, ie);
          break;
        case "backwards":
          for (K = null, ee = z.child, z.child = null; ee !== null; ) {
            if (((F = ee.alternate), F !== null && rs(F) === null)) {
              z.child = ee;
              break;
            }
            (F = ee.sibling), (ee.sibling = K), (K = ee), (ee = F);
          }
          nl(z, !0, K, null, ie);
          break;
        case "together":
          nl(z, !1, null, null, void 0);
          break;
        default:
          z.memoizedState = null;
      }
      return z.child;
    }
    function $n(F, z, K) {
      if (
        (F !== null && (z.dependencies = F.dependencies),
        (di |= z.lanes),
        (K & z.childLanes) === 0)
      )
        if (F !== null) {
          if ((Hr(F, z, K, !1), (K & z.childLanes) === 0)) return null;
        } else return null;
      if (F !== null && z.child !== F.child) throw Error(B(153));
      if (z.child !== null) {
        for (
          F = z.child, K = jn(F, F.pendingProps), z.child = K, K.return = z;
          F.sibling !== null;

        )
          (F = F.sibling),
            (K = K.sibling = jn(F, F.pendingProps)),
            (K.return = z);
        K.sibling = null;
      }
      return z.child;
    }
    function il(F, z) {
      return (F.lanes & z) !== 0
        ? !0
        : ((F = F.dependencies), !!(F !== null && qa(F)));
    }
    function Gh(F, z, K) {
      switch (z.tag) {
        case 3:
          ct(z, z.stateNode.containerInfo),
            ei(z, Bt, F.memoizedState.cache),
            zr();
          break;
        case 27:
        case 5:
          tt(z);
          break;
        case 4:
          ct(z, z.stateNode.containerInfo);
          break;
        case 10:
          ei(z, z.type, z.memoizedProps.value);
          break;
        case 13:
          var W = z.memoizedState;
          if (W !== null)
            return W.dehydrated !== null
              ? (ai(z), (z.flags |= 128), null)
              : (K & z.child.childLanes) !== 0
              ? cd(F, z, K)
              : (ai(z), (F = $n(F, z, K)), F !== null ? F.sibling : null);
          ai(z);
          break;
        case 19:
          var ee = (F.flags & 128) !== 0;
          if (
            ((W = (K & z.childLanes) !== 0),
            W || (Hr(F, z, K, !1), (W = (K & z.childLanes) !== 0)),
            ee)
          ) {
            if (W) return dd(F, z, K);
            z.flags |= 128;
          }
          if (
            ((ee = z.memoizedState),
            ee !== null &&
              ((ee.rendering = null), (ee.tail = null), (ee.lastEffect = null)),
            pe(Ft, Ft.current),
            W)
          )
            break;
          return null;
        case 22:
        case 23:
          return (z.lanes = 0), rd(F, z, K);
        case 24:
          ei(z, Bt, F.memoizedState.cache);
      }
      return $n(F, z, K);
    }
    function fd(F, z, K) {
      if (F !== null)
        if (F.memoizedProps !== z.pendingProps) $t = !0;
        else {
          if (!il(F, K) && (z.flags & 128) === 0) return ($t = !1), Gh(F, z, K);
          $t = (F.flags & 131072) !== 0;
        }
      else ($t = !1), St && (z.flags & 1048576) !== 0 && Fc(z, Fa, z.index);
      switch (((z.lanes = 0), z.tag)) {
        case 16:
          e: {
            F = z.pendingProps;
            var W = z.elementType,
              ee = W._init;
            if (((W = ee(W._payload)), (z.type = W), typeof W == "function"))
              fo(W)
                ? ((F = Ni(W, F)), (z.tag = 1), (z = od(null, z, W, F, K)))
                : ((z.tag = 0), (z = Wo(null, z, W, F, K)));
            else {
              if (W != null) {
                if (((ee = W.$$typeof), ee === me)) {
                  (z.tag = 11), (z = ed(null, z, W, F, K));
                  break e;
                } else if (ee === Ee) {
                  (z.tag = 14), (z = td(null, z, W, F, K));
                  break e;
                }
              }
              throw ((z = Me(W) || W), Error(B(306, z, "")));
            }
          }
          return z;
        case 0:
          return Wo(F, z, z.type, z.pendingProps, K);
        case 1:
          return (W = z.type), (ee = Ni(W, z.pendingProps)), od(F, z, W, ee, K);
        case 3:
          e: {
            if ((ct(z, z.stateNode.containerInfo), F === null))
              throw Error(B(387));
            W = z.pendingProps;
            var ie = z.memoizedState;
            (ee = ie.element), Ro(F, z), Jr(z, W, null, K);
            var le = z.memoizedState;
            if (
              ((W = le.cache),
              ei(z, Bt, W),
              W !== ie.cache && So(z, [Bt], K, !0),
              Xr(),
              (W = le.element),
              ie.isDehydrated)
            )
              if (
                ((ie = { element: W, isDehydrated: !1, cache: le.cache }),
                (z.updateQueue.baseState = ie),
                (z.memoizedState = ie),
                z.flags & 256)
              ) {
                z = ld(F, z, W, K);
                break e;
              } else if (W !== ee) {
                (ee = bn(Error(B(424)), z)), $r(ee), (z = ld(F, z, W, K));
                break e;
              } else {
                switch (((F = z.stateNode.containerInfo), F.nodeType)) {
                  case 9:
                    F = F.body;
                    break;
                  default:
                    F = F.nodeName === "HTML" ? F.ownerDocument.body : F;
                }
                for (
                  Ot = An(F.firstChild),
                    tn = z,
                    St = !0,
                    Pi = null,
                    Pn = !0,
                    K = zu(z, null, W, K),
                    z.child = K;
                  K;

                )
                  (K.flags = (K.flags & -3) | 4096), (K = K.sibling);
              }
            else {
              if ((zr(), W === ee)) {
                z = $n(F, z, K);
                break e;
              }
              Kt(F, z, W, K);
            }
            z = z.child;
          }
          return z;
        case 26:
          return (
            os(F, z),
            F === null
              ? (K = vf(z.type, null, z.pendingProps, null))
                ? (z.memoizedState = K)
                : St ||
                  ((K = z.type),
                  (F = z.pendingProps),
                  (W = ks(Ie.current).createElement(K)),
                  (W[Wt] = z),
                  (W[rn] = F),
                  Qt(W, K, F),
                  zt(W),
                  (z.stateNode = W))
              : (z.memoizedState = vf(
                  z.type,
                  F.memoizedProps,
                  z.pendingProps,
                  F.memoizedState
                )),
            null
          );
        case 27:
          return (
            tt(z),
            F === null &&
              St &&
              ((W = z.stateNode = pf(z.type, z.pendingProps, Ie.current)),
              (tn = z),
              (Pn = !0),
              (ee = Ot),
              mi(z.type) ? ((jl = ee), (Ot = An(W.firstChild))) : (Ot = ee)),
            Kt(F, z, z.pendingProps.children, K),
            os(F, z),
            F === null && (z.flags |= 4194304),
            z.child
          );
        case 5:
          return (
            F === null &&
              St &&
              ((ee = W = Ot) &&
                ((W = Sp(W, z.type, z.pendingProps, Pn)),
                W !== null
                  ? ((z.stateNode = W),
                    (tn = z),
                    (Ot = An(W.firstChild)),
                    (Pn = !1),
                    (ee = !0))
                  : (ee = !1)),
              ee || Di(z)),
            tt(z),
            (ee = z.type),
            (ie = z.pendingProps),
            (le = F !== null ? F.memoizedProps : null),
            (W = ie.children),
            Ml(ee, ie)
              ? (W = null)
              : le !== null && Ml(ee, le) && (z.flags |= 32),
            z.memoizedState !== null &&
              ((ee = Oo(F, z, Uh, null, null, K)), (Sa._currentValue = ee)),
            os(F, z),
            Kt(F, z, W, K),
            z.child
          );
        case 6:
          return (
            F === null &&
              St &&
              ((F = K = Ot) &&
                ((K = Tp(K, z.pendingProps, Pn)),
                K !== null
                  ? ((z.stateNode = K), (tn = z), (Ot = null), (F = !0))
                  : (F = !1)),
              F || Di(z)),
            null
          );
        case 13:
          return cd(F, z, K);
        case 4:
          return (
            ct(z, z.stateNode.containerInfo),
            (W = z.pendingProps),
            F === null ? (z.child = mr(z, null, W, K)) : Kt(F, z, W, K),
            z.child
          );
        case 11:
          return ed(F, z, z.type, z.pendingProps, K);
        case 7:
          return Kt(F, z, z.pendingProps, K), z.child;
        case 8:
          return Kt(F, z, z.pendingProps.children, K), z.child;
        case 12:
          return Kt(F, z, z.pendingProps.children, K), z.child;
        case 10:
          return (
            (W = z.pendingProps),
            ei(z, z.type, W.value),
            Kt(F, z, W.children, K),
            z.child
          );
        case 9:
          return (
            (ee = z.type._context),
            (W = z.pendingProps.children),
            Mi(z),
            (ee = Xt(ee)),
            (W = W(ee)),
            (z.flags |= 1),
            Kt(F, z, W, K),
            z.child
          );
        case 14:
          return td(F, z, z.type, z.pendingProps, K);
        case 15:
          return nd(F, z, z.type, z.pendingProps, K);
        case 19:
          return dd(F, z, K);
        case 31:
          return (
            (W = z.pendingProps),
            (K = z.mode),
            (W = { mode: W.mode, children: W.children }),
            F === null
              ? ((K = ls(W, K)),
                (K.ref = z.ref),
                (z.child = K),
                (K.return = z),
                (z = K))
              : ((K = jn(F.child, W)),
                (K.ref = z.ref),
                (z.child = K),
                (K.return = z),
                (z = K)),
            z
          );
        case 22:
          return rd(F, z, K);
        case 24:
          return (
            Mi(z),
            (W = Xt(Bt)),
            F === null
              ? ((ee = Co()),
                ee === null &&
                  ((ee = wt),
                  (ie = To()),
                  (ee.pooledCache = ie),
                  ie.refCount++,
                  ie !== null && (ee.pooledCacheLanes |= K),
                  (ee = ie)),
                (z.memoizedState = { parent: W, cache: ee }),
                xo(z),
                ei(z, Bt, ee))
              : ((F.lanes & K) !== 0 && (Ro(F, z), Jr(z, null, null, K), Xr()),
                (ee = F.memoizedState),
                (ie = z.memoizedState),
                ee.parent !== W
                  ? ((ee = { parent: W, cache: W }),
                    (z.memoizedState = ee),
                    z.lanes === 0 &&
                      (z.memoizedState = z.updateQueue.baseState = ee),
                    ei(z, Bt, W))
                  : ((W = ie.cache),
                    ei(z, Bt, W),
                    W !== ee.cache && So(z, [Bt], K, !0))),
            Kt(F, z, z.pendingProps.children, K),
            z.child
          );
        case 29:
          throw z.pendingProps;
      }
      throw Error(B(156, z.tag));
    }
    function Hn(F) {
      F.flags |= 4;
    }
    function hd(F, z) {
      if (z.type !== "stylesheet" || (z.state.loading & 4) !== 0)
        F.flags &= -16777217;
      else if (((F.flags |= 16777216), !kf(z))) {
        if (
          ((z = Cn.current),
          z !== null &&
            ((mt & 4194048) === mt
              ? Dn !== null
              : ((mt & 62914560) !== mt && (mt & 536870912) === 0) || z !== Dn))
        )
          throw ((Qr = Eo), Qc);
        F.flags |= 8192;
      }
    }
    function cs(F, z) {
      z !== null && (F.flags |= 4),
        F.flags & 16384 &&
          ((z = F.tag !== 22 ? Rt() : 536870912), (F.lanes |= z), (br |= z));
    }
    function aa(F, z) {
      if (!St)
        switch (F.tailMode) {
          case "hidden":
            z = F.tail;
            for (var K = null; z !== null; )
              z.alternate !== null && (K = z), (z = z.sibling);
            K === null ? (F.tail = null) : (K.sibling = null);
            break;
          case "collapsed":
            K = F.tail;
            for (var W = null; K !== null; )
              K.alternate !== null && (W = K), (K = K.sibling);
            W === null
              ? z || F.tail === null
                ? (F.tail = null)
                : (F.tail.sibling = null)
              : (W.sibling = null);
        }
    }
    function Dt(F) {
      var z = F.alternate !== null && F.alternate.child === F.child,
        K = 0,
        W = 0;
      if (z)
        for (var ee = F.child; ee !== null; )
          (K |= ee.lanes | ee.childLanes),
            (W |= ee.subtreeFlags & 65011712),
            (W |= ee.flags & 65011712),
            (ee.return = F),
            (ee = ee.sibling);
      else
        for (ee = F.child; ee !== null; )
          (K |= ee.lanes | ee.childLanes),
            (W |= ee.subtreeFlags),
            (W |= ee.flags),
            (ee.return = F),
            (ee = ee.sibling);
      return (F.subtreeFlags |= W), (F.childLanes = K), z;
    }
    function Kh(F, z, K) {
      var W = z.pendingProps;
      switch ((go(z), z.tag)) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Dt(z), null;
        case 1:
          return Dt(z), null;
        case 3:
          return (
            (K = z.stateNode),
            (W = null),
            F !== null && (W = F.memoizedState.cache),
            z.memoizedState.cache !== W && (z.flags |= 2048),
            Fn(Bt),
            We(),
            K.pendingContext &&
              ((K.context = K.pendingContext), (K.pendingContext = null)),
            (F === null || F.child === null) &&
              (qr(z)
                ? Hn(z)
                : F === null ||
                  (F.memoizedState.isDehydrated && (z.flags & 256) === 0) ||
                  ((z.flags |= 1024), $c())),
            Dt(z),
            null
          );
        case 26:
          return (
            (K = z.memoizedState),
            F === null
              ? (Hn(z),
                K !== null
                  ? (Dt(z), hd(z, K))
                  : (Dt(z), (z.flags &= -16777217)))
              : K
              ? K !== F.memoizedState
                ? (Hn(z), Dt(z), hd(z, K))
                : (Dt(z), (z.flags &= -16777217))
              : (F.memoizedProps !== W && Hn(z), Dt(z), (z.flags &= -16777217)),
            null
          );
        case 27:
          gt(z), (K = Ie.current);
          var ee = z.type;
          if (F !== null && z.stateNode != null) F.memoizedProps !== W && Hn(z);
          else {
            if (!W) {
              if (z.stateNode === null) throw Error(B(166));
              return Dt(z), null;
            }
            (F = Ye.current),
              qr(z) ? qc(z) : ((F = pf(ee, W, K)), (z.stateNode = F), Hn(z));
          }
          return Dt(z), null;
        case 5:
          if ((gt(z), (K = z.type), F !== null && z.stateNode != null))
            F.memoizedProps !== W && Hn(z);
          else {
            if (!W) {
              if (z.stateNode === null) throw Error(B(166));
              return Dt(z), null;
            }
            if (((F = Ye.current), qr(z))) qc(z);
            else {
              switch (((ee = ks(Ie.current)), F)) {
                case 1:
                  F = ee.createElementNS("http://www.w3.org/2000/svg", K);
                  break;
                case 2:
                  F = ee.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    K
                  );
                  break;
                default:
                  switch (K) {
                    case "svg":
                      F = ee.createElementNS("http://www.w3.org/2000/svg", K);
                      break;
                    case "math":
                      F = ee.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        K
                      );
                      break;
                    case "script":
                      (F = ee.createElement("div")),
                        (F.innerHTML = "<script></script>"),
                        (F = F.removeChild(F.firstChild));
                      break;
                    case "select":
                      (F =
                        typeof W.is == "string"
                          ? ee.createElement("select", { is: W.is })
                          : ee.createElement("select")),
                        W.multiple
                          ? (F.multiple = !0)
                          : W.size && (F.size = W.size);
                      break;
                    default:
                      F =
                        typeof W.is == "string"
                          ? ee.createElement(K, { is: W.is })
                          : ee.createElement(K);
                  }
              }
              (F[Wt] = z), (F[rn] = W);
              e: for (ee = z.child; ee !== null; ) {
                if (ee.tag === 5 || ee.tag === 6) F.appendChild(ee.stateNode);
                else if (ee.tag !== 4 && ee.tag !== 27 && ee.child !== null) {
                  (ee.child.return = ee), (ee = ee.child);
                  continue;
                }
                if (ee === z) break e;
                for (; ee.sibling === null; ) {
                  if (ee.return === null || ee.return === z) break e;
                  ee = ee.return;
                }
                (ee.sibling.return = ee.return), (ee = ee.sibling);
              }
              z.stateNode = F;
              e: switch ((Qt(F, K, W), K)) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  F = !!W.autoFocus;
                  break e;
                case "img":
                  F = !0;
                  break e;
                default:
                  F = !1;
              }
              F && Hn(z);
            }
          }
          return Dt(z), (z.flags &= -16777217), null;
        case 6:
          if (F && z.stateNode != null) F.memoizedProps !== W && Hn(z);
          else {
            if (typeof W != "string" && z.stateNode === null)
              throw Error(B(166));
            if (((F = Ie.current), qr(z))) {
              if (
                ((F = z.stateNode),
                (K = z.memoizedProps),
                (W = null),
                (ee = tn),
                ee !== null)
              )
                switch (ee.tag) {
                  case 27:
                  case 5:
                    W = ee.memoizedProps;
                }
              (F[Wt] = z),
                (F = !!(
                  F.nodeValue === K ||
                  (W !== null && W.suppressHydrationWarning === !0) ||
                  of(F.nodeValue, K)
                )),
                F || Di(z);
            } else
              (F = ks(F).createTextNode(W)), (F[Wt] = z), (z.stateNode = F);
          }
          return Dt(z), null;
        case 13:
          if (
            ((W = z.memoizedState),
            F === null ||
              (F.memoizedState !== null && F.memoizedState.dehydrated !== null))
          ) {
            if (((ee = qr(z)), W !== null && W.dehydrated !== null)) {
              if (F === null) {
                if (!ee) throw Error(B(318));
                if (
                  ((ee = z.memoizedState),
                  (ee = ee !== null ? ee.dehydrated : null),
                  !ee)
                )
                  throw Error(B(317));
                ee[Wt] = z;
              } else
                zr(),
                  (z.flags & 128) === 0 && (z.memoizedState = null),
                  (z.flags |= 4);
              Dt(z), (ee = !1);
            } else
              (ee = $c()),
                F !== null &&
                  F.memoizedState !== null &&
                  (F.memoizedState.hydrationErrors = ee),
                (ee = !0);
            if (!ee) return z.flags & 256 ? (zn(z), z) : (zn(z), null);
          }
          if ((zn(z), (z.flags & 128) !== 0)) return (z.lanes = K), z;
          if (
            ((K = W !== null), (F = F !== null && F.memoizedState !== null), K)
          ) {
            (W = z.child),
              (ee = null),
              W.alternate !== null &&
                W.alternate.memoizedState !== null &&
                W.alternate.memoizedState.cachePool !== null &&
                (ee = W.alternate.memoizedState.cachePool.pool);
            var ie = null;
            W.memoizedState !== null &&
              W.memoizedState.cachePool !== null &&
              (ie = W.memoizedState.cachePool.pool),
              ie !== ee && (W.flags |= 2048);
          }
          return (
            K !== F && K && (z.child.flags |= 8192),
            cs(z, z.updateQueue),
            Dt(z),
            null
          );
        case 4:
          return We(), F === null && wl(z.stateNode.containerInfo), Dt(z), null;
        case 10:
          return Fn(z.type), Dt(z), null;
        case 19:
          if ((Ge(Ft), (ee = z.memoizedState), ee === null)) return Dt(z), null;
          if (((W = (z.flags & 128) !== 0), (ie = ee.rendering), ie === null))
            if (W) aa(ee, !1);
            else {
              if (Mt !== 0 || (F !== null && (F.flags & 128) !== 0))
                for (F = z.child; F !== null; ) {
                  if (((ie = rs(F)), ie !== null)) {
                    for (
                      z.flags |= 128,
                        aa(ee, !1),
                        F = ie.updateQueue,
                        z.updateQueue = F,
                        cs(z, F),
                        z.subtreeFlags = 0,
                        F = K,
                        K = z.child;
                      K !== null;

                    )
                      Bc(K, F), (K = K.sibling);
                    return pe(Ft, (Ft.current & 1) | 2), z.child;
                  }
                  F = F.sibling;
                }
              ee.tail !== null &&
                At() > fs &&
                ((z.flags |= 128), (W = !0), aa(ee, !1), (z.lanes = 4194304));
            }
          else {
            if (!W)
              if (((F = rs(ie)), F !== null)) {
                if (
                  ((z.flags |= 128),
                  (W = !0),
                  (F = F.updateQueue),
                  (z.updateQueue = F),
                  cs(z, F),
                  aa(ee, !0),
                  ee.tail === null &&
                    ee.tailMode === "hidden" &&
                    !ie.alternate &&
                    !St)
                )
                  return Dt(z), null;
              } else
                2 * At() - ee.renderingStartTime > fs &&
                  K !== 536870912 &&
                  ((z.flags |= 128), (W = !0), aa(ee, !1), (z.lanes = 4194304));
            ee.isBackwards
              ? ((ie.sibling = z.child), (z.child = ie))
              : ((F = ee.last),
                F !== null ? (F.sibling = ie) : (z.child = ie),
                (ee.last = ie));
          }
          return ee.tail !== null
            ? ((z = ee.tail),
              (ee.rendering = z),
              (ee.tail = z.sibling),
              (ee.renderingStartTime = At()),
              (z.sibling = null),
              (F = Ft.current),
              pe(Ft, W ? (F & 1) | 2 : F & 1),
              z)
            : (Dt(z), null);
        case 22:
        case 23:
          return (
            zn(z),
            Po(),
            (W = z.memoizedState !== null),
            F !== null
              ? (F.memoizedState !== null) !== W && (z.flags |= 8192)
              : W && (z.flags |= 8192),
            W
              ? (K & 536870912) !== 0 &&
                (z.flags & 128) === 0 &&
                (Dt(z), z.subtreeFlags & 6 && (z.flags |= 8192))
              : Dt(z),
            (K = z.updateQueue),
            K !== null && cs(z, K.retryQueue),
            (K = null),
            F !== null &&
              F.memoizedState !== null &&
              F.memoizedState.cachePool !== null &&
              (K = F.memoizedState.cachePool.pool),
            (W = null),
            z.memoizedState !== null &&
              z.memoizedState.cachePool !== null &&
              (W = z.memoizedState.cachePool.pool),
            W !== K && (z.flags |= 2048),
            F !== null && Ge(Ii),
            null
          );
        case 24:
          return (
            (K = null),
            F !== null && (K = F.memoizedState.cache),
            z.memoizedState.cache !== K && (z.flags |= 2048),
            Fn(Bt),
            Dt(z),
            null
          );
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(B(156, z.tag));
    }
    function Yh(F, z) {
      switch ((go(z), z.tag)) {
        case 1:
          return (
            (F = z.flags),
            F & 65536 ? ((z.flags = (F & -65537) | 128), z) : null
          );
        case 3:
          return (
            Fn(Bt),
            We(),
            (F = z.flags),
            (F & 65536) !== 0 && (F & 128) === 0
              ? ((z.flags = (F & -65537) | 128), z)
              : null
          );
        case 26:
        case 27:
        case 5:
          return gt(z), null;
        case 13:
          if (
            (zn(z), (F = z.memoizedState), F !== null && F.dehydrated !== null)
          ) {
            if (z.alternate === null) throw Error(B(340));
            zr();
          }
          return (
            (F = z.flags),
            F & 65536 ? ((z.flags = (F & -65537) | 128), z) : null
          );
        case 19:
          return Ge(Ft), null;
        case 4:
          return We(), null;
        case 10:
          return Fn(z.type), null;
        case 22:
        case 23:
          return (
            zn(z),
            Po(),
            F !== null && Ge(Ii),
            (F = z.flags),
            F & 65536 ? ((z.flags = (F & -65537) | 128), z) : null
          );
        case 24:
          return Fn(Bt), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function pd(F, z) {
      switch ((go(z), z.tag)) {
        case 3:
          Fn(Bt), We();
          break;
        case 26:
        case 27:
        case 5:
          gt(z);
          break;
        case 4:
          We();
          break;
        case 13:
          zn(z);
          break;
        case 19:
          Ge(Ft);
          break;
        case 10:
          Fn(z.type);
          break;
        case 22:
        case 23:
          zn(z), Po(), F !== null && Ge(Ii);
          break;
        case 24:
          Fn(Bt);
      }
    }
    function sa(F, z) {
      try {
        var K = z.updateQueue,
          W = K !== null ? K.lastEffect : null;
        if (W !== null) {
          var ee = W.next;
          K = ee;
          do {
            if ((K.tag & F) === F) {
              W = void 0;
              var ie = K.create,
                le = K.inst;
              (W = ie()), (le.destroy = W);
            }
            K = K.next;
          } while (K !== ee);
        }
      } catch (de) {
        _t(z, z.return, de);
      }
    }
    function oi(F, z, K) {
      try {
        var W = z.updateQueue,
          ee = W !== null ? W.lastEffect : null;
        if (ee !== null) {
          var ie = ee.next;
          W = ie;
          do {
            if ((W.tag & F) === F) {
              var le = W.inst,
                de = le.destroy;
              if (de !== void 0) {
                (le.destroy = void 0), (ee = z);
                var ye = K,
                  we = de;
                try {
                  we();
                } catch (Ve) {
                  _t(ee, ye, Ve);
                }
              }
            }
            W = W.next;
          } while (W !== ie);
        }
      } catch (Ve) {
        _t(z, z.return, Ve);
      }
    }
    function md(F) {
      var z = F.updateQueue;
      if (z !== null) {
        var K = F.stateNode;
        try {
          tu(z, K);
        } catch (W) {
          _t(F, F.return, W);
        }
      }
    }
    function gd(F, z, K) {
      (K.props = Ni(F.type, F.memoizedProps)), (K.state = F.memoizedState);
      try {
        K.componentWillUnmount();
      } catch (W) {
        _t(F, z, W);
      }
    }
    function oa(F, z) {
      try {
        var K = F.ref;
        if (K !== null) {
          switch (F.tag) {
            case 26:
            case 27:
            case 5:
              var W = F.stateNode;
              break;
            case 30:
              W = F.stateNode;
              break;
            default:
              W = F.stateNode;
          }
          typeof K == "function" ? (F.refCleanup = K(W)) : (K.current = W);
        }
      } catch (ee) {
        _t(F, z, ee);
      }
    }
    function On(F, z) {
      var K = F.ref,
        W = F.refCleanup;
      if (K !== null)
        if (typeof W == "function")
          try {
            W();
          } catch (ee) {
            _t(F, z, ee);
          } finally {
            (F.refCleanup = null),
              (F = F.alternate),
              F != null && (F.refCleanup = null);
          }
        else if (typeof K == "function")
          try {
            K(null);
          } catch (ee) {
            _t(F, z, ee);
          }
        else K.current = null;
    }
    function vd(F) {
      var z = F.type,
        K = F.memoizedProps,
        W = F.stateNode;
      try {
        e: switch (z) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            K.autoFocus && W.focus();
            break e;
          case "img":
            K.src ? (W.src = K.src) : K.srcSet && (W.srcset = K.srcSet);
        }
      } catch (ee) {
        _t(F, F.return, ee);
      }
    }
    function rl(F, z, K) {
      try {
        var W = F.stateNode;
        mp(W, F.type, K, z), (W[rn] = z);
      } catch (ee) {
        _t(F, F.return, ee);
      }
    }
    function yd(F) {
      return (
        F.tag === 5 ||
        F.tag === 3 ||
        F.tag === 26 ||
        (F.tag === 27 && mi(F.type)) ||
        F.tag === 4
      );
    }
    function al(F) {
      e: for (;;) {
        for (; F.sibling === null; ) {
          if (F.return === null || yd(F.return)) return null;
          F = F.return;
        }
        for (
          F.sibling.return = F.return, F = F.sibling;
          F.tag !== 5 && F.tag !== 6 && F.tag !== 18;

        ) {
          if (
            (F.tag === 27 && mi(F.type)) ||
            F.flags & 2 ||
            F.child === null ||
            F.tag === 4
          )
            continue e;
          (F.child.return = F), (F = F.child);
        }
        if (!(F.flags & 2)) return F.stateNode;
      }
    }
    function sl(F, z, K) {
      var W = F.tag;
      if (W === 5 || W === 6)
        (F = F.stateNode),
          z
            ? (K.nodeType === 9
                ? K.body
                : K.nodeName === "HTML"
                ? K.ownerDocument.body
                : K
              ).insertBefore(F, z)
            : ((z =
                K.nodeType === 9
                  ? K.body
                  : K.nodeName === "HTML"
                  ? K.ownerDocument.body
                  : K),
              z.appendChild(F),
              (K = K._reactRootContainer),
              K != null || z.onclick !== null || (z.onclick = Ts));
      else if (
        W !== 4 &&
        (W === 27 && mi(F.type) && ((K = F.stateNode), (z = null)),
        (F = F.child),
        F !== null)
      )
        for (sl(F, z, K), F = F.sibling; F !== null; )
          sl(F, z, K), (F = F.sibling);
    }
    function us(F, z, K) {
      var W = F.tag;
      if (W === 5 || W === 6)
        (F = F.stateNode), z ? K.insertBefore(F, z) : K.appendChild(F);
      else if (
        W !== 4 &&
        (W === 27 && mi(F.type) && (K = F.stateNode), (F = F.child), F !== null)
      )
        for (us(F, z, K), F = F.sibling; F !== null; )
          us(F, z, K), (F = F.sibling);
    }
    function bd(F) {
      var z = F.stateNode,
        K = F.memoizedProps;
      try {
        for (var W = F.type, ee = z.attributes; ee.length; )
          z.removeAttributeNode(ee[0]);
        Qt(z, W, K), (z[Wt] = F), (z[rn] = K);
      } catch (ie) {
        _t(F, F.return, ie);
      }
    }
    var Gn = !1,
      Nt = !1,
      ol = !1,
      Sd = typeof WeakSet == "function" ? WeakSet : Set,
      Ht = null;
    function Qh(F, z) {
      if (((F = F.containerInfo), (Dl = ws), (F = Pc(F)), ro(F))) {
        if ("selectionStart" in F)
          var K = { start: F.selectionStart, end: F.selectionEnd };
        else
          e: {
            K = ((K = F.ownerDocument) && K.defaultView) || window;
            var W = K.getSelection && K.getSelection();
            if (W && W.rangeCount !== 0) {
              K = W.anchorNode;
              var ee = W.anchorOffset,
                ie = W.focusNode;
              W = W.focusOffset;
              try {
                K.nodeType, ie.nodeType;
              } catch {
                K = null;
                break e;
              }
              var le = 0,
                de = -1,
                ye = -1,
                we = 0,
                Ve = 0,
                $e = F,
                Pe = null;
              t: for (;;) {
                for (
                  var Oe;
                  $e !== K || (ee !== 0 && $e.nodeType !== 3) || (de = le + ee),
                    $e !== ie ||
                      (W !== 0 && $e.nodeType !== 3) ||
                      (ye = le + W),
                    $e.nodeType === 3 && (le += $e.nodeValue.length),
                    (Oe = $e.firstChild) !== null;

                )
                  (Pe = $e), ($e = Oe);
                for (;;) {
                  if ($e === F) break t;
                  if (
                    (Pe === K && ++we === ee && (de = le),
                    Pe === ie && ++Ve === W && (ye = le),
                    (Oe = $e.nextSibling) !== null)
                  )
                    break;
                  ($e = Pe), (Pe = $e.parentNode);
                }
                $e = Oe;
              }
              K = de === -1 || ye === -1 ? null : { start: de, end: ye };
            } else K = null;
          }
        K = K || { start: 0, end: 0 };
      } else K = null;
      for (
        Ol = { focusedElem: F, selectionRange: K }, ws = !1, Ht = z;
        Ht !== null;

      )
        if (
          ((z = Ht), (F = z.child), (z.subtreeFlags & 1024) !== 0 && F !== null)
        )
          (F.return = z), (Ht = F);
        else
          for (; Ht !== null; ) {
            switch (((z = Ht), (ie = z.alternate), (F = z.flags), z.tag)) {
              case 0:
                break;
              case 11:
              case 15:
                break;
              case 1:
                if ((F & 1024) !== 0 && ie !== null) {
                  (F = void 0),
                    (K = z),
                    (ee = ie.memoizedProps),
                    (ie = ie.memoizedState),
                    (W = K.stateNode);
                  try {
                    var ot = Ni(K.type, ee, K.elementType === K.type);
                    (F = W.getSnapshotBeforeUpdate(ot, ie)),
                      (W.__reactInternalSnapshotBeforeUpdate = F);
                  } catch (at) {
                    _t(K, K.return, at);
                  }
                }
                break;
              case 3:
                if ((F & 1024) !== 0) {
                  if (
                    ((F = z.stateNode.containerInfo), (K = F.nodeType), K === 9)
                  )
                    Ll(F);
                  else if (K === 1)
                    switch (F.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        Ll(F);
                        break;
                      default:
                        F.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if ((F & 1024) !== 0) throw Error(B(163));
            }
            if (((F = z.sibling), F !== null)) {
              (F.return = z.return), (Ht = F);
              break;
            }
            Ht = z.return;
          }
    }
    function Td(F, z, K) {
      var W = K.flags;
      switch (K.tag) {
        case 0:
        case 11:
        case 15:
          li(F, K), W & 4 && sa(5, K);
          break;
        case 1:
          if ((li(F, K), W & 4))
            if (((F = K.stateNode), z === null))
              try {
                F.componentDidMount();
              } catch (le) {
                _t(K, K.return, le);
              }
            else {
              var ee = Ni(K.type, z.memoizedProps);
              z = z.memoizedState;
              try {
                F.componentDidUpdate(
                  ee,
                  z,
                  F.__reactInternalSnapshotBeforeUpdate
                );
              } catch (le) {
                _t(K, K.return, le);
              }
            }
          W & 64 && md(K), W & 512 && oa(K, K.return);
          break;
        case 3:
          if ((li(F, K), W & 64 && ((F = K.updateQueue), F !== null))) {
            if (((z = null), K.child !== null))
              switch (K.child.tag) {
                case 27:
                case 5:
                  z = K.child.stateNode;
                  break;
                case 1:
                  z = K.child.stateNode;
              }
            try {
              tu(F, z);
            } catch (le) {
              _t(K, K.return, le);
            }
          }
          break;
        case 27:
          z === null && W & 4 && bd(K);
        case 26:
        case 5:
          li(F, K), z === null && W & 4 && vd(K), W & 512 && oa(K, K.return);
          break;
        case 12:
          li(F, K);
          break;
        case 13:
          li(F, K),
            W & 4 && Ed(F, K),
            W & 64 &&
              ((F = K.memoizedState),
              F !== null &&
                ((F = F.dehydrated),
                F !== null && ((K = rp.bind(null, K)), kp(F, K))));
          break;
        case 22:
          if (((W = K.memoizedState !== null || Gn), !W)) {
            (z = (z !== null && z.memoizedState !== null) || Nt), (ee = Gn);
            var ie = Nt;
            (Gn = W),
              (Nt = z) && !ie
                ? ci(F, K, (K.subtreeFlags & 8772) !== 0)
                : li(F, K),
              (Gn = ee),
              (Nt = ie);
          }
          break;
        case 30:
          break;
        default:
          li(F, K);
      }
    }
    function kd(F) {
      var z = F.alternate;
      z !== null && ((F.alternate = null), kd(z)),
        (F.child = null),
        (F.deletions = null),
        (F.sibling = null),
        F.tag === 5 && ((z = F.stateNode), z !== null && Vs(z)),
        (F.stateNode = null),
        (F.return = null),
        (F.dependencies = null),
        (F.memoizedProps = null),
        (F.memoizedState = null),
        (F.pendingProps = null),
        (F.stateNode = null),
        (F.updateQueue = null);
    }
    var Pt = null,
      on = !1;
    function Kn(F, z, K) {
      for (K = K.child; K !== null; ) Cd(F, z, K), (K = K.sibling);
    }
    function Cd(F, z, K) {
      if (Ke && typeof Ke.onCommitFiberUnmount == "function")
        try {
          Ke.onCommitFiberUnmount(Ne, K);
        } catch {}
      switch (K.tag) {
        case 26:
          Nt || On(K, z),
            Kn(F, z, K),
            K.memoizedState
              ? K.memoizedState.count--
              : K.stateNode && ((K = K.stateNode), K.parentNode.removeChild(K));
          break;
        case 27:
          Nt || On(K, z);
          var W = Pt,
            ee = on;
          mi(K.type) && ((Pt = K.stateNode), (on = !1)),
            Kn(F, z, K),
            ga(K.stateNode),
            (Pt = W),
            (on = ee);
          break;
        case 5:
          Nt || On(K, z);
        case 6:
          if (
            ((W = Pt),
            (ee = on),
            (Pt = null),
            Kn(F, z, K),
            (Pt = W),
            (on = ee),
            Pt !== null)
          )
            if (on)
              try {
                (Pt.nodeType === 9
                  ? Pt.body
                  : Pt.nodeName === "HTML"
                  ? Pt.ownerDocument.body
                  : Pt
                ).removeChild(K.stateNode);
              } catch (ie) {
                _t(K, z, ie);
              }
            else
              try {
                Pt.removeChild(K.stateNode);
              } catch (ie) {
                _t(K, z, ie);
              }
          break;
        case 18:
          Pt !== null &&
            (on
              ? ((F = Pt),
                ff(
                  F.nodeType === 9
                    ? F.body
                    : F.nodeName === "HTML"
                    ? F.ownerDocument.body
                    : F,
                  K.stateNode
                ),
                Ea(F))
              : ff(Pt, K.stateNode));
          break;
        case 4:
          (W = Pt),
            (ee = on),
            (Pt = K.stateNode.containerInfo),
            (on = !0),
            Kn(F, z, K),
            (Pt = W),
            (on = ee);
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          Nt || oi(2, K, z), Nt || oi(4, K, z), Kn(F, z, K);
          break;
        case 1:
          Nt ||
            (On(K, z),
            (W = K.stateNode),
            typeof W.componentWillUnmount == "function" && gd(K, z, W)),
            Kn(F, z, K);
          break;
        case 21:
          Kn(F, z, K);
          break;
        case 22:
          (Nt = (W = Nt) || K.memoizedState !== null), Kn(F, z, K), (Nt = W);
          break;
        default:
          Kn(F, z, K);
      }
    }
    function Ed(F, z) {
      if (
        z.memoizedState === null &&
        ((F = z.alternate),
        F !== null &&
          ((F = F.memoizedState),
          F !== null && ((F = F.dehydrated), F !== null)))
      )
        try {
          Ea(F);
        } catch (K) {
          _t(z, z.return, K);
        }
    }
    function Wh(F) {
      switch (F.tag) {
        case 13:
        case 19:
          var z = F.stateNode;
          return z === null && (z = F.stateNode = new Sd()), z;
        case 22:
          return (
            (F = F.stateNode),
            (z = F._retryCache),
            z === null && (z = F._retryCache = new Sd()),
            z
          );
        default:
          throw Error(B(435, F.tag));
      }
    }
    function ll(F, z) {
      var K = Wh(F);
      z.forEach(function (W) {
        var ee = ap.bind(null, F, W);
        K.has(W) || (K.add(W), W.then(ee, ee));
      });
    }
    function dn(F, z) {
      var K = z.deletions;
      if (K !== null)
        for (var W = 0; W < K.length; W++) {
          var ee = K[W],
            ie = F,
            le = z,
            de = le;
          e: for (; de !== null; ) {
            switch (de.tag) {
              case 27:
                if (mi(de.type)) {
                  (Pt = de.stateNode), (on = !1);
                  break e;
                }
                break;
              case 5:
                (Pt = de.stateNode), (on = !1);
                break e;
              case 3:
              case 4:
                (Pt = de.stateNode.containerInfo), (on = !0);
                break e;
            }
            de = de.return;
          }
          if (Pt === null) throw Error(B(160));
          Cd(ie, le, ee),
            (Pt = null),
            (on = !1),
            (ie = ee.alternate),
            ie !== null && (ie.return = null),
            (ee.return = null);
        }
      if (z.subtreeFlags & 13878)
        for (z = z.child; z !== null; ) xd(z, F), (z = z.sibling);
    }
    var wn = null;
    function xd(F, z) {
      var K = F.alternate,
        W = F.flags;
      switch (F.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dn(z, F),
            fn(F),
            W & 4 && (oi(3, F, F.return), sa(3, F), oi(5, F, F.return));
          break;
        case 1:
          dn(z, F),
            fn(F),
            W & 512 && (Nt || K === null || On(K, K.return)),
            W & 64 &&
              Gn &&
              ((F = F.updateQueue),
              F !== null &&
                ((W = F.callbacks),
                W !== null &&
                  ((K = F.shared.hiddenCallbacks),
                  (F.shared.hiddenCallbacks = K === null ? W : K.concat(W)))));
          break;
        case 26:
          var ee = wn;
          if (
            (dn(z, F),
            fn(F),
            W & 512 && (Nt || K === null || On(K, K.return)),
            W & 4)
          ) {
            var ie = K !== null ? K.memoizedState : null;
            if (((W = F.memoizedState), K === null))
              if (W === null)
                if (F.stateNode === null) {
                  e: {
                    (W = F.type),
                      (K = F.memoizedProps),
                      (ee = ee.ownerDocument || ee);
                    t: switch (W) {
                      case "title":
                        (ie = ee.getElementsByTagName("title")[0]),
                          (!ie ||
                            ie[Dr] ||
                            ie[Wt] ||
                            ie.namespaceURI === "http://www.w3.org/2000/svg" ||
                            ie.hasAttribute("itemprop")) &&
                            ((ie = ee.createElement(W)),
                            ee.head.insertBefore(
                              ie,
                              ee.querySelector("head > title")
                            )),
                          Qt(ie, W, K),
                          (ie[Wt] = F),
                          zt(ie),
                          (W = ie);
                        break e;
                      case "link":
                        var le = Sf("link", "href", ee).get(W + (K.href || ""));
                        if (le) {
                          for (var de = 0; de < le.length; de++)
                            if (
                              ((ie = le[de]),
                              ie.getAttribute("href") ===
                                (K.href == null || K.href === ""
                                  ? null
                                  : K.href) &&
                                ie.getAttribute("rel") ===
                                  (K.rel == null ? null : K.rel) &&
                                ie.getAttribute("title") ===
                                  (K.title == null ? null : K.title) &&
                                ie.getAttribute("crossorigin") ===
                                  (K.crossOrigin == null
                                    ? null
                                    : K.crossOrigin))
                            ) {
                              le.splice(de, 1);
                              break t;
                            }
                        }
                        (ie = ee.createElement(W)),
                          Qt(ie, W, K),
                          ee.head.appendChild(ie);
                        break;
                      case "meta":
                        if (
                          (le = Sf("meta", "content", ee).get(
                            W + (K.content || "")
                          ))
                        ) {
                          for (de = 0; de < le.length; de++)
                            if (
                              ((ie = le[de]),
                              ie.getAttribute("content") ===
                                (K.content == null ? null : "" + K.content) &&
                                ie.getAttribute("name") ===
                                  (K.name == null ? null : K.name) &&
                                ie.getAttribute("property") ===
                                  (K.property == null ? null : K.property) &&
                                ie.getAttribute("http-equiv") ===
                                  (K.httpEquiv == null ? null : K.httpEquiv) &&
                                ie.getAttribute("charset") ===
                                  (K.charSet == null ? null : K.charSet))
                            ) {
                              le.splice(de, 1);
                              break t;
                            }
                        }
                        (ie = ee.createElement(W)),
                          Qt(ie, W, K),
                          ee.head.appendChild(ie);
                        break;
                      default:
                        throw Error(B(468, W));
                    }
                    (ie[Wt] = F), zt(ie), (W = ie);
                  }
                  F.stateNode = W;
                } else Tf(ee, F.type, F.stateNode);
              else F.stateNode = bf(ee, W, F.memoizedProps);
            else
              ie !== W
                ? (ie === null
                    ? K.stateNode !== null &&
                      ((K = K.stateNode), K.parentNode.removeChild(K))
                    : ie.count--,
                  W === null
                    ? Tf(ee, F.type, F.stateNode)
                    : bf(ee, W, F.memoizedProps))
                : W === null &&
                  F.stateNode !== null &&
                  rl(F, F.memoizedProps, K.memoizedProps);
          }
          break;
        case 27:
          dn(z, F),
            fn(F),
            W & 512 && (Nt || K === null || On(K, K.return)),
            K !== null && W & 4 && rl(F, F.memoizedProps, K.memoizedProps);
          break;
        case 5:
          if (
            (dn(z, F),
            fn(F),
            W & 512 && (Nt || K === null || On(K, K.return)),
            F.flags & 32)
          ) {
            ee = F.stateNode;
            try {
              Xi(ee, "");
            } catch (Oe) {
              _t(F, F.return, Oe);
            }
          }
          W & 4 &&
            F.stateNode != null &&
            ((ee = F.memoizedProps),
            rl(F, ee, K !== null ? K.memoizedProps : ee)),
            W & 1024 && (ol = !0);
          break;
        case 6:
          if ((dn(z, F), fn(F), W & 4)) {
            if (F.stateNode === null) throw Error(B(162));
            (W = F.memoizedProps), (K = F.stateNode);
            try {
              K.nodeValue = W;
            } catch (Oe) {
              _t(F, F.return, Oe);
            }
          }
          break;
        case 3:
          if (
            ((xs = null),
            (ee = wn),
            (wn = Cs(z.containerInfo)),
            dn(z, F),
            (wn = ee),
            fn(F),
            W & 4 && K !== null && K.memoizedState.isDehydrated)
          )
            try {
              Ea(z.containerInfo);
            } catch (Oe) {
              _t(F, F.return, Oe);
            }
          ol && ((ol = !1), Rd(F));
          break;
        case 4:
          (W = wn),
            (wn = Cs(F.stateNode.containerInfo)),
            dn(z, F),
            fn(F),
            (wn = W);
          break;
        case 12:
          dn(z, F), fn(F);
          break;
        case 13:
          dn(z, F),
            fn(F),
            F.child.flags & 8192 &&
              (F.memoizedState !== null) !=
                (K !== null && K.memoizedState !== null) &&
              (pl = At()),
            W & 4 &&
              ((W = F.updateQueue),
              W !== null && ((F.updateQueue = null), ll(F, W)));
          break;
        case 22:
          ee = F.memoizedState !== null;
          var ye = K !== null && K.memoizedState !== null,
            we = Gn,
            Ve = Nt;
          if (
            ((Gn = we || ee),
            (Nt = Ve || ye),
            dn(z, F),
            (Nt = Ve),
            (Gn = we),
            fn(F),
            W & 8192)
          )
            e: for (
              z = F.stateNode,
                z._visibility = ee ? z._visibility & -2 : z._visibility | 1,
                ee && (K === null || ye || Gn || Nt || ji(F)),
                K = null,
                z = F;
              ;

            ) {
              if (z.tag === 5 || z.tag === 26) {
                if (K === null) {
                  ye = K = z;
                  try {
                    if (((ie = ye.stateNode), ee))
                      (le = ie.style),
                        typeof le.setProperty == "function"
                          ? le.setProperty("display", "none", "important")
                          : (le.display = "none");
                    else {
                      de = ye.stateNode;
                      var $e = ye.memoizedProps.style,
                        Pe =
                          $e != null && $e.hasOwnProperty("display")
                            ? $e.display
                            : null;
                      de.style.display =
                        Pe == null || typeof Pe == "boolean"
                          ? ""
                          : ("" + Pe).trim();
                    }
                  } catch (Oe) {
                    _t(ye, ye.return, Oe);
                  }
                }
              } else if (z.tag === 6) {
                if (K === null) {
                  ye = z;
                  try {
                    ye.stateNode.nodeValue = ee ? "" : ye.memoizedProps;
                  } catch (Oe) {
                    _t(ye, ye.return, Oe);
                  }
                }
              } else if (
                ((z.tag !== 22 && z.tag !== 23) ||
                  z.memoizedState === null ||
                  z === F) &&
                z.child !== null
              ) {
                (z.child.return = z), (z = z.child);
                continue;
              }
              if (z === F) break e;
              for (; z.sibling === null; ) {
                if (z.return === null || z.return === F) break e;
                K === z && (K = null), (z = z.return);
              }
              K === z && (K = null),
                (z.sibling.return = z.return),
                (z = z.sibling);
            }
          W & 4 &&
            ((W = F.updateQueue),
            W !== null &&
              ((K = W.retryQueue),
              K !== null && ((W.retryQueue = null), ll(F, K))));
          break;
        case 19:
          dn(z, F),
            fn(F),
            W & 4 &&
              ((W = F.updateQueue),
              W !== null && ((F.updateQueue = null), ll(F, W)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          dn(z, F), fn(F);
      }
    }
    function fn(F) {
      var z = F.flags;
      if (z & 2) {
        try {
          for (var K, W = F.return; W !== null; ) {
            if (yd(W)) {
              K = W;
              break;
            }
            W = W.return;
          }
          if (K == null) throw Error(B(160));
          switch (K.tag) {
            case 27:
              var ee = K.stateNode,
                ie = al(F);
              us(F, ie, ee);
              break;
            case 5:
              var le = K.stateNode;
              K.flags & 32 && (Xi(le, ""), (K.flags &= -33));
              var de = al(F);
              us(F, de, le);
              break;
            case 3:
            case 4:
              var ye = K.stateNode.containerInfo,
                we = al(F);
              sl(F, we, ye);
              break;
            default:
              throw Error(B(161));
          }
        } catch (Ve) {
          _t(F, F.return, Ve);
        }
        F.flags &= -3;
      }
      z & 4096 && (F.flags &= -4097);
    }
    function Rd(F) {
      if (F.subtreeFlags & 1024)
        for (F = F.child; F !== null; ) {
          var z = F;
          Rd(z),
            z.tag === 5 && z.flags & 1024 && z.stateNode.reset(),
            (F = F.sibling);
        }
    }
    function li(F, z) {
      if (z.subtreeFlags & 8772)
        for (z = z.child; z !== null; ) Td(F, z.alternate, z), (z = z.sibling);
    }
    function ji(F) {
      for (F = F.child; F !== null; ) {
        var z = F;
        switch (z.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            oi(4, z, z.return), ji(z);
            break;
          case 1:
            On(z, z.return);
            var K = z.stateNode;
            typeof K.componentWillUnmount == "function" && gd(z, z.return, K),
              ji(z);
            break;
          case 27:
            ga(z.stateNode);
          case 26:
          case 5:
            On(z, z.return), ji(z);
            break;
          case 22:
            z.memoizedState === null && ji(z);
            break;
          case 30:
            ji(z);
            break;
          default:
            ji(z);
        }
        F = F.sibling;
      }
    }
    function ci(F, z, K) {
      for (K = K && (z.subtreeFlags & 8772) !== 0, z = z.child; z !== null; ) {
        var W = z.alternate,
          ee = F,
          ie = z,
          le = ie.flags;
        switch (ie.tag) {
          case 0:
          case 11:
          case 15:
            ci(ee, ie, K), sa(4, ie);
            break;
          case 1:
            if (
              (ci(ee, ie, K),
              (W = ie),
              (ee = W.stateNode),
              typeof ee.componentDidMount == "function")
            )
              try {
                ee.componentDidMount();
              } catch (we) {
                _t(W, W.return, we);
              }
            if (((W = ie), (ee = W.updateQueue), ee !== null)) {
              var de = W.stateNode;
              try {
                var ye = ee.shared.hiddenCallbacks;
                if (ye !== null)
                  for (
                    ee.shared.hiddenCallbacks = null, ee = 0;
                    ee < ye.length;
                    ee++
                  )
                    eu(ye[ee], de);
              } catch (we) {
                _t(W, W.return, we);
              }
            }
            K && le & 64 && md(ie), oa(ie, ie.return);
            break;
          case 27:
            bd(ie);
          case 26:
          case 5:
            ci(ee, ie, K),
              K && W === null && le & 4 && vd(ie),
              oa(ie, ie.return);
            break;
          case 12:
            ci(ee, ie, K);
            break;
          case 13:
            ci(ee, ie, K), K && le & 4 && Ed(ee, ie);
            break;
          case 22:
            ie.memoizedState === null && ci(ee, ie, K), oa(ie, ie.return);
            break;
          case 30:
            break;
          default:
            ci(ee, ie, K);
        }
        z = z.sibling;
      }
    }
    function cl(F, z) {
      var K = null;
      F !== null &&
        F.memoizedState !== null &&
        F.memoizedState.cachePool !== null &&
        (K = F.memoizedState.cachePool.pool),
        (F = null),
        z.memoizedState !== null &&
          z.memoizedState.cachePool !== null &&
          (F = z.memoizedState.cachePool.pool),
        F !== K && (F != null && F.refCount++, K != null && Gr(K));
    }
    function ul(F, z) {
      (F = null),
        z.alternate !== null && (F = z.alternate.memoizedState.cache),
        (z = z.memoizedState.cache),
        z !== F && (z.refCount++, F != null && Gr(F));
    }
    function Mn(F, z, K, W) {
      if (z.subtreeFlags & 10256)
        for (z = z.child; z !== null; ) _d(F, z, K, W), (z = z.sibling);
    }
    function _d(F, z, K, W) {
      var ee = z.flags;
      switch (z.tag) {
        case 0:
        case 11:
        case 15:
          Mn(F, z, K, W), ee & 2048 && sa(9, z);
          break;
        case 1:
          Mn(F, z, K, W);
          break;
        case 3:
          Mn(F, z, K, W),
            ee & 2048 &&
              ((F = null),
              z.alternate !== null && (F = z.alternate.memoizedState.cache),
              (z = z.memoizedState.cache),
              z !== F && (z.refCount++, F != null && Gr(F)));
          break;
        case 12:
          if (ee & 2048) {
            Mn(F, z, K, W), (F = z.stateNode);
            try {
              var ie = z.memoizedProps,
                le = ie.id,
                de = ie.onPostCommit;
              typeof de == "function" &&
                de(
                  le,
                  z.alternate === null ? "mount" : "update",
                  F.passiveEffectDuration,
                  -0
                );
            } catch (ye) {
              _t(z, z.return, ye);
            }
          } else Mn(F, z, K, W);
          break;
        case 13:
          Mn(F, z, K, W);
          break;
        case 23:
          break;
        case 22:
          (ie = z.stateNode),
            (le = z.alternate),
            z.memoizedState !== null
              ? ie._visibility & 2
                ? Mn(F, z, K, W)
                : la(F, z)
              : ie._visibility & 2
              ? Mn(F, z, K, W)
              : ((ie._visibility |= 2),
                gr(F, z, K, W, (z.subtreeFlags & 10256) !== 0)),
            ee & 2048 && cl(le, z);
          break;
        case 24:
          Mn(F, z, K, W), ee & 2048 && ul(z.alternate, z);
          break;
        default:
          Mn(F, z, K, W);
      }
    }
    function gr(F, z, K, W, ee) {
      for (
        ee = ee && (z.subtreeFlags & 10256) !== 0, z = z.child;
        z !== null;

      ) {
        var ie = F,
          le = z,
          de = K,
          ye = W,
          we = le.flags;
        switch (le.tag) {
          case 0:
          case 11:
          case 15:
            gr(ie, le, de, ye, ee), sa(8, le);
            break;
          case 23:
            break;
          case 22:
            var Ve = le.stateNode;
            le.memoizedState !== null
              ? Ve._visibility & 2
                ? gr(ie, le, de, ye, ee)
                : la(ie, le)
              : ((Ve._visibility |= 2), gr(ie, le, de, ye, ee)),
              ee && we & 2048 && cl(le.alternate, le);
            break;
          case 24:
            gr(ie, le, de, ye, ee), ee && we & 2048 && ul(le.alternate, le);
            break;
          default:
            gr(ie, le, de, ye, ee);
        }
        z = z.sibling;
      }
    }
    function la(F, z) {
      if (z.subtreeFlags & 10256)
        for (z = z.child; z !== null; ) {
          var K = F,
            W = z,
            ee = W.flags;
          switch (W.tag) {
            case 22:
              la(K, W), ee & 2048 && cl(W.alternate, W);
              break;
            case 24:
              la(K, W), ee & 2048 && ul(W.alternate, W);
              break;
            default:
              la(K, W);
          }
          z = z.sibling;
        }
    }
    var ca = 8192;
    function vr(F) {
      if (F.subtreeFlags & ca)
        for (F = F.child; F !== null; ) wd(F), (F = F.sibling);
    }
    function wd(F) {
      switch (F.tag) {
        case 26:
          vr(F),
            F.flags & ca &&
              F.memoizedState !== null &&
              Lp(wn, F.memoizedState, F.memoizedProps);
          break;
        case 5:
          vr(F);
          break;
        case 3:
        case 4:
          var z = wn;
          (wn = Cs(F.stateNode.containerInfo)), vr(F), (wn = z);
          break;
        case 22:
          F.memoizedState === null &&
            ((z = F.alternate),
            z !== null && z.memoizedState !== null
              ? ((z = ca), (ca = 16777216), vr(F), (ca = z))
              : vr(F));
          break;
        default:
          vr(F);
      }
    }
    function Ad(F) {
      var z = F.alternate;
      if (z !== null && ((F = z.child), F !== null)) {
        z.child = null;
        do (z = F.sibling), (F.sibling = null), (F = z);
        while (F !== null);
      }
    }
    function ua(F) {
      var z = F.deletions;
      if ((F.flags & 16) !== 0) {
        if (z !== null)
          for (var K = 0; K < z.length; K++) {
            var W = z[K];
            (Ht = W), Dd(W, F);
          }
        Ad(F);
      }
      if (F.subtreeFlags & 10256)
        for (F = F.child; F !== null; ) Pd(F), (F = F.sibling);
    }
    function Pd(F) {
      switch (F.tag) {
        case 0:
        case 11:
        case 15:
          ua(F), F.flags & 2048 && oi(9, F, F.return);
          break;
        case 3:
          ua(F);
          break;
        case 12:
          ua(F);
          break;
        case 22:
          var z = F.stateNode;
          F.memoizedState !== null &&
          z._visibility & 2 &&
          (F.return === null || F.return.tag !== 13)
            ? ((z._visibility &= -3), ds(F))
            : ua(F);
          break;
        default:
          ua(F);
      }
    }
    function ds(F) {
      var z = F.deletions;
      if ((F.flags & 16) !== 0) {
        if (z !== null)
          for (var K = 0; K < z.length; K++) {
            var W = z[K];
            (Ht = W), Dd(W, F);
          }
        Ad(F);
      }
      for (F = F.child; F !== null; ) {
        switch (((z = F), z.tag)) {
          case 0:
          case 11:
          case 15:
            oi(8, z, z.return), ds(z);
            break;
          case 22:
            (K = z.stateNode),
              K._visibility & 2 && ((K._visibility &= -3), ds(z));
            break;
          default:
            ds(z);
        }
        F = F.sibling;
      }
    }
    function Dd(F, z) {
      for (; Ht !== null; ) {
        var K = Ht;
        switch (K.tag) {
          case 0:
          case 11:
          case 15:
            oi(8, K, z);
            break;
          case 23:
          case 22:
            if (
              K.memoizedState !== null &&
              K.memoizedState.cachePool !== null
            ) {
              var W = K.memoizedState.cachePool.pool;
              W != null && W.refCount++;
            }
            break;
          case 24:
            Gr(K.memoizedState.cache);
        }
        if (((W = K.child), W !== null)) (W.return = K), (Ht = W);
        else
          e: for (K = F; Ht !== null; ) {
            W = Ht;
            var ee = W.sibling,
              ie = W.return;
            if ((kd(W), W === K)) {
              Ht = null;
              break e;
            }
            if (ee !== null) {
              (ee.return = ie), (Ht = ee);
              break e;
            }
            Ht = ie;
          }
      }
    }
    var Xh = {
        getCacheForType: function (F) {
          var z = Xt(Bt),
            K = z.data.get(F);
          return K === void 0 && ((K = F()), z.data.set(F, K)), K;
        },
      },
      Jh = typeof WeakMap == "function" ? WeakMap : Map,
      Tt = 0,
      wt = null,
      ft = null,
      mt = 0,
      kt = 0,
      hn = null,
      ui = !1,
      yr = !1,
      dl = !1,
      Yn = 0,
      Mt = 0,
      di = 0,
      Ui = 0,
      fl = 0,
      En = 0,
      br = 0,
      da = null,
      ln = null,
      hl = !1,
      pl = 0,
      fs = 1 / 0,
      hs = null,
      fi = null,
      Yt = 0,
      hi = null,
      Sr = null,
      Tr = 0,
      ml = 0,
      gl = null,
      Od = null,
      fa = 0,
      vl = null;
    function pn() {
      if ((Tt & 2) !== 0 && mt !== 0) return mt & -mt;
      if (Te.T !== null) {
        var F = lr;
        return F !== 0 ? F : El();
      }
      return Kl();
    }
    function Md() {
      En === 0 && (En = (mt & 536870912) === 0 || St ? lt() : 536870912);
      var F = Cn.current;
      return F !== null && (F.flags |= 32), En;
    }
    function mn(F, z, K) {
      ((F === wt && (kt === 2 || kt === 9)) ||
        F.cancelPendingCommit !== null) &&
        (kr(F, 0), pi(F, mt, En, !1)),
        It(F, K),
        ((Tt & 2) === 0 || F !== wt) &&
          (F === wt &&
            ((Tt & 2) === 0 && (Ui |= K), Mt === 4 && pi(F, mt, En, !1)),
          In(F));
    }
    function Id(F, z, K) {
      if ((Tt & 6) !== 0) throw Error(B(327));
      var W = (!K && (z & 124) === 0 && (z & F.expiredLanes) === 0) || Xe(F, z),
        ee = W ? tp(F, z) : Sl(F, z, !0),
        ie = W;
      do {
        if (ee === 0) {
          yr && !W && pi(F, z, 0, !1);
          break;
        } else {
          if (((K = F.current.alternate), ie && !Zh(K))) {
            (ee = Sl(F, z, !1)), (ie = !1);
            continue;
          }
          if (ee === 2) {
            if (((ie = z), F.errorRecoveryDisabledLanes & ie)) var le = 0;
            else
              (le = F.pendingLanes & -536870913),
                (le = le !== 0 ? le : le & 536870912 ? 536870912 : 0);
            if (le !== 0) {
              z = le;
              e: {
                var de = F;
                ee = da;
                var ye = de.current.memoizedState.isDehydrated;
                if (
                  (ye && (kr(de, le).flags |= 256),
                  (le = Sl(de, le, !1)),
                  le !== 2)
                ) {
                  if (dl && !ye) {
                    (de.errorRecoveryDisabledLanes |= ie), (Ui |= ie), (ee = 4);
                    break e;
                  }
                  (ie = ln),
                    (ln = ee),
                    ie !== null &&
                      (ln === null ? (ln = ie) : ln.push.apply(ln, ie));
                }
                ee = le;
              }
              if (((ie = !1), ee !== 2)) continue;
            }
          }
          if (ee === 1) {
            kr(F, 0), pi(F, z, 0, !0);
            break;
          }
          e: {
            switch (((W = F), (ie = ee), ie)) {
              case 0:
              case 1:
                throw Error(B(345));
              case 4:
                if ((z & 4194048) !== z) break;
              case 6:
                pi(W, z, En, !ui);
                break e;
              case 2:
                ln = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(B(329));
            }
            if ((z & 62914560) === z && ((ee = pl + 300 - At()), 10 < ee)) {
              if ((pi(W, z, En, !ui), qe(W, 0, !0) !== 0)) break e;
              W.timeoutHandle = uf(
                Ld.bind(
                  null,
                  W,
                  K,
                  ln,
                  hs,
                  hl,
                  z,
                  En,
                  Ui,
                  br,
                  ui,
                  ie,
                  2,
                  -0,
                  0
                ),
                ee
              );
              break e;
            }
            Ld(W, K, ln, hs, hl, z, En, Ui, br, ui, ie, 0, -0, 0);
          }
        }
        break;
      } while (!0);
      In(F);
    }
    function Ld(F, z, K, W, ee, ie, le, de, ye, we, Ve, $e, Pe, Oe) {
      if (
        ((F.timeoutHandle = -1),
        ($e = z.subtreeFlags),
        ($e & 8192 || ($e & 16785408) === 16785408) &&
          ((ba = { stylesheets: null, count: 0, unsuspend: Ip }),
          wd(z),
          ($e = Np()),
          $e !== null))
      ) {
        (F.cancelPendingCommit = $e(
          qd.bind(null, F, z, ie, K, W, ee, le, de, ye, Ve, 1, Pe, Oe)
        )),
          pi(F, ie, le, !we);
        return;
      }
      qd(F, z, ie, K, W, ee, le, de, ye);
    }
    function Zh(F) {
      for (var z = F; ; ) {
        var K = z.tag;
        if (
          (K === 0 || K === 11 || K === 15) &&
          z.flags & 16384 &&
          ((K = z.updateQueue), K !== null && ((K = K.stores), K !== null))
        )
          for (var W = 0; W < K.length; W++) {
            var ee = K[W],
              ie = ee.getSnapshot;
            ee = ee.value;
            try {
              if (!cn(ie(), ee)) return !1;
            } catch {
              return !1;
            }
          }
        if (((K = z.child), z.subtreeFlags & 16384 && K !== null))
          (K.return = z), (z = K);
        else {
          if (z === F) break;
          for (; z.sibling === null; ) {
            if (z.return === null || z.return === F) return !0;
            z = z.return;
          }
          (z.sibling.return = z.return), (z = z.sibling);
        }
      }
      return !0;
    }
    function pi(F, z, K, W) {
      (z &= ~fl),
        (z &= ~Ui),
        (F.suspendedLanes |= z),
        (F.pingedLanes &= ~z),
        W && (F.warmLanes |= z),
        (W = F.expirationTimes);
      for (var ee = z; 0 < ee; ) {
        var ie = 31 - rt(ee),
          le = 1 << ie;
        (W[ie] = -1), (ee &= ~le);
      }
      K !== 0 && Ls(F, K, z);
    }
    function ps() {
      return (Tt & 6) === 0 ? (ha(0), !1) : !0;
    }
    function yl() {
      if (ft !== null) {
        if (kt === 0) var F = ft.return;
        else (F = ft), (Bn = Oi = null), Lo(F), (pr = null), (ia = 0), (F = ft);
        for (; F !== null; ) pd(F.alternate, F), (F = F.return);
        ft = null;
      }
    }
    function kr(F, z) {
      var K = F.timeoutHandle;
      K !== -1 && ((F.timeoutHandle = -1), vp(K)),
        (K = F.cancelPendingCommit),
        K !== null && ((F.cancelPendingCommit = null), K()),
        yl(),
        (wt = F),
        (ft = K = jn(F.current, null)),
        (mt = z),
        (kt = 0),
        (hn = null),
        (ui = !1),
        (yr = Xe(F, z)),
        (dl = !1),
        (br = En = fl = Ui = di = Mt = 0),
        (ln = da = null),
        (hl = !1),
        (z & 8) !== 0 && (z |= z & 32);
      var W = F.entangledLanes;
      if (W !== 0)
        for (F = F.entanglements, W &= z; 0 < W; ) {
          var ee = 31 - rt(W),
            ie = 1 << ee;
          (z |= F[ee]), (W &= ~ie);
        }
      return (Yn = z), Na(), K;
    }
    function Nd(F, z) {
      (ut = null),
        (Te.H = ts),
        z === Yr || z === Ha
          ? ((z = Jc()), (kt = 3))
          : z === Qc
          ? ((z = Jc()), (kt = 4))
          : (kt =
              z === Zu
                ? 8
                : z !== null &&
                  typeof z == "object" &&
                  typeof z.then == "function"
                ? 6
                : 1),
        (hn = z),
        ft === null && ((Mt = 1), ss(F, bn(z, F.current)));
    }
    function jd() {
      var F = Te.H;
      return (Te.H = ts), F === null ? ts : F;
    }
    function Ud() {
      var F = Te.A;
      return (Te.A = Xh), F;
    }
    function bl() {
      (Mt = 4),
        ui || ((mt & 4194048) !== mt && Cn.current !== null) || (yr = !0),
        ((di & 134217727) === 0 && (Ui & 134217727) === 0) ||
          wt === null ||
          pi(wt, mt, En, !1);
    }
    function Sl(F, z, K) {
      var W = Tt;
      Tt |= 2;
      var ee = jd(),
        ie = Ud();
      (wt !== F || mt !== z) && ((hs = null), kr(F, z)), (z = !1);
      var le = Mt;
      e: do
        try {
          if (kt !== 0 && ft !== null) {
            var de = ft,
              ye = hn;
            switch (kt) {
              case 8:
                yl(), (le = 6);
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                Cn.current === null && (z = !0);
                var we = kt;
                if (((kt = 0), (hn = null), Cr(F, de, ye, we), K && yr)) {
                  le = 0;
                  break e;
                }
                break;
              default:
                (we = kt), (kt = 0), (hn = null), Cr(F, de, ye, we);
            }
          }
          ep(), (le = Mt);
          break;
        } catch (Ve) {
          Nd(F, Ve);
        }
      while (!0);
      return (
        z && F.shellSuspendCounter++,
        (Bn = Oi = null),
        (Tt = W),
        (Te.H = ee),
        (Te.A = ie),
        ft === null && ((wt = null), (mt = 0), Na()),
        le
      );
    }
    function ep() {
      for (; ft !== null; ) Vd(ft);
    }
    function tp(F, z) {
      var K = Tt;
      Tt |= 2;
      var W = jd(),
        ee = Ud();
      wt !== F || mt !== z
        ? ((hs = null), (fs = At() + 500), kr(F, z))
        : (yr = Xe(F, z));
      e: do
        try {
          if (kt !== 0 && ft !== null) {
            z = ft;
            var ie = hn;
            t: switch (kt) {
              case 1:
                (kt = 0), (hn = null), Cr(F, z, ie, 1);
                break;
              case 2:
              case 9:
                if (Wc(ie)) {
                  (kt = 0), (hn = null), Bd(z);
                  break;
                }
                (z = function () {
                  (kt !== 2 && kt !== 9) || wt !== F || (kt = 7), In(F);
                }),
                  ie.then(z, z);
                break e;
              case 3:
                kt = 7;
                break e;
              case 4:
                kt = 5;
                break e;
              case 7:
                Wc(ie)
                  ? ((kt = 0), (hn = null), Bd(z))
                  : ((kt = 0), (hn = null), Cr(F, z, ie, 7));
                break;
              case 5:
                var le = null;
                switch (ft.tag) {
                  case 26:
                    le = ft.memoizedState;
                  case 5:
                  case 27:
                    var de = ft;
                    if (!le || kf(le)) {
                      (kt = 0), (hn = null);
                      var ye = de.sibling;
                      if (ye !== null) ft = ye;
                      else {
                        var we = de.return;
                        we !== null ? ((ft = we), ms(we)) : (ft = null);
                      }
                      break t;
                    }
                }
                (kt = 0), (hn = null), Cr(F, z, ie, 5);
                break;
              case 6:
                (kt = 0), (hn = null), Cr(F, z, ie, 6);
                break;
              case 8:
                yl(), (Mt = 6);
                break e;
              default:
                throw Error(B(462));
            }
          }
          np();
          break;
        } catch (Ve) {
          Nd(F, Ve);
        }
      while (!0);
      return (
        (Bn = Oi = null),
        (Te.H = W),
        (Te.A = ee),
        (Tt = K),
        ft !== null ? 0 : ((wt = null), (mt = 0), Na(), Mt)
      );
    }
    function np() {
      for (; ft !== null && !Bi(); ) Vd(ft);
    }
    function Vd(F) {
      var z = fd(F.alternate, F, Yn);
      (F.memoizedProps = F.pendingProps), z === null ? ms(F) : (ft = z);
    }
    function Bd(F) {
      var z = F,
        K = z.alternate;
      switch (z.tag) {
        case 15:
        case 0:
          z = sd(K, z, z.pendingProps, z.type, void 0, mt);
          break;
        case 11:
          z = sd(K, z, z.pendingProps, z.type.render, z.ref, mt);
          break;
        case 5:
          Lo(z);
        default:
          pd(K, z), (z = ft = Bc(z, Yn)), (z = fd(K, z, Yn));
      }
      (F.memoizedProps = F.pendingProps), z === null ? ms(F) : (ft = z);
    }
    function Cr(F, z, K, W) {
      (Bn = Oi = null), Lo(z), (pr = null), (ia = 0);
      var ee = z.return;
      try {
        if (Hh(F, ee, z, K, mt)) {
          (Mt = 1), ss(F, bn(K, F.current)), (ft = null);
          return;
        }
      } catch (ie) {
        if (ee !== null) throw ((ft = ee), ie);
        (Mt = 1), ss(F, bn(K, F.current)), (ft = null);
        return;
      }
      z.flags & 32768
        ? (St || W === 1
            ? (F = !0)
            : yr || (mt & 536870912) !== 0
            ? (F = !1)
            : ((ui = F = !0),
              (W === 2 || W === 9 || W === 3 || W === 6) &&
                ((W = Cn.current),
                W !== null && W.tag === 13 && (W.flags |= 16384))),
          Fd(z, F))
        : ms(z);
    }
    function ms(F) {
      var z = F;
      do {
        if ((z.flags & 32768) !== 0) {
          Fd(z, ui);
          return;
        }
        F = z.return;
        var K = Kh(z.alternate, z, Yn);
        if (K !== null) {
          ft = K;
          return;
        }
        if (((z = z.sibling), z !== null)) {
          ft = z;
          return;
        }
        ft = z = F;
      } while (z !== null);
      Mt === 0 && (Mt = 5);
    }
    function Fd(F, z) {
      do {
        var K = Yh(F.alternate, F);
        if (K !== null) {
          (K.flags &= 32767), (ft = K);
          return;
        }
        if (
          ((K = F.return),
          K !== null &&
            ((K.flags |= 32768), (K.subtreeFlags = 0), (K.deletions = null)),
          !z && ((F = F.sibling), F !== null))
        ) {
          ft = F;
          return;
        }
        ft = F = K;
      } while (F !== null);
      (Mt = 6), (ft = null);
    }
    function qd(F, z, K, W, ee, ie, le, de, ye) {
      F.cancelPendingCommit = null;
      do gs();
      while (Yt !== 0);
      if ((Tt & 6) !== 0) throw Error(B(327));
      if (z !== null) {
        if (z === F.current) throw Error(B(177));
        if (
          ((ie = z.lanes | z.childLanes),
          (ie |= co),
          qi(F, K, ie, le, de, ye),
          F === wt && ((ft = wt = null), (mt = 0)),
          (Sr = z),
          (hi = F),
          (Tr = K),
          (ml = ie),
          (gl = ee),
          (Od = W),
          (z.subtreeFlags & 10256) !== 0 || (z.flags & 10256) !== 0
            ? ((F.callbackNode = null),
              (F.callbackPriority = 0),
              sp(Xn, function () {
                return Kd(), null;
              }))
            : ((F.callbackNode = null), (F.callbackPriority = 0)),
          (W = (z.flags & 13878) !== 0),
          (z.subtreeFlags & 13878) !== 0 || W)
        ) {
          (W = Te.T),
            (Te.T = null),
            (ee = xe.p),
            (xe.p = 2),
            (le = Tt),
            (Tt |= 4);
          try {
            Qh(F, z, K);
          } finally {
            (Tt = le), (xe.p = ee), (Te.T = W);
          }
        }
        (Yt = 1), zd(), $d(), Hd();
      }
    }
    function zd() {
      if (Yt === 1) {
        Yt = 0;
        var F = hi,
          z = Sr,
          K = (z.flags & 13878) !== 0;
        if ((z.subtreeFlags & 13878) !== 0 || K) {
          (K = Te.T), (Te.T = null);
          var W = xe.p;
          xe.p = 2;
          var ee = Tt;
          Tt |= 4;
          try {
            xd(z, F);
            var ie = Ol,
              le = Pc(F.containerInfo),
              de = ie.focusedElem,
              ye = ie.selectionRange;
            if (
              le !== de &&
              de &&
              de.ownerDocument &&
              Ac(de.ownerDocument.documentElement, de)
            ) {
              if (ye !== null && ro(de)) {
                var we = ye.start,
                  Ve = ye.end;
                if ((Ve === void 0 && (Ve = we), "selectionStart" in de))
                  (de.selectionStart = we),
                    (de.selectionEnd = Math.min(Ve, de.value.length));
                else {
                  var $e = de.ownerDocument || document,
                    Pe = ($e && $e.defaultView) || window;
                  if (Pe.getSelection) {
                    var Oe = Pe.getSelection(),
                      ot = de.textContent.length,
                      at = Math.min(ye.start, ot),
                      xt = ye.end === void 0 ? at : Math.min(ye.end, ot);
                    !Oe.extend && at > xt && ((le = xt), (xt = at), (at = le));
                    var ke = wc(de, at),
                      Se = wc(de, xt);
                    if (
                      ke &&
                      Se &&
                      (Oe.rangeCount !== 1 ||
                        Oe.anchorNode !== ke.node ||
                        Oe.anchorOffset !== ke.offset ||
                        Oe.focusNode !== Se.node ||
                        Oe.focusOffset !== Se.offset)
                    ) {
                      var _e = $e.createRange();
                      _e.setStart(ke.node, ke.offset),
                        Oe.removeAllRanges(),
                        at > xt
                          ? (Oe.addRange(_e), Oe.extend(Se.node, Se.offset))
                          : (_e.setEnd(Se.node, Se.offset), Oe.addRange(_e));
                    }
                  }
                }
              }
              for ($e = [], Oe = de; (Oe = Oe.parentNode); )
                Oe.nodeType === 1 &&
                  $e.push({
                    element: Oe,
                    left: Oe.scrollLeft,
                    top: Oe.scrollTop,
                  });
              for (
                typeof de.focus == "function" && de.focus(), de = 0;
                de < $e.length;
                de++
              ) {
                var ze = $e[de];
                (ze.element.scrollLeft = ze.left),
                  (ze.element.scrollTop = ze.top);
              }
            }
            (ws = !!Dl), (Ol = Dl = null);
          } finally {
            (Tt = ee), (xe.p = W), (Te.T = K);
          }
        }
        (F.current = z), (Yt = 2);
      }
    }
    function $d() {
      if (Yt === 2) {
        Yt = 0;
        var F = hi,
          z = Sr,
          K = (z.flags & 8772) !== 0;
        if ((z.subtreeFlags & 8772) !== 0 || K) {
          (K = Te.T), (Te.T = null);
          var W = xe.p;
          xe.p = 2;
          var ee = Tt;
          Tt |= 4;
          try {
            Td(F, z.alternate, z);
          } finally {
            (Tt = ee), (xe.p = W), (Te.T = K);
          }
        }
        Yt = 3;
      }
    }
    function Hd() {
      if (Yt === 4 || Yt === 3) {
        (Yt = 0), Wn();
        var F = hi,
          z = Sr,
          K = Tr,
          W = Od;
        (z.subtreeFlags & 10256) !== 0 || (z.flags & 10256) !== 0
          ? (Yt = 5)
          : ((Yt = 0), (Sr = hi = null), Gd(F, F.pendingLanes));
        var ee = F.pendingLanes;
        if (
          (ee === 0 && (fi = null),
          js(K),
          (z = z.stateNode),
          Ke && typeof Ke.onCommitFiberRoot == "function")
        )
          try {
            Ke.onCommitFiberRoot(
              Ne,
              z,
              void 0,
              (z.current.flags & 128) === 128
            );
          } catch {}
        if (W !== null) {
          (z = Te.T), (ee = xe.p), (xe.p = 2), (Te.T = null);
          try {
            for (var ie = F.onRecoverableError, le = 0; le < W.length; le++) {
              var de = W[le];
              ie(de.value, { componentStack: de.stack });
            }
          } finally {
            (Te.T = z), (xe.p = ee);
          }
        }
        (Tr & 3) !== 0 && gs(),
          In(F),
          (ee = F.pendingLanes),
          (K & 4194090) !== 0 && (ee & 42) !== 0
            ? F === vl
              ? fa++
              : ((fa = 0), (vl = F))
            : (fa = 0),
          ha(0);
      }
    }
    function Gd(F, z) {
      (F.pooledCacheLanes &= z) === 0 &&
        ((z = F.pooledCache), z != null && ((F.pooledCache = null), Gr(z)));
    }
    function gs(F) {
      return zd(), $d(), Hd(), Kd();
    }
    function Kd() {
      if (Yt !== 5) return !1;
      var F = hi,
        z = ml;
      ml = 0;
      var K = js(Tr),
        W = Te.T,
        ee = xe.p;
      try {
        (xe.p = 32 > K ? 32 : K), (Te.T = null), (K = gl), (gl = null);
        var ie = hi,
          le = Tr;
        if (((Yt = 0), (Sr = hi = null), (Tr = 0), (Tt & 6) !== 0))
          throw Error(B(331));
        var de = Tt;
        if (
          ((Tt |= 4),
          Pd(ie.current),
          _d(ie, ie.current, le, K),
          (Tt = de),
          ha(0, !1),
          Ke && typeof Ke.onPostCommitFiberRoot == "function")
        )
          try {
            Ke.onPostCommitFiberRoot(Ne, ie);
          } catch {}
        return !0;
      } finally {
        (xe.p = ee), (Te.T = W), Gd(F, z);
      }
    }
    function Yd(F, z, K) {
      (z = bn(K, z)),
        (z = Qo(F.stateNode, z, 2)),
        (F = ii(F, z, 2)),
        F !== null && (It(F, 2), In(F));
    }
    function _t(F, z, K) {
      if (F.tag === 3) Yd(F, F, K);
      else
        for (; z !== null; ) {
          if (z.tag === 3) {
            Yd(z, F, K);
            break;
          } else if (z.tag === 1) {
            var W = z.stateNode;
            if (
              typeof z.type.getDerivedStateFromError == "function" ||
              (typeof W.componentDidCatch == "function" &&
                (fi === null || !fi.has(W)))
            ) {
              (F = bn(K, F)),
                (K = Xu(2)),
                (W = ii(z, K, 2)),
                W !== null && (Ju(K, W, z, F), It(W, 2), In(W));
              break;
            }
          }
          z = z.return;
        }
    }
    function Tl(F, z, K) {
      var W = F.pingCache;
      if (W === null) {
        W = F.pingCache = new Jh();
        var ee = new Set();
        W.set(z, ee);
      } else (ee = W.get(z)), ee === void 0 && ((ee = new Set()), W.set(z, ee));
      ee.has(K) ||
        ((dl = !0), ee.add(K), (F = ip.bind(null, F, z, K)), z.then(F, F));
    }
    function ip(F, z, K) {
      var W = F.pingCache;
      W !== null && W.delete(z),
        (F.pingedLanes |= F.suspendedLanes & K),
        (F.warmLanes &= ~K),
        wt === F &&
          (mt & K) === K &&
          (Mt === 4 || (Mt === 3 && (mt & 62914560) === mt && 300 > At() - pl)
            ? (Tt & 2) === 0 && kr(F, 0)
            : (fl |= K),
          br === mt && (br = 0)),
        In(F);
    }
    function Qd(F, z) {
      z === 0 && (z = Rt()), (F = rr(F, z)), F !== null && (It(F, z), In(F));
    }
    function rp(F) {
      var z = F.memoizedState,
        K = 0;
      z !== null && (K = z.retryLane), Qd(F, K);
    }
    function ap(F, z) {
      var K = 0;
      switch (F.tag) {
        case 13:
          var W = F.stateNode,
            ee = F.memoizedState;
          ee !== null && (K = ee.retryLane);
          break;
        case 19:
          W = F.stateNode;
          break;
        case 22:
          W = F.stateNode._retryCache;
          break;
        default:
          throw Error(B(314));
      }
      W !== null && W.delete(z), Qd(F, K);
    }
    function sp(F, z) {
      return nn(F, z);
    }
    var vs = null,
      Er = null,
      kl = !1,
      ys = !1,
      Cl = !1,
      Vi = 0;
    function In(F) {
      F !== Er &&
        F.next === null &&
        (Er === null ? (vs = Er = F) : (Er = Er.next = F)),
        (ys = !0),
        kl || ((kl = !0), lp());
    }
    function ha(F, z) {
      if (!Cl && ys) {
        Cl = !0;
        do
          for (var K = !1, W = vs; W !== null; ) {
            if (F !== 0) {
              var ee = W.pendingLanes;
              if (ee === 0) var ie = 0;
              else {
                var le = W.suspendedLanes,
                  de = W.pingedLanes;
                (ie = (1 << (31 - rt(42 | F) + 1)) - 1),
                  (ie &= ee & ~(le & ~de)),
                  (ie =
                    ie & 201326741 ? (ie & 201326741) | 1 : ie ? ie | 2 : 0);
              }
              ie !== 0 && ((K = !0), Zd(W, ie));
            } else
              (ie = mt),
                (ie = qe(
                  W,
                  W === wt ? ie : 0,
                  W.cancelPendingCommit !== null || W.timeoutHandle !== -1
                )),
                (ie & 3) === 0 || Xe(W, ie) || ((K = !0), Zd(W, ie));
            W = W.next;
          }
        while (K);
        Cl = !1;
      }
    }
    function op() {
      Wd();
    }
    function Wd() {
      ys = kl = !1;
      var F = 0;
      Vi !== 0 && (gp() && (F = Vi), (Vi = 0));
      for (var z = At(), K = null, W = vs; W !== null; ) {
        var ee = W.next,
          ie = Xd(W, z);
        ie === 0
          ? ((W.next = null),
            K === null ? (vs = ee) : (K.next = ee),
            ee === null && (Er = K))
          : ((K = W), (F !== 0 || (ie & 3) !== 0) && (ys = !0)),
          (W = ee);
      }
      ha(F);
    }
    function Xd(F, z) {
      for (
        var K = F.suspendedLanes,
          W = F.pingedLanes,
          ee = F.expirationTimes,
          ie = F.pendingLanes & -62914561;
        0 < ie;

      ) {
        var le = 31 - rt(ie),
          de = 1 << le,
          ye = ee[le];
        ye === -1
          ? ((de & K) === 0 || (de & W) !== 0) && (ee[le] = Ze(de, z))
          : ye <= z && (F.expiredLanes |= de),
          (ie &= ~de);
      }
      if (
        ((z = wt),
        (K = mt),
        (K = qe(
          F,
          F === z ? K : 0,
          F.cancelPendingCommit !== null || F.timeoutHandle !== -1
        )),
        (W = F.callbackNode),
        K === 0 ||
          (F === z && (kt === 2 || kt === 9)) ||
          F.cancelPendingCommit !== null)
      )
        return (
          W !== null && W !== null && gn(W),
          (F.callbackNode = null),
          (F.callbackPriority = 0)
        );
      if ((K & 3) === 0 || Xe(F, K)) {
        if (((z = K & -K), z === F.callbackPriority)) return z;
        switch ((W !== null && gn(W), js(K))) {
          case 2:
          case 8:
            K = Ti;
            break;
          case 32:
            K = Xn;
            break;
          case 268435456:
            K = ki;
            break;
          default:
            K = Xn;
        }
        return (
          (W = Jd.bind(null, F)),
          (K = nn(K, W)),
          (F.callbackPriority = z),
          (F.callbackNode = K),
          z
        );
      }
      return (
        W !== null && W !== null && gn(W),
        (F.callbackPriority = 2),
        (F.callbackNode = null),
        2
      );
    }
    function Jd(F, z) {
      if (Yt !== 0 && Yt !== 5)
        return (F.callbackNode = null), (F.callbackPriority = 0), null;
      var K = F.callbackNode;
      if (gs() && F.callbackNode !== K) return null;
      var W = mt;
      return (
        (W = qe(
          F,
          F === wt ? W : 0,
          F.cancelPendingCommit !== null || F.timeoutHandle !== -1
        )),
        W === 0
          ? null
          : (Id(F, W, z),
            Xd(F, At()),
            F.callbackNode != null && F.callbackNode === K
              ? Jd.bind(null, F)
              : null)
      );
    }
    function Zd(F, z) {
      if (gs()) return null;
      Id(F, z, !0);
    }
    function lp() {
      yp(function () {
        (Tt & 6) !== 0 ? nn(qt, op) : Wd();
      });
    }
    function El() {
      return Vi === 0 && (Vi = lt()), Vi;
    }
    function ef(F) {
      return F == null || typeof F == "symbol" || typeof F == "boolean"
        ? null
        : typeof F == "function"
        ? F
        : Aa("" + F);
    }
    function tf(F, z) {
      var K = z.ownerDocument.createElement("input");
      return (
        (K.name = z.name),
        (K.value = z.value),
        F.id && K.setAttribute("form", F.id),
        z.parentNode.insertBefore(K, z),
        (F = new FormData(F)),
        K.parentNode.removeChild(K),
        F
      );
    }
    function cp(F, z, K, W, ee) {
      if (z === "submit" && K && K.stateNode === ee) {
        var ie = ef((ee[rn] || null).action),
          le = W.submitter;
        le &&
          ((z = (z = le[rn] || null)
            ? ef(z.formAction)
            : le.getAttribute("formAction")),
          z !== null && ((ie = z), (le = null)));
        var de = new Ma("action", "action", null, W, ee);
        F.push({
          event: de,
          listeners: [
            {
              instance: null,
              listener: function () {
                if (W.defaultPrevented) {
                  if (Vi !== 0) {
                    var ye = le ? tf(ee, le) : new FormData(ee);
                    $o(
                      K,
                      { pending: !0, data: ye, method: ee.method, action: ie },
                      null,
                      ye
                    );
                  }
                } else
                  typeof ie == "function" &&
                    (de.preventDefault(),
                    (ye = le ? tf(ee, le) : new FormData(ee)),
                    $o(
                      K,
                      { pending: !0, data: ye, method: ee.method, action: ie },
                      ie,
                      ye
                    ));
              },
              currentTarget: ee,
            },
          ],
        });
      }
    }
    for (var xl = 0; xl < lo.length; xl++) {
      var Rl = lo[xl],
        up = Rl.toLowerCase(),
        dp = Rl[0].toUpperCase() + Rl.slice(1);
      _n(up, "on" + dp);
    }
    _n(Mc, "onAnimationEnd"),
      _n(Ic, "onAnimationIteration"),
      _n(Lc, "onAnimationStart"),
      _n("dblclick", "onDoubleClick"),
      _n("focusin", "onFocus"),
      _n("focusout", "onBlur"),
      _n(wh, "onTransitionRun"),
      _n(Ah, "onTransitionStart"),
      _n(Ph, "onTransitionCancel"),
      _n(Nc, "onTransitionEnd"),
      Yi("onMouseEnter", ["mouseout", "mouseover"]),
      Yi("onMouseLeave", ["mouseout", "mouseover"]),
      Yi("onPointerEnter", ["pointerout", "pointerover"]),
      Yi("onPointerLeave", ["pointerout", "pointerover"]),
      Ci(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(
          " "
        )
      ),
      Ci(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      ),
      Ci("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]),
      Ci(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      ),
      Ci(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      ),
      Ci(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
    var pa =
        "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
          " "
        ),
      fp = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle"
          .split(" ")
          .concat(pa)
      );
    function nf(F, z) {
      z = (z & 4) !== 0;
      for (var K = 0; K < F.length; K++) {
        var W = F[K],
          ee = W.event;
        W = W.listeners;
        e: {
          var ie = void 0;
          if (z)
            for (var le = W.length - 1; 0 <= le; le--) {
              var de = W[le],
                ye = de.instance,
                we = de.currentTarget;
              if (((de = de.listener), ye !== ie && ee.isPropagationStopped()))
                break e;
              (ie = de), (ee.currentTarget = we);
              try {
                ie(ee);
              } catch (Ve) {
                as(Ve);
              }
              (ee.currentTarget = null), (ie = ye);
            }
          else
            for (le = 0; le < W.length; le++) {
              if (
                ((de = W[le]),
                (ye = de.instance),
                (we = de.currentTarget),
                (de = de.listener),
                ye !== ie && ee.isPropagationStopped())
              )
                break e;
              (ie = de), (ee.currentTarget = we);
              try {
                ie(ee);
              } catch (Ve) {
                as(Ve);
              }
              (ee.currentTarget = null), (ie = ye);
            }
        }
      }
    }
    function ht(F, z) {
      var K = z[Us];
      K === void 0 && (K = z[Us] = new Set());
      var W = F + "__bubble";
      K.has(W) || (rf(z, F, 2, !1), K.add(W));
    }
    function _l(F, z, K) {
      var W = 0;
      z && (W |= 4), rf(K, F, W, z);
    }
    var bs = "_reactListening" + Math.random().toString(36).slice(2);
    function wl(F) {
      if (!F[bs]) {
        (F[bs] = !0),
          Ql.forEach(function (K) {
            K !== "selectionchange" &&
              (fp.has(K) || _l(K, !1, F), _l(K, !0, F));
          });
        var z = F.nodeType === 9 ? F : F.ownerDocument;
        z === null || z[bs] || ((z[bs] = !0), _l("selectionchange", !1, z));
      }
    }
    function rf(F, z, K, W) {
      switch (wf(z)) {
        case 2:
          var ee = Vp;
          break;
        case 8:
          ee = Bp;
          break;
        default:
          ee = ql;
      }
      (K = ee.bind(null, z, K, F)),
        (ee = void 0),
        !Qs ||
          (z !== "touchstart" && z !== "touchmove" && z !== "wheel") ||
          (ee = !0),
        W
          ? ee !== void 0
            ? F.addEventListener(z, K, { capture: !0, passive: ee })
            : F.addEventListener(z, K, !0)
          : ee !== void 0
          ? F.addEventListener(z, K, { passive: ee })
          : F.addEventListener(z, K, !1);
    }
    function Al(F, z, K, W, ee) {
      var ie = W;
      if ((z & 1) === 0 && (z & 2) === 0 && W !== null)
        e: for (;;) {
          if (W === null) return;
          var le = W.tag;
          if (le === 3 || le === 4) {
            var de = W.stateNode.containerInfo;
            if (de === ee) break;
            if (le === 4)
              for (le = W.return; le !== null; ) {
                var ye = le.tag;
                if ((ye === 3 || ye === 4) && le.stateNode.containerInfo === ee)
                  return;
                le = le.return;
              }
            for (; de !== null; ) {
              if (((le = Hi(de)), le === null)) return;
              if (
                ((ye = le.tag), ye === 5 || ye === 6 || ye === 26 || ye === 27)
              ) {
                W = ie = le;
                continue e;
              }
              de = de.parentNode;
            }
          }
          W = W.return;
        }
      cc(function () {
        var we = ie,
          Ve = Ks(K),
          $e = [];
        e: {
          var Pe = jc.get(F);
          if (Pe !== void 0) {
            var Oe = Ma,
              ot = F;
            switch (F) {
              case "keypress":
                if (Da(K) === 0) break e;
              case "keydown":
              case "keyup":
                Oe = ah;
                break;
              case "focusin":
                (ot = "focus"), (Oe = Zs);
                break;
              case "focusout":
                (ot = "blur"), (Oe = Zs);
                break;
              case "beforeblur":
              case "afterblur":
                Oe = Zs;
                break;
              case "click":
                if (K.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                Oe = fc;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                Oe = Kf;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                Oe = lh;
                break;
              case Mc:
              case Ic:
              case Lc:
                Oe = Wf;
                break;
              case Nc:
                Oe = uh;
                break;
              case "scroll":
              case "scrollend":
                Oe = Hf;
                break;
              case "wheel":
                Oe = fh;
                break;
              case "copy":
              case "cut":
              case "paste":
                Oe = Jf;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                Oe = pc;
                break;
              case "toggle":
              case "beforetoggle":
                Oe = ph;
            }
            var at = (z & 4) !== 0,
              xt = !at && (F === "scroll" || F === "scrollend"),
              ke = at ? (Pe !== null ? Pe + "Capture" : null) : Pe;
            at = [];
            for (var Se = we, _e; Se !== null; ) {
              var ze = Se;
              if (
                ((_e = ze.stateNode),
                (ze = ze.tag),
                (ze !== 5 && ze !== 26 && ze !== 27) ||
                  _e === null ||
                  ke === null ||
                  ((ze = Mr(Se, ke)), ze != null && at.push(ma(Se, ze, _e))),
                xt)
              )
                break;
              Se = Se.return;
            }
            0 < at.length &&
              ((Pe = new Oe(Pe, ot, null, K, Ve)),
              $e.push({ event: Pe, listeners: at }));
          }
        }
        if ((z & 7) === 0) {
          e: {
            if (
              ((Pe = F === "mouseover" || F === "pointerover"),
              (Oe = F === "mouseout" || F === "pointerout"),
              Pe &&
                K !== Gs &&
                (ot = K.relatedTarget || K.fromElement) &&
                (Hi(ot) || ot[$i]))
            )
              break e;
            if (
              (Oe || Pe) &&
              ((Pe =
                Ve.window === Ve
                  ? Ve
                  : (Pe = Ve.ownerDocument)
                  ? Pe.defaultView || Pe.parentWindow
                  : window),
              Oe
                ? ((ot = K.relatedTarget || K.toElement),
                  (Oe = we),
                  (ot = ot ? Hi(ot) : null),
                  ot !== null &&
                    ((xt = $(ot)),
                    (at = ot.tag),
                    ot !== xt || (at !== 5 && at !== 27 && at !== 6)) &&
                    (ot = null))
                : ((Oe = null), (ot = we)),
              Oe !== ot)
            ) {
              if (
                ((at = fc),
                (ze = "onMouseLeave"),
                (ke = "onMouseEnter"),
                (Se = "mouse"),
                (F === "pointerout" || F === "pointerover") &&
                  ((at = pc),
                  (ze = "onPointerLeave"),
                  (ke = "onPointerEnter"),
                  (Se = "pointer")),
                (xt = Oe == null ? Pe : Or(Oe)),
                (_e = ot == null ? Pe : Or(ot)),
                (Pe = new at(ze, Se + "leave", Oe, K, Ve)),
                (Pe.target = xt),
                (Pe.relatedTarget = _e),
                (ze = null),
                Hi(Ve) === we &&
                  ((at = new at(ke, Se + "enter", ot, K, Ve)),
                  (at.target = _e),
                  (at.relatedTarget = xt),
                  (ze = at)),
                (xt = ze),
                Oe && ot)
              )
                t: {
                  for (at = Oe, ke = ot, Se = 0, _e = at; _e; _e = xr(_e)) Se++;
                  for (_e = 0, ze = ke; ze; ze = xr(ze)) _e++;
                  for (; 0 < Se - _e; ) (at = xr(at)), Se--;
                  for (; 0 < _e - Se; ) (ke = xr(ke)), _e--;
                  for (; Se--; ) {
                    if (at === ke || (ke !== null && at === ke.alternate))
                      break t;
                    (at = xr(at)), (ke = xr(ke));
                  }
                  at = null;
                }
              else at = null;
              Oe !== null && af($e, Pe, Oe, at, !1),
                ot !== null && xt !== null && af($e, xt, ot, at, !0);
            }
          }
          e: {
            if (
              ((Pe = we ? Or(we) : window),
              (Oe = Pe.nodeName && Pe.nodeName.toLowerCase()),
              Oe === "select" || (Oe === "input" && Pe.type === "file"))
            )
              var et = kc;
            else if (Sc(Pe))
              if (Cc) et = xh;
              else {
                et = Ch;
                var dt = kh;
              }
            else
              (Oe = Pe.nodeName),
                !Oe ||
                Oe.toLowerCase() !== "input" ||
                (Pe.type !== "checkbox" && Pe.type !== "radio")
                  ? we && Hs(we.elementType) && (et = kc)
                  : (et = Eh);
            if (et && (et = et(F, we))) {
              Tc($e, et, K, Ve);
              break e;
            }
            dt && dt(F, Pe, we),
              F === "focusout" &&
                we &&
                Pe.type === "number" &&
                we.memoizedProps.value != null &&
                $s(Pe, "number", Pe.value);
          }
          switch (((dt = we ? Or(we) : window), F)) {
            case "focusin":
              (Sc(dt) || dt.contentEditable === "true") &&
                ((tr = dt), (ao = we), (Fr = null));
              break;
            case "focusout":
              Fr = ao = tr = null;
              break;
            case "mousedown":
              so = !0;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              (so = !1), Dc($e, K, Ve);
              break;
            case "selectionchange":
              if (_h) break;
            case "keydown":
            case "keyup":
              Dc($e, K, Ve);
          }
          var nt;
          if (to)
            e: {
              switch (F) {
                case "compositionstart":
                  var st = "onCompositionStart";
                  break e;
                case "compositionend":
                  st = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  st = "onCompositionUpdate";
                  break e;
              }
              st = void 0;
            }
          else
            er
              ? yc(F, K) && (st = "onCompositionEnd")
              : F === "keydown" &&
                K.keyCode === 229 &&
                (st = "onCompositionStart");
          st &&
            (mc &&
              K.locale !== "ko" &&
              (er || st !== "onCompositionStart"
                ? st === "onCompositionEnd" && er && (nt = uc())
                : ((Zn = Ve),
                  (Ws = "value" in Zn ? Zn.value : Zn.textContent),
                  (er = !0))),
            (dt = Ss(we, st)),
            0 < dt.length &&
              ((st = new hc(st, F, null, K, Ve)),
              $e.push({ event: st, listeners: dt }),
              nt
                ? (st.data = nt)
                : ((nt = bc(K)), nt !== null && (st.data = nt)))),
            (nt = gh ? yh(F, K) : bh(F, K)) &&
              ((st = Ss(we, "onBeforeInput")),
              0 < st.length &&
                ((dt = new hc("onBeforeInput", "beforeinput", null, K, Ve)),
                $e.push({ event: dt, listeners: st }),
                (dt.data = nt))),
            cp($e, F, we, K, Ve);
        }
        nf($e, z);
      });
    }
    function ma(F, z, K) {
      return { instance: F, listener: z, currentTarget: K };
    }
    function Ss(F, z) {
      for (var K = z + "Capture", W = []; F !== null; ) {
        var ee = F,
          ie = ee.stateNode;
        if (
          ((ee = ee.tag),
          (ee !== 5 && ee !== 26 && ee !== 27) ||
            ie === null ||
            ((ee = Mr(F, K)),
            ee != null && W.unshift(ma(F, ee, ie)),
            (ee = Mr(F, z)),
            ee != null && W.push(ma(F, ee, ie))),
          F.tag === 3)
        )
          return W;
        F = F.return;
      }
      return [];
    }
    function xr(F) {
      if (F === null) return null;
      do F = F.return;
      while (F && F.tag !== 5 && F.tag !== 27);
      return F || null;
    }
    function af(F, z, K, W, ee) {
      for (var ie = z._reactName, le = []; K !== null && K !== W; ) {
        var de = K,
          ye = de.alternate,
          we = de.stateNode;
        if (((de = de.tag), ye !== null && ye === W)) break;
        (de !== 5 && de !== 26 && de !== 27) ||
          we === null ||
          ((ye = we),
          ee
            ? ((we = Mr(K, ie)), we != null && le.unshift(ma(K, we, ye)))
            : ee || ((we = Mr(K, ie)), we != null && le.push(ma(K, we, ye)))),
          (K = K.return);
      }
      le.length !== 0 && F.push({ event: z, listeners: le });
    }
    var hp = /\r\n?/g,
      pp = /\u0000|\uFFFD/g;
    function sf(F) {
      return (typeof F == "string" ? F : "" + F)
        .replace(
          hp,
          `
`
        )
        .replace(pp, "");
    }
    function of(F, z) {
      return (z = sf(z)), sf(F) === z;
    }
    function Ts() {}
    function Et(F, z, K, W, ee, ie) {
      switch (K) {
        case "children":
          typeof W == "string"
            ? z === "body" || (z === "textarea" && W === "") || Xi(F, W)
            : (typeof W == "number" || typeof W == "bigint") &&
              z !== "body" &&
              Xi(F, "" + W);
          break;
        case "className":
          Ra(F, "class", W);
          break;
        case "tabIndex":
          Ra(F, "tabindex", W);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Ra(F, K, W);
          break;
        case "style":
          oc(F, W, ie);
          break;
        case "data":
          if (z !== "object") {
            Ra(F, "data", W);
            break;
          }
        case "src":
        case "href":
          if (W === "" && (z !== "a" || K !== "href")) {
            F.removeAttribute(K);
            break;
          }
          if (
            W == null ||
            typeof W == "function" ||
            typeof W == "symbol" ||
            typeof W == "boolean"
          ) {
            F.removeAttribute(K);
            break;
          }
          (W = Aa("" + W)), F.setAttribute(K, W);
          break;
        case "action":
        case "formAction":
          if (typeof W == "function") {
            F.setAttribute(
              K,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            typeof ie == "function" &&
              (K === "formAction"
                ? (z !== "input" && Et(F, z, "name", ee.name, ee, null),
                  Et(F, z, "formEncType", ee.formEncType, ee, null),
                  Et(F, z, "formMethod", ee.formMethod, ee, null),
                  Et(F, z, "formTarget", ee.formTarget, ee, null))
                : (Et(F, z, "encType", ee.encType, ee, null),
                  Et(F, z, "method", ee.method, ee, null),
                  Et(F, z, "target", ee.target, ee, null)));
          if (W == null || typeof W == "symbol" || typeof W == "boolean") {
            F.removeAttribute(K);
            break;
          }
          (W = Aa("" + W)), F.setAttribute(K, W);
          break;
        case "onClick":
          W != null && (F.onclick = Ts);
          break;
        case "onScroll":
          W != null && ht("scroll", F);
          break;
        case "onScrollEnd":
          W != null && ht("scrollend", F);
          break;
        case "dangerouslySetInnerHTML":
          if (W != null) {
            if (typeof W != "object" || !("__html" in W)) throw Error(B(61));
            if (((K = W.__html), K != null)) {
              if (ee.children != null) throw Error(B(60));
              F.innerHTML = K;
            }
          }
          break;
        case "multiple":
          F.multiple = W && typeof W != "function" && typeof W != "symbol";
          break;
        case "muted":
          F.muted = W && typeof W != "function" && typeof W != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (
            W == null ||
            typeof W == "function" ||
            typeof W == "boolean" ||
            typeof W == "symbol"
          ) {
            F.removeAttribute("xlink:href");
            break;
          }
          (K = Aa("" + W)),
            F.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", K);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          W != null && typeof W != "function" && typeof W != "symbol"
            ? F.setAttribute(K, "" + W)
            : F.removeAttribute(K);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          W && typeof W != "function" && typeof W != "symbol"
            ? F.setAttribute(K, "")
            : F.removeAttribute(K);
          break;
        case "capture":
        case "download":
          W === !0
            ? F.setAttribute(K, "")
            : W !== !1 &&
              W != null &&
              typeof W != "function" &&
              typeof W != "symbol"
            ? F.setAttribute(K, W)
            : F.removeAttribute(K);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          W != null &&
          typeof W != "function" &&
          typeof W != "symbol" &&
          !isNaN(W) &&
          1 <= W
            ? F.setAttribute(K, W)
            : F.removeAttribute(K);
          break;
        case "rowSpan":
        case "start":
          W == null ||
          typeof W == "function" ||
          typeof W == "symbol" ||
          isNaN(W)
            ? F.removeAttribute(K)
            : F.setAttribute(K, W);
          break;
        case "popover":
          ht("beforetoggle", F), ht("toggle", F), xa(F, "popover", W);
          break;
        case "xlinkActuate":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:actuate", W);
          break;
        case "xlinkArcrole":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:arcrole", W);
          break;
        case "xlinkRole":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:role", W);
          break;
        case "xlinkShow":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:show", W);
          break;
        case "xlinkTitle":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:title", W);
          break;
        case "xlinkType":
          Ln(F, "http://www.w3.org/1999/xlink", "xlink:type", W);
          break;
        case "xmlBase":
          Ln(F, "http://www.w3.org/XML/1998/namespace", "xml:base", W);
          break;
        case "xmlLang":
          Ln(F, "http://www.w3.org/XML/1998/namespace", "xml:lang", W);
          break;
        case "xmlSpace":
          Ln(F, "http://www.w3.org/XML/1998/namespace", "xml:space", W);
          break;
        case "is":
          xa(F, "is", W);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < K.length) ||
            (K[0] !== "o" && K[0] !== "O") ||
            (K[1] !== "n" && K[1] !== "N")) &&
            ((K = zf.get(K) || K), xa(F, K, W));
      }
    }
    function Pl(F, z, K, W, ee, ie) {
      switch (K) {
        case "style":
          oc(F, W, ie);
          break;
        case "dangerouslySetInnerHTML":
          if (W != null) {
            if (typeof W != "object" || !("__html" in W)) throw Error(B(61));
            if (((K = W.__html), K != null)) {
              if (ee.children != null) throw Error(B(60));
              F.innerHTML = K;
            }
          }
          break;
        case "children":
          typeof W == "string"
            ? Xi(F, W)
            : (typeof W == "number" || typeof W == "bigint") && Xi(F, "" + W);
          break;
        case "onScroll":
          W != null && ht("scroll", F);
          break;
        case "onScrollEnd":
          W != null && ht("scrollend", F);
          break;
        case "onClick":
          W != null && (F.onclick = Ts);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!Wl.hasOwnProperty(K))
            e: {
              if (
                K[0] === "o" &&
                K[1] === "n" &&
                ((ee = K.endsWith("Capture")),
                (z = K.slice(2, ee ? K.length - 7 : void 0)),
                (ie = F[rn] || null),
                (ie = ie != null ? ie[K] : null),
                typeof ie == "function" && F.removeEventListener(z, ie, ee),
                typeof W == "function")
              ) {
                typeof ie != "function" &&
                  ie !== null &&
                  (K in F
                    ? (F[K] = null)
                    : F.hasAttribute(K) && F.removeAttribute(K)),
                  F.addEventListener(z, W, ee);
                break e;
              }
              K in F
                ? (F[K] = W)
                : W === !0
                ? F.setAttribute(K, "")
                : xa(F, K, W);
            }
      }
    }
    function Qt(F, z, K) {
      switch (z) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          ht("error", F), ht("load", F);
          var W = !1,
            ee = !1,
            ie;
          for (ie in K)
            if (K.hasOwnProperty(ie)) {
              var le = K[ie];
              if (le != null)
                switch (ie) {
                  case "src":
                    W = !0;
                    break;
                  case "srcSet":
                    ee = !0;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(B(137, z));
                  default:
                    Et(F, z, ie, le, K, null);
                }
            }
          ee && Et(F, z, "srcSet", K.srcSet, K, null),
            W && Et(F, z, "src", K.src, K, null);
          return;
        case "input":
          ht("invalid", F);
          var de = (ie = le = ee = null),
            ye = null,
            we = null;
          for (W in K)
            if (K.hasOwnProperty(W)) {
              var Ve = K[W];
              if (Ve != null)
                switch (W) {
                  case "name":
                    ee = Ve;
                    break;
                  case "type":
                    le = Ve;
                    break;
                  case "checked":
                    ye = Ve;
                    break;
                  case "defaultChecked":
                    we = Ve;
                    break;
                  case "value":
                    ie = Ve;
                    break;
                  case "defaultValue":
                    de = Ve;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (Ve != null) throw Error(B(137, z));
                    break;
                  default:
                    Et(F, z, W, Ve, K, null);
                }
            }
          ic(F, ie, de, ye, we, le, ee, !1), _a(F);
          return;
        case "select":
          ht("invalid", F), (W = le = ie = null);
          for (ee in K)
            if (K.hasOwnProperty(ee) && ((de = K[ee]), de != null))
              switch (ee) {
                case "value":
                  ie = de;
                  break;
                case "defaultValue":
                  le = de;
                  break;
                case "multiple":
                  W = de;
                default:
                  Et(F, z, ee, de, K, null);
              }
          (z = ie),
            (K = le),
            (F.multiple = !!W),
            z != null ? Wi(F, !!W, z, !1) : K != null && Wi(F, !!W, K, !0);
          return;
        case "textarea":
          ht("invalid", F), (ie = ee = W = null);
          for (le in K)
            if (K.hasOwnProperty(le) && ((de = K[le]), de != null))
              switch (le) {
                case "value":
                  W = de;
                  break;
                case "defaultValue":
                  ee = de;
                  break;
                case "children":
                  ie = de;
                  break;
                case "dangerouslySetInnerHTML":
                  if (de != null) throw Error(B(91));
                  break;
                default:
                  Et(F, z, le, de, K, null);
              }
          ac(F, W, ee, ie), _a(F);
          return;
        case "option":
          for (ye in K)
            if (K.hasOwnProperty(ye) && ((W = K[ye]), W != null))
              switch (ye) {
                case "selected":
                  F.selected =
                    W && typeof W != "function" && typeof W != "symbol";
                  break;
                default:
                  Et(F, z, ye, W, K, null);
              }
          return;
        case "dialog":
          ht("beforetoggle", F),
            ht("toggle", F),
            ht("cancel", F),
            ht("close", F);
          break;
        case "iframe":
        case "object":
          ht("load", F);
          break;
        case "video":
        case "audio":
          for (W = 0; W < pa.length; W++) ht(pa[W], F);
          break;
        case "image":
          ht("error", F), ht("load", F);
          break;
        case "details":
          ht("toggle", F);
          break;
        case "embed":
        case "source":
        case "link":
          ht("error", F), ht("load", F);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (we in K)
            if (K.hasOwnProperty(we) && ((W = K[we]), W != null))
              switch (we) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(B(137, z));
                default:
                  Et(F, z, we, W, K, null);
              }
          return;
        default:
          if (Hs(z)) {
            for (Ve in K)
              K.hasOwnProperty(Ve) &&
                ((W = K[Ve]), W !== void 0 && Pl(F, z, Ve, W, K, void 0));
            return;
          }
      }
      for (de in K)
        K.hasOwnProperty(de) &&
          ((W = K[de]), W != null && Et(F, z, de, W, K, null));
    }
    function mp(F, z, K, W) {
      switch (z) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var ee = null,
            ie = null,
            le = null,
            de = null,
            ye = null,
            we = null,
            Ve = null;
          for (Oe in K) {
            var $e = K[Oe];
            if (K.hasOwnProperty(Oe) && $e != null)
              switch (Oe) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  ye = $e;
                default:
                  W.hasOwnProperty(Oe) || Et(F, z, Oe, null, W, $e);
              }
          }
          for (var Pe in W) {
            var Oe = W[Pe];
            if (
              (($e = K[Pe]), W.hasOwnProperty(Pe) && (Oe != null || $e != null))
            )
              switch (Pe) {
                case "type":
                  ie = Oe;
                  break;
                case "name":
                  ee = Oe;
                  break;
                case "checked":
                  we = Oe;
                  break;
                case "defaultChecked":
                  Ve = Oe;
                  break;
                case "value":
                  le = Oe;
                  break;
                case "defaultValue":
                  de = Oe;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Oe != null) throw Error(B(137, z));
                  break;
                default:
                  Oe !== $e && Et(F, z, Pe, Oe, W, $e);
              }
          }
          zs(F, le, de, ye, we, Ve, ie, ee);
          return;
        case "select":
          Oe = le = de = Pe = null;
          for (ie in K)
            if (((ye = K[ie]), K.hasOwnProperty(ie) && ye != null))
              switch (ie) {
                case "value":
                  break;
                case "multiple":
                  Oe = ye;
                default:
                  W.hasOwnProperty(ie) || Et(F, z, ie, null, W, ye);
              }
          for (ee in W)
            if (
              ((ie = W[ee]),
              (ye = K[ee]),
              W.hasOwnProperty(ee) && (ie != null || ye != null))
            )
              switch (ee) {
                case "value":
                  Pe = ie;
                  break;
                case "defaultValue":
                  de = ie;
                  break;
                case "multiple":
                  le = ie;
                default:
                  ie !== ye && Et(F, z, ee, ie, W, ye);
              }
          (z = de),
            (K = le),
            (W = Oe),
            Pe != null
              ? Wi(F, !!K, Pe, !1)
              : !!W != !!K &&
                (z != null ? Wi(F, !!K, z, !0) : Wi(F, !!K, K ? [] : "", !1));
          return;
        case "textarea":
          Oe = Pe = null;
          for (de in K)
            if (
              ((ee = K[de]),
              K.hasOwnProperty(de) && ee != null && !W.hasOwnProperty(de))
            )
              switch (de) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  Et(F, z, de, null, W, ee);
              }
          for (le in W)
            if (
              ((ee = W[le]),
              (ie = K[le]),
              W.hasOwnProperty(le) && (ee != null || ie != null))
            )
              switch (le) {
                case "value":
                  Pe = ee;
                  break;
                case "defaultValue":
                  Oe = ee;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (ee != null) throw Error(B(91));
                  break;
                default:
                  ee !== ie && Et(F, z, le, ee, W, ie);
              }
          rc(F, Pe, Oe);
          return;
        case "option":
          for (var ot in K)
            if (
              ((Pe = K[ot]),
              K.hasOwnProperty(ot) && Pe != null && !W.hasOwnProperty(ot))
            )
              switch (ot) {
                case "selected":
                  F.selected = !1;
                  break;
                default:
                  Et(F, z, ot, null, W, Pe);
              }
          for (ye in W)
            if (
              ((Pe = W[ye]),
              (Oe = K[ye]),
              W.hasOwnProperty(ye) && Pe !== Oe && (Pe != null || Oe != null))
            )
              switch (ye) {
                case "selected":
                  F.selected =
                    Pe && typeof Pe != "function" && typeof Pe != "symbol";
                  break;
                default:
                  Et(F, z, ye, Pe, W, Oe);
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var at in K)
            (Pe = K[at]),
              K.hasOwnProperty(at) &&
                Pe != null &&
                !W.hasOwnProperty(at) &&
                Et(F, z, at, null, W, Pe);
          for (we in W)
            if (
              ((Pe = W[we]),
              (Oe = K[we]),
              W.hasOwnProperty(we) && Pe !== Oe && (Pe != null || Oe != null))
            )
              switch (we) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (Pe != null) throw Error(B(137, z));
                  break;
                default:
                  Et(F, z, we, Pe, W, Oe);
              }
          return;
        default:
          if (Hs(z)) {
            for (var xt in K)
              (Pe = K[xt]),
                K.hasOwnProperty(xt) &&
                  Pe !== void 0 &&
                  !W.hasOwnProperty(xt) &&
                  Pl(F, z, xt, void 0, W, Pe);
            for (Ve in W)
              (Pe = W[Ve]),
                (Oe = K[Ve]),
                !W.hasOwnProperty(Ve) ||
                  Pe === Oe ||
                  (Pe === void 0 && Oe === void 0) ||
                  Pl(F, z, Ve, Pe, W, Oe);
            return;
          }
      }
      for (var ke in K)
        (Pe = K[ke]),
          K.hasOwnProperty(ke) &&
            Pe != null &&
            !W.hasOwnProperty(ke) &&
            Et(F, z, ke, null, W, Pe);
      for ($e in W)
        (Pe = W[$e]),
          (Oe = K[$e]),
          !W.hasOwnProperty($e) ||
            Pe === Oe ||
            (Pe == null && Oe == null) ||
            Et(F, z, $e, Pe, W, Oe);
    }
    var Dl = null,
      Ol = null;
    function ks(F) {
      return F.nodeType === 9 ? F : F.ownerDocument;
    }
    function lf(F) {
      switch (F) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function cf(F, z) {
      if (F === 0)
        switch (z) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return F === 1 && z === "foreignObject" ? 0 : F;
    }
    function Ml(F, z) {
      return (
        F === "textarea" ||
        F === "noscript" ||
        typeof z.children == "string" ||
        typeof z.children == "number" ||
        typeof z.children == "bigint" ||
        (typeof z.dangerouslySetInnerHTML == "object" &&
          z.dangerouslySetInnerHTML !== null &&
          z.dangerouslySetInnerHTML.__html != null)
      );
    }
    var Il = null;
    function gp() {
      var F = window.event;
      return F && F.type === "popstate"
        ? F === Il
          ? !1
          : ((Il = F), !0)
        : ((Il = null), !1);
    }
    var uf = typeof setTimeout == "function" ? setTimeout : void 0,
      vp = typeof clearTimeout == "function" ? clearTimeout : void 0,
      df = typeof Promise == "function" ? Promise : void 0,
      yp =
        typeof queueMicrotask == "function"
          ? queueMicrotask
          : typeof df < "u"
          ? function (F) {
              return df.resolve(null).then(F).catch(bp);
            }
          : uf;
    function bp(F) {
      setTimeout(function () {
        throw F;
      });
    }
    function mi(F) {
      return F === "head";
    }
    function ff(F, z) {
      var K = z,
        W = 0,
        ee = 0;
      do {
        var ie = K.nextSibling;
        if ((F.removeChild(K), ie && ie.nodeType === 8))
          if (((K = ie.data), K === "/$")) {
            if (0 < W && 8 > W) {
              K = W;
              var le = F.ownerDocument;
              if (
                (K & 1 && ga(le.documentElement), K & 2 && ga(le.body), K & 4)
              )
                for (K = le.head, ga(K), le = K.firstChild; le; ) {
                  var de = le.nextSibling,
                    ye = le.nodeName;
                  le[Dr] ||
                    ye === "SCRIPT" ||
                    ye === "STYLE" ||
                    (ye === "LINK" && le.rel.toLowerCase() === "stylesheet") ||
                    K.removeChild(le),
                    (le = de);
                }
            }
            if (ee === 0) {
              F.removeChild(ie), Ea(z);
              return;
            }
            ee--;
          } else
            K === "$" || K === "$?" || K === "$!"
              ? ee++
              : (W = K.charCodeAt(0) - 48);
        else W = 0;
        K = ie;
      } while (K);
      Ea(z);
    }
    function Ll(F) {
      var z = F.firstChild;
      for (z && z.nodeType === 10 && (z = z.nextSibling); z; ) {
        var K = z;
        switch (((z = z.nextSibling), K.nodeName)) {
          case "HTML":
          case "HEAD":
          case "BODY":
            Ll(K), Vs(K);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (K.rel.toLowerCase() === "stylesheet") continue;
        }
        F.removeChild(K);
      }
    }
    function Sp(F, z, K, W) {
      for (; F.nodeType === 1; ) {
        var ee = K;
        if (F.nodeName.toLowerCase() !== z.toLowerCase()) {
          if (!W && (F.nodeName !== "INPUT" || F.type !== "hidden")) break;
        } else if (W) {
          if (!F[Dr])
            switch (z) {
              case "meta":
                if (!F.hasAttribute("itemprop")) break;
                return F;
              case "link":
                if (
                  ((ie = F.getAttribute("rel")),
                  ie === "stylesheet" && F.hasAttribute("data-precedence"))
                )
                  break;
                if (
                  ie !== ee.rel ||
                  F.getAttribute("href") !==
                    (ee.href == null || ee.href === "" ? null : ee.href) ||
                  F.getAttribute("crossorigin") !==
                    (ee.crossOrigin == null ? null : ee.crossOrigin) ||
                  F.getAttribute("title") !==
                    (ee.title == null ? null : ee.title)
                )
                  break;
                return F;
              case "style":
                if (F.hasAttribute("data-precedence")) break;
                return F;
              case "script":
                if (
                  ((ie = F.getAttribute("src")),
                  (ie !== (ee.src == null ? null : ee.src) ||
                    F.getAttribute("type") !==
                      (ee.type == null ? null : ee.type) ||
                    F.getAttribute("crossorigin") !==
                      (ee.crossOrigin == null ? null : ee.crossOrigin)) &&
                    ie &&
                    F.hasAttribute("async") &&
                    !F.hasAttribute("itemprop"))
                )
                  break;
                return F;
              default:
                return F;
            }
        } else if (z === "input" && F.type === "hidden") {
          var ie = ee.name == null ? null : "" + ee.name;
          if (ee.type === "hidden" && F.getAttribute("name") === ie) return F;
        } else return F;
        if (((F = An(F.nextSibling)), F === null)) break;
      }
      return null;
    }
    function Tp(F, z, K) {
      if (z === "") return null;
      for (; F.nodeType !== 3; )
        if (
          ((F.nodeType !== 1 ||
            F.nodeName !== "INPUT" ||
            F.type !== "hidden") &&
            !K) ||
          ((F = An(F.nextSibling)), F === null)
        )
          return null;
      return F;
    }
    function Nl(F) {
      return (
        F.data === "$!" ||
        (F.data === "$?" && F.ownerDocument.readyState === "complete")
      );
    }
    function kp(F, z) {
      var K = F.ownerDocument;
      if (F.data !== "$?" || K.readyState === "complete") z();
      else {
        var W = function () {
          z(), K.removeEventListener("DOMContentLoaded", W);
        };
        K.addEventListener("DOMContentLoaded", W), (F._reactRetry = W);
      }
    }
    function An(F) {
      for (; F != null; F = F.nextSibling) {
        var z = F.nodeType;
        if (z === 1 || z === 3) break;
        if (z === 8) {
          if (
            ((z = F.data),
            z === "$" || z === "$!" || z === "$?" || z === "F!" || z === "F")
          )
            break;
          if (z === "/$") return null;
        }
      }
      return F;
    }
    var jl = null;
    function hf(F) {
      F = F.previousSibling;
      for (var z = 0; F; ) {
        if (F.nodeType === 8) {
          var K = F.data;
          if (K === "$" || K === "$!" || K === "$?") {
            if (z === 0) return F;
            z--;
          } else K === "/$" && z++;
        }
        F = F.previousSibling;
      }
      return null;
    }
    function pf(F, z, K) {
      switch (((z = ks(K)), F)) {
        case "html":
          if (((F = z.documentElement), !F)) throw Error(B(452));
          return F;
        case "head":
          if (((F = z.head), !F)) throw Error(B(453));
          return F;
        case "body":
          if (((F = z.body), !F)) throw Error(B(454));
          return F;
        default:
          throw Error(B(451));
      }
    }
    function ga(F) {
      for (var z = F.attributes; z.length; ) F.removeAttributeNode(z[0]);
      Vs(F);
    }
    var xn = new Map(),
      mf = new Set();
    function Cs(F) {
      return typeof F.getRootNode == "function"
        ? F.getRootNode()
        : F.nodeType === 9
        ? F
        : F.ownerDocument;
    }
    var Qn = xe.d;
    xe.d = { f: Cp, r: Ep, D: xp, C: Rp, L: _p, m: wp, X: Pp, S: Ap, M: Dp };
    function Cp() {
      var F = Qn.f(),
        z = ps();
      return F || z;
    }
    function Ep(F) {
      var z = Gi(F);
      z !== null && z.tag === 5 && z.type === "form" ? Mu(z) : Qn.r(F);
    }
    var Rr = typeof document > "u" ? null : document;
    function gf(F, z, K) {
      var W = Rr;
      if (W && typeof z == "string" && z) {
        var ee = yn(z);
        (ee = 'link[rel="' + F + '"][href="' + ee + '"]'),
          typeof K == "string" && (ee += '[crossorigin="' + K + '"]'),
          mf.has(ee) ||
            (mf.add(ee),
            (F = { rel: F, crossOrigin: K, href: z }),
            W.querySelector(ee) === null &&
              ((z = W.createElement("link")),
              Qt(z, "link", F),
              zt(z),
              W.head.appendChild(z)));
      }
    }
    function xp(F) {
      Qn.D(F), gf("dns-prefetch", F, null);
    }
    function Rp(F, z) {
      Qn.C(F, z), gf("preconnect", F, z);
    }
    function _p(F, z, K) {
      Qn.L(F, z, K);
      var W = Rr;
      if (W && F && z) {
        var ee = 'link[rel="preload"][as="' + yn(z) + '"]';
        z === "image" && K && K.imageSrcSet
          ? ((ee += '[imagesrcset="' + yn(K.imageSrcSet) + '"]'),
            typeof K.imageSizes == "string" &&
              (ee += '[imagesizes="' + yn(K.imageSizes) + '"]'))
          : (ee += '[href="' + yn(F) + '"]');
        var ie = ee;
        switch (z) {
          case "style":
            ie = _r(F);
            break;
          case "script":
            ie = wr(F);
        }
        xn.has(ie) ||
          ((F = X(
            {
              rel: "preload",
              href: z === "image" && K && K.imageSrcSet ? void 0 : F,
              as: z,
            },
            K
          )),
          xn.set(ie, F),
          W.querySelector(ee) !== null ||
            (z === "style" && W.querySelector(va(ie))) ||
            (z === "script" && W.querySelector(ya(ie))) ||
            ((z = W.createElement("link")),
            Qt(z, "link", F),
            zt(z),
            W.head.appendChild(z)));
      }
    }
    function wp(F, z) {
      Qn.m(F, z);
      var K = Rr;
      if (K && F) {
        var W = z && typeof z.as == "string" ? z.as : "script",
          ee =
            'link[rel="modulepreload"][as="' +
            yn(W) +
            '"][href="' +
            yn(F) +
            '"]',
          ie = ee;
        switch (W) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            ie = wr(F);
        }
        if (
          !xn.has(ie) &&
          ((F = X({ rel: "modulepreload", href: F }, z)),
          xn.set(ie, F),
          K.querySelector(ee) === null)
        ) {
          switch (W) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (K.querySelector(ya(ie))) return;
          }
          (W = K.createElement("link")),
            Qt(W, "link", F),
            zt(W),
            K.head.appendChild(W);
        }
      }
    }
    function Ap(F, z, K) {
      Qn.S(F, z, K);
      var W = Rr;
      if (W && F) {
        var ee = Ki(W).hoistableStyles,
          ie = _r(F);
        z = z || "default";
        var le = ee.get(ie);
        if (!le) {
          var de = { loading: 0, preload: null };
          if ((le = W.querySelector(va(ie)))) de.loading = 5;
          else {
            (F = X({ rel: "stylesheet", href: F, "data-precedence": z }, K)),
              (K = xn.get(ie)) && Ul(F, K);
            var ye = (le = W.createElement("link"));
            zt(ye),
              Qt(ye, "link", F),
              (ye._p = new Promise(function (we, Ve) {
                (ye.onload = we), (ye.onerror = Ve);
              })),
              ye.addEventListener("load", function () {
                de.loading |= 1;
              }),
              ye.addEventListener("error", function () {
                de.loading |= 2;
              }),
              (de.loading |= 4),
              Es(le, z, W);
          }
          (le = { type: "stylesheet", instance: le, count: 1, state: de }),
            ee.set(ie, le);
        }
      }
    }
    function Pp(F, z) {
      Qn.X(F, z);
      var K = Rr;
      if (K && F) {
        var W = Ki(K).hoistableScripts,
          ee = wr(F),
          ie = W.get(ee);
        ie ||
          ((ie = K.querySelector(ya(ee))),
          ie ||
            ((F = X({ src: F, async: !0 }, z)),
            (z = xn.get(ee)) && Vl(F, z),
            (ie = K.createElement("script")),
            zt(ie),
            Qt(ie, "link", F),
            K.head.appendChild(ie)),
          (ie = { type: "script", instance: ie, count: 1, state: null }),
          W.set(ee, ie));
      }
    }
    function Dp(F, z) {
      Qn.M(F, z);
      var K = Rr;
      if (K && F) {
        var W = Ki(K).hoistableScripts,
          ee = wr(F),
          ie = W.get(ee);
        ie ||
          ((ie = K.querySelector(ya(ee))),
          ie ||
            ((F = X({ src: F, async: !0, type: "module" }, z)),
            (z = xn.get(ee)) && Vl(F, z),
            (ie = K.createElement("script")),
            zt(ie),
            Qt(ie, "link", F),
            K.head.appendChild(ie)),
          (ie = { type: "script", instance: ie, count: 1, state: null }),
          W.set(ee, ie));
      }
    }
    function vf(F, z, K, W) {
      var ee = (ee = Ie.current) ? Cs(ee) : null;
      if (!ee) throw Error(B(446));
      switch (F) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof K.precedence == "string" && typeof K.href == "string"
            ? ((z = _r(K.href)),
              (K = Ki(ee).hoistableStyles),
              (W = K.get(z)),
              W ||
                ((W = { type: "style", instance: null, count: 0, state: null }),
                K.set(z, W)),
              W)
            : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if (
            K.rel === "stylesheet" &&
            typeof K.href == "string" &&
            typeof K.precedence == "string"
          ) {
            F = _r(K.href);
            var ie = Ki(ee).hoistableStyles,
              le = ie.get(F);
            if (
              (le ||
                ((ee = ee.ownerDocument || ee),
                (le = {
                  type: "stylesheet",
                  instance: null,
                  count: 0,
                  state: { loading: 0, preload: null },
                }),
                ie.set(F, le),
                (ie = ee.querySelector(va(F))) &&
                  !ie._p &&
                  ((le.instance = ie), (le.state.loading = 5)),
                xn.has(F) ||
                  ((K = {
                    rel: "preload",
                    as: "style",
                    href: K.href,
                    crossOrigin: K.crossOrigin,
                    integrity: K.integrity,
                    media: K.media,
                    hrefLang: K.hrefLang,
                    referrerPolicy: K.referrerPolicy,
                  }),
                  xn.set(F, K),
                  ie || Op(ee, F, K, le.state))),
              z && W === null)
            )
              throw Error(B(528, ""));
            return le;
          }
          if (z && W !== null) throw Error(B(529, ""));
          return null;
        case "script":
          return (
            (z = K.async),
            (K = K.src),
            typeof K == "string" &&
            z &&
            typeof z != "function" &&
            typeof z != "symbol"
              ? ((z = wr(K)),
                (K = Ki(ee).hoistableScripts),
                (W = K.get(z)),
                W ||
                  ((W = {
                    type: "script",
                    instance: null,
                    count: 0,
                    state: null,
                  }),
                  K.set(z, W)),
                W)
              : { type: "void", instance: null, count: 0, state: null }
          );
        default:
          throw Error(B(444, F));
      }
    }
    function _r(F) {
      return 'href="' + yn(F) + '"';
    }
    function va(F) {
      return 'link[rel="stylesheet"][' + F + "]";
    }
    function yf(F) {
      return X({}, F, { "data-precedence": F.precedence, precedence: null });
    }
    function Op(F, z, K, W) {
      F.querySelector('link[rel="preload"][as="style"][' + z + "]")
        ? (W.loading = 1)
        : ((z = F.createElement("link")),
          (W.preload = z),
          z.addEventListener("load", function () {
            return (W.loading |= 1);
          }),
          z.addEventListener("error", function () {
            return (W.loading |= 2);
          }),
          Qt(z, "link", K),
          zt(z),
          F.head.appendChild(z));
    }
    function wr(F) {
      return '[src="' + yn(F) + '"]';
    }
    function ya(F) {
      return "script[async]" + F;
    }
    function bf(F, z, K) {
      if ((z.count++, z.instance === null))
        switch (z.type) {
          case "style":
            var W = F.querySelector('style[data-href~="' + yn(K.href) + '"]');
            if (W) return (z.instance = W), zt(W), W;
            var ee = X({}, K, {
              "data-href": K.href,
              "data-precedence": K.precedence,
              href: null,
              precedence: null,
            });
            return (
              (W = (F.ownerDocument || F).createElement("style")),
              zt(W),
              Qt(W, "style", ee),
              Es(W, K.precedence, F),
              (z.instance = W)
            );
          case "stylesheet":
            ee = _r(K.href);
            var ie = F.querySelector(va(ee));
            if (ie)
              return (z.state.loading |= 4), (z.instance = ie), zt(ie), ie;
            (W = yf(K)),
              (ee = xn.get(ee)) && Ul(W, ee),
              (ie = (F.ownerDocument || F).createElement("link")),
              zt(ie);
            var le = ie;
            return (
              (le._p = new Promise(function (de, ye) {
                (le.onload = de), (le.onerror = ye);
              })),
              Qt(ie, "link", W),
              (z.state.loading |= 4),
              Es(ie, K.precedence, F),
              (z.instance = ie)
            );
          case "script":
            return (
              (ie = wr(K.src)),
              (ee = F.querySelector(ya(ie)))
                ? ((z.instance = ee), zt(ee), ee)
                : ((W = K),
                  (ee = xn.get(ie)) && ((W = X({}, K)), Vl(W, ee)),
                  (F = F.ownerDocument || F),
                  (ee = F.createElement("script")),
                  zt(ee),
                  Qt(ee, "link", W),
                  F.head.appendChild(ee),
                  (z.instance = ee))
            );
          case "void":
            return null;
          default:
            throw Error(B(443, z.type));
        }
      else
        z.type === "stylesheet" &&
          (z.state.loading & 4) === 0 &&
          ((W = z.instance), (z.state.loading |= 4), Es(W, K.precedence, F));
      return z.instance;
    }
    function Es(F, z, K) {
      for (
        var W = K.querySelectorAll(
            'link[rel="stylesheet"][data-precedence],style[data-precedence]'
          ),
          ee = W.length ? W[W.length - 1] : null,
          ie = ee,
          le = 0;
        le < W.length;
        le++
      ) {
        var de = W[le];
        if (de.dataset.precedence === z) ie = de;
        else if (ie !== ee) break;
      }
      ie
        ? ie.parentNode.insertBefore(F, ie.nextSibling)
        : ((z = K.nodeType === 9 ? K.head : K),
          z.insertBefore(F, z.firstChild));
    }
    function Ul(F, z) {
      F.crossOrigin == null && (F.crossOrigin = z.crossOrigin),
        F.referrerPolicy == null && (F.referrerPolicy = z.referrerPolicy),
        F.title == null && (F.title = z.title);
    }
    function Vl(F, z) {
      F.crossOrigin == null && (F.crossOrigin = z.crossOrigin),
        F.referrerPolicy == null && (F.referrerPolicy = z.referrerPolicy),
        F.integrity == null && (F.integrity = z.integrity);
    }
    var xs = null;
    function Sf(F, z, K) {
      if (xs === null) {
        var W = new Map(),
          ee = (xs = new Map());
        ee.set(K, W);
      } else (ee = xs), (W = ee.get(K)), W || ((W = new Map()), ee.set(K, W));
      if (W.has(F)) return W;
      for (
        W.set(F, null), K = K.getElementsByTagName(F), ee = 0;
        ee < K.length;
        ee++
      ) {
        var ie = K[ee];
        if (
          !(
            ie[Dr] ||
            ie[Wt] ||
            (F === "link" && ie.getAttribute("rel") === "stylesheet")
          ) &&
          ie.namespaceURI !== "http://www.w3.org/2000/svg"
        ) {
          var le = ie.getAttribute(z) || "";
          le = F + le;
          var de = W.get(le);
          de ? de.push(ie) : W.set(le, [ie]);
        }
      }
      return W;
    }
    function Tf(F, z, K) {
      (F = F.ownerDocument || F),
        F.head.insertBefore(
          K,
          z === "title" ? F.querySelector("head > title") : null
        );
    }
    function Mp(F, z, K) {
      if (K === 1 || z.itemProp != null) return !1;
      switch (F) {
        case "meta":
        case "title":
          return !0;
        case "style":
          if (
            typeof z.precedence != "string" ||
            typeof z.href != "string" ||
            z.href === ""
          )
            break;
          return !0;
        case "link":
          if (
            typeof z.rel != "string" ||
            typeof z.href != "string" ||
            z.href === "" ||
            z.onLoad ||
            z.onError
          )
            break;
          switch (z.rel) {
            case "stylesheet":
              return (
                (F = z.disabled), typeof z.precedence == "string" && F == null
              );
            default:
              return !0;
          }
        case "script":
          if (
            z.async &&
            typeof z.async != "function" &&
            typeof z.async != "symbol" &&
            !z.onLoad &&
            !z.onError &&
            z.src &&
            typeof z.src == "string"
          )
            return !0;
      }
      return !1;
    }
    function kf(F) {
      return !(F.type === "stylesheet" && (F.state.loading & 3) === 0);
    }
    var ba = null;
    function Ip() {}
    function Lp(F, z, K) {
      if (ba === null) throw Error(B(475));
      var W = ba;
      if (
        z.type === "stylesheet" &&
        (typeof K.media != "string" || matchMedia(K.media).matches !== !1) &&
        (z.state.loading & 4) === 0
      ) {
        if (z.instance === null) {
          var ee = _r(K.href),
            ie = F.querySelector(va(ee));
          if (ie) {
            (F = ie._p),
              F !== null &&
                typeof F == "object" &&
                typeof F.then == "function" &&
                (W.count++, (W = Rs.bind(W)), F.then(W, W)),
              (z.state.loading |= 4),
              (z.instance = ie),
              zt(ie);
            return;
          }
          (ie = F.ownerDocument || F),
            (K = yf(K)),
            (ee = xn.get(ee)) && Ul(K, ee),
            (ie = ie.createElement("link")),
            zt(ie);
          var le = ie;
          (le._p = new Promise(function (de, ye) {
            (le.onload = de), (le.onerror = ye);
          })),
            Qt(ie, "link", K),
            (z.instance = ie);
        }
        W.stylesheets === null && (W.stylesheets = new Map()),
          W.stylesheets.set(z, F),
          (F = z.state.preload) &&
            (z.state.loading & 3) === 0 &&
            (W.count++,
            (z = Rs.bind(W)),
            F.addEventListener("load", z),
            F.addEventListener("error", z));
      }
    }
    function Np() {
      if (ba === null) throw Error(B(475));
      var F = ba;
      return (
        F.stylesheets && F.count === 0 && Bl(F, F.stylesheets),
        0 < F.count
          ? function (z) {
              var K = setTimeout(function () {
                if ((F.stylesheets && Bl(F, F.stylesheets), F.unsuspend)) {
                  var W = F.unsuspend;
                  (F.unsuspend = null), W();
                }
              }, 6e4);
              return (
                (F.unsuspend = z),
                function () {
                  (F.unsuspend = null), clearTimeout(K);
                }
              );
            }
          : null
      );
    }
    function Rs() {
      if ((this.count--, this.count === 0)) {
        if (this.stylesheets) Bl(this, this.stylesheets);
        else if (this.unsuspend) {
          var F = this.unsuspend;
          (this.unsuspend = null), F();
        }
      }
    }
    var _s = null;
    function Bl(F, z) {
      (F.stylesheets = null),
        F.unsuspend !== null &&
          (F.count++,
          (_s = new Map()),
          z.forEach(jp, F),
          (_s = null),
          Rs.call(F));
    }
    function jp(F, z) {
      if (!(z.state.loading & 4)) {
        var K = _s.get(F);
        if (K) var W = K.get(null);
        else {
          (K = new Map()), _s.set(F, K);
          for (
            var ee = F.querySelectorAll(
                "link[data-precedence],style[data-precedence]"
              ),
              ie = 0;
            ie < ee.length;
            ie++
          ) {
            var le = ee[ie];
            (le.nodeName === "LINK" ||
              le.getAttribute("media") !== "not all") &&
              (K.set(le.dataset.precedence, le), (W = le));
          }
          W && K.set(null, W);
        }
        (ee = z.instance),
          (le = ee.getAttribute("data-precedence")),
          (ie = K.get(le) || W),
          ie === W && K.set(null, ee),
          K.set(le, ee),
          this.count++,
          (W = Rs.bind(this)),
          ee.addEventListener("load", W),
          ee.addEventListener("error", W),
          ie
            ? ie.parentNode.insertBefore(ee, ie.nextSibling)
            : ((F = F.nodeType === 9 ? F.head : F),
              F.insertBefore(ee, F.firstChild)),
          (z.state.loading |= 4);
      }
    }
    var Sa = {
      $$typeof: he,
      Provider: null,
      Consumer: null,
      _currentValue: He,
      _currentValue2: He,
      _threadCount: 0,
    };
    function Up(F, z, K, W, ee, ie, le, de) {
      (this.tag = 1),
        (this.containerInfo = F),
        (this.pingCache = this.current = this.pendingChildren = null),
        (this.timeoutHandle = -1),
        (this.callbackNode =
          this.next =
          this.pendingContext =
          this.context =
          this.cancelPendingCommit =
            null),
        (this.callbackPriority = 0),
        (this.expirationTimes = jt(-1)),
        (this.entangledLanes =
          this.shellSuspendCounter =
          this.errorRecoveryDisabledLanes =
          this.expiredLanes =
          this.warmLanes =
          this.pingedLanes =
          this.suspendedLanes =
          this.pendingLanes =
            0),
        (this.entanglements = jt(0)),
        (this.hiddenUpdates = jt(null)),
        (this.identifierPrefix = W),
        (this.onUncaughtError = ee),
        (this.onCaughtError = ie),
        (this.onRecoverableError = le),
        (this.pooledCache = null),
        (this.pooledCacheLanes = 0),
        (this.formState = de),
        (this.incompleteTransitions = new Map());
    }
    function Cf(F, z, K, W, ee, ie, le, de, ye, we, Ve, $e) {
      return (
        (F = new Up(F, z, K, le, de, ye, we, $e)),
        (z = 1),
        ie === !0 && (z |= 24),
        (ie = un(3, null, null, z)),
        (F.current = ie),
        (ie.stateNode = F),
        (z = To()),
        z.refCount++,
        (F.pooledCache = z),
        z.refCount++,
        (ie.memoizedState = { element: W, isDehydrated: K, cache: z }),
        xo(ie),
        F
      );
    }
    function Ef(F) {
      return F ? ((F = ar), F) : ar;
    }
    function xf(F, z, K, W, ee, ie) {
      (ee = Ef(ee)),
        W.context === null ? (W.context = ee) : (W.pendingContext = ee),
        (W = ni(z)),
        (W.payload = { element: K }),
        (ie = ie === void 0 ? null : ie),
        ie !== null && (W.callback = ie),
        (K = ii(F, W, z)),
        K !== null && (mn(K, F, z), Wr(K, F, z));
    }
    function Rf(F, z) {
      if (((F = F.memoizedState), F !== null && F.dehydrated !== null)) {
        var K = F.retryLane;
        F.retryLane = K !== 0 && K < z ? K : z;
      }
    }
    function Fl(F, z) {
      Rf(F, z), (F = F.alternate) && Rf(F, z);
    }
    function _f(F) {
      if (F.tag === 13) {
        var z = rr(F, 67108864);
        z !== null && mn(z, F, 67108864), Fl(F, 67108864);
      }
    }
    var ws = !0;
    function Vp(F, z, K, W) {
      var ee = Te.T;
      Te.T = null;
      var ie = xe.p;
      try {
        (xe.p = 2), ql(F, z, K, W);
      } finally {
        (xe.p = ie), (Te.T = ee);
      }
    }
    function Bp(F, z, K, W) {
      var ee = Te.T;
      Te.T = null;
      var ie = xe.p;
      try {
        (xe.p = 8), ql(F, z, K, W);
      } finally {
        (xe.p = ie), (Te.T = ee);
      }
    }
    function ql(F, z, K, W) {
      if (ws) {
        var ee = zl(W);
        if (ee === null) Al(F, z, W, As, K), Af(F, W);
        else if (qp(ee, F, z, K, W)) W.stopPropagation();
        else if ((Af(F, W), z & 4 && -1 < Fp.indexOf(F))) {
          for (; ee !== null; ) {
            var ie = Gi(ee);
            if (ie !== null)
              switch (ie.tag) {
                case 3:
                  if (
                    ((ie = ie.stateNode), ie.current.memoizedState.isDehydrated)
                  ) {
                    var le = Ue(ie.pendingLanes);
                    if (le !== 0) {
                      var de = ie;
                      for (de.pendingLanes |= 2, de.entangledLanes |= 2; le; ) {
                        var ye = 1 << (31 - rt(le));
                        (de.entanglements[1] |= ye), (le &= ~ye);
                      }
                      In(ie), (Tt & 6) === 0 && ((fs = At() + 500), ha(0));
                    }
                  }
                  break;
                case 13:
                  (de = rr(ie, 2)),
                    de !== null && mn(de, ie, 2),
                    ps(),
                    Fl(ie, 2);
              }
            if (((ie = zl(W)), ie === null && Al(F, z, W, As, K), ie === ee))
              break;
            ee = ie;
          }
          ee !== null && W.stopPropagation();
        } else Al(F, z, W, null, K);
      }
    }
    function zl(F) {
      return (F = Ks(F)), $l(F);
    }
    var As = null;
    function $l(F) {
      if (((As = null), (F = Hi(F)), F !== null)) {
        var z = $(F);
        if (z === null) F = null;
        else {
          var K = z.tag;
          if (K === 13) {
            if (((F = H(z)), F !== null)) return F;
            F = null;
          } else if (K === 3) {
            if (z.stateNode.current.memoizedState.isDehydrated)
              return z.tag === 3 ? z.stateNode.containerInfo : null;
            F = null;
          } else z !== F && (F = null);
        }
      }
      return (As = F), null;
    }
    function wf(F) {
      switch (F) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (Fi()) {
            case qt:
              return 2;
            case Ti:
              return 8;
            case Xn:
            case Ar:
              return 32;
            case ki:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var Hl = !1,
      gi = null,
      vi = null,
      yi = null,
      Ta = new Map(),
      ka = new Map(),
      bi = [],
      Fp =
        "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
          " "
        );
    function Af(F, z) {
      switch (F) {
        case "focusin":
        case "focusout":
          gi = null;
          break;
        case "dragenter":
        case "dragleave":
          vi = null;
          break;
        case "mouseover":
        case "mouseout":
          yi = null;
          break;
        case "pointerover":
        case "pointerout":
          Ta.delete(z.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          ka.delete(z.pointerId);
      }
    }
    function Ca(F, z, K, W, ee, ie) {
      return F === null || F.nativeEvent !== ie
        ? ((F = {
            blockedOn: z,
            domEventName: K,
            eventSystemFlags: W,
            nativeEvent: ie,
            targetContainers: [ee],
          }),
          z !== null && ((z = Gi(z)), z !== null && _f(z)),
          F)
        : ((F.eventSystemFlags |= W),
          (z = F.targetContainers),
          ee !== null && z.indexOf(ee) === -1 && z.push(ee),
          F);
    }
    function qp(F, z, K, W, ee) {
      switch (z) {
        case "focusin":
          return (gi = Ca(gi, F, z, K, W, ee)), !0;
        case "dragenter":
          return (vi = Ca(vi, F, z, K, W, ee)), !0;
        case "mouseover":
          return (yi = Ca(yi, F, z, K, W, ee)), !0;
        case "pointerover":
          var ie = ee.pointerId;
          return Ta.set(ie, Ca(Ta.get(ie) || null, F, z, K, W, ee)), !0;
        case "gotpointercapture":
          return (
            (ie = ee.pointerId),
            ka.set(ie, Ca(ka.get(ie) || null, F, z, K, W, ee)),
            !0
          );
      }
      return !1;
    }
    function Pf(F) {
      var z = Hi(F.target);
      if (z !== null) {
        var K = $(z);
        if (K !== null) {
          if (((z = K.tag), z === 13)) {
            if (((z = H(K)), z !== null)) {
              (F.blockedOn = z),
                If(F.priority, function () {
                  if (K.tag === 13) {
                    var W = pn();
                    W = Ns(W);
                    var ee = rr(K, W);
                    ee !== null && mn(ee, K, W), Fl(K, W);
                  }
                });
              return;
            }
          } else if (
            z === 3 &&
            K.stateNode.current.memoizedState.isDehydrated
          ) {
            F.blockedOn = K.tag === 3 ? K.stateNode.containerInfo : null;
            return;
          }
        }
      }
      F.blockedOn = null;
    }
    function Ps(F) {
      if (F.blockedOn !== null) return !1;
      for (var z = F.targetContainers; 0 < z.length; ) {
        var K = zl(F.nativeEvent);
        if (K === null) {
          K = F.nativeEvent;
          var W = new K.constructor(K.type, K);
          (Gs = W), K.target.dispatchEvent(W), (Gs = null);
        } else return (z = Gi(K)), z !== null && _f(z), (F.blockedOn = K), !1;
        z.shift();
      }
      return !0;
    }
    function Df(F, z, K) {
      Ps(F) && K.delete(z);
    }
    function zp() {
      (Hl = !1),
        gi !== null && Ps(gi) && (gi = null),
        vi !== null && Ps(vi) && (vi = null),
        yi !== null && Ps(yi) && (yi = null),
        Ta.forEach(Df),
        ka.forEach(Df);
    }
    function Ds(F, z) {
      F.blockedOn === z &&
        ((F.blockedOn = null),
        Hl ||
          ((Hl = !0),
          U.unstable_scheduleCallback(U.unstable_NormalPriority, zp)));
    }
    var Os = null;
    function Of(F) {
      Os !== F &&
        ((Os = F),
        U.unstable_scheduleCallback(U.unstable_NormalPriority, function () {
          Os === F && (Os = null);
          for (var z = 0; z < F.length; z += 3) {
            var K = F[z],
              W = F[z + 1],
              ee = F[z + 2];
            if (typeof W != "function") {
              if ($l(W || K) === null) continue;
              break;
            }
            var ie = Gi(K);
            ie !== null &&
              (F.splice(z, 3),
              (z -= 3),
              $o(
                ie,
                { pending: !0, data: ee, method: K.method, action: W },
                W,
                ee
              ));
          }
        }));
    }
    function Ea(F) {
      function z(ye) {
        return Ds(ye, F);
      }
      gi !== null && Ds(gi, F),
        vi !== null && Ds(vi, F),
        yi !== null && Ds(yi, F),
        Ta.forEach(z),
        ka.forEach(z);
      for (var K = 0; K < bi.length; K++) {
        var W = bi[K];
        W.blockedOn === F && (W.blockedOn = null);
      }
      for (; 0 < bi.length && ((K = bi[0]), K.blockedOn === null); )
        Pf(K), K.blockedOn === null && bi.shift();
      if (((K = (F.ownerDocument || F).$$reactFormReplay), K != null))
        for (W = 0; W < K.length; W += 3) {
          var ee = K[W],
            ie = K[W + 1],
            le = ee[rn] || null;
          if (typeof ie == "function") le || Of(K);
          else if (le) {
            var de = null;
            if (ie && ie.hasAttribute("formAction")) {
              if (((ee = ie), (le = ie[rn] || null))) de = le.formAction;
              else if ($l(ee) !== null) continue;
            } else de = le.action;
            typeof de == "function"
              ? (K[W + 1] = de)
              : (K.splice(W, 3), (W -= 3)),
              Of(K);
          }
        }
    }
    function Gl(F) {
      this._internalRoot = F;
    }
    (Ms.prototype.render = Gl.prototype.render =
      function (F) {
        var z = this._internalRoot;
        if (z === null) throw Error(B(409));
        var K = z.current,
          W = pn();
        xf(K, W, F, z, null, null);
      }),
      (Ms.prototype.unmount = Gl.prototype.unmount =
        function () {
          var F = this._internalRoot;
          if (F !== null) {
            this._internalRoot = null;
            var z = F.containerInfo;
            xf(F.current, 2, null, F, null, null), ps(), (z[$i] = null);
          }
        });
    function Ms(F) {
      this._internalRoot = F;
    }
    Ms.prototype.unstable_scheduleHydration = function (F) {
      if (F) {
        var z = Kl();
        F = { blockedOn: null, target: F, priority: z };
        for (var K = 0; K < bi.length && z !== 0 && z < bi[K].priority; K++);
        bi.splice(K, 0, F), K === 0 && Pf(F);
      }
    };
    var Mf = j.version;
    if (Mf !== "19.1.0") throw Error(B(527, Mf, "19.1.0"));
    xe.findDOMNode = function (F) {
      var z = F._reactInternals;
      if (z === void 0)
        throw typeof F.render == "function"
          ? Error(B(188))
          : ((F = Object.keys(F).join(",")), Error(B(268, F)));
      return (
        (F = Y(z)),
        (F = F !== null ? Q(F) : null),
        (F = F === null ? null : F.stateNode),
        F
      );
    };
    var $p = {
      bundleType: 0,
      version: "19.1.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: Te,
      reconcilerVersion: "19.1.0",
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Is = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Is.isDisabled && Is.supportsFiber)
        try {
          (Ne = Is.inject($p)), (Ke = Is);
        } catch {}
    }
    return (
      (reactDomClient_production.createRoot = function (F, z) {
        if (!q(F)) throw Error(B(299));
        var K = !1,
          W = "",
          ee = Ku,
          ie = Yu,
          le = Qu,
          de = null;
        return (
          z != null &&
            (z.unstable_strictMode === !0 && (K = !0),
            z.identifierPrefix !== void 0 && (W = z.identifierPrefix),
            z.onUncaughtError !== void 0 && (ee = z.onUncaughtError),
            z.onCaughtError !== void 0 && (ie = z.onCaughtError),
            z.onRecoverableError !== void 0 && (le = z.onRecoverableError),
            z.unstable_transitionCallbacks !== void 0 &&
              (de = z.unstable_transitionCallbacks)),
          (z = Cf(F, 1, !1, null, null, K, W, ee, ie, le, de, null)),
          (F[$i] = z.current),
          wl(F),
          new Gl(z)
        );
      }),
      (reactDomClient_production.hydrateRoot = function (F, z, K) {
        if (!q(F)) throw Error(B(299));
        var W = !1,
          ee = "",
          ie = Ku,
          le = Yu,
          de = Qu,
          ye = null,
          we = null;
        return (
          K != null &&
            (K.unstable_strictMode === !0 && (W = !0),
            K.identifierPrefix !== void 0 && (ee = K.identifierPrefix),
            K.onUncaughtError !== void 0 && (ie = K.onUncaughtError),
            K.onCaughtError !== void 0 && (le = K.onCaughtError),
            K.onRecoverableError !== void 0 && (de = K.onRecoverableError),
            K.unstable_transitionCallbacks !== void 0 &&
              (ye = K.unstable_transitionCallbacks),
            K.formState !== void 0 && (we = K.formState)),
          (z = Cf(F, 1, !0, z, K ?? null, W, ee, ie, le, de, ye, we)),
          (z.context = Ef(null)),
          (K = z.current),
          (W = pn()),
          (W = Ns(W)),
          (ee = ni(W)),
          (ee.callback = null),
          ii(K, ee, W),
          (K = W),
          (z.current.lanes = K),
          It(z, K),
          In(z),
          (F[$i] = z.current),
          wl(F),
          new Ms(z)
        );
      }),
      (reactDomClient_production.version = "19.1.0"),
      reactDomClient_production
    );
  }
  var hasRequiredClient;
  function requireClient() {
    if (hasRequiredClient) return client.exports;
    hasRequiredClient = 1;
    function U() {
      if (
        !(
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
          typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
        )
      )
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(U);
        } catch (j) {
          console.error(j);
        }
    }
    return (
      U(), (client.exports = requireReactDomClient_production()), client.exports
    );
  }
  var clientExports = requireClient(),
    reactExports = requireReact();
  const LayoutGroupContext = reactExports.createContext({});
  function useConstant(U) {
    const j = reactExports.useRef(null);
    return j.current === null && (j.current = U()), j.current;
  }
  const isBrowser = typeof window < "u",
    useIsomorphicLayoutEffect = isBrowser
      ? reactExports.useLayoutEffect
      : reactExports.useEffect,
    PresenceContext = reactExports.createContext(null);
  function addUniqueItem(U, j) {
    U.indexOf(j) === -1 && U.push(j);
  }
  function removeItem(U, j) {
    const V = U.indexOf(j);
    V > -1 && U.splice(V, 1);
  }
  const clamp = (U, j, V) => (V > j ? j : V < U ? U : V);
  let invariant = () => {};
  const MotionGlobalConfig = {},
    isNumericalString = (U) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(U);
  function isObject$1(U) {
    return typeof U == "object" && U !== null;
  }
  const isZeroValueString = (U) => /^0[^.\s]+$/u.test(U);
  function memo(U) {
    let j;
    return () => (j === void 0 && (j = U()), j);
  }
  const noop = (U) => U,
    combineFunctions = (U, j) => (V) => j(U(V)),
    pipe = (...U) => U.reduce(combineFunctions),
    progress = (U, j, V) => {
      const B = j - U;
      return B === 0 ? 1 : (V - U) / B;
    };
  class SubscriptionManager {
    constructor() {
      this.subscriptions = [];
    }
    add(j) {
      return (
        addUniqueItem(this.subscriptions, j),
        () => removeItem(this.subscriptions, j)
      );
    }
    notify(j, V, B) {
      const q = this.subscriptions.length;
      if (q)
        if (q === 1) this.subscriptions[0](j, V, B);
        else
          for (let $ = 0; $ < q; $++) {
            const H = this.subscriptions[$];
            H && H(j, V, B);
          }
    }
    getSize() {
      return this.subscriptions.length;
    }
    clear() {
      this.subscriptions.length = 0;
    }
  }
  const secondsToMilliseconds = (U) => U * 1e3,
    millisecondsToSeconds = (U) => U / 1e3;
  function velocityPerSecond(U, j) {
    return j ? U * (1e3 / j) : 0;
  }
  const calcBezier = (U, j, V) =>
      (((1 - 3 * V + 3 * j) * U + (3 * V - 6 * j)) * U + 3 * j) * U,
    subdivisionPrecision = 1e-7,
    subdivisionMaxIterations = 12;
  function binarySubdivide(U, j, V, B, q) {
    let $,
      H,
      G = 0;
    do
      (H = j + (V - j) / 2),
        ($ = calcBezier(H, B, q) - U),
        $ > 0 ? (V = H) : (j = H);
    while (
      Math.abs($) > subdivisionPrecision &&
      ++G < subdivisionMaxIterations
    );
    return H;
  }
  function cubicBezier(U, j, V, B) {
    if (U === j && V === B) return noop;
    const q = ($) => binarySubdivide($, 0, 1, U, V);
    return ($) => ($ === 0 || $ === 1 ? $ : calcBezier(q($), j, B));
  }
  const mirrorEasing = (U) => (j) =>
      j <= 0.5 ? U(2 * j) / 2 : (2 - U(2 * (1 - j))) / 2,
    reverseEasing = (U) => (j) => 1 - U(1 - j),
    backOut = cubicBezier(0.33, 1.53, 0.69, 0.99),
    backIn = reverseEasing(backOut),
    backInOut = mirrorEasing(backIn),
    anticipate = (U) =>
      (U *= 2) < 1 ? 0.5 * backIn(U) : 0.5 * (2 - Math.pow(2, -10 * (U - 1))),
    circIn = (U) => 1 - Math.sin(Math.acos(U)),
    circOut = reverseEasing(circIn),
    circInOut = mirrorEasing(circIn),
    easeIn = cubicBezier(0.42, 0, 1, 1),
    easeOut = cubicBezier(0, 0, 0.58, 1),
    easeInOut = cubicBezier(0.42, 0, 0.58, 1),
    isEasingArray = (U) => Array.isArray(U) && typeof U[0] != "number",
    isBezierDefinition = (U) => Array.isArray(U) && typeof U[0] == "number",
    easingLookup = {
      linear: noop,
      easeIn,
      easeInOut,
      easeOut,
      circIn,
      circInOut,
      circOut,
      backIn,
      backInOut,
      backOut,
      anticipate,
    },
    isValidEasing = (U) => typeof U == "string",
    easingDefinitionToFunction = (U) => {
      if (isBezierDefinition(U)) {
        invariant(U.length === 4);
        const [j, V, B, q] = U;
        return cubicBezier(j, V, B, q);
      } else if (isValidEasing(U)) return easingLookup[U];
      return U;
    },
    stepsOrder = [
      "setup",
      "read",
      "resolveKeyframes",
      "preUpdate",
      "update",
      "preRender",
      "render",
      "postRender",
    ],
    statsBuffer = { value: null };
  function createRenderStep(U, j) {
    let V = new Set(),
      B = new Set(),
      q = !1,
      $ = !1;
    const H = new WeakSet();
    let G = { delta: 0, timestamp: 0, isProcessing: !1 },
      Y = 0;
    function Q(Z) {
      H.has(Z) && (X.schedule(Z), U()), Y++, Z(G);
    }
    const X = {
      schedule: (Z, te = !1, ne = !1) => {
        const se = ne && q ? V : B;
        return te && H.add(Z), se.has(Z) || se.add(Z), Z;
      },
      cancel: (Z) => {
        B.delete(Z), H.delete(Z);
      },
      process: (Z) => {
        if (((G = Z), q)) {
          $ = !0;
          return;
        }
        (q = !0),
          ([V, B] = [B, V]),
          V.forEach(Q),
          j && statsBuffer.value && statsBuffer.value.frameloop[j].push(Y),
          (Y = 0),
          V.clear(),
          (q = !1),
          $ && (($ = !1), X.process(Z));
      },
    };
    return X;
  }
  const maxElapsed = 40;
  function createRenderBatcher(U, j) {
    let V = !1,
      B = !0;
    const q = { delta: 0, timestamp: 0, isProcessing: !1 },
      $ = () => (V = !0),
      H = stepsOrder.reduce(
        (he, me) => ((he[me] = createRenderStep($, j ? me : void 0)), he),
        {}
      ),
      {
        setup: G,
        read: Y,
        resolveKeyframes: Q,
        preUpdate: X,
        update: Z,
        preRender: te,
        render: ne,
        postRender: ae,
      } = H,
      se = () => {
        const he = MotionGlobalConfig.useManualTiming
          ? q.timestamp
          : performance.now();
        (V = !1),
          MotionGlobalConfig.useManualTiming ||
            (q.delta = B
              ? 1e3 / 60
              : Math.max(Math.min(he - q.timestamp, maxElapsed), 1)),
          (q.timestamp = he),
          (q.isProcessing = !0),
          G.process(q),
          Y.process(q),
          Q.process(q),
          X.process(q),
          Z.process(q),
          te.process(q),
          ne.process(q),
          ae.process(q),
          (q.isProcessing = !1),
          V && j && ((B = !1), U(se));
      },
      fe = () => {
        (V = !0), (B = !0), q.isProcessing || U(se);
      };
    return {
      schedule: stepsOrder.reduce((he, me) => {
        const ve = H[me];
        return (
          (he[me] = (ge, Ee = !1, Ce = !1) => (
            V || fe(), ve.schedule(ge, Ee, Ce)
          )),
          he
        );
      }, {}),
      cancel: (he) => {
        for (let me = 0; me < stepsOrder.length; me++)
          H[stepsOrder[me]].cancel(he);
      },
      state: q,
      steps: H,
    };
  }
  const {
    schedule: frame,
    cancel: cancelFrame,
    state: frameData,
    steps: frameSteps,
  } = createRenderBatcher(
    typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop,
    !0
  );
  let now;
  function clearTime() {
    now = void 0;
  }
  const time = {
      now: () => (
        now === void 0 &&
          time.set(
            frameData.isProcessing || MotionGlobalConfig.useManualTiming
              ? frameData.timestamp
              : performance.now()
          ),
        now
      ),
      set: (U) => {
        (now = U), queueMicrotask(clearTime);
      },
    },
    checkStringStartsWith = (U) => (j) =>
      typeof j == "string" && j.startsWith(U),
    isCSSVariableName = checkStringStartsWith("--"),
    startsAsVariableToken = checkStringStartsWith("var(--"),
    isCSSVariableToken = (U) =>
      startsAsVariableToken(U)
        ? singleCssVariableRegex.test(U.split("/*")[0].trim())
        : !1,
    singleCssVariableRegex =
      /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    number$1 = {
      test: (U) => typeof U == "number",
      parse: parseFloat,
      transform: (U) => U,
    },
    alpha = { ...number$1, transform: (U) => clamp(0, 1, U) },
    scale = { ...number$1, default: 1 },
    sanitize = (U) => Math.round(U * 1e5) / 1e5,
    floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
  function isNullish(U) {
    return U == null;
  }
  const singleColorRegex =
      /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    isColorString = (U, j) => (V) =>
      !!(
        (typeof V == "string" && singleColorRegex.test(V) && V.startsWith(U)) ||
        (j && !isNullish(V) && Object.prototype.hasOwnProperty.call(V, j))
      ),
    splitColor = (U, j, V) => (B) => {
      if (typeof B != "string") return B;
      const [q, $, H, G] = B.match(floatRegex);
      return {
        [U]: parseFloat(q),
        [j]: parseFloat($),
        [V]: parseFloat(H),
        alpha: G !== void 0 ? parseFloat(G) : 1,
      };
    },
    clampRgbUnit = (U) => clamp(0, 255, U),
    rgbUnit = { ...number$1, transform: (U) => Math.round(clampRgbUnit(U)) },
    rgba = {
      test: isColorString("rgb", "red"),
      parse: splitColor("red", "green", "blue"),
      transform: ({ red: U, green: j, blue: V, alpha: B = 1 }) =>
        "rgba(" +
        rgbUnit.transform(U) +
        ", " +
        rgbUnit.transform(j) +
        ", " +
        rgbUnit.transform(V) +
        ", " +
        sanitize(alpha.transform(B)) +
        ")",
    };
  function parseHex(U) {
    let j = "",
      V = "",
      B = "",
      q = "";
    return (
      U.length > 5
        ? ((j = U.substring(1, 3)),
          (V = U.substring(3, 5)),
          (B = U.substring(5, 7)),
          (q = U.substring(7, 9)))
        : ((j = U.substring(1, 2)),
          (V = U.substring(2, 3)),
          (B = U.substring(3, 4)),
          (q = U.substring(4, 5)),
          (j += j),
          (V += V),
          (B += B),
          (q += q)),
      {
        red: parseInt(j, 16),
        green: parseInt(V, 16),
        blue: parseInt(B, 16),
        alpha: q ? parseInt(q, 16) / 255 : 1,
      }
    );
  }
  const hex = {
      test: isColorString("#"),
      parse: parseHex,
      transform: rgba.transform,
    },
    createUnitType = (U) => ({
      test: (j) =>
        typeof j == "string" && j.endsWith(U) && j.split(" ").length === 1,
      parse: parseFloat,
      transform: (j) => `${j}${U}`,
    }),
    degrees = createUnitType("deg"),
    percent = createUnitType("%"),
    px = createUnitType("px"),
    vh = createUnitType("vh"),
    vw = createUnitType("vw"),
    progressPercentage = {
      ...percent,
      parse: (U) => percent.parse(U) / 100,
      transform: (U) => percent.transform(U * 100),
    },
    hsla = {
      test: isColorString("hsl", "hue"),
      parse: splitColor("hue", "saturation", "lightness"),
      transform: ({ hue: U, saturation: j, lightness: V, alpha: B = 1 }) =>
        "hsla(" +
        Math.round(U) +
        ", " +
        percent.transform(sanitize(j)) +
        ", " +
        percent.transform(sanitize(V)) +
        ", " +
        sanitize(alpha.transform(B)) +
        ")",
    },
    color$1 = {
      test: (U) => rgba.test(U) || hex.test(U) || hsla.test(U),
      parse: (U) =>
        rgba.test(U)
          ? rgba.parse(U)
          : hsla.test(U)
          ? hsla.parse(U)
          : hex.parse(U),
      transform: (U) =>
        typeof U == "string"
          ? U
          : U.hasOwnProperty("red")
          ? rgba.transform(U)
          : hsla.transform(U),
      getAnimatableNone: (U) => {
        const j = color$1.parse(U);
        return (j.alpha = 0), color$1.transform(j);
      },
    },
    colorRegex =
      /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
  function test(U) {
    return (
      isNaN(U) &&
      typeof U == "string" &&
      (U.match(floatRegex)?.length || 0) + (U.match(colorRegex)?.length || 0) >
        0
    );
  }
  const NUMBER_TOKEN = "number",
    COLOR_TOKEN = "color",
    VAR_TOKEN = "var",
    VAR_FUNCTION_TOKEN = "var(",
    SPLIT_TOKEN = "${}",
    complexRegex =
      /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
  function analyseComplexValue(U) {
    const j = U.toString(),
      V = [],
      B = { color: [], number: [], var: [] },
      q = [];
    let $ = 0;
    const G = j
      .replace(
        complexRegex,
        (Y) => (
          color$1.test(Y)
            ? (B.color.push($), q.push(COLOR_TOKEN), V.push(color$1.parse(Y)))
            : Y.startsWith(VAR_FUNCTION_TOKEN)
            ? (B.var.push($), q.push(VAR_TOKEN), V.push(Y))
            : (B.number.push($), q.push(NUMBER_TOKEN), V.push(parseFloat(Y))),
          ++$,
          SPLIT_TOKEN
        )
      )
      .split(SPLIT_TOKEN);
    return { values: V, split: G, indexes: B, types: q };
  }
  function parseComplexValue(U) {
    return analyseComplexValue(U).values;
  }
  function createTransformer(U) {
    const { split: j, types: V } = analyseComplexValue(U),
      B = j.length;
    return (q) => {
      let $ = "";
      for (let H = 0; H < B; H++)
        if ((($ += j[H]), q[H] !== void 0)) {
          const G = V[H];
          G === NUMBER_TOKEN
            ? ($ += sanitize(q[H]))
            : G === COLOR_TOKEN
            ? ($ += color$1.transform(q[H]))
            : ($ += q[H]);
        }
      return $;
    };
  }
  const convertNumbersToZero = (U) =>
    typeof U == "number"
      ? 0
      : color$1.test(U)
      ? color$1.getAnimatableNone(U)
      : U;
  function getAnimatableNone$1(U) {
    const j = parseComplexValue(U);
    return createTransformer(U)(j.map(convertNumbersToZero));
  }
  const complex = {
    test,
    parse: parseComplexValue,
    createTransformer,
    getAnimatableNone: getAnimatableNone$1,
  };
  function hueToRgb(U, j, V) {
    return (
      V < 0 && (V += 1),
      V > 1 && (V -= 1),
      V < 1 / 6
        ? U + (j - U) * 6 * V
        : V < 1 / 2
        ? j
        : V < 2 / 3
        ? U + (j - U) * (2 / 3 - V) * 6
        : U
    );
  }
  function hslaToRgba({ hue: U, saturation: j, lightness: V, alpha: B }) {
    (U /= 360), (j /= 100), (V /= 100);
    let q = 0,
      $ = 0,
      H = 0;
    if (!j) q = $ = H = V;
    else {
      const G = V < 0.5 ? V * (1 + j) : V + j - V * j,
        Y = 2 * V - G;
      (q = hueToRgb(Y, G, U + 1 / 3)),
        ($ = hueToRgb(Y, G, U)),
        (H = hueToRgb(Y, G, U - 1 / 3));
    }
    return {
      red: Math.round(q * 255),
      green: Math.round($ * 255),
      blue: Math.round(H * 255),
      alpha: B,
    };
  }
  function mixImmediate(U, j) {
    return (V) => (V > 0 ? j : U);
  }
  const mixNumber$1 = (U, j, V) => U + (j - U) * V,
    mixLinearColor = (U, j, V) => {
      const B = U * U,
        q = V * (j * j - B) + B;
      return q < 0 ? 0 : Math.sqrt(q);
    },
    colorTypes = [hex, rgba, hsla],
    getColorType = (U) => colorTypes.find((j) => j.test(U));
  function asRGBA(U) {
    const j = getColorType(U);
    if (!j) return !1;
    let V = j.parse(U);
    return j === hsla && (V = hslaToRgba(V)), V;
  }
  const mixColor = (U, j) => {
      const V = asRGBA(U),
        B = asRGBA(j);
      if (!V || !B) return mixImmediate(U, j);
      const q = { ...V };
      return ($) => (
        (q.red = mixLinearColor(V.red, B.red, $)),
        (q.green = mixLinearColor(V.green, B.green, $)),
        (q.blue = mixLinearColor(V.blue, B.blue, $)),
        (q.alpha = mixNumber$1(V.alpha, B.alpha, $)),
        rgba.transform(q)
      );
    },
    invisibleValues = new Set(["none", "hidden"]);
  function mixVisibility(U, j) {
    return invisibleValues.has(U)
      ? (V) => (V <= 0 ? U : j)
      : (V) => (V >= 1 ? j : U);
  }
  function mixNumber(U, j) {
    return (V) => mixNumber$1(U, j, V);
  }
  function getMixer(U) {
    return typeof U == "number"
      ? mixNumber
      : typeof U == "string"
      ? isCSSVariableToken(U)
        ? mixImmediate
        : color$1.test(U)
        ? mixColor
        : mixComplex
      : Array.isArray(U)
      ? mixArray
      : typeof U == "object"
      ? color$1.test(U)
        ? mixColor
        : mixObject
      : mixImmediate;
  }
  function mixArray(U, j) {
    const V = [...U],
      B = V.length,
      q = U.map(($, H) => getMixer($)($, j[H]));
    return ($) => {
      for (let H = 0; H < B; H++) V[H] = q[H]($);
      return V;
    };
  }
  function mixObject(U, j) {
    const V = { ...U, ...j },
      B = {};
    for (const q in V)
      U[q] !== void 0 && j[q] !== void 0 && (B[q] = getMixer(U[q])(U[q], j[q]));
    return (q) => {
      for (const $ in B) V[$] = B[$](q);
      return V;
    };
  }
  function matchOrder(U, j) {
    const V = [],
      B = { color: 0, var: 0, number: 0 };
    for (let q = 0; q < j.values.length; q++) {
      const $ = j.types[q],
        H = U.indexes[$][B[$]],
        G = U.values[H] ?? 0;
      (V[q] = G), B[$]++;
    }
    return V;
  }
  const mixComplex = (U, j) => {
    const V = complex.createTransformer(j),
      B = analyseComplexValue(U),
      q = analyseComplexValue(j);
    return B.indexes.var.length === q.indexes.var.length &&
      B.indexes.color.length === q.indexes.color.length &&
      B.indexes.number.length >= q.indexes.number.length
      ? (invisibleValues.has(U) && !q.values.length) ||
        (invisibleValues.has(j) && !B.values.length)
        ? mixVisibility(U, j)
        : pipe(mixArray(matchOrder(B, q), q.values), V)
      : mixImmediate(U, j);
  };
  function mix(U, j, V) {
    return typeof U == "number" && typeof j == "number" && typeof V == "number"
      ? mixNumber$1(U, j, V)
      : getMixer(U)(U, j);
  }
  const frameloopDriver = (U) => {
      const j = ({ timestamp: V }) => U(V);
      return {
        start: (V = !0) => frame.update(j, V),
        stop: () => cancelFrame(j),
        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),
      };
    },
    generateLinearEasing = (U, j, V = 10) => {
      let B = "";
      const q = Math.max(Math.round(j / V), 2);
      for (let $ = 0; $ < q; $++)
        B += Math.round(U($ / (q - 1)) * 1e4) / 1e4 + ", ";
      return `linear(${B.substring(0, B.length - 2)})`;
    },
    maxGeneratorDuration = 2e4;
  function calcGeneratorDuration(U) {
    let j = 0;
    const V = 50;
    let B = U.next(j);
    for (; !B.done && j < maxGeneratorDuration; ) (j += V), (B = U.next(j));
    return j >= maxGeneratorDuration ? 1 / 0 : j;
  }
  function createGeneratorEasing(U, j = 100, V) {
    const B = V({ ...U, keyframes: [0, j] }),
      q = Math.min(calcGeneratorDuration(B), maxGeneratorDuration);
    return {
      type: "keyframes",
      ease: ($) => B.next(q * $).value / j,
      duration: millisecondsToSeconds(q),
    };
  }
  const velocitySampleDuration = 5;
  function calcGeneratorVelocity(U, j, V) {
    const B = Math.max(j - velocitySampleDuration, 0);
    return velocityPerSecond(V - U(B), j - B);
  }
  const springDefaults = {
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      duration: 800,
      bounce: 0.3,
      visualDuration: 0.3,
      restSpeed: { granular: 0.01, default: 2 },
      restDelta: { granular: 0.005, default: 0.5 },
      minDuration: 0.01,
      maxDuration: 10,
      minDamping: 0.05,
      maxDamping: 1,
    },
    safeMin = 0.001;
  function findSpring({
    duration: U = springDefaults.duration,
    bounce: j = springDefaults.bounce,
    velocity: V = springDefaults.velocity,
    mass: B = springDefaults.mass,
  }) {
    let q,
      $,
      H = 1 - j;
    (H = clamp(springDefaults.minDamping, springDefaults.maxDamping, H)),
      (U = clamp(
        springDefaults.minDuration,
        springDefaults.maxDuration,
        millisecondsToSeconds(U)
      )),
      H < 1
        ? ((q = (Q) => {
            const X = Q * H,
              Z = X * U,
              te = X - V,
              ne = calcAngularFreq(Q, H),
              ae = Math.exp(-Z);
            return safeMin - (te / ne) * ae;
          }),
          ($ = (Q) => {
            const Z = Q * H * U,
              te = Z * V + V,
              ne = Math.pow(H, 2) * Math.pow(Q, 2) * U,
              ae = Math.exp(-Z),
              se = calcAngularFreq(Math.pow(Q, 2), H);
            return ((-q(Q) + safeMin > 0 ? -1 : 1) * ((te - ne) * ae)) / se;
          }))
        : ((q = (Q) => {
            const X = Math.exp(-Q * U),
              Z = (Q - V) * U + 1;
            return -safeMin + X * Z;
          }),
          ($ = (Q) => {
            const X = Math.exp(-Q * U),
              Z = (V - Q) * (U * U);
            return X * Z;
          }));
    const G = 5 / U,
      Y = approximateRoot(q, $, G);
    if (((U = secondsToMilliseconds(U)), isNaN(Y)))
      return {
        stiffness: springDefaults.stiffness,
        damping: springDefaults.damping,
        duration: U,
      };
    {
      const Q = Math.pow(Y, 2) * B;
      return { stiffness: Q, damping: H * 2 * Math.sqrt(B * Q), duration: U };
    }
  }
  const rootIterations = 12;
  function approximateRoot(U, j, V) {
    let B = V;
    for (let q = 1; q < rootIterations; q++) B = B - U(B) / j(B);
    return B;
  }
  function calcAngularFreq(U, j) {
    return U * Math.sqrt(1 - j * j);
  }
  const durationKeys = ["duration", "bounce"],
    physicsKeys = ["stiffness", "damping", "mass"];
  function isSpringType(U, j) {
    return j.some((V) => U[V] !== void 0);
  }
  function getSpringOptions(U) {
    let j = {
      velocity: springDefaults.velocity,
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      mass: springDefaults.mass,
      isResolvedFromDuration: !1,
      ...U,
    };
    if (!isSpringType(U, physicsKeys) && isSpringType(U, durationKeys))
      if (U.visualDuration) {
        const V = U.visualDuration,
          B = (2 * Math.PI) / (V * 1.2),
          q = B * B,
          $ = 2 * clamp(0.05, 1, 1 - (U.bounce || 0)) * Math.sqrt(q);
        j = { ...j, mass: springDefaults.mass, stiffness: q, damping: $ };
      } else {
        const V = findSpring(U);
        (j = { ...j, ...V, mass: springDefaults.mass }),
          (j.isResolvedFromDuration = !0);
      }
    return j;
  }
  function spring(
    U = springDefaults.visualDuration,
    j = springDefaults.bounce
  ) {
    const V =
      typeof U != "object"
        ? { visualDuration: U, keyframes: [0, 1], bounce: j }
        : U;
    let { restSpeed: B, restDelta: q } = V;
    const $ = V.keyframes[0],
      H = V.keyframes[V.keyframes.length - 1],
      G = { done: !1, value: $ },
      {
        stiffness: Y,
        damping: Q,
        mass: X,
        duration: Z,
        velocity: te,
        isResolvedFromDuration: ne,
      } = getSpringOptions({
        ...V,
        velocity: -millisecondsToSeconds(V.velocity || 0),
      }),
      ae = te || 0,
      se = Q / (2 * Math.sqrt(Y * X)),
      fe = H - $,
      ce = millisecondsToSeconds(Math.sqrt(Y / X)),
      ue = Math.abs(fe) < 5;
    B ||
      (B = ue
        ? springDefaults.restSpeed.granular
        : springDefaults.restSpeed.default),
      q ||
        (q = ue
          ? springDefaults.restDelta.granular
          : springDefaults.restDelta.default);
    let he;
    if (se < 1) {
      const ve = calcAngularFreq(ce, se);
      he = (ge) => {
        const Ee = Math.exp(-se * ce * ge);
        return (
          H -
          Ee *
            (((ae + se * ce * fe) / ve) * Math.sin(ve * ge) +
              fe * Math.cos(ve * ge))
        );
      };
    } else if (se === 1)
      he = (ve) => H - Math.exp(-ce * ve) * (fe + (ae + ce * fe) * ve);
    else {
      const ve = ce * Math.sqrt(se * se - 1);
      he = (ge) => {
        const Ee = Math.exp(-se * ce * ge),
          Ce = Math.min(ve * ge, 300);
        return (
          H -
          (Ee *
            ((ae + se * ce * fe) * Math.sinh(Ce) + ve * fe * Math.cosh(Ce))) /
            ve
        );
      };
    }
    const me = {
      calculatedDuration: (ne && Z) || null,
      next: (ve) => {
        const ge = he(ve);
        if (ne) G.done = ve >= Z;
        else {
          let Ee = ve === 0 ? ae : 0;
          se < 1 &&
            (Ee =
              ve === 0
                ? secondsToMilliseconds(ae)
                : calcGeneratorVelocity(he, ve, ge));
          const Ce = Math.abs(Ee) <= B,
            Re = Math.abs(H - ge) <= q;
          G.done = Ce && Re;
        }
        return (G.value = G.done ? H : ge), G;
      },
      toString: () => {
        const ve = Math.min(calcGeneratorDuration(me), maxGeneratorDuration),
          ge = generateLinearEasing((Ee) => me.next(ve * Ee).value, ve, 30);
        return ve + "ms " + ge;
      },
      toTransition: () => {},
    };
    return me;
  }
  spring.applyToOptions = (U) => {
    const j = createGeneratorEasing(U, 100, spring);
    return (
      (U.ease = j.ease),
      (U.duration = secondsToMilliseconds(j.duration)),
      (U.type = "keyframes"),
      U
    );
  };
  function inertia({
    keyframes: U,
    velocity: j = 0,
    power: V = 0.8,
    timeConstant: B = 325,
    bounceDamping: q = 10,
    bounceStiffness: $ = 500,
    modifyTarget: H,
    min: G,
    max: Y,
    restDelta: Q = 0.5,
    restSpeed: X,
  }) {
    const Z = U[0],
      te = { done: !1, value: Z },
      ne = (Ce) => (G !== void 0 && Ce < G) || (Y !== void 0 && Ce > Y),
      ae = (Ce) =>
        G === void 0
          ? Y
          : Y === void 0 || Math.abs(G - Ce) < Math.abs(Y - Ce)
          ? G
          : Y;
    let se = V * j;
    const fe = Z + se,
      ce = H === void 0 ? fe : H(fe);
    ce !== fe && (se = ce - Z);
    const ue = (Ce) => -se * Math.exp(-Ce / B),
      he = (Ce) => ce + ue(Ce),
      me = (Ce) => {
        const Re = ue(Ce),
          Ae = he(Ce);
        (te.done = Math.abs(Re) <= Q), (te.value = te.done ? ce : Ae);
      };
    let ve, ge;
    const Ee = (Ce) => {
      ne(te.value) &&
        ((ve = Ce),
        (ge = spring({
          keyframes: [te.value, ae(te.value)],
          velocity: calcGeneratorVelocity(he, Ce, te.value),
          damping: q,
          stiffness: $,
          restDelta: Q,
          restSpeed: X,
        })));
    };
    return (
      Ee(0),
      {
        calculatedDuration: null,
        next: (Ce) => {
          let Re = !1;
          return (
            !ge && ve === void 0 && ((Re = !0), me(Ce), Ee(Ce)),
            ve !== void 0 && Ce >= ve ? ge.next(Ce - ve) : (!Re && me(Ce), te)
          );
        },
      }
    );
  }
  function createMixers(U, j, V) {
    const B = [],
      q = V || MotionGlobalConfig.mix || mix,
      $ = U.length - 1;
    for (let H = 0; H < $; H++) {
      let G = q(U[H], U[H + 1]);
      if (j) {
        const Y = Array.isArray(j) ? j[H] || noop : j;
        G = pipe(Y, G);
      }
      B.push(G);
    }
    return B;
  }
  function interpolate(U, j, { clamp: V = !0, ease: B, mixer: q } = {}) {
    const $ = U.length;
    if ((invariant($ === j.length), $ === 1)) return () => j[0];
    if ($ === 2 && j[0] === j[1]) return () => j[1];
    const H = U[0] === U[1];
    U[0] > U[$ - 1] && ((U = [...U].reverse()), (j = [...j].reverse()));
    const G = createMixers(j, B, q),
      Y = G.length,
      Q = (X) => {
        if (H && X < U[0]) return j[0];
        let Z = 0;
        if (Y > 1) for (; Z < U.length - 2 && !(X < U[Z + 1]); Z++);
        const te = progress(U[Z], U[Z + 1], X);
        return G[Z](te);
      };
    return V ? (X) => Q(clamp(U[0], U[$ - 1], X)) : Q;
  }
  function fillOffset(U, j) {
    const V = U[U.length - 1];
    for (let B = 1; B <= j; B++) {
      const q = progress(0, j, B);
      U.push(mixNumber$1(V, 1, q));
    }
  }
  function defaultOffset(U) {
    const j = [0];
    return fillOffset(j, U.length - 1), j;
  }
  function convertOffsetToTimes(U, j) {
    return U.map((V) => V * j);
  }
  function defaultEasing(U, j) {
    return U.map(() => j || easeInOut).splice(0, U.length - 1);
  }
  function keyframes({
    duration: U = 300,
    keyframes: j,
    times: V,
    ease: B = "easeInOut",
  }) {
    const q = isEasingArray(B)
        ? B.map(easingDefinitionToFunction)
        : easingDefinitionToFunction(B),
      $ = { done: !1, value: j[0] },
      H = convertOffsetToTimes(
        V && V.length === j.length ? V : defaultOffset(j),
        U
      ),
      G = interpolate(H, j, {
        ease: Array.isArray(q) ? q : defaultEasing(j, q),
      });
    return {
      calculatedDuration: U,
      next: (Y) => (($.value = G(Y)), ($.done = Y >= U), $),
    };
  }
  const isNotNull$1 = (U) => U !== null;
  function getFinalKeyframe$1(
    U,
    { repeat: j, repeatType: V = "loop" },
    B,
    q = 1
  ) {
    const $ = U.filter(isNotNull$1),
      G = q < 0 || (j && V !== "loop" && j % 2 === 1) ? 0 : $.length - 1;
    return !G || B === void 0 ? $[G] : B;
  }
  const transitionTypeMap = {
    decay: inertia,
    inertia,
    tween: keyframes,
    keyframes,
    spring,
  };
  function replaceTransitionType(U) {
    typeof U.type == "string" && (U.type = transitionTypeMap[U.type]);
  }
  class WithPromise {
    constructor() {
      this.updateFinished();
    }
    get finished() {
      return this._finished;
    }
    updateFinished() {
      this._finished = new Promise((j) => {
        this.resolve = j;
      });
    }
    notifyFinished() {
      this.resolve();
    }
    then(j, V) {
      return this.finished.then(j, V);
    }
  }
  const percentToProgress = (U) => U / 100;
  class JSAnimation extends WithPromise {
    constructor(j) {
      super(),
        (this.state = "idle"),
        (this.startTime = null),
        (this.isStopped = !1),
        (this.currentTime = 0),
        (this.holdTime = null),
        (this.playbackSpeed = 1),
        (this.stop = () => {
          const { motionValue: V } = this.options;
          V && V.updatedAt !== time.now() && this.tick(time.now()),
            (this.isStopped = !0),
            this.state !== "idle" && (this.teardown(), this.options.onStop?.());
        }),
        (this.options = j),
        this.initAnimation(),
        this.play(),
        j.autoplay === !1 && this.pause();
    }
    initAnimation() {
      const { options: j } = this;
      replaceTransitionType(j);
      const {
        type: V = keyframes,
        repeat: B = 0,
        repeatDelay: q = 0,
        repeatType: $,
        velocity: H = 0,
      } = j;
      let { keyframes: G } = j;
      const Y = V || keyframes;
      Y !== keyframes &&
        typeof G[0] != "number" &&
        ((this.mixKeyframes = pipe(percentToProgress, mix(G[0], G[1]))),
        (G = [0, 100]));
      const Q = Y({ ...j, keyframes: G });
      $ === "mirror" &&
        (this.mirroredGenerator = Y({
          ...j,
          keyframes: [...G].reverse(),
          velocity: -H,
        })),
        Q.calculatedDuration === null &&
          (Q.calculatedDuration = calcGeneratorDuration(Q));
      const { calculatedDuration: X } = Q;
      (this.calculatedDuration = X),
        (this.resolvedDuration = X + q),
        (this.totalDuration = this.resolvedDuration * (B + 1) - q),
        (this.generator = Q);
    }
    updateTime(j) {
      const V = Math.round(j - this.startTime) * this.playbackSpeed;
      this.holdTime !== null
        ? (this.currentTime = this.holdTime)
        : (this.currentTime = V);
    }
    tick(j, V = !1) {
      const {
        generator: B,
        totalDuration: q,
        mixKeyframes: $,
        mirroredGenerator: H,
        resolvedDuration: G,
        calculatedDuration: Y,
      } = this;
      if (this.startTime === null) return B.next(0);
      const {
        delay: Q = 0,
        keyframes: X,
        repeat: Z,
        repeatType: te,
        repeatDelay: ne,
        type: ae,
        onUpdate: se,
        finalKeyframe: fe,
      } = this.options;
      this.speed > 0
        ? (this.startTime = Math.min(this.startTime, j))
        : this.speed < 0 &&
          (this.startTime = Math.min(j - q / this.speed, this.startTime)),
        V ? (this.currentTime = j) : this.updateTime(j);
      const ce = this.currentTime - Q * (this.playbackSpeed >= 0 ? 1 : -1),
        ue = this.playbackSpeed >= 0 ? ce < 0 : ce > q;
      (this.currentTime = Math.max(ce, 0)),
        this.state === "finished" &&
          this.holdTime === null &&
          (this.currentTime = q);
      let he = this.currentTime,
        me = B;
      if (Z) {
        const Ce = Math.min(this.currentTime, q) / G;
        let Re = Math.floor(Ce),
          Ae = Ce % 1;
        !Ae && Ce >= 1 && (Ae = 1),
          Ae === 1 && Re--,
          (Re = Math.min(Re, Z + 1)),
          !!(Re % 2) &&
            (te === "reverse"
              ? ((Ae = 1 - Ae), ne && (Ae -= ne / G))
              : te === "mirror" && (me = H)),
          (he = clamp(0, 1, Ae) * G);
      }
      const ve = ue ? { done: !1, value: X[0] } : me.next(he);
      $ && (ve.value = $(ve.value));
      let { done: ge } = ve;
      !ue &&
        Y !== null &&
        (ge =
          this.playbackSpeed >= 0
            ? this.currentTime >= q
            : this.currentTime <= 0);
      const Ee =
        this.holdTime === null &&
        (this.state === "finished" || (this.state === "running" && ge));
      return (
        Ee &&
          ae !== inertia &&
          (ve.value = getFinalKeyframe$1(X, this.options, fe, this.speed)),
        se && se(ve.value),
        Ee && this.finish(),
        ve
      );
    }
    then(j, V) {
      return this.finished.then(j, V);
    }
    get duration() {
      return millisecondsToSeconds(this.calculatedDuration);
    }
    get time() {
      return millisecondsToSeconds(this.currentTime);
    }
    set time(j) {
      (j = secondsToMilliseconds(j)),
        (this.currentTime = j),
        this.startTime === null ||
        this.holdTime !== null ||
        this.playbackSpeed === 0
          ? (this.holdTime = j)
          : this.driver &&
            (this.startTime = this.driver.now() - j / this.playbackSpeed),
        this.driver?.start(!1);
    }
    get speed() {
      return this.playbackSpeed;
    }
    set speed(j) {
      this.updateTime(time.now());
      const V = this.playbackSpeed !== j;
      (this.playbackSpeed = j),
        V && (this.time = millisecondsToSeconds(this.currentTime));
    }
    play() {
      if (this.isStopped) return;
      const { driver: j = frameloopDriver, startTime: V } = this.options;
      this.driver || (this.driver = j((q) => this.tick(q))),
        this.options.onPlay?.();
      const B = this.driver.now();
      this.state === "finished"
        ? (this.updateFinished(), (this.startTime = B))
        : this.holdTime !== null
        ? (this.startTime = B - this.holdTime)
        : this.startTime || (this.startTime = V ?? B),
        this.state === "finished" &&
          this.speed < 0 &&
          (this.startTime += this.calculatedDuration),
        (this.holdTime = null),
        (this.state = "running"),
        this.driver.start();
    }
    pause() {
      (this.state = "paused"),
        this.updateTime(time.now()),
        (this.holdTime = this.currentTime);
    }
    complete() {
      this.state !== "running" && this.play(),
        (this.state = "finished"),
        (this.holdTime = null);
    }
    finish() {
      this.notifyFinished(),
        this.teardown(),
        (this.state = "finished"),
        this.options.onComplete?.();
    }
    cancel() {
      (this.holdTime = null),
        (this.startTime = 0),
        this.tick(0),
        this.teardown(),
        this.options.onCancel?.();
    }
    teardown() {
      (this.state = "idle"),
        this.stopDriver(),
        (this.startTime = this.holdTime = null);
    }
    stopDriver() {
      this.driver && (this.driver.stop(), (this.driver = void 0));
    }
    sample(j) {
      return (this.startTime = 0), this.tick(j, !0);
    }
    attachTimeline(j) {
      return (
        this.options.allowFlatten &&
          ((this.options.type = "keyframes"),
          (this.options.ease = "linear"),
          this.initAnimation()),
        this.driver?.stop(),
        j.observe(this)
      );
    }
  }
  function fillWildcards(U) {
    for (let j = 1; j < U.length; j++) U[j] ?? (U[j] = U[j - 1]);
  }
  const radToDeg = (U) => (U * 180) / Math.PI,
    rotate = (U) => {
      const j = radToDeg(Math.atan2(U[1], U[0]));
      return rebaseAngle(j);
    },
    matrix2dParsers = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: (U) => (Math.abs(U[0]) + Math.abs(U[3])) / 2,
      rotate,
      rotateZ: rotate,
      skewX: (U) => radToDeg(Math.atan(U[1])),
      skewY: (U) => radToDeg(Math.atan(U[2])),
      skew: (U) => (Math.abs(U[1]) + Math.abs(U[2])) / 2,
    },
    rebaseAngle = (U) => ((U = U % 360), U < 0 && (U += 360), U),
    rotateZ = rotate,
    scaleX = (U) => Math.sqrt(U[0] * U[0] + U[1] * U[1]),
    scaleY = (U) => Math.sqrt(U[4] * U[4] + U[5] * U[5]),
    matrix3dParsers = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX,
      scaleY,
      scale: (U) => (scaleX(U) + scaleY(U)) / 2,
      rotateX: (U) => rebaseAngle(radToDeg(Math.atan2(U[6], U[5]))),
      rotateY: (U) => rebaseAngle(radToDeg(Math.atan2(-U[2], U[0]))),
      rotateZ,
      rotate: rotateZ,
      skewX: (U) => radToDeg(Math.atan(U[4])),
      skewY: (U) => radToDeg(Math.atan(U[1])),
      skew: (U) => (Math.abs(U[1]) + Math.abs(U[4])) / 2,
    };
  function defaultTransformValue(U) {
    return U.includes("scale") ? 1 : 0;
  }
  function parseValueFromTransform(U, j) {
    if (!U || U === "none") return defaultTransformValue(j);
    const V = U.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
    let B, q;
    if (V) (B = matrix3dParsers), (q = V);
    else {
      const G = U.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      (B = matrix2dParsers), (q = G);
    }
    if (!q) return defaultTransformValue(j);
    const $ = B[j],
      H = q[1].split(",").map(convertTransformToNumber);
    return typeof $ == "function" ? $(H) : H[$];
  }
  const readTransformValue = (U, j) => {
    const { transform: V = "none" } = getComputedStyle(U);
    return parseValueFromTransform(V, j);
  };
  function convertTransformToNumber(U) {
    return parseFloat(U.trim());
  }
  const transformPropOrder = [
      "transformPerspective",
      "x",
      "y",
      "z",
      "translateX",
      "translateY",
      "translateZ",
      "scale",
      "scaleX",
      "scaleY",
      "rotate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "skew",
      "skewX",
      "skewY",
    ],
    transformProps = new Set(transformPropOrder),
    isNumOrPxType = (U) => U === number$1 || U === px,
    transformKeys = new Set(["x", "y", "z"]),
    nonTranslationalTransformKeys = transformPropOrder.filter(
      (U) => !transformKeys.has(U)
    );
  function removeNonTranslationalTransform(U) {
    const j = [];
    return (
      nonTranslationalTransformKeys.forEach((V) => {
        const B = U.getValue(V);
        B !== void 0 &&
          (j.push([V, B.get()]), B.set(V.startsWith("scale") ? 1 : 0));
      }),
      j
    );
  }
  const positionalValues = {
    width: ({ x: U }, { paddingLeft: j = "0", paddingRight: V = "0" }) =>
      U.max - U.min - parseFloat(j) - parseFloat(V),
    height: ({ y: U }, { paddingTop: j = "0", paddingBottom: V = "0" }) =>
      U.max - U.min - parseFloat(j) - parseFloat(V),
    top: (U, { top: j }) => parseFloat(j),
    left: (U, { left: j }) => parseFloat(j),
    bottom: ({ y: U }, { top: j }) => parseFloat(j) + (U.max - U.min),
    right: ({ x: U }, { left: j }) => parseFloat(j) + (U.max - U.min),
    x: (U, { transform: j }) => parseValueFromTransform(j, "x"),
    y: (U, { transform: j }) => parseValueFromTransform(j, "y"),
  };
  (positionalValues.translateX = positionalValues.x),
    (positionalValues.translateY = positionalValues.y);
  const toResolve = new Set();
  let isScheduled = !1,
    anyNeedsMeasurement = !1,
    isForced = !1;
  function measureAllKeyframes() {
    if (anyNeedsMeasurement) {
      const U = Array.from(toResolve).filter((B) => B.needsMeasurement),
        j = new Set(U.map((B) => B.element)),
        V = new Map();
      j.forEach((B) => {
        const q = removeNonTranslationalTransform(B);
        q.length && (V.set(B, q), B.render());
      }),
        U.forEach((B) => B.measureInitialState()),
        j.forEach((B) => {
          B.render();
          const q = V.get(B);
          q &&
            q.forEach(([$, H]) => {
              B.getValue($)?.set(H);
            });
        }),
        U.forEach((B) => B.measureEndState()),
        U.forEach((B) => {
          B.suspendedScrollY !== void 0 &&
            window.scrollTo(0, B.suspendedScrollY);
        });
    }
    (anyNeedsMeasurement = !1),
      (isScheduled = !1),
      toResolve.forEach((U) => U.complete(isForced)),
      toResolve.clear();
  }
  function readAllKeyframes() {
    toResolve.forEach((U) => {
      U.readKeyframes(), U.needsMeasurement && (anyNeedsMeasurement = !0);
    });
  }
  function flushKeyframeResolvers() {
    (isForced = !0), readAllKeyframes(), measureAllKeyframes(), (isForced = !1);
  }
  class KeyframeResolver {
    constructor(j, V, B, q, $, H = !1) {
      (this.state = "pending"),
        (this.isAsync = !1),
        (this.needsMeasurement = !1),
        (this.unresolvedKeyframes = [...j]),
        (this.onComplete = V),
        (this.name = B),
        (this.motionValue = q),
        (this.element = $),
        (this.isAsync = H);
    }
    scheduleResolve() {
      (this.state = "scheduled"),
        this.isAsync
          ? (toResolve.add(this),
            isScheduled ||
              ((isScheduled = !0),
              frame.read(readAllKeyframes),
              frame.resolveKeyframes(measureAllKeyframes)))
          : (this.readKeyframes(), this.complete());
    }
    readKeyframes() {
      const {
        unresolvedKeyframes: j,
        name: V,
        element: B,
        motionValue: q,
      } = this;
      if (j[0] === null) {
        const $ = q?.get(),
          H = j[j.length - 1];
        if ($ !== void 0) j[0] = $;
        else if (B && V) {
          const G = B.readValue(V, H);
          G != null && (j[0] = G);
        }
        j[0] === void 0 && (j[0] = H), q && $ === void 0 && q.set(j[0]);
      }
      fillWildcards(j);
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete(j = !1) {
      (this.state = "complete"),
        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, j),
        toResolve.delete(this);
    }
    cancel() {
      this.state === "scheduled" &&
        (toResolve.delete(this), (this.state = "pending"));
    }
    resume() {
      this.state === "pending" && this.scheduleResolve();
    }
  }
  const isCSSVar = (U) => U.startsWith("--");
  function setStyle(U, j, V) {
    isCSSVar(j) ? U.style.setProperty(j, V) : (U.style[j] = V);
  }
  const supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0),
    supportsFlags = {};
  function memoSupports(U, j) {
    const V = memo(U);
    return () => supportsFlags[j] ?? V();
  }
  const supportsLinearEasing = memoSupports(() => {
      try {
        document
          .createElement("div")
          .animate({ opacity: 0 }, { easing: "linear(0, 1)" });
      } catch {
        return !1;
      }
      return !0;
    }, "linearEasing"),
    cubicBezierAsString = ([U, j, V, B]) =>
      `cubic-bezier(${U}, ${j}, ${V}, ${B})`,
    supportedWaapiEasing = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
      circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
      backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
      backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),
    };
  function mapEasingToNativeEasing(U, j) {
    if (U)
      return typeof U == "function"
        ? supportsLinearEasing()
          ? generateLinearEasing(U, j)
          : "ease-out"
        : isBezierDefinition(U)
        ? cubicBezierAsString(U)
        : Array.isArray(U)
        ? U.map(
            (V) => mapEasingToNativeEasing(V, j) || supportedWaapiEasing.easeOut
          )
        : supportedWaapiEasing[U];
  }
  function startWaapiAnimation(
    U,
    j,
    V,
    {
      delay: B = 0,
      duration: q = 300,
      repeat: $ = 0,
      repeatType: H = "loop",
      ease: G = "easeOut",
      times: Y,
    } = {},
    Q = void 0
  ) {
    const X = { [j]: V };
    Y && (X.offset = Y);
    const Z = mapEasingToNativeEasing(G, q);
    Array.isArray(Z) && (X.easing = Z);
    const te = {
      delay: B,
      duration: q,
      easing: Array.isArray(Z) ? "linear" : Z,
      fill: "both",
      iterations: $ + 1,
      direction: H === "reverse" ? "alternate" : "normal",
    };
    return Q && (te.pseudoElement = Q), U.animate(X, te);
  }
  function isGenerator(U) {
    return typeof U == "function" && "applyToOptions" in U;
  }
  function applyGeneratorOptions({ type: U, ...j }) {
    return isGenerator(U) && supportsLinearEasing()
      ? U.applyToOptions(j)
      : (j.duration ?? (j.duration = 300), j.ease ?? (j.ease = "easeOut"), j);
  }
  class NativeAnimation extends WithPromise {
    constructor(j) {
      if ((super(), (this.finishedTime = null), (this.isStopped = !1), !j))
        return;
      const {
        element: V,
        name: B,
        keyframes: q,
        pseudoElement: $,
        allowFlatten: H = !1,
        finalKeyframe: G,
        onComplete: Y,
      } = j;
      (this.isPseudoElement = !!$),
        (this.allowFlatten = H),
        (this.options = j),
        invariant(typeof j.type != "string");
      const Q = applyGeneratorOptions(j);
      (this.animation = startWaapiAnimation(V, B, q, Q, $)),
        Q.autoplay === !1 && this.animation.pause(),
        (this.animation.onfinish = () => {
          if (((this.finishedTime = this.time), !$)) {
            const X = getFinalKeyframe$1(q, this.options, G, this.speed);
            this.updateMotionValue
              ? this.updateMotionValue(X)
              : setStyle(V, B, X),
              this.animation.cancel();
          }
          Y?.(), this.notifyFinished();
        });
    }
    play() {
      this.isStopped ||
        (this.animation.play(),
        this.state === "finished" && this.updateFinished());
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.finish?.();
    }
    cancel() {
      try {
        this.animation.cancel();
      } catch {}
    }
    stop() {
      if (this.isStopped) return;
      this.isStopped = !0;
      const { state: j } = this;
      j === "idle" ||
        j === "finished" ||
        (this.updateMotionValue
          ? this.updateMotionValue()
          : this.commitStyles(),
        this.isPseudoElement || this.cancel());
    }
    commitStyles() {
      this.isPseudoElement || this.animation.commitStyles?.();
    }
    get duration() {
      const j = this.animation.effect?.getComputedTiming?.().duration || 0;
      return millisecondsToSeconds(Number(j));
    }
    get time() {
      return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
    }
    set time(j) {
      (this.finishedTime = null),
        (this.animation.currentTime = secondsToMilliseconds(j));
    }
    get speed() {
      return this.animation.playbackRate;
    }
    set speed(j) {
      j < 0 && (this.finishedTime = null), (this.animation.playbackRate = j);
    }
    get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState;
    }
    get startTime() {
      return Number(this.animation.startTime);
    }
    set startTime(j) {
      this.animation.startTime = j;
    }
    attachTimeline({ timeline: j, observe: V }) {
      return (
        this.allowFlatten &&
          this.animation.effect?.updateTiming({ easing: "linear" }),
        (this.animation.onfinish = null),
        j && supportsScrollTimeline()
          ? ((this.animation.timeline = j), noop)
          : V(this)
      );
    }
  }
  const unsupportedEasingFunctions = { anticipate, backInOut, circInOut };
  function isUnsupportedEase(U) {
    return U in unsupportedEasingFunctions;
  }
  function replaceStringEasing(U) {
    typeof U.ease == "string" &&
      isUnsupportedEase(U.ease) &&
      (U.ease = unsupportedEasingFunctions[U.ease]);
  }
  const sampleDelta = 10;
  class NativeAnimationExtended extends NativeAnimation {
    constructor(j) {
      replaceStringEasing(j),
        replaceTransitionType(j),
        super(j),
        j.startTime && (this.startTime = j.startTime),
        (this.options = j);
    }
    updateMotionValue(j) {
      const {
        motionValue: V,
        onUpdate: B,
        onComplete: q,
        element: $,
        ...H
      } = this.options;
      if (!V) return;
      if (j !== void 0) {
        V.set(j);
        return;
      }
      const G = new JSAnimation({ ...H, autoplay: !1 }),
        Y = secondsToMilliseconds(this.finishedTime ?? this.time);
      V.setWithVelocity(
        G.sample(Y - sampleDelta).value,
        G.sample(Y).value,
        sampleDelta
      ),
        G.stop();
    }
  }
  const isAnimatable = (U, j) =>
    j === "zIndex"
      ? !1
      : !!(
          typeof U == "number" ||
          Array.isArray(U) ||
          (typeof U == "string" &&
            (complex.test(U) || U === "0") &&
            !U.startsWith("url("))
        );
  function hasKeyframesChanged(U) {
    const j = U[0];
    if (U.length === 1) return !0;
    for (let V = 0; V < U.length; V++) if (U[V] !== j) return !0;
  }
  function canAnimate(U, j, V, B) {
    const q = U[0];
    if (q === null) return !1;
    if (j === "display" || j === "visibility") return !0;
    const $ = U[U.length - 1],
      H = isAnimatable(q, j),
      G = isAnimatable($, j);
    return !H || !G
      ? !1
      : hasKeyframesChanged(U) || ((V === "spring" || isGenerator(V)) && B);
  }
  function isHTMLElement(U) {
    return isObject$1(U) && "offsetHeight" in U;
  }
  const acceleratedValues = new Set([
      "opacity",
      "clipPath",
      "filter",
      "transform",
    ]),
    supportsWaapi = memo(() =>
      Object.hasOwnProperty.call(Element.prototype, "animate")
    );
  function supportsBrowserAnimation(U) {
    const {
      motionValue: j,
      name: V,
      repeatDelay: B,
      repeatType: q,
      damping: $,
      type: H,
    } = U;
    if (!isHTMLElement(j?.owner?.current)) return !1;
    const { onUpdate: G, transformTemplate: Y } = j.owner.getProps();
    return (
      supportsWaapi() &&
      V &&
      acceleratedValues.has(V) &&
      (V !== "transform" || !Y) &&
      !G &&
      !B &&
      q !== "mirror" &&
      $ !== 0 &&
      H !== "inertia"
    );
  }
  const MAX_RESOLVE_DELAY = 40;
  class AsyncMotionValueAnimation extends WithPromise {
    constructor({
      autoplay: j = !0,
      delay: V = 0,
      type: B = "keyframes",
      repeat: q = 0,
      repeatDelay: $ = 0,
      repeatType: H = "loop",
      keyframes: G,
      name: Y,
      motionValue: Q,
      element: X,
      ...Z
    }) {
      super(),
        (this.stop = () => {
          this._animation && (this._animation.stop(), this.stopTimeline?.()),
            this.keyframeResolver?.cancel();
        }),
        (this.createdAt = time.now());
      const te = {
          autoplay: j,
          delay: V,
          type: B,
          repeat: q,
          repeatDelay: $,
          repeatType: H,
          name: Y,
          motionValue: Q,
          element: X,
          ...Z,
        },
        ne = X?.KeyframeResolver || KeyframeResolver;
      (this.keyframeResolver = new ne(
        G,
        (ae, se, fe) => this.onKeyframesResolved(ae, se, te, !fe),
        Y,
        Q,
        X
      )),
        this.keyframeResolver?.scheduleResolve();
    }
    onKeyframesResolved(j, V, B, q) {
      this.keyframeResolver = void 0;
      const {
        name: $,
        type: H,
        velocity: G,
        delay: Y,
        isHandoff: Q,
        onUpdate: X,
      } = B;
      (this.resolvedAt = time.now()),
        canAnimate(j, $, H, G) ||
          ((MotionGlobalConfig.instantAnimations || !Y) &&
            X?.(getFinalKeyframe$1(j, B, V)),
          (j[0] = j[j.length - 1]),
          (B.duration = 0),
          (B.repeat = 0));
      const te = {
          startTime: q
            ? this.resolvedAt
              ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY
                ? this.resolvedAt
                : this.createdAt
              : this.createdAt
            : void 0,
          finalKeyframe: V,
          ...B,
          keyframes: j,
        },
        ne =
          !Q && supportsBrowserAnimation(te)
            ? new NativeAnimationExtended({
                ...te,
                element: te.motionValue.owner.current,
              })
            : new JSAnimation(te);
      ne.finished.then(() => this.notifyFinished()).catch(noop),
        this.pendingTimeline &&
          ((this.stopTimeline = ne.attachTimeline(this.pendingTimeline)),
          (this.pendingTimeline = void 0)),
        (this._animation = ne);
    }
    get finished() {
      return this._animation ? this.animation.finished : this._finished;
    }
    then(j, V) {
      return this.finished.finally(j).then(() => {});
    }
    get animation() {
      return (
        this._animation ||
          (this.keyframeResolver?.resume(), flushKeyframeResolvers()),
        this._animation
      );
    }
    get duration() {
      return this.animation.duration;
    }
    get time() {
      return this.animation.time;
    }
    set time(j) {
      this.animation.time = j;
    }
    get speed() {
      return this.animation.speed;
    }
    get state() {
      return this.animation.state;
    }
    set speed(j) {
      this.animation.speed = j;
    }
    get startTime() {
      return this.animation.startTime;
    }
    attachTimeline(j) {
      return (
        this._animation
          ? (this.stopTimeline = this.animation.attachTimeline(j))
          : (this.pendingTimeline = j),
        () => this.stop()
      );
    }
    play() {
      this.animation.play();
    }
    pause() {
      this.animation.pause();
    }
    complete() {
      this.animation.complete();
    }
    cancel() {
      this._animation && this.animation.cancel(),
        this.keyframeResolver?.cancel();
    }
  }
  const splitCSSVariableRegex =
    /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
  function parseCSSVariable(U) {
    const j = splitCSSVariableRegex.exec(U);
    if (!j) return [,];
    const [, V, B, q] = j;
    return [`--${V ?? B}`, q];
  }
  function getVariableValue(U, j, V = 1) {
    const [B, q] = parseCSSVariable(U);
    if (!B) return;
    const $ = window.getComputedStyle(j).getPropertyValue(B);
    if ($) {
      const H = $.trim();
      return isNumericalString(H) ? parseFloat(H) : H;
    }
    return isCSSVariableToken(q) ? getVariableValue(q, j, V + 1) : q;
  }
  function getValueTransition(U, j) {
    return U?.[j] ?? U?.default ?? U;
  }
  const positionalKeys = new Set([
      "width",
      "height",
      "top",
      "left",
      "right",
      "bottom",
      ...transformPropOrder,
    ]),
    auto = { test: (U) => U === "auto", parse: (U) => U },
    testValueType = (U) => (j) => j.test(U),
    dimensionValueTypes = [number$1, px, percent, degrees, vw, vh, auto],
    findDimensionValueType = (U) => dimensionValueTypes.find(testValueType(U));
  function isNone(U) {
    return typeof U == "number"
      ? U === 0
      : U !== null
      ? U === "none" || U === "0" || isZeroValueString(U)
      : !0;
  }
  const maxDefaults = new Set([
    "brightness",
    "contrast",
    "saturate",
    "opacity",
  ]);
  function applyDefaultFilter(U) {
    const [j, V] = U.slice(0, -1).split("(");
    if (j === "drop-shadow") return U;
    const [B] = V.match(floatRegex) || [];
    if (!B) return U;
    const q = V.replace(B, "");
    let $ = maxDefaults.has(j) ? 1 : 0;
    return B !== V && ($ *= 100), j + "(" + $ + q + ")";
  }
  const functionRegex = /\b([a-z-]*)\(.*?\)/gu,
    filter = {
      ...complex,
      getAnimatableNone: (U) => {
        const j = U.match(functionRegex);
        return j ? j.map(applyDefaultFilter).join(" ") : U;
      },
    },
    int = { ...number$1, transform: Math.round },
    transformValueTypes = {
      rotate: degrees,
      rotateX: degrees,
      rotateY: degrees,
      rotateZ: degrees,
      scale,
      scaleX: scale,
      scaleY: scale,
      scaleZ: scale,
      skew: degrees,
      skewX: degrees,
      skewY: degrees,
      distance: px,
      translateX: px,
      translateY: px,
      translateZ: px,
      x: px,
      y: px,
      z: px,
      perspective: px,
      transformPerspective: px,
      opacity: alpha,
      originX: progressPercentage,
      originY: progressPercentage,
      originZ: px,
    },
    numberValueTypes = {
      borderWidth: px,
      borderTopWidth: px,
      borderRightWidth: px,
      borderBottomWidth: px,
      borderLeftWidth: px,
      borderRadius: px,
      radius: px,
      borderTopLeftRadius: px,
      borderTopRightRadius: px,
      borderBottomRightRadius: px,
      borderBottomLeftRadius: px,
      width: px,
      maxWidth: px,
      height: px,
      maxHeight: px,
      top: px,
      right: px,
      bottom: px,
      left: px,
      padding: px,
      paddingTop: px,
      paddingRight: px,
      paddingBottom: px,
      paddingLeft: px,
      margin: px,
      marginTop: px,
      marginRight: px,
      marginBottom: px,
      marginLeft: px,
      backgroundPositionX: px,
      backgroundPositionY: px,
      ...transformValueTypes,
      zIndex: int,
      fillOpacity: alpha,
      strokeOpacity: alpha,
      numOctaves: int,
    },
    defaultValueTypes = {
      ...numberValueTypes,
      color: color$1,
      backgroundColor: color$1,
      outlineColor: color$1,
      fill: color$1,
      stroke: color$1,
      borderColor: color$1,
      borderTopColor: color$1,
      borderRightColor: color$1,
      borderBottomColor: color$1,
      borderLeftColor: color$1,
      filter,
      WebkitFilter: filter,
    },
    getDefaultValueType = (U) => defaultValueTypes[U];
  function getAnimatableNone(U, j) {
    let V = getDefaultValueType(U);
    return (
      V !== filter && (V = complex),
      V.getAnimatableNone ? V.getAnimatableNone(j) : void 0
    );
  }
  const invalidTemplates = new Set(["auto", "none", "0"]);
  function makeNoneKeyframesAnimatable(U, j, V) {
    let B = 0,
      q;
    for (; B < U.length && !q; ) {
      const $ = U[B];
      typeof $ == "string" &&
        !invalidTemplates.has($) &&
        analyseComplexValue($).values.length &&
        (q = U[B]),
        B++;
    }
    if (q && V) for (const $ of j) U[$] = getAnimatableNone(V, q);
  }
  class DOMKeyframesResolver extends KeyframeResolver {
    constructor(j, V, B, q, $) {
      super(j, V, B, q, $, !0);
    }
    readKeyframes() {
      const { unresolvedKeyframes: j, element: V, name: B } = this;
      if (!V || !V.current) return;
      super.readKeyframes();
      for (let Y = 0; Y < j.length; Y++) {
        let Q = j[Y];
        if (typeof Q == "string" && ((Q = Q.trim()), isCSSVariableToken(Q))) {
          const X = getVariableValue(Q, V.current);
          X !== void 0 && (j[Y] = X),
            Y === j.length - 1 && (this.finalKeyframe = Q);
        }
      }
      if (
        (this.resolveNoneKeyframes(), !positionalKeys.has(B) || j.length !== 2)
      )
        return;
      const [q, $] = j,
        H = findDimensionValueType(q),
        G = findDimensionValueType($);
      if (H !== G)
        if (isNumOrPxType(H) && isNumOrPxType(G))
          for (let Y = 0; Y < j.length; Y++) {
            const Q = j[Y];
            typeof Q == "string" && (j[Y] = parseFloat(Q));
          }
        else positionalValues[B] && (this.needsMeasurement = !0);
    }
    resolveNoneKeyframes() {
      const { unresolvedKeyframes: j, name: V } = this,
        B = [];
      for (let q = 0; q < j.length; q++)
        (j[q] === null || isNone(j[q])) && B.push(q);
      B.length && makeNoneKeyframesAnimatable(j, B, V);
    }
    measureInitialState() {
      const { element: j, unresolvedKeyframes: V, name: B } = this;
      if (!j || !j.current) return;
      B === "height" && (this.suspendedScrollY = window.pageYOffset),
        (this.measuredOrigin = positionalValues[B](
          j.measureViewportBox(),
          window.getComputedStyle(j.current)
        )),
        (V[0] = this.measuredOrigin);
      const q = V[V.length - 1];
      q !== void 0 && j.getValue(B, q).jump(q, !1);
    }
    measureEndState() {
      const { element: j, name: V, unresolvedKeyframes: B } = this;
      if (!j || !j.current) return;
      const q = j.getValue(V);
      q && q.jump(this.measuredOrigin, !1);
      const $ = B.length - 1,
        H = B[$];
      (B[$] = positionalValues[V](
        j.measureViewportBox(),
        window.getComputedStyle(j.current)
      )),
        H !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = H),
        this.removedTransforms?.length &&
          this.removedTransforms.forEach(([G, Y]) => {
            j.getValue(G).set(Y);
          }),
        this.resolveNoneKeyframes();
    }
  }
  function resolveElements(U, j, V) {
    if (U instanceof EventTarget) return [U];
    if (typeof U == "string") {
      let B = document;
      const q = V?.[U] ?? B.querySelectorAll(U);
      return q ? Array.from(q) : [];
    }
    return Array.from(U);
  }
  const getValueAsType = (U, j) =>
      j && typeof U == "number" ? j.transform(U) : U,
    MAX_VELOCITY_DELTA = 30,
    isFloat = (U) => !isNaN(parseFloat(U));
  class MotionValue {
    constructor(j, V = {}) {
      (this.canTrackVelocity = null),
        (this.events = {}),
        (this.updateAndNotify = (B, q = !0) => {
          const $ = time.now();
          if (
            (this.updatedAt !== $ && this.setPrevFrameValue(),
            (this.prev = this.current),
            this.setCurrent(B),
            this.current !== this.prev &&
              (this.events.change?.notify(this.current), this.dependents))
          )
            for (const H of this.dependents) H.dirty();
          q && this.events.renderRequest?.notify(this.current);
        }),
        (this.hasAnimated = !1),
        this.setCurrent(j),
        (this.owner = V.owner);
    }
    setCurrent(j) {
      (this.current = j),
        (this.updatedAt = time.now()),
        this.canTrackVelocity === null &&
          j !== void 0 &&
          (this.canTrackVelocity = isFloat(this.current));
    }
    setPrevFrameValue(j = this.current) {
      (this.prevFrameValue = j), (this.prevUpdatedAt = this.updatedAt);
    }
    onChange(j) {
      return this.on("change", j);
    }
    on(j, V) {
      this.events[j] || (this.events[j] = new SubscriptionManager());
      const B = this.events[j].add(V);
      return j === "change"
        ? () => {
            B(),
              frame.read(() => {
                this.events.change.getSize() || this.stop();
              });
          }
        : B;
    }
    clearListeners() {
      for (const j in this.events) this.events[j].clear();
    }
    attach(j, V) {
      (this.passiveEffect = j), (this.stopPassiveEffect = V);
    }
    set(j, V = !0) {
      !V || !this.passiveEffect
        ? this.updateAndNotify(j, V)
        : this.passiveEffect(j, this.updateAndNotify);
    }
    setWithVelocity(j, V, B) {
      this.set(V),
        (this.prev = void 0),
        (this.prevFrameValue = j),
        (this.prevUpdatedAt = this.updatedAt - B);
    }
    jump(j, V = !0) {
      this.updateAndNotify(j),
        (this.prev = j),
        (this.prevUpdatedAt = this.prevFrameValue = void 0),
        V && this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect();
    }
    dirty() {
      this.events.change?.notify(this.current);
    }
    addDependent(j) {
      this.dependents || (this.dependents = new Set()), this.dependents.add(j);
    }
    removeDependent(j) {
      this.dependents && this.dependents.delete(j);
    }
    get() {
      return this.current;
    }
    getPrevious() {
      return this.prev;
    }
    getVelocity() {
      const j = time.now();
      if (
        !this.canTrackVelocity ||
        this.prevFrameValue === void 0 ||
        j - this.updatedAt > MAX_VELOCITY_DELTA
      )
        return 0;
      const V = Math.min(
        this.updatedAt - this.prevUpdatedAt,
        MAX_VELOCITY_DELTA
      );
      return velocityPerSecond(
        parseFloat(this.current) - parseFloat(this.prevFrameValue),
        V
      );
    }
    start(j) {
      return (
        this.stop(),
        new Promise((V) => {
          (this.hasAnimated = !0),
            (this.animation = j(V)),
            this.events.animationStart && this.events.animationStart.notify();
        }).then(() => {
          this.events.animationComplete &&
            this.events.animationComplete.notify(),
            this.clearAnimation();
        })
      );
    }
    stop() {
      this.animation &&
        (this.animation.stop(),
        this.events.animationCancel && this.events.animationCancel.notify()),
        this.clearAnimation();
    }
    isAnimating() {
      return !!this.animation;
    }
    clearAnimation() {
      delete this.animation;
    }
    destroy() {
      this.dependents?.clear(),
        this.events.destroy?.notify(),
        this.clearListeners(),
        this.stop(),
        this.stopPassiveEffect && this.stopPassiveEffect();
    }
  }
  function motionValue(U, j) {
    return new MotionValue(U, j);
  }
  const { schedule: microtask } = createRenderBatcher(queueMicrotask, !1),
    isDragging = { x: !1, y: !1 };
  function isDragActive() {
    return isDragging.x || isDragging.y;
  }
  function setDragLock(U) {
    return U === "x" || U === "y"
      ? isDragging[U]
        ? null
        : ((isDragging[U] = !0),
          () => {
            isDragging[U] = !1;
          })
      : isDragging.x || isDragging.y
      ? null
      : ((isDragging.x = isDragging.y = !0),
        () => {
          isDragging.x = isDragging.y = !1;
        });
  }
  function setupGesture(U, j) {
    const V = resolveElements(U),
      B = new AbortController(),
      q = { passive: !0, ...j, signal: B.signal };
    return [V, q, () => B.abort()];
  }
  function isValidHover(U) {
    return !(U.pointerType === "touch" || isDragActive());
  }
  function hover(U, j, V = {}) {
    const [B, q, $] = setupGesture(U, V),
      H = (G) => {
        if (!isValidHover(G)) return;
        const { target: Y } = G,
          Q = j(Y, G);
        if (typeof Q != "function" || !Y) return;
        const X = (Z) => {
          isValidHover(Z) && (Q(Z), Y.removeEventListener("pointerleave", X));
        };
        Y.addEventListener("pointerleave", X, q);
      };
    return (
      B.forEach((G) => {
        G.addEventListener("pointerenter", H, q);
      }),
      $
    );
  }
  const isNodeOrChild = (U, j) =>
      j ? (U === j ? !0 : isNodeOrChild(U, j.parentElement)) : !1,
    isPrimaryPointer = (U) =>
      U.pointerType === "mouse"
        ? typeof U.button != "number" || U.button <= 0
        : U.isPrimary !== !1,
    focusableElements = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
  function isElementKeyboardAccessible(U) {
    return focusableElements.has(U.tagName) || U.tabIndex !== -1;
  }
  const isPressing = new WeakSet();
  function filterEvents(U) {
    return (j) => {
      j.key === "Enter" && U(j);
    };
  }
  function firePointerEvent(U, j) {
    U.dispatchEvent(
      new PointerEvent("pointer" + j, { isPrimary: !0, bubbles: !0 })
    );
  }
  const enableKeyboardPress = (U, j) => {
    const V = U.currentTarget;
    if (!V) return;
    const B = filterEvents(() => {
      if (isPressing.has(V)) return;
      firePointerEvent(V, "down");
      const q = filterEvents(() => {
          firePointerEvent(V, "up");
        }),
        $ = () => firePointerEvent(V, "cancel");
      V.addEventListener("keyup", q, j), V.addEventListener("blur", $, j);
    });
    V.addEventListener("keydown", B, j),
      V.addEventListener("blur", () => V.removeEventListener("keydown", B), j);
  };
  function isValidPressEvent(U) {
    return isPrimaryPointer(U) && !isDragActive();
  }
  function press(U, j, V = {}) {
    const [B, q, $] = setupGesture(U, V),
      H = (G) => {
        const Y = G.currentTarget;
        if (!isValidPressEvent(G)) return;
        isPressing.add(Y);
        const Q = j(Y, G),
          X = (ne, ae) => {
            window.removeEventListener("pointerup", Z),
              window.removeEventListener("pointercancel", te),
              isPressing.has(Y) && isPressing.delete(Y),
              isValidPressEvent(ne) &&
                typeof Q == "function" &&
                Q(ne, { success: ae });
          },
          Z = (ne) => {
            X(
              ne,
              Y === window ||
                Y === document ||
                V.useGlobalTarget ||
                isNodeOrChild(Y, ne.target)
            );
          },
          te = (ne) => {
            X(ne, !1);
          };
        window.addEventListener("pointerup", Z, q),
          window.addEventListener("pointercancel", te, q);
      };
    return (
      B.forEach((G) => {
        (V.useGlobalTarget ? window : G).addEventListener("pointerdown", H, q),
          isHTMLElement(G) &&
            (G.addEventListener("focus", (Q) => enableKeyboardPress(Q, q)),
            !isElementKeyboardAccessible(G) &&
              !G.hasAttribute("tabindex") &&
              (G.tabIndex = 0));
      }),
      $
    );
  }
  function isSVGElement(U) {
    return isObject$1(U) && "ownerSVGElement" in U;
  }
  function isSVGSVGElement(U) {
    return isSVGElement(U) && U.tagName === "svg";
  }
  const isMotionValue = (U) => !!(U && U.getVelocity),
    valueTypes = [...dimensionValueTypes, color$1, complex],
    findValueType = (U) => valueTypes.find(testValueType(U)),
    MotionConfigContext = reactExports.createContext({
      transformPagePoint: (U) => U,
      isStatic: !1,
      reducedMotion: "never",
    });
  class PopChildMeasure extends reactExports.Component {
    getSnapshotBeforeUpdate(j) {
      const V = this.props.childRef.current;
      if (V && j.isPresent && !this.props.isPresent) {
        const B = V.offsetParent,
          q = (isHTMLElement(B) && B.offsetWidth) || 0,
          $ = this.props.sizeRef.current;
        ($.height = V.offsetHeight || 0),
          ($.width = V.offsetWidth || 0),
          ($.top = V.offsetTop),
          ($.left = V.offsetLeft),
          ($.right = q - $.width - $.left);
      }
      return null;
    }
    componentDidUpdate() {}
    render() {
      return this.props.children;
    }
  }
  function PopChild({ children: U, isPresent: j, anchorX: V, root: B }) {
    const q = reactExports.useId(),
      $ = reactExports.useRef(null),
      H = reactExports.useRef({
        width: 0,
        height: 0,
        top: 0,
        left: 0,
        right: 0,
      }),
      { nonce: G } = reactExports.useContext(MotionConfigContext);
    return (
      reactExports.useInsertionEffect(() => {
        const { width: Y, height: Q, top: X, left: Z, right: te } = H.current;
        if (j || !$.current || !Y || !Q) return;
        const ne = V === "left" ? `left: ${Z}` : `right: ${te}`;
        $.current.dataset.motionPopId = q;
        const ae = document.createElement("style");
        G && (ae.nonce = G);
        const se = B ?? document.head;
        return (
          se.appendChild(ae),
          ae.sheet &&
            ae.sheet.insertRule(`
          [data-motion-pop-id="${q}"] {
            position: absolute !important;
            width: ${Y}px !important;
            height: ${Q}px !important;
            ${ne}px !important;
            top: ${X}px !important;
          }
        `),
          () => {
            se.removeChild(ae), se.contains(ae) && se.removeChild(ae);
          }
        );
      }, [j]),
      jsxRuntimeExports.jsx(PopChildMeasure, {
        isPresent: j,
        childRef: $,
        sizeRef: H,
        children: reactExports.cloneElement(U, { ref: $ }),
      })
    );
  }
  const PresenceChild = ({
    children: U,
    initial: j,
    isPresent: V,
    onExitComplete: B,
    custom: q,
    presenceAffectsLayout: $,
    mode: H,
    anchorX: G,
    root: Y,
  }) => {
    const Q = useConstant(newChildrenMap),
      X = reactExports.useId();
    let Z = !0,
      te = reactExports.useMemo(
        () => (
          (Z = !1),
          {
            id: X,
            initial: j,
            isPresent: V,
            custom: q,
            onExitComplete: (ne) => {
              Q.set(ne, !0);
              for (const ae of Q.values()) if (!ae) return;
              B && B();
            },
            register: (ne) => (Q.set(ne, !1), () => Q.delete(ne)),
          }
        ),
        [V, Q, B]
      );
    return (
      $ && Z && (te = { ...te }),
      reactExports.useMemo(() => {
        Q.forEach((ne, ae) => Q.set(ae, !1));
      }, [V]),
      reactExports.useEffect(() => {
        !V && !Q.size && B && B();
      }, [V]),
      H === "popLayout" &&
        (U = jsxRuntimeExports.jsx(PopChild, {
          isPresent: V,
          anchorX: G,
          root: Y,
          children: U,
        })),
      jsxRuntimeExports.jsx(PresenceContext.Provider, {
        value: te,
        children: U,
      })
    );
  };
  function newChildrenMap() {
    return new Map();
  }
  function usePresence(U = !0) {
    const j = reactExports.useContext(PresenceContext);
    if (j === null) return [!0, null];
    const { isPresent: V, onExitComplete: B, register: q } = j,
      $ = reactExports.useId();
    reactExports.useEffect(() => {
      if (U) return q($);
    }, [U]);
    const H = reactExports.useCallback(() => U && B && B($), [$, B, U]);
    return !V && B ? [!1, H] : [!0];
  }
  const getChildKey = (U) => U.key || "";
  function onlyElements(U) {
    const j = [];
    return (
      reactExports.Children.forEach(U, (V) => {
        reactExports.isValidElement(V) && j.push(V);
      }),
      j
    );
  }
  const AnimatePresence = ({
      children: U,
      custom: j,
      initial: V = !0,
      onExitComplete: B,
      presenceAffectsLayout: q = !0,
      mode: $ = "sync",
      propagate: H = !1,
      anchorX: G = "left",
      root: Y,
    }) => {
      const [Q, X] = usePresence(H),
        Z = reactExports.useMemo(() => onlyElements(U), [U]),
        te = H && !Q ? [] : Z.map(getChildKey),
        ne = reactExports.useRef(!0),
        ae = reactExports.useRef(Z),
        se = useConstant(() => new Map()),
        [fe, ce] = reactExports.useState(Z),
        [ue, he] = reactExports.useState(Z);
      useIsomorphicLayoutEffect(() => {
        (ne.current = !1), (ae.current = Z);
        for (let ge = 0; ge < ue.length; ge++) {
          const Ee = getChildKey(ue[ge]);
          te.includes(Ee) ? se.delete(Ee) : se.get(Ee) !== !0 && se.set(Ee, !1);
        }
      }, [ue, te.length, te.join("-")]);
      const me = [];
      if (Z !== fe) {
        let ge = [...Z];
        for (let Ee = 0; Ee < ue.length; Ee++) {
          const Ce = ue[Ee],
            Re = getChildKey(Ce);
          te.includes(Re) || (ge.splice(Ee, 0, Ce), me.push(Ce));
        }
        return (
          $ === "wait" && me.length && (ge = me),
          he(onlyElements(ge)),
          ce(Z),
          null
        );
      }
      const { forceRender: ve } = reactExports.useContext(LayoutGroupContext);
      return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: ue.map((ge) => {
          const Ee = getChildKey(ge),
            Ce = H && !Q ? !1 : Z === ue || te.includes(Ee),
            Re = () => {
              if (se.has(Ee)) se.set(Ee, !0);
              else return;
              let Ae = !0;
              se.forEach((be) => {
                be || (Ae = !1);
              }),
                Ae && (ve?.(), he(ae.current), H && X?.(), B && B());
            };
          return jsxRuntimeExports.jsx(
            PresenceChild,
            {
              isPresent: Ce,
              initial: !ne.current || V ? void 0 : !1,
              custom: j,
              presenceAffectsLayout: q,
              mode: $,
              root: Y,
              onExitComplete: Ce ? void 0 : Re,
              anchorX: G,
              children: ge,
            },
            Ee
          );
        }),
      });
    },
    LazyContext = reactExports.createContext({ strict: !1 }),
    featureProps = {
      animation: [
        "animate",
        "variants",
        "whileHover",
        "whileTap",
        "exit",
        "whileInView",
        "whileFocus",
        "whileDrag",
      ],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"],
    },
    featureDefinitions = {};
  for (const U in featureProps)
    featureDefinitions[U] = {
      isEnabled: (j) => featureProps[U].some((V) => !!j[V]),
    };
  function loadFeatures(U) {
    for (const j in U)
      featureDefinitions[j] = { ...featureDefinitions[j], ...U[j] };
  }
  const validMotionProps = new Set([
    "animate",
    "exit",
    "variants",
    "initial",
    "style",
    "values",
    "variants",
    "transition",
    "transformTemplate",
    "custom",
    "inherit",
    "onBeforeLayoutMeasure",
    "onAnimationStart",
    "onAnimationComplete",
    "onUpdate",
    "onDragStart",
    "onDrag",
    "onDragEnd",
    "onMeasureDragConstraints",
    "onDirectionLock",
    "onDragTransitionEnd",
    "_dragX",
    "_dragY",
    "onHoverStart",
    "onHoverEnd",
    "onViewportEnter",
    "onViewportLeave",
    "globalTapTarget",
    "ignoreStrict",
    "viewport",
  ]);
  function isValidMotionProp(U) {
    return (
      U.startsWith("while") ||
      (U.startsWith("drag") && U !== "draggable") ||
      U.startsWith("layout") ||
      U.startsWith("onTap") ||
      U.startsWith("onPan") ||
      U.startsWith("onLayout") ||
      validMotionProps.has(U)
    );
  }
  let shouldForward = (U) => !isValidMotionProp(U);
  function loadExternalIsValidProp(U) {
    typeof U == "function" &&
      (shouldForward = (j) =>
        j.startsWith("on") ? !isValidMotionProp(j) : U(j));
  }
  try {
    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
  } catch {}
  function filterProps(U, j, V) {
    const B = {};
    for (const q in U)
      (q === "values" && typeof U.values == "object") ||
        ((shouldForward(q) ||
          (V === !0 && isValidMotionProp(q)) ||
          (!j && !isValidMotionProp(q)) ||
          (U.draggable && q.startsWith("onDrag"))) &&
          (B[q] = U[q]));
    return B;
  }
  function createDOMMotionComponentProxy(U) {
    if (typeof Proxy > "u") return U;
    const j = new Map(),
      V = (...B) => U(...B);
    return new Proxy(V, {
      get: (B, q) =>
        q === "create" ? U : (j.has(q) || j.set(q, U(q)), j.get(q)),
    });
  }
  const MotionContext = reactExports.createContext({});
  function isAnimationControls(U) {
    return U !== null && typeof U == "object" && typeof U.start == "function";
  }
  function isVariantLabel(U) {
    return typeof U == "string" || Array.isArray(U);
  }
  const variantPriorityOrder = [
      "animate",
      "whileInView",
      "whileFocus",
      "whileHover",
      "whileTap",
      "whileDrag",
      "exit",
    ],
    variantProps = ["initial", ...variantPriorityOrder];
  function isControllingVariants(U) {
    return (
      isAnimationControls(U.animate) ||
      variantProps.some((j) => isVariantLabel(U[j]))
    );
  }
  function isVariantNode(U) {
    return !!(isControllingVariants(U) || U.variants);
  }
  function getCurrentTreeVariants(U, j) {
    if (isControllingVariants(U)) {
      const { initial: V, animate: B } = U;
      return {
        initial: V === !1 || isVariantLabel(V) ? V : void 0,
        animate: isVariantLabel(B) ? B : void 0,
      };
    }
    return U.inherit !== !1 ? j : {};
  }
  function useCreateMotionContext(U) {
    const { initial: j, animate: V } = getCurrentTreeVariants(
      U,
      reactExports.useContext(MotionContext)
    );
    return reactExports.useMemo(
      () => ({ initial: j, animate: V }),
      [variantLabelsAsDependency(j), variantLabelsAsDependency(V)]
    );
  }
  function variantLabelsAsDependency(U) {
    return Array.isArray(U) ? U.join(" ") : U;
  }
  const motionComponentSymbol = Symbol.for("motionComponentSymbol");
  function isRefObject(U) {
    return (
      U &&
      typeof U == "object" &&
      Object.prototype.hasOwnProperty.call(U, "current")
    );
  }
  function useMotionRef(U, j, V) {
    return reactExports.useCallback(
      (B) => {
        B && U.onMount && U.onMount(B),
          j && (B ? j.mount(B) : j.unmount()),
          V &&
            (typeof V == "function" ? V(B) : isRefObject(V) && (V.current = B));
      },
      [j]
    );
  }
  const camelToDash = (U) =>
      U.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    optimizedAppearDataId = "framerAppearId",
    optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId),
    SwitchLayoutGroupContext = reactExports.createContext({});
  function useVisualElement(U, j, V, B, q) {
    const { visualElement: $ } = reactExports.useContext(MotionContext),
      H = reactExports.useContext(LazyContext),
      G = reactExports.useContext(PresenceContext),
      Y = reactExports.useContext(MotionConfigContext).reducedMotion,
      Q = reactExports.useRef(null);
    (B = B || H.renderer),
      !Q.current &&
        B &&
        (Q.current = B(U, {
          visualState: j,
          parent: $,
          props: V,
          presenceContext: G,
          blockInitialAnimation: G ? G.initial === !1 : !1,
          reducedMotionConfig: Y,
        }));
    const X = Q.current,
      Z = reactExports.useContext(SwitchLayoutGroupContext);
    X &&
      !X.projection &&
      q &&
      (X.type === "html" || X.type === "svg") &&
      createProjectionNode$1(Q.current, V, q, Z);
    const te = reactExports.useRef(!1);
    reactExports.useInsertionEffect(() => {
      X && te.current && X.update(V, G);
    });
    const ne = V[optimizedAppearDataAttribute],
      ae = reactExports.useRef(
        !!ne &&
          !window.MotionHandoffIsComplete?.(ne) &&
          window.MotionHasOptimisedAnimation?.(ne)
      );
    return (
      useIsomorphicLayoutEffect(() => {
        X &&
          ((te.current = !0),
          (window.MotionIsMounted = !0),
          X.updateFeatures(),
          microtask.render(X.render),
          ae.current && X.animationState && X.animationState.animateChanges());
      }),
      reactExports.useEffect(() => {
        X &&
          (!ae.current && X.animationState && X.animationState.animateChanges(),
          ae.current &&
            (queueMicrotask(() => {
              window.MotionHandoffMarkAsComplete?.(ne);
            }),
            (ae.current = !1)));
      }),
      X
    );
  }
  function createProjectionNode$1(U, j, V, B) {
    const {
      layoutId: q,
      layout: $,
      drag: H,
      dragConstraints: G,
      layoutScroll: Y,
      layoutRoot: Q,
      layoutCrossfade: X,
    } = j;
    (U.projection = new V(
      U.latestValues,
      j["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(U.parent)
    )),
      U.projection.setOptions({
        layoutId: q,
        layout: $,
        alwaysMeasureLayout: !!H || (G && isRefObject(G)),
        visualElement: U,
        animationType: typeof $ == "string" ? $ : "both",
        initialPromotionConfig: B,
        crossfade: X,
        layoutScroll: Y,
        layoutRoot: Q,
      });
  }
  function getClosestProjectingNode(U) {
    if (U)
      return U.options.allowProjection !== !1
        ? U.projection
        : getClosestProjectingNode(U.parent);
  }
  function createRendererMotionComponent({
    preloadedFeatures: U,
    createVisualElement: j,
    useRender: V,
    useVisualState: B,
    Component: q,
  }) {
    U && loadFeatures(U);
    function $(G, Y) {
      let Q;
      const X = {
          ...reactExports.useContext(MotionConfigContext),
          ...G,
          layoutId: useLayoutId(G),
        },
        { isStatic: Z } = X,
        te = useCreateMotionContext(G),
        ne = B(G, Z);
      if (!Z && isBrowser) {
        useStrictMode();
        const ae = getProjectionFunctionality(X);
        (Q = ae.MeasureLayout),
          (te.visualElement = useVisualElement(q, ne, X, j, ae.ProjectionNode));
      }
      return jsxRuntimeExports.jsxs(MotionContext.Provider, {
        value: te,
        children: [
          Q && te.visualElement
            ? jsxRuntimeExports.jsx(Q, {
                visualElement: te.visualElement,
                ...X,
              })
            : null,
          V(
            q,
            G,
            useMotionRef(ne, te.visualElement, Y),
            ne,
            Z,
            te.visualElement
          ),
        ],
      });
    }
    $.displayName = `motion.${
      typeof q == "string" ? q : `create(${q.displayName ?? q.name ?? ""})`
    }`;
    const H = reactExports.forwardRef($);
    return (H[motionComponentSymbol] = q), H;
  }
  function useLayoutId({ layoutId: U }) {
    const j = reactExports.useContext(LayoutGroupContext).id;
    return j && U !== void 0 ? j + "-" + U : U;
  }
  function useStrictMode(U, j) {
    reactExports.useContext(LazyContext).strict;
  }
  function getProjectionFunctionality(U) {
    const { drag: j, layout: V } = featureDefinitions;
    if (!j && !V) return {};
    const B = { ...j, ...V };
    return {
      MeasureLayout:
        j?.isEnabled(U) || V?.isEnabled(U) ? B.MeasureLayout : void 0,
      ProjectionNode: B.ProjectionNode,
    };
  }
  const scaleCorrectors = {};
  function addScaleCorrector(U) {
    for (const j in U)
      (scaleCorrectors[j] = U[j]),
        isCSSVariableName(j) && (scaleCorrectors[j].isCSSVariable = !0);
  }
  function isForcedMotionValue(U, { layout: j, layoutId: V }) {
    return (
      transformProps.has(U) ||
      U.startsWith("origin") ||
      ((j || V !== void 0) && (!!scaleCorrectors[U] || U === "opacity"))
    );
  }
  const translateAlias = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective",
    },
    numTransforms = transformPropOrder.length;
  function buildTransform(U, j, V) {
    let B = "",
      q = !0;
    for (let $ = 0; $ < numTransforms; $++) {
      const H = transformPropOrder[$],
        G = U[H];
      if (G === void 0) continue;
      let Y = !0;
      if (
        (typeof G == "number"
          ? (Y = G === (H.startsWith("scale") ? 1 : 0))
          : (Y = parseFloat(G) === 0),
        !Y || V)
      ) {
        const Q = getValueAsType(G, numberValueTypes[H]);
        if (!Y) {
          q = !1;
          const X = translateAlias[H] || H;
          B += `${X}(${Q}) `;
        }
        V && (j[H] = Q);
      }
    }
    return (B = B.trim()), V ? (B = V(j, q ? "" : B)) : q && (B = "none"), B;
  }
  function buildHTMLStyles(U, j, V) {
    const { style: B, vars: q, transformOrigin: $ } = U;
    let H = !1,
      G = !1;
    for (const Y in j) {
      const Q = j[Y];
      if (transformProps.has(Y)) {
        H = !0;
        continue;
      } else if (isCSSVariableName(Y)) {
        q[Y] = Q;
        continue;
      } else {
        const X = getValueAsType(Q, numberValueTypes[Y]);
        Y.startsWith("origin") ? ((G = !0), ($[Y] = X)) : (B[Y] = X);
      }
    }
    if (
      (j.transform ||
        (H || V
          ? (B.transform = buildTransform(j, U.transform, V))
          : B.transform && (B.transform = "none")),
      G)
    ) {
      const { originX: Y = "50%", originY: Q = "50%", originZ: X = 0 } = $;
      B.transformOrigin = `${Y} ${Q} ${X}`;
    }
  }
  const createHtmlRenderState = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {},
  });
  function copyRawValuesOnly(U, j, V) {
    for (const B in j)
      !isMotionValue(j[B]) && !isForcedMotionValue(B, V) && (U[B] = j[B]);
  }
  function useInitialMotionValues({ transformTemplate: U }, j) {
    return reactExports.useMemo(() => {
      const V = createHtmlRenderState();
      return buildHTMLStyles(V, j, U), Object.assign({}, V.vars, V.style);
    }, [j]);
  }
  function useStyle(U, j) {
    const V = U.style || {},
      B = {};
    return (
      copyRawValuesOnly(B, V, U),
      Object.assign(B, useInitialMotionValues(U, j)),
      B
    );
  }
  function useHTMLProps(U, j) {
    const V = {},
      B = useStyle(U, j);
    return (
      U.drag &&
        U.dragListener !== !1 &&
        ((V.draggable = !1),
        (B.userSelect = B.WebkitUserSelect = B.WebkitTouchCallout = "none"),
        (B.touchAction =
          U.drag === !0 ? "none" : `pan-${U.drag === "x" ? "y" : "x"}`)),
      U.tabIndex === void 0 &&
        (U.onTap || U.onTapStart || U.whileTap) &&
        (V.tabIndex = 0),
      (V.style = B),
      V
    );
  }
  const dashKeys = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
    camelKeys = { offset: "strokeDashoffset", array: "strokeDasharray" };
  function buildSVGPath(U, j, V = 1, B = 0, q = !0) {
    U.pathLength = 1;
    const $ = q ? dashKeys : camelKeys;
    U[$.offset] = px.transform(-B);
    const H = px.transform(j),
      G = px.transform(V);
    U[$.array] = `${H} ${G}`;
  }
  function buildSVGAttrs(
    U,
    {
      attrX: j,
      attrY: V,
      attrScale: B,
      pathLength: q,
      pathSpacing: $ = 1,
      pathOffset: H = 0,
      ...G
    },
    Y,
    Q,
    X
  ) {
    if ((buildHTMLStyles(U, G, Q), Y)) {
      U.style.viewBox && (U.attrs.viewBox = U.style.viewBox);
      return;
    }
    (U.attrs = U.style), (U.style = {});
    const { attrs: Z, style: te } = U;
    Z.transform && ((te.transform = Z.transform), delete Z.transform),
      (te.transform || Z.transformOrigin) &&
        ((te.transformOrigin = Z.transformOrigin ?? "50% 50%"),
        delete Z.transformOrigin),
      te.transform &&
        ((te.transformBox = X?.transformBox ?? "fill-box"),
        delete Z.transformBox),
      j !== void 0 && (Z.x = j),
      V !== void 0 && (Z.y = V),
      B !== void 0 && (Z.scale = B),
      q !== void 0 && buildSVGPath(Z, q, $, H, !1);
  }
  const createSvgRenderState = () => ({
      ...createHtmlRenderState(),
      attrs: {},
    }),
    isSVGTag = (U) => typeof U == "string" && U.toLowerCase() === "svg";
  function useSVGProps(U, j, V, B) {
    const q = reactExports.useMemo(() => {
      const $ = createSvgRenderState();
      return (
        buildSVGAttrs($, j, isSVGTag(B), U.transformTemplate, U.style),
        { ...$.attrs, style: { ...$.style } }
      );
    }, [j]);
    if (U.style) {
      const $ = {};
      copyRawValuesOnly($, U.style, U), (q.style = { ...$, ...q.style });
    }
    return q;
  }
  const lowercaseSVGElements = [
    "animate",
    "circle",
    "defs",
    "desc",
    "ellipse",
    "g",
    "image",
    "line",
    "filter",
    "marker",
    "mask",
    "metadata",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "rect",
    "stop",
    "switch",
    "symbol",
    "svg",
    "text",
    "tspan",
    "use",
    "view",
  ];
  function isSVGComponent(U) {
    return typeof U != "string" || U.includes("-")
      ? !1
      : !!(lowercaseSVGElements.indexOf(U) > -1 || /[A-Z]/u.test(U));
  }
  function createUseRender(U = !1) {
    return (V, B, q, { latestValues: $ }, H) => {
      const Y = (isSVGComponent(V) ? useSVGProps : useHTMLProps)(B, $, H, V),
        Q = filterProps(B, typeof V == "string", U),
        X = V !== reactExports.Fragment ? { ...Q, ...Y, ref: q } : {},
        { children: Z } = B,
        te = reactExports.useMemo(() => (isMotionValue(Z) ? Z.get() : Z), [Z]);
      return reactExports.createElement(V, { ...X, children: te });
    };
  }
  function getValueState(U) {
    const j = [{}, {}];
    return (
      U?.values.forEach((V, B) => {
        (j[0][B] = V.get()), (j[1][B] = V.getVelocity());
      }),
      j
    );
  }
  function resolveVariantFromProps(U, j, V, B) {
    if (typeof j == "function") {
      const [q, $] = getValueState(B);
      j = j(V !== void 0 ? V : U.custom, q, $);
    }
    if (
      (typeof j == "string" && (j = U.variants && U.variants[j]),
      typeof j == "function")
    ) {
      const [q, $] = getValueState(B);
      j = j(V !== void 0 ? V : U.custom, q, $);
    }
    return j;
  }
  function resolveMotionValue(U) {
    return isMotionValue(U) ? U.get() : U;
  }
  function makeState(
    { scrapeMotionValuesFromProps: U, createRenderState: j },
    V,
    B,
    q
  ) {
    return { latestValues: makeLatestValues(V, B, q, U), renderState: j() };
  }
  const makeUseVisualState = (U) => (j, V) => {
    const B = reactExports.useContext(MotionContext),
      q = reactExports.useContext(PresenceContext),
      $ = () => makeState(U, j, B, q);
    return V ? $() : useConstant($);
  };
  function makeLatestValues(U, j, V, B) {
    const q = {},
      $ = B(U, {});
    for (const te in $) q[te] = resolveMotionValue($[te]);
    let { initial: H, animate: G } = U;
    const Y = isControllingVariants(U),
      Q = isVariantNode(U);
    j &&
      Q &&
      !Y &&
      U.inherit !== !1 &&
      (H === void 0 && (H = j.initial), G === void 0 && (G = j.animate));
    let X = V ? V.initial === !1 : !1;
    X = X || H === !1;
    const Z = X ? G : H;
    if (Z && typeof Z != "boolean" && !isAnimationControls(Z)) {
      const te = Array.isArray(Z) ? Z : [Z];
      for (let ne = 0; ne < te.length; ne++) {
        const ae = resolveVariantFromProps(U, te[ne]);
        if (ae) {
          const { transitionEnd: se, transition: fe, ...ce } = ae;
          for (const ue in ce) {
            let he = ce[ue];
            if (Array.isArray(he)) {
              const me = X ? he.length - 1 : 0;
              he = he[me];
            }
            he !== null && (q[ue] = he);
          }
          for (const ue in se) q[ue] = se[ue];
        }
      }
    }
    return q;
  }
  function scrapeMotionValuesFromProps$1(U, j, V) {
    const { style: B } = U,
      q = {};
    for (const $ in B)
      (isMotionValue(B[$]) ||
        (j.style && isMotionValue(j.style[$])) ||
        isForcedMotionValue($, U) ||
        V?.getValue($)?.liveStyle !== void 0) &&
        (q[$] = B[$]);
    return q;
  }
  const htmlMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
      createRenderState: createHtmlRenderState,
    }),
  };
  function scrapeMotionValuesFromProps(U, j, V) {
    const B = scrapeMotionValuesFromProps$1(U, j, V);
    for (const q in U)
      if (isMotionValue(U[q]) || isMotionValue(j[q])) {
        const $ =
          transformPropOrder.indexOf(q) !== -1
            ? "attr" + q.charAt(0).toUpperCase() + q.substring(1)
            : q;
        B[$] = U[q];
      }
    return B;
  }
  const svgMotionConfig = {
    useVisualState: makeUseVisualState({
      scrapeMotionValuesFromProps,
      createRenderState: createSvgRenderState,
    }),
  };
  function createMotionComponentFactory(U, j) {
    return function (
      B,
      { forwardMotionProps: q } = { forwardMotionProps: !1 }
    ) {
      const H = {
        ...(isSVGComponent(B) ? svgMotionConfig : htmlMotionConfig),
        preloadedFeatures: U,
        useRender: createUseRender(q),
        createVisualElement: j,
        Component: B,
      };
      return createRendererMotionComponent(H);
    };
  }
  function resolveVariant(U, j, V) {
    const B = U.getProps();
    return resolveVariantFromProps(B, j, V !== void 0 ? V : B.custom, U);
  }
  const isKeyframesTarget = (U) => Array.isArray(U);
  function setMotionValue(U, j, V) {
    U.hasValue(j) ? U.getValue(j).set(V) : U.addValue(j, motionValue(V));
  }
  function resolveFinalValueInKeyframes(U) {
    return isKeyframesTarget(U) ? U[U.length - 1] || 0 : U;
  }
  function setTarget(U, j) {
    const V = resolveVariant(U, j);
    let { transitionEnd: B = {}, transition: q = {}, ...$ } = V || {};
    $ = { ...$, ...B };
    for (const H in $) {
      const G = resolveFinalValueInKeyframes($[H]);
      setMotionValue(U, H, G);
    }
  }
  function isWillChangeMotionValue(U) {
    return !!(isMotionValue(U) && U.add);
  }
  function addValueToWillChange(U, j) {
    const V = U.getValue("willChange");
    if (isWillChangeMotionValue(V)) return V.add(j);
    if (!V && MotionGlobalConfig.WillChange) {
      const B = new MotionGlobalConfig.WillChange("auto");
      U.addValue("willChange", B), B.add(j);
    }
  }
  function getOptimisedAppearId(U) {
    return U.props[optimizedAppearDataAttribute];
  }
  const isNotNull = (U) => U !== null;
  function getFinalKeyframe(U, { repeat: j, repeatType: V = "loop" }, B) {
    const q = U.filter(isNotNull),
      $ = j && V !== "loop" && j % 2 === 1 ? 0 : q.length - 1;
    return q[$];
  }
  const underDampedSpring = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10,
    },
    criticallyDampedSpring = (U) => ({
      type: "spring",
      stiffness: 550,
      damping: U === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10,
    }),
    keyframesTransition = { type: "keyframes", duration: 0.8 },
    ease = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
    getDefaultTransition = (U, { keyframes: j }) =>
      j.length > 2
        ? keyframesTransition
        : transformProps.has(U)
        ? U.startsWith("scale")
          ? criticallyDampedSpring(j[1])
          : underDampedSpring
        : ease;
  function isTransitionDefined({
    when: U,
    delay: j,
    delayChildren: V,
    staggerChildren: B,
    staggerDirection: q,
    repeat: $,
    repeatType: H,
    repeatDelay: G,
    from: Y,
    elapsed: Q,
    ...X
  }) {
    return !!Object.keys(X).length;
  }
  const animateMotionValue =
    (U, j, V, B = {}, q, $) =>
    (H) => {
      const G = getValueTransition(B, U) || {},
        Y = G.delay || B.delay || 0;
      let { elapsed: Q = 0 } = B;
      Q = Q - secondsToMilliseconds(Y);
      const X = {
        keyframes: Array.isArray(V) ? V : [null, V],
        ease: "easeOut",
        velocity: j.getVelocity(),
        ...G,
        delay: -Q,
        onUpdate: (te) => {
          j.set(te), G.onUpdate && G.onUpdate(te);
        },
        onComplete: () => {
          H(), G.onComplete && G.onComplete();
        },
        name: U,
        motionValue: j,
        element: $ ? void 0 : q,
      };
      isTransitionDefined(G) || Object.assign(X, getDefaultTransition(U, X)),
        X.duration && (X.duration = secondsToMilliseconds(X.duration)),
        X.repeatDelay && (X.repeatDelay = secondsToMilliseconds(X.repeatDelay)),
        X.from !== void 0 && (X.keyframes[0] = X.from);
      let Z = !1;
      if (
        ((X.type === !1 || (X.duration === 0 && !X.repeatDelay)) &&
          ((X.duration = 0), X.delay === 0 && (Z = !0)),
        (MotionGlobalConfig.instantAnimations ||
          MotionGlobalConfig.skipAnimations) &&
          ((Z = !0), (X.duration = 0), (X.delay = 0)),
        (X.allowFlatten = !G.type && !G.ease),
        Z && !$ && j.get() !== void 0)
      ) {
        const te = getFinalKeyframe(X.keyframes, G);
        if (te !== void 0) {
          frame.update(() => {
            X.onUpdate(te), X.onComplete();
          });
          return;
        }
      }
      return G.isSync ? new JSAnimation(X) : new AsyncMotionValueAnimation(X);
    };
  function shouldBlockAnimation({ protectedKeys: U, needsAnimating: j }, V) {
    const B = U.hasOwnProperty(V) && j[V] !== !0;
    return (j[V] = !1), B;
  }
  function animateTarget(
    U,
    j,
    { delay: V = 0, transitionOverride: B, type: q } = {}
  ) {
    let {
      transition: $ = U.getDefaultTransition(),
      transitionEnd: H,
      ...G
    } = j;
    B && ($ = B);
    const Y = [],
      Q = q && U.animationState && U.animationState.getState()[q];
    for (const X in G) {
      const Z = U.getValue(X, U.latestValues[X] ?? null),
        te = G[X];
      if (te === void 0 || (Q && shouldBlockAnimation(Q, X))) continue;
      const ne = { delay: V, ...getValueTransition($ || {}, X) },
        ae = Z.get();
      if (
        ae !== void 0 &&
        !Z.isAnimating &&
        !Array.isArray(te) &&
        te === ae &&
        !ne.velocity
      )
        continue;
      let se = !1;
      if (window.MotionHandoffAnimation) {
        const ce = getOptimisedAppearId(U);
        if (ce) {
          const ue = window.MotionHandoffAnimation(ce, X, frame);
          ue !== null && ((ne.startTime = ue), (se = !0));
        }
      }
      addValueToWillChange(U, X),
        Z.start(
          animateMotionValue(
            X,
            Z,
            te,
            U.shouldReduceMotion && positionalKeys.has(X) ? { type: !1 } : ne,
            U,
            se
          )
        );
      const fe = Z.animation;
      fe && Y.push(fe);
    }
    return (
      H &&
        Promise.all(Y).then(() => {
          frame.update(() => {
            H && setTarget(U, H);
          });
        }),
      Y
    );
  }
  function animateVariant(U, j, V = {}) {
    const B = resolveVariant(
      U,
      j,
      V.type === "exit" ? U.presenceContext?.custom : void 0
    );
    let { transition: q = U.getDefaultTransition() || {} } = B || {};
    V.transitionOverride && (q = V.transitionOverride);
    const $ = B
        ? () => Promise.all(animateTarget(U, B, V))
        : () => Promise.resolve(),
      H =
        U.variantChildren && U.variantChildren.size
          ? (Y = 0) => {
              const {
                delayChildren: Q = 0,
                staggerChildren: X,
                staggerDirection: Z,
              } = q;
              return animateChildren(U, j, Y, Q, X, Z, V);
            }
          : () => Promise.resolve(),
      { when: G } = q;
    if (G) {
      const [Y, Q] = G === "beforeChildren" ? [$, H] : [H, $];
      return Y().then(() => Q());
    } else return Promise.all([$(), H(V.delay)]);
  }
  function animateChildren(U, j, V = 0, B = 0, q = 0, $ = 1, H) {
    const G = [],
      Y = U.variantChildren.size,
      Q = (Y - 1) * q,
      X = typeof B == "function",
      Z = X
        ? (te) => B(te, Y)
        : $ === 1
        ? (te = 0) => te * q
        : (te = 0) => Q - te * q;
    return (
      Array.from(U.variantChildren)
        .sort(sortByTreeOrder)
        .forEach((te, ne) => {
          te.notify("AnimationStart", j),
            G.push(
              animateVariant(te, j, {
                ...H,
                delay: V + (X ? 0 : B) + Z(ne),
              }).then(() => te.notify("AnimationComplete", j))
            );
        }),
      Promise.all(G)
    );
  }
  function sortByTreeOrder(U, j) {
    return U.sortNodePosition(j);
  }
  function animateVisualElement(U, j, V = {}) {
    U.notify("AnimationStart", j);
    let B;
    if (Array.isArray(j)) {
      const q = j.map(($) => animateVariant(U, $, V));
      B = Promise.all(q);
    } else if (typeof j == "string") B = animateVariant(U, j, V);
    else {
      const q = typeof j == "function" ? resolveVariant(U, j, V.custom) : j;
      B = Promise.all(animateTarget(U, q, V));
    }
    return B.then(() => {
      U.notify("AnimationComplete", j);
    });
  }
  function shallowCompare(U, j) {
    if (!Array.isArray(j)) return !1;
    const V = j.length;
    if (V !== U.length) return !1;
    for (let B = 0; B < V; B++) if (j[B] !== U[B]) return !1;
    return !0;
  }
  const numVariantProps = variantProps.length;
  function getVariantContext(U) {
    if (!U) return;
    if (!U.isControllingVariants) {
      const V = U.parent ? getVariantContext(U.parent) || {} : {};
      return U.props.initial !== void 0 && (V.initial = U.props.initial), V;
    }
    const j = {};
    for (let V = 0; V < numVariantProps; V++) {
      const B = variantProps[V],
        q = U.props[B];
      (isVariantLabel(q) || q === !1) && (j[B] = q);
    }
    return j;
  }
  const reversePriorityOrder = [...variantPriorityOrder].reverse(),
    numAnimationTypes = variantPriorityOrder.length;
  function animateList(U) {
    return (j) =>
      Promise.all(
        j.map(({ animation: V, options: B }) => animateVisualElement(U, V, B))
      );
  }
  function createAnimationState(U) {
    let j = animateList(U),
      V = createState$1(),
      B = !0;
    const q = (Y) => (Q, X) => {
      const Z = resolveVariant(
        U,
        X,
        Y === "exit" ? U.presenceContext?.custom : void 0
      );
      if (Z) {
        const { transition: te, transitionEnd: ne, ...ae } = Z;
        Q = { ...Q, ...ae, ...ne };
      }
      return Q;
    };
    function $(Y) {
      j = Y(U);
    }
    function H(Y) {
      const { props: Q } = U,
        X = getVariantContext(U.parent) || {},
        Z = [],
        te = new Set();
      let ne = {},
        ae = 1 / 0;
      for (let fe = 0; fe < numAnimationTypes; fe++) {
        const ce = reversePriorityOrder[fe],
          ue = V[ce],
          he = Q[ce] !== void 0 ? Q[ce] : X[ce],
          me = isVariantLabel(he),
          ve = ce === Y ? ue.isActive : null;
        ve === !1 && (ae = fe);
        let ge = he === X[ce] && he !== Q[ce] && me;
        if (
          (ge && B && U.manuallyAnimateOnMount && (ge = !1),
          (ue.protectedKeys = { ...ne }),
          (!ue.isActive && ve === null) ||
            (!he && !ue.prevProp) ||
            isAnimationControls(he) ||
            typeof he == "boolean")
        )
          continue;
        const Ee = checkVariantsDidChange(ue.prevProp, he);
        let Ce =
            Ee || (ce === Y && ue.isActive && !ge && me) || (fe > ae && me),
          Re = !1;
        const Ae = Array.isArray(he) ? he : [he];
        let be = Ae.reduce(q(ce), {});
        ve === !1 && (be = {});
        const { prevResolvedValues: Le = {} } = ue,
          Fe = { ...Le, ...be },
          Me = (xe) => {
            (Ce = !0),
              te.has(xe) && ((Re = !0), te.delete(xe)),
              (ue.needsAnimating[xe] = !0);
            const He = U.getValue(xe);
            He && (He.liveStyle = !1);
          };
        for (const xe in Fe) {
          const He = be[xe],
            Je = Le[xe];
          if (ne.hasOwnProperty(xe)) continue;
          let oe = !1;
          isKeyframesTarget(He) && isKeyframesTarget(Je)
            ? (oe = !shallowCompare(He, Je))
            : (oe = He !== Je),
            oe
              ? He != null
                ? Me(xe)
                : te.add(xe)
              : He !== void 0 && te.has(xe)
              ? Me(xe)
              : (ue.protectedKeys[xe] = !0);
        }
        (ue.prevProp = he),
          (ue.prevResolvedValues = be),
          ue.isActive && (ne = { ...ne, ...be }),
          B && U.blockInitialAnimation && (Ce = !1),
          Ce &&
            (!(ge && Ee) || Re) &&
            Z.push(
              ...Ae.map((xe) => ({ animation: xe, options: { type: ce } }))
            );
      }
      if (te.size) {
        const fe = {};
        if (typeof Q.initial != "boolean") {
          const ce = resolveVariant(
            U,
            Array.isArray(Q.initial) ? Q.initial[0] : Q.initial
          );
          ce && ce.transition && (fe.transition = ce.transition);
        }
        te.forEach((ce) => {
          const ue = U.getBaseTarget(ce),
            he = U.getValue(ce);
          he && (he.liveStyle = !0), (fe[ce] = ue ?? null);
        }),
          Z.push({ animation: fe });
      }
      let se = !!Z.length;
      return (
        B &&
          (Q.initial === !1 || Q.initial === Q.animate) &&
          !U.manuallyAnimateOnMount &&
          (se = !1),
        (B = !1),
        se ? j(Z) : Promise.resolve()
      );
    }
    function G(Y, Q) {
      if (V[Y].isActive === Q) return Promise.resolve();
      U.variantChildren?.forEach((Z) => Z.animationState?.setActive(Y, Q)),
        (V[Y].isActive = Q);
      const X = H(Y);
      for (const Z in V) V[Z].protectedKeys = {};
      return X;
    }
    return {
      animateChanges: H,
      setActive: G,
      setAnimateFunction: $,
      getState: () => V,
      reset: () => {
        (V = createState$1()), (B = !0);
      },
    };
  }
  function checkVariantsDidChange(U, j) {
    return typeof j == "string"
      ? j !== U
      : Array.isArray(j)
      ? !shallowCompare(j, U)
      : !1;
  }
  function createTypeState(U = !1) {
    return {
      isActive: U,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {},
    };
  }
  function createState$1() {
    return {
      animate: createTypeState(!0),
      whileInView: createTypeState(),
      whileHover: createTypeState(),
      whileTap: createTypeState(),
      whileDrag: createTypeState(),
      whileFocus: createTypeState(),
      exit: createTypeState(),
    };
  }
  class Feature {
    constructor(j) {
      (this.isMounted = !1), (this.node = j);
    }
    update() {}
  }
  class AnimationFeature extends Feature {
    constructor(j) {
      super(j),
        j.animationState || (j.animationState = createAnimationState(j));
    }
    updateAnimationControlsSubscription() {
      const { animate: j } = this.node.getProps();
      isAnimationControls(j) && (this.unmountControls = j.subscribe(this.node));
    }
    mount() {
      this.updateAnimationControlsSubscription();
    }
    update() {
      const { animate: j } = this.node.getProps(),
        { animate: V } = this.node.prevProps || {};
      j !== V && this.updateAnimationControlsSubscription();
    }
    unmount() {
      this.node.animationState.reset(), this.unmountControls?.();
    }
  }
  let id$1 = 0;
  class ExitAnimationFeature extends Feature {
    constructor() {
      super(...arguments), (this.id = id$1++);
    }
    update() {
      if (!this.node.presenceContext) return;
      const { isPresent: j, onExitComplete: V } = this.node.presenceContext,
        { isPresent: B } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || j === B) return;
      const q = this.node.animationState.setActive("exit", !j);
      V &&
        !j &&
        q.then(() => {
          V(this.id);
        });
    }
    mount() {
      const { register: j, onExitComplete: V } =
        this.node.presenceContext || {};
      V && V(this.id), j && (this.unmount = j(this.id));
    }
    unmount() {}
  }
  const animations = {
    animation: { Feature: AnimationFeature },
    exit: { Feature: ExitAnimationFeature },
  };
  function addDomEvent(U, j, V, B = { passive: !0 }) {
    return U.addEventListener(j, V, B), () => U.removeEventListener(j, V);
  }
  function extractEventInfo(U) {
    return { point: { x: U.pageX, y: U.pageY } };
  }
  const addPointerInfo = (U) => (j) =>
    isPrimaryPointer(j) && U(j, extractEventInfo(j));
  function addPointerEvent(U, j, V, B) {
    return addDomEvent(U, j, addPointerInfo(V), B);
  }
  function convertBoundingBoxToBox({ top: U, left: j, right: V, bottom: B }) {
    return { x: { min: j, max: V }, y: { min: U, max: B } };
  }
  function convertBoxToBoundingBox({ x: U, y: j }) {
    return { top: j.min, right: U.max, bottom: j.max, left: U.min };
  }
  function transformBoxPoints(U, j) {
    if (!j) return U;
    const V = j({ x: U.left, y: U.top }),
      B = j({ x: U.right, y: U.bottom });
    return { top: V.y, left: V.x, bottom: B.y, right: B.x };
  }
  const SCALE_PRECISION = 1e-4,
    SCALE_MIN = 1 - SCALE_PRECISION,
    SCALE_MAX = 1 + SCALE_PRECISION,
    TRANSLATE_PRECISION = 0.01,
    TRANSLATE_MIN = 0 - TRANSLATE_PRECISION,
    TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
  function calcLength(U) {
    return U.max - U.min;
  }
  function isNear(U, j, V) {
    return Math.abs(U - j) <= V;
  }
  function calcAxisDelta(U, j, V, B = 0.5) {
    (U.origin = B),
      (U.originPoint = mixNumber$1(j.min, j.max, U.origin)),
      (U.scale = calcLength(V) / calcLength(j)),
      (U.translate = mixNumber$1(V.min, V.max, U.origin) - U.originPoint),
      ((U.scale >= SCALE_MIN && U.scale <= SCALE_MAX) || isNaN(U.scale)) &&
        (U.scale = 1),
      ((U.translate >= TRANSLATE_MIN && U.translate <= TRANSLATE_MAX) ||
        isNaN(U.translate)) &&
        (U.translate = 0);
  }
  function calcBoxDelta(U, j, V, B) {
    calcAxisDelta(U.x, j.x, V.x, B ? B.originX : void 0),
      calcAxisDelta(U.y, j.y, V.y, B ? B.originY : void 0);
  }
  function calcRelativeAxis(U, j, V) {
    (U.min = V.min + j.min), (U.max = U.min + calcLength(j));
  }
  function calcRelativeBox(U, j, V) {
    calcRelativeAxis(U.x, j.x, V.x), calcRelativeAxis(U.y, j.y, V.y);
  }
  function calcRelativeAxisPosition(U, j, V) {
    (U.min = j.min - V.min), (U.max = U.min + calcLength(j));
  }
  function calcRelativePosition(U, j, V) {
    calcRelativeAxisPosition(U.x, j.x, V.x),
      calcRelativeAxisPosition(U.y, j.y, V.y);
  }
  const createAxisDelta = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0,
    }),
    createDelta = () => ({ x: createAxisDelta(), y: createAxisDelta() }),
    createAxis = () => ({ min: 0, max: 0 }),
    createBox = () => ({ x: createAxis(), y: createAxis() });
  function eachAxis(U) {
    return [U("x"), U("y")];
  }
  function isIdentityScale(U) {
    return U === void 0 || U === 1;
  }
  function hasScale({ scale: U, scaleX: j, scaleY: V }) {
    return !isIdentityScale(U) || !isIdentityScale(j) || !isIdentityScale(V);
  }
  function hasTransform(U) {
    return (
      hasScale(U) ||
      has2DTranslate(U) ||
      U.z ||
      U.rotate ||
      U.rotateX ||
      U.rotateY ||
      U.skewX ||
      U.skewY
    );
  }
  function has2DTranslate(U) {
    return is2DTranslate(U.x) || is2DTranslate(U.y);
  }
  function is2DTranslate(U) {
    return U && U !== "0%";
  }
  function scalePoint(U, j, V) {
    const B = U - V,
      q = j * B;
    return V + q;
  }
  function applyPointDelta(U, j, V, B, q) {
    return q !== void 0 && (U = scalePoint(U, q, B)), scalePoint(U, V, B) + j;
  }
  function applyAxisDelta(U, j = 0, V = 1, B, q) {
    (U.min = applyPointDelta(U.min, j, V, B, q)),
      (U.max = applyPointDelta(U.max, j, V, B, q));
  }
  function applyBoxDelta(U, { x: j, y: V }) {
    applyAxisDelta(U.x, j.translate, j.scale, j.originPoint),
      applyAxisDelta(U.y, V.translate, V.scale, V.originPoint);
  }
  const TREE_SCALE_SNAP_MIN = 0.999999999999,
    TREE_SCALE_SNAP_MAX = 1.0000000000001;
  function applyTreeDeltas(U, j, V, B = !1) {
    const q = V.length;
    if (!q) return;
    j.x = j.y = 1;
    let $, H;
    for (let G = 0; G < q; G++) {
      ($ = V[G]), (H = $.projectionDelta);
      const { visualElement: Y } = $.options;
      (Y && Y.props.style && Y.props.style.display === "contents") ||
        (B &&
          $.options.layoutScroll &&
          $.scroll &&
          $ !== $.root &&
          transformBox(U, { x: -$.scroll.offset.x, y: -$.scroll.offset.y }),
        H && ((j.x *= H.x.scale), (j.y *= H.y.scale), applyBoxDelta(U, H)),
        B && hasTransform($.latestValues) && transformBox(U, $.latestValues));
    }
    j.x < TREE_SCALE_SNAP_MAX && j.x > TREE_SCALE_SNAP_MIN && (j.x = 1),
      j.y < TREE_SCALE_SNAP_MAX && j.y > TREE_SCALE_SNAP_MIN && (j.y = 1);
  }
  function translateAxis(U, j) {
    (U.min = U.min + j), (U.max = U.max + j);
  }
  function transformAxis(U, j, V, B, q = 0.5) {
    const $ = mixNumber$1(U.min, U.max, q);
    applyAxisDelta(U, j, V, $, B);
  }
  function transformBox(U, j) {
    transformAxis(U.x, j.x, j.scaleX, j.scale, j.originX),
      transformAxis(U.y, j.y, j.scaleY, j.scale, j.originY);
  }
  function measureViewportBox(U, j) {
    return convertBoundingBoxToBox(
      transformBoxPoints(U.getBoundingClientRect(), j)
    );
  }
  function measurePageBox(U, j, V) {
    const B = measureViewportBox(U, V),
      { scroll: q } = j;
    return (
      q && (translateAxis(B.x, q.offset.x), translateAxis(B.y, q.offset.y)), B
    );
  }
  const getContextWindow = ({ current: U }) =>
      U ? U.ownerDocument.defaultView : null,
    distance = (U, j) => Math.abs(U - j);
  function distance2D(U, j) {
    const V = distance(U.x, j.x),
      B = distance(U.y, j.y);
    return Math.sqrt(V ** 2 + B ** 2);
  }
  class PanSession {
    constructor(
      j,
      V,
      {
        transformPagePoint: B,
        contextWindow: q = window,
        dragSnapToOrigin: $ = !1,
        distanceThreshold: H = 3,
      } = {}
    ) {
      if (
        ((this.startEvent = null),
        (this.lastMoveEvent = null),
        (this.lastMoveEventInfo = null),
        (this.handlers = {}),
        (this.contextWindow = window),
        (this.updatePoint = () => {
          if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
          const te = getPanInfo(this.lastMoveEventInfo, this.history),
            ne = this.startEvent !== null,
            ae =
              distance2D(te.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
          if (!ne && !ae) return;
          const { point: se } = te,
            { timestamp: fe } = frameData;
          this.history.push({ ...se, timestamp: fe });
          const { onStart: ce, onMove: ue } = this.handlers;
          ne ||
            (ce && ce(this.lastMoveEvent, te),
            (this.startEvent = this.lastMoveEvent)),
            ue && ue(this.lastMoveEvent, te);
        }),
        (this.handlePointerMove = (te, ne) => {
          (this.lastMoveEvent = te),
            (this.lastMoveEventInfo = transformPoint(
              ne,
              this.transformPagePoint
            )),
            frame.update(this.updatePoint, !0);
        }),
        (this.handlePointerUp = (te, ne) => {
          this.end();
          const {
            onEnd: ae,
            onSessionEnd: se,
            resumeAnimation: fe,
          } = this.handlers;
          if (
            (this.dragSnapToOrigin && fe && fe(),
            !(this.lastMoveEvent && this.lastMoveEventInfo))
          )
            return;
          const ce = getPanInfo(
            te.type === "pointercancel"
              ? this.lastMoveEventInfo
              : transformPoint(ne, this.transformPagePoint),
            this.history
          );
          this.startEvent && ae && ae(te, ce), se && se(te, ce);
        }),
        !isPrimaryPointer(j))
      )
        return;
      (this.dragSnapToOrigin = $),
        (this.handlers = V),
        (this.transformPagePoint = B),
        (this.distanceThreshold = H),
        (this.contextWindow = q || window);
      const G = extractEventInfo(j),
        Y = transformPoint(G, this.transformPagePoint),
        { point: Q } = Y,
        { timestamp: X } = frameData;
      this.history = [{ ...Q, timestamp: X }];
      const { onSessionStart: Z } = V;
      Z && Z(j, getPanInfo(Y, this.history)),
        (this.removeListeners = pipe(
          addPointerEvent(
            this.contextWindow,
            "pointermove",
            this.handlePointerMove
          ),
          addPointerEvent(
            this.contextWindow,
            "pointerup",
            this.handlePointerUp
          ),
          addPointerEvent(
            this.contextWindow,
            "pointercancel",
            this.handlePointerUp
          )
        ));
    }
    updateHandlers(j) {
      this.handlers = j;
    }
    end() {
      this.removeListeners && this.removeListeners(),
        cancelFrame(this.updatePoint);
    }
  }
  function transformPoint(U, j) {
    return j ? { point: j(U.point) } : U;
  }
  function subtractPoint(U, j) {
    return { x: U.x - j.x, y: U.y - j.y };
  }
  function getPanInfo({ point: U }, j) {
    return {
      point: U,
      delta: subtractPoint(U, lastDevicePoint(j)),
      offset: subtractPoint(U, startDevicePoint(j)),
      velocity: getVelocity(j, 0.1),
    };
  }
  function startDevicePoint(U) {
    return U[0];
  }
  function lastDevicePoint(U) {
    return U[U.length - 1];
  }
  function getVelocity(U, j) {
    if (U.length < 2) return { x: 0, y: 0 };
    let V = U.length - 1,
      B = null;
    const q = lastDevicePoint(U);
    for (
      ;
      V >= 0 &&
      ((B = U[V]), !(q.timestamp - B.timestamp > secondsToMilliseconds(j)));

    )
      V--;
    if (!B) return { x: 0, y: 0 };
    const $ = millisecondsToSeconds(q.timestamp - B.timestamp);
    if ($ === 0) return { x: 0, y: 0 };
    const H = { x: (q.x - B.x) / $, y: (q.y - B.y) / $ };
    return H.x === 1 / 0 && (H.x = 0), H.y === 1 / 0 && (H.y = 0), H;
  }
  function applyConstraints(U, { min: j, max: V }, B) {
    return (
      j !== void 0 && U < j
        ? (U = B ? mixNumber$1(j, U, B.min) : Math.max(U, j))
        : V !== void 0 &&
          U > V &&
          (U = B ? mixNumber$1(V, U, B.max) : Math.min(U, V)),
      U
    );
  }
  function calcRelativeAxisConstraints(U, j, V) {
    return {
      min: j !== void 0 ? U.min + j : void 0,
      max: V !== void 0 ? U.max + V - (U.max - U.min) : void 0,
    };
  }
  function calcRelativeConstraints(
    U,
    { top: j, left: V, bottom: B, right: q }
  ) {
    return {
      x: calcRelativeAxisConstraints(U.x, V, q),
      y: calcRelativeAxisConstraints(U.y, j, B),
    };
  }
  function calcViewportAxisConstraints(U, j) {
    let V = j.min - U.min,
      B = j.max - U.max;
    return (
      j.max - j.min < U.max - U.min && ([V, B] = [B, V]), { min: V, max: B }
    );
  }
  function calcViewportConstraints(U, j) {
    return {
      x: calcViewportAxisConstraints(U.x, j.x),
      y: calcViewportAxisConstraints(U.y, j.y),
    };
  }
  function calcOrigin(U, j) {
    let V = 0.5;
    const B = calcLength(U),
      q = calcLength(j);
    return (
      q > B
        ? (V = progress(j.min, j.max - B, U.min))
        : B > q && (V = progress(U.min, U.max - q, j.min)),
      clamp(0, 1, V)
    );
  }
  function rebaseAxisConstraints(U, j) {
    const V = {};
    return (
      j.min !== void 0 && (V.min = j.min - U.min),
      j.max !== void 0 && (V.max = j.max - U.min),
      V
    );
  }
  const defaultElastic = 0.35;
  function resolveDragElastic(U = defaultElastic) {
    return (
      U === !1 ? (U = 0) : U === !0 && (U = defaultElastic),
      {
        x: resolveAxisElastic(U, "left", "right"),
        y: resolveAxisElastic(U, "top", "bottom"),
      }
    );
  }
  function resolveAxisElastic(U, j, V) {
    return { min: resolvePointElastic(U, j), max: resolvePointElastic(U, V) };
  }
  function resolvePointElastic(U, j) {
    return typeof U == "number" ? U : U[j] || 0;
  }
  const elementDragControls = new WeakMap();
  class VisualElementDragControls {
    constructor(j) {
      (this.openDragLock = null),
        (this.isDragging = !1),
        (this.currentDirection = null),
        (this.originPoint = { x: 0, y: 0 }),
        (this.constraints = !1),
        (this.hasMutatedConstraints = !1),
        (this.elastic = createBox()),
        (this.visualElement = j);
    }
    start(j, { snapToCursor: V = !1, distanceThreshold: B } = {}) {
      const { presenceContext: q } = this.visualElement;
      if (q && q.isPresent === !1) return;
      const $ = (Z) => {
          const { dragSnapToOrigin: te } = this.getProps();
          te ? this.pauseAnimation() : this.stopAnimation(),
            V && this.snapToCursor(extractEventInfo(Z).point);
        },
        H = (Z, te) => {
          const {
            drag: ne,
            dragPropagation: ae,
            onDragStart: se,
          } = this.getProps();
          if (
            ne &&
            !ae &&
            (this.openDragLock && this.openDragLock(),
            (this.openDragLock = setDragLock(ne)),
            !this.openDragLock)
          )
            return;
          (this.isDragging = !0),
            (this.currentDirection = null),
            this.resolveConstraints(),
            this.visualElement.projection &&
              ((this.visualElement.projection.isAnimationBlocked = !0),
              (this.visualElement.projection.target = void 0)),
            eachAxis((ce) => {
              let ue = this.getAxisMotionValue(ce).get() || 0;
              if (percent.test(ue)) {
                const { projection: he } = this.visualElement;
                if (he && he.layout) {
                  const me = he.layout.layoutBox[ce];
                  me && (ue = calcLength(me) * (parseFloat(ue) / 100));
                }
              }
              this.originPoint[ce] = ue;
            }),
            se && frame.postRender(() => se(Z, te)),
            addValueToWillChange(this.visualElement, "transform");
          const { animationState: fe } = this.visualElement;
          fe && fe.setActive("whileDrag", !0);
        },
        G = (Z, te) => {
          const {
            dragPropagation: ne,
            dragDirectionLock: ae,
            onDirectionLock: se,
            onDrag: fe,
          } = this.getProps();
          if (!ne && !this.openDragLock) return;
          const { offset: ce } = te;
          if (ae && this.currentDirection === null) {
            (this.currentDirection = getCurrentDirection(ce)),
              this.currentDirection !== null && se && se(this.currentDirection);
            return;
          }
          this.updateAxis("x", te.point, ce),
            this.updateAxis("y", te.point, ce),
            this.visualElement.render(),
            fe && fe(Z, te);
        },
        Y = (Z, te) => this.stop(Z, te),
        Q = () =>
          eachAxis(
            (Z) =>
              this.getAnimationState(Z) === "paused" &&
              this.getAxisMotionValue(Z).animation?.play()
          ),
        { dragSnapToOrigin: X } = this.getProps();
      this.panSession = new PanSession(
        j,
        {
          onSessionStart: $,
          onStart: H,
          onMove: G,
          onSessionEnd: Y,
          resumeAnimation: Q,
        },
        {
          transformPagePoint: this.visualElement.getTransformPagePoint(),
          dragSnapToOrigin: X,
          distanceThreshold: B,
          contextWindow: getContextWindow(this.visualElement),
        }
      );
    }
    stop(j, V) {
      const B = this.isDragging;
      if ((this.cancel(), !B)) return;
      const { velocity: q } = V;
      this.startAnimation(q);
      const { onDragEnd: $ } = this.getProps();
      $ && frame.postRender(() => $(j, V));
    }
    cancel() {
      this.isDragging = !1;
      const { projection: j, animationState: V } = this.visualElement;
      j && (j.isAnimationBlocked = !1),
        this.panSession && this.panSession.end(),
        (this.panSession = void 0);
      const { dragPropagation: B } = this.getProps();
      !B &&
        this.openDragLock &&
        (this.openDragLock(), (this.openDragLock = null)),
        V && V.setActive("whileDrag", !1);
    }
    updateAxis(j, V, B) {
      const { drag: q } = this.getProps();
      if (!B || !shouldDrag(j, q, this.currentDirection)) return;
      const $ = this.getAxisMotionValue(j);
      let H = this.originPoint[j] + B[j];
      this.constraints &&
        this.constraints[j] &&
        (H = applyConstraints(H, this.constraints[j], this.elastic[j])),
        $.set(H);
    }
    resolveConstraints() {
      const { dragConstraints: j, dragElastic: V } = this.getProps(),
        B =
          this.visualElement.projection && !this.visualElement.projection.layout
            ? this.visualElement.projection.measure(!1)
            : this.visualElement.projection?.layout,
        q = this.constraints;
      j && isRefObject(j)
        ? this.constraints || (this.constraints = this.resolveRefConstraints())
        : j && B
        ? (this.constraints = calcRelativeConstraints(B.layoutBox, j))
        : (this.constraints = !1),
        (this.elastic = resolveDragElastic(V)),
        q !== this.constraints &&
          B &&
          this.constraints &&
          !this.hasMutatedConstraints &&
          eachAxis(($) => {
            this.constraints !== !1 &&
              this.getAxisMotionValue($) &&
              (this.constraints[$] = rebaseAxisConstraints(
                B.layoutBox[$],
                this.constraints[$]
              ));
          });
    }
    resolveRefConstraints() {
      const { dragConstraints: j, onMeasureDragConstraints: V } =
        this.getProps();
      if (!j || !isRefObject(j)) return !1;
      const B = j.current,
        { projection: q } = this.visualElement;
      if (!q || !q.layout) return !1;
      const $ = measurePageBox(
        B,
        q.root,
        this.visualElement.getTransformPagePoint()
      );
      let H = calcViewportConstraints(q.layout.layoutBox, $);
      if (V) {
        const G = V(convertBoxToBoundingBox(H));
        (this.hasMutatedConstraints = !!G),
          G && (H = convertBoundingBoxToBox(G));
      }
      return H;
    }
    startAnimation(j) {
      const {
          drag: V,
          dragMomentum: B,
          dragElastic: q,
          dragTransition: $,
          dragSnapToOrigin: H,
          onDragTransitionEnd: G,
        } = this.getProps(),
        Y = this.constraints || {},
        Q = eachAxis((X) => {
          if (!shouldDrag(X, V, this.currentDirection)) return;
          let Z = (Y && Y[X]) || {};
          H && (Z = { min: 0, max: 0 });
          const te = q ? 200 : 1e6,
            ne = q ? 40 : 1e7,
            ae = {
              type: "inertia",
              velocity: B ? j[X] : 0,
              bounceStiffness: te,
              bounceDamping: ne,
              timeConstant: 750,
              restDelta: 1,
              restSpeed: 10,
              ...$,
              ...Z,
            };
          return this.startAxisValueAnimation(X, ae);
        });
      return Promise.all(Q).then(G);
    }
    startAxisValueAnimation(j, V) {
      const B = this.getAxisMotionValue(j);
      return (
        addValueToWillChange(this.visualElement, j),
        B.start(animateMotionValue(j, B, 0, V, this.visualElement, !1))
      );
    }
    stopAnimation() {
      eachAxis((j) => this.getAxisMotionValue(j).stop());
    }
    pauseAnimation() {
      eachAxis((j) => this.getAxisMotionValue(j).animation?.pause());
    }
    getAnimationState(j) {
      return this.getAxisMotionValue(j).animation?.state;
    }
    getAxisMotionValue(j) {
      const V = `_drag${j.toUpperCase()}`,
        B = this.visualElement.getProps(),
        q = B[V];
      return (
        q ||
        this.visualElement.getValue(j, (B.initial ? B.initial[j] : void 0) || 0)
      );
    }
    snapToCursor(j) {
      eachAxis((V) => {
        const { drag: B } = this.getProps();
        if (!shouldDrag(V, B, this.currentDirection)) return;
        const { projection: q } = this.visualElement,
          $ = this.getAxisMotionValue(V);
        if (q && q.layout) {
          const { min: H, max: G } = q.layout.layoutBox[V];
          $.set(j[V] - mixNumber$1(H, G, 0.5));
        }
      });
    }
    scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const { drag: j, dragConstraints: V } = this.getProps(),
        { projection: B } = this.visualElement;
      if (!isRefObject(V) || !B || !this.constraints) return;
      this.stopAnimation();
      const q = { x: 0, y: 0 };
      eachAxis((H) => {
        const G = this.getAxisMotionValue(H);
        if (G && this.constraints !== !1) {
          const Y = G.get();
          q[H] = calcOrigin({ min: Y, max: Y }, this.constraints[H]);
        }
      });
      const { transformTemplate: $ } = this.visualElement.getProps();
      (this.visualElement.current.style.transform = $ ? $({}, "") : "none"),
        B.root && B.root.updateScroll(),
        B.updateLayout(),
        this.resolveConstraints(),
        eachAxis((H) => {
          if (!shouldDrag(H, j, null)) return;
          const G = this.getAxisMotionValue(H),
            { min: Y, max: Q } = this.constraints[H];
          G.set(mixNumber$1(Y, Q, q[H]));
        });
    }
    addListeners() {
      if (!this.visualElement.current) return;
      elementDragControls.set(this.visualElement, this);
      const j = this.visualElement.current,
        V = addPointerEvent(j, "pointerdown", (Y) => {
          const { drag: Q, dragListener: X = !0 } = this.getProps();
          Q && X && this.start(Y);
        }),
        B = () => {
          const { dragConstraints: Y } = this.getProps();
          isRefObject(Y) &&
            Y.current &&
            (this.constraints = this.resolveRefConstraints());
        },
        { projection: q } = this.visualElement,
        $ = q.addEventListener("measure", B);
      q && !q.layout && (q.root && q.root.updateScroll(), q.updateLayout()),
        frame.read(B);
      const H = addDomEvent(window, "resize", () =>
          this.scalePositionWithinConstraints()
        ),
        G = q.addEventListener(
          "didUpdate",
          ({ delta: Y, hasLayoutChanged: Q }) => {
            this.isDragging &&
              Q &&
              (eachAxis((X) => {
                const Z = this.getAxisMotionValue(X);
                Z &&
                  ((this.originPoint[X] += Y[X].translate),
                  Z.set(Z.get() + Y[X].translate));
              }),
              this.visualElement.render());
          }
        );
      return () => {
        H(), V(), $(), G && G();
      };
    }
    getProps() {
      const j = this.visualElement.getProps(),
        {
          drag: V = !1,
          dragDirectionLock: B = !1,
          dragPropagation: q = !1,
          dragConstraints: $ = !1,
          dragElastic: H = defaultElastic,
          dragMomentum: G = !0,
        } = j;
      return {
        ...j,
        drag: V,
        dragDirectionLock: B,
        dragPropagation: q,
        dragConstraints: $,
        dragElastic: H,
        dragMomentum: G,
      };
    }
  }
  function shouldDrag(U, j, V) {
    return (j === !0 || j === U) && (V === null || V === U);
  }
  function getCurrentDirection(U, j = 10) {
    let V = null;
    return Math.abs(U.y) > j ? (V = "y") : Math.abs(U.x) > j && (V = "x"), V;
  }
  class DragGesture extends Feature {
    constructor(j) {
      super(j),
        (this.removeGroupControls = noop),
        (this.removeListeners = noop),
        (this.controls = new VisualElementDragControls(j));
    }
    mount() {
      const { dragControls: j } = this.node.getProps();
      j && (this.removeGroupControls = j.subscribe(this.controls)),
        (this.removeListeners = this.controls.addListeners() || noop);
    }
    unmount() {
      this.removeGroupControls(), this.removeListeners();
    }
  }
  const asyncHandler = (U) => (j, V) => {
    U && frame.postRender(() => U(j, V));
  };
  class PanGesture extends Feature {
    constructor() {
      super(...arguments), (this.removePointerDownListener = noop);
    }
    onPointerDown(j) {
      this.session = new PanSession(j, this.createPanHandlers(), {
        transformPagePoint: this.node.getTransformPagePoint(),
        contextWindow: getContextWindow(this.node),
      });
    }
    createPanHandlers() {
      const {
        onPanSessionStart: j,
        onPanStart: V,
        onPan: B,
        onPanEnd: q,
      } = this.node.getProps();
      return {
        onSessionStart: asyncHandler(j),
        onStart: asyncHandler(V),
        onMove: B,
        onEnd: ($, H) => {
          delete this.session, q && frame.postRender(() => q($, H));
        },
      };
    }
    mount() {
      this.removePointerDownListener = addPointerEvent(
        this.node.current,
        "pointerdown",
        (j) => this.onPointerDown(j)
      );
    }
    update() {
      this.session && this.session.updateHandlers(this.createPanHandlers());
    }
    unmount() {
      this.removePointerDownListener(), this.session && this.session.end();
    }
  }
  const globalProjectionState = {
    hasAnimatedSinceResize: !0,
    hasEverUpdated: !1,
  };
  function pixelsToPercent(U, j) {
    return j.max === j.min ? 0 : (U / (j.max - j.min)) * 100;
  }
  const correctBorderRadius = {
      correct: (U, j) => {
        if (!j.target) return U;
        if (typeof U == "string")
          if (px.test(U)) U = parseFloat(U);
          else return U;
        const V = pixelsToPercent(U, j.target.x),
          B = pixelsToPercent(U, j.target.y);
        return `${V}% ${B}%`;
      },
    },
    correctBoxShadow = {
      correct: (U, { treeScale: j, projectionDelta: V }) => {
        const B = U,
          q = complex.parse(U);
        if (q.length > 5) return B;
        const $ = complex.createTransformer(U),
          H = typeof q[0] != "number" ? 1 : 0,
          G = V.x.scale * j.x,
          Y = V.y.scale * j.y;
        (q[0 + H] /= G), (q[1 + H] /= Y);
        const Q = mixNumber$1(G, Y, 0.5);
        return (
          typeof q[2 + H] == "number" && (q[2 + H] /= Q),
          typeof q[3 + H] == "number" && (q[3 + H] /= Q),
          $(q)
        );
      },
    };
  let hasTakenAnySnapshot = !1;
  class MeasureLayoutWithContext extends reactExports.Component {
    componentDidMount() {
      const {
          visualElement: j,
          layoutGroup: V,
          switchLayoutGroup: B,
          layoutId: q,
        } = this.props,
        { projection: $ } = j;
      addScaleCorrector(defaultScaleCorrectors),
        $ &&
          (V.group && V.group.add($),
          B && B.register && q && B.register($),
          hasTakenAnySnapshot && $.root.didUpdate(),
          $.addEventListener("animationComplete", () => {
            this.safeToRemove();
          }),
          $.setOptions({
            ...$.options,
            onExitComplete: () => this.safeToRemove(),
          })),
        (globalProjectionState.hasEverUpdated = !0);
    }
    getSnapshotBeforeUpdate(j) {
      const {
          layoutDependency: V,
          visualElement: B,
          drag: q,
          isPresent: $,
        } = this.props,
        { projection: H } = B;
      return (
        H &&
          ((H.isPresent = $),
          (hasTakenAnySnapshot = !0),
          q || j.layoutDependency !== V || V === void 0 || j.isPresent !== $
            ? H.willUpdate()
            : this.safeToRemove(),
          j.isPresent !== $ &&
            ($
              ? H.promote()
              : H.relegate() ||
                frame.postRender(() => {
                  const G = H.getStack();
                  (!G || !G.members.length) && this.safeToRemove();
                }))),
        null
      );
    }
    componentDidUpdate() {
      const { projection: j } = this.props.visualElement;
      j &&
        (j.root.didUpdate(),
        microtask.postRender(() => {
          !j.currentAnimation && j.isLead() && this.safeToRemove();
        }));
    }
    componentWillUnmount() {
      const {
          visualElement: j,
          layoutGroup: V,
          switchLayoutGroup: B,
        } = this.props,
        { projection: q } = j;
      q &&
        (q.scheduleCheckAfterUnmount(),
        V && V.group && V.group.remove(q),
        B && B.deregister && B.deregister(q));
    }
    safeToRemove() {
      const { safeToRemove: j } = this.props;
      j && j();
    }
    render() {
      return null;
    }
  }
  function MeasureLayout(U) {
    const [j, V] = usePresence(),
      B = reactExports.useContext(LayoutGroupContext);
    return jsxRuntimeExports.jsx(MeasureLayoutWithContext, {
      ...U,
      layoutGroup: B,
      switchLayoutGroup: reactExports.useContext(SwitchLayoutGroupContext),
      isPresent: j,
      safeToRemove: V,
    });
  }
  const defaultScaleCorrectors = {
    borderRadius: {
      ...correctBorderRadius,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: correctBorderRadius,
    borderTopRightRadius: correctBorderRadius,
    borderBottomLeftRadius: correctBorderRadius,
    borderBottomRightRadius: correctBorderRadius,
    boxShadow: correctBoxShadow,
  };
  function animateSingleValue(U, j, V) {
    const B = isMotionValue(U) ? U : motionValue(U);
    return B.start(animateMotionValue("", B, j, V)), B.animation;
  }
  const compareByDepth = (U, j) => U.depth - j.depth;
  class FlatTree {
    constructor() {
      (this.children = []), (this.isDirty = !1);
    }
    add(j) {
      addUniqueItem(this.children, j), (this.isDirty = !0);
    }
    remove(j) {
      removeItem(this.children, j), (this.isDirty = !0);
    }
    forEach(j) {
      this.isDirty && this.children.sort(compareByDepth),
        (this.isDirty = !1),
        this.children.forEach(j);
    }
  }
  function delay(U, j) {
    const V = time.now(),
      B = ({ timestamp: q }) => {
        const $ = q - V;
        $ >= j && (cancelFrame(B), U($ - j));
      };
    return frame.setup(B, !0), () => cancelFrame(B);
  }
  const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    numBorders = borders.length,
    asNumber = (U) => (typeof U == "string" ? parseFloat(U) : U),
    isPx = (U) => typeof U == "number" || px.test(U);
  function mixValues(U, j, V, B, q, $) {
    q
      ? ((U.opacity = mixNumber$1(0, V.opacity ?? 1, easeCrossfadeIn(B))),
        (U.opacityExit = mixNumber$1(j.opacity ?? 1, 0, easeCrossfadeOut(B))))
      : $ && (U.opacity = mixNumber$1(j.opacity ?? 1, V.opacity ?? 1, B));
    for (let H = 0; H < numBorders; H++) {
      const G = `border${borders[H]}Radius`;
      let Y = getRadius(j, G),
        Q = getRadius(V, G);
      if (Y === void 0 && Q === void 0) continue;
      Y || (Y = 0),
        Q || (Q = 0),
        Y === 0 || Q === 0 || isPx(Y) === isPx(Q)
          ? ((U[G] = Math.max(mixNumber$1(asNumber(Y), asNumber(Q), B), 0)),
            (percent.test(Q) || percent.test(Y)) && (U[G] += "%"))
          : (U[G] = Q);
    }
    (j.rotate || V.rotate) &&
      (U.rotate = mixNumber$1(j.rotate || 0, V.rotate || 0, B));
  }
  function getRadius(U, j) {
    return U[j] !== void 0 ? U[j] : U.borderRadius;
  }
  const easeCrossfadeIn = compress(0, 0.5, circOut),
    easeCrossfadeOut = compress(0.5, 0.95, noop);
  function compress(U, j, V) {
    return (B) => (B < U ? 0 : B > j ? 1 : V(progress(U, j, B)));
  }
  function copyAxisInto(U, j) {
    (U.min = j.min), (U.max = j.max);
  }
  function copyBoxInto(U, j) {
    copyAxisInto(U.x, j.x), copyAxisInto(U.y, j.y);
  }
  function copyAxisDeltaInto(U, j) {
    (U.translate = j.translate),
      (U.scale = j.scale),
      (U.originPoint = j.originPoint),
      (U.origin = j.origin);
  }
  function removePointDelta(U, j, V, B, q) {
    return (
      (U -= j),
      (U = scalePoint(U, 1 / V, B)),
      q !== void 0 && (U = scalePoint(U, 1 / q, B)),
      U
    );
  }
  function removeAxisDelta(U, j = 0, V = 1, B = 0.5, q, $ = U, H = U) {
    if (
      (percent.test(j) &&
        ((j = parseFloat(j)), (j = mixNumber$1(H.min, H.max, j / 100) - H.min)),
      typeof j != "number")
    )
      return;
    let G = mixNumber$1($.min, $.max, B);
    U === $ && (G -= j),
      (U.min = removePointDelta(U.min, j, V, G, q)),
      (U.max = removePointDelta(U.max, j, V, G, q));
  }
  function removeAxisTransforms(U, j, [V, B, q], $, H) {
    removeAxisDelta(U, j[V], j[B], j[q], j.scale, $, H);
  }
  const xKeys = ["x", "scaleX", "originX"],
    yKeys = ["y", "scaleY", "originY"];
  function removeBoxTransforms(U, j, V, B) {
    removeAxisTransforms(U.x, j, xKeys, V ? V.x : void 0, B ? B.x : void 0),
      removeAxisTransforms(U.y, j, yKeys, V ? V.y : void 0, B ? B.y : void 0);
  }
  function isAxisDeltaZero(U) {
    return U.translate === 0 && U.scale === 1;
  }
  function isDeltaZero(U) {
    return isAxisDeltaZero(U.x) && isAxisDeltaZero(U.y);
  }
  function axisEquals(U, j) {
    return U.min === j.min && U.max === j.max;
  }
  function boxEquals(U, j) {
    return axisEquals(U.x, j.x) && axisEquals(U.y, j.y);
  }
  function axisEqualsRounded(U, j) {
    return (
      Math.round(U.min) === Math.round(j.min) &&
      Math.round(U.max) === Math.round(j.max)
    );
  }
  function boxEqualsRounded(U, j) {
    return axisEqualsRounded(U.x, j.x) && axisEqualsRounded(U.y, j.y);
  }
  function aspectRatio(U) {
    return calcLength(U.x) / calcLength(U.y);
  }
  function axisDeltaEquals(U, j) {
    return (
      U.translate === j.translate &&
      U.scale === j.scale &&
      U.originPoint === j.originPoint
    );
  }
  class NodeStack {
    constructor() {
      this.members = [];
    }
    add(j) {
      addUniqueItem(this.members, j), j.scheduleRender();
    }
    remove(j) {
      if (
        (removeItem(this.members, j),
        j === this.prevLead && (this.prevLead = void 0),
        j === this.lead)
      ) {
        const V = this.members[this.members.length - 1];
        V && this.promote(V);
      }
    }
    relegate(j) {
      const V = this.members.findIndex((q) => j === q);
      if (V === 0) return !1;
      let B;
      for (let q = V; q >= 0; q--) {
        const $ = this.members[q];
        if ($.isPresent !== !1) {
          B = $;
          break;
        }
      }
      return B ? (this.promote(B), !0) : !1;
    }
    promote(j, V) {
      const B = this.lead;
      if (j !== B && ((this.prevLead = B), (this.lead = j), j.show(), B)) {
        B.instance && B.scheduleRender(),
          j.scheduleRender(),
          (j.resumeFrom = B),
          V && (j.resumeFrom.preserveOpacity = !0),
          B.snapshot &&
            ((j.snapshot = B.snapshot),
            (j.snapshot.latestValues = B.animationValues || B.latestValues)),
          j.root && j.root.isUpdating && (j.isLayoutDirty = !0);
        const { crossfade: q } = j.options;
        q === !1 && B.hide();
      }
    }
    exitAnimationComplete() {
      this.members.forEach((j) => {
        const { options: V, resumingFrom: B } = j;
        V.onExitComplete && V.onExitComplete(),
          B && B.options.onExitComplete && B.options.onExitComplete();
      });
    }
    scheduleRender() {
      this.members.forEach((j) => {
        j.instance && j.scheduleRender(!1);
      });
    }
    removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
    }
  }
  function buildProjectionTransform(U, j, V) {
    let B = "";
    const q = U.x.translate / j.x,
      $ = U.y.translate / j.y,
      H = V?.z || 0;
    if (
      ((q || $ || H) && (B = `translate3d(${q}px, ${$}px, ${H}px) `),
      (j.x !== 1 || j.y !== 1) && (B += `scale(${1 / j.x}, ${1 / j.y}) `),
      V)
    ) {
      const {
        transformPerspective: Q,
        rotate: X,
        rotateX: Z,
        rotateY: te,
        skewX: ne,
        skewY: ae,
      } = V;
      Q && (B = `perspective(${Q}px) ${B}`),
        X && (B += `rotate(${X}deg) `),
        Z && (B += `rotateX(${Z}deg) `),
        te && (B += `rotateY(${te}deg) `),
        ne && (B += `skewX(${ne}deg) `),
        ae && (B += `skewY(${ae}deg) `);
    }
    const G = U.x.scale * j.x,
      Y = U.y.scale * j.y;
    return (G !== 1 || Y !== 1) && (B += `scale(${G}, ${Y})`), B || "none";
  }
  const transformAxes = ["", "X", "Y", "Z"],
    animationTarget = 1e3;
  let id = 0;
  function resetDistortingTransform(U, j, V, B) {
    const { latestValues: q } = j;
    q[U] && ((V[U] = q[U]), j.setStaticValue(U, 0), B && (B[U] = 0));
  }
  function cancelTreeOptimisedTransformAnimations(U) {
    if (((U.hasCheckedOptimisedAppear = !0), U.root === U)) return;
    const { visualElement: j } = U.options;
    if (!j) return;
    const V = getOptimisedAppearId(j);
    if (window.MotionHasOptimisedAnimation(V, "transform")) {
      const { layout: q, layoutId: $ } = U.options;
      window.MotionCancelOptimisedAnimation(V, "transform", frame, !(q || $));
    }
    const { parent: B } = U;
    B &&
      !B.hasCheckedOptimisedAppear &&
      cancelTreeOptimisedTransformAnimations(B);
  }
  function createProjectionNode({
    attachResizeListener: U,
    defaultParent: j,
    measureScroll: V,
    checkIsScrollRoot: B,
    resetTransform: q,
  }) {
    return class {
      constructor(H = {}, G = j?.()) {
        (this.id = id++),
          (this.animationId = 0),
          (this.animationCommitId = 0),
          (this.children = new Set()),
          (this.options = {}),
          (this.isTreeAnimating = !1),
          (this.isAnimationBlocked = !1),
          (this.isLayoutDirty = !1),
          (this.isProjectionDirty = !1),
          (this.isSharedProjectionDirty = !1),
          (this.isTransformDirty = !1),
          (this.updateManuallyBlocked = !1),
          (this.updateBlockedByResize = !1),
          (this.isUpdating = !1),
          (this.isSVG = !1),
          (this.needsReset = !1),
          (this.shouldResetTransform = !1),
          (this.hasCheckedOptimisedAppear = !1),
          (this.treeScale = { x: 1, y: 1 }),
          (this.eventHandlers = new Map()),
          (this.hasTreeAnimated = !1),
          (this.updateScheduled = !1),
          (this.scheduleUpdate = () => this.update()),
          (this.projectionUpdateScheduled = !1),
          (this.checkUpdateFailed = () => {
            this.isUpdating &&
              ((this.isUpdating = !1), this.clearAllSnapshots());
          }),
          (this.updateProjection = () => {
            (this.projectionUpdateScheduled = !1),
              this.nodes.forEach(propagateDirtyNodes),
              this.nodes.forEach(resolveTargetDelta),
              this.nodes.forEach(calcProjection),
              this.nodes.forEach(cleanDirtyNodes);
          }),
          (this.resolvedRelativeTargetAt = 0),
          (this.hasProjected = !1),
          (this.isVisible = !0),
          (this.animationProgress = 0),
          (this.sharedNodes = new Map()),
          (this.latestValues = H),
          (this.root = G ? G.root || G : this),
          (this.path = G ? [...G.path, G] : []),
          (this.parent = G),
          (this.depth = G ? G.depth + 1 : 0);
        for (let Y = 0; Y < this.path.length; Y++)
          this.path[Y].shouldResetTransform = !0;
        this.root === this && (this.nodes = new FlatTree());
      }
      addEventListener(H, G) {
        return (
          this.eventHandlers.has(H) ||
            this.eventHandlers.set(H, new SubscriptionManager()),
          this.eventHandlers.get(H).add(G)
        );
      }
      notifyListeners(H, ...G) {
        const Y = this.eventHandlers.get(H);
        Y && Y.notify(...G);
      }
      hasListeners(H) {
        return this.eventHandlers.has(H);
      }
      mount(H) {
        if (this.instance) return;
        (this.isSVG = isSVGElement(H) && !isSVGSVGElement(H)),
          (this.instance = H);
        const { layoutId: G, layout: Y, visualElement: Q } = this.options;
        if (
          (Q && !Q.current && Q.mount(H),
          this.root.nodes.add(this),
          this.parent && this.parent.children.add(this),
          this.root.hasTreeAnimated && (Y || G) && (this.isLayoutDirty = !0),
          U)
        ) {
          let X,
            Z = 0;
          const te = () => (this.root.updateBlockedByResize = !1);
          frame.read(() => {
            Z = window.innerWidth;
          }),
            U(H, () => {
              const ne = window.innerWidth;
              ne !== Z &&
                ((Z = ne),
                (this.root.updateBlockedByResize = !0),
                X && X(),
                (X = delay(te, 250)),
                globalProjectionState.hasAnimatedSinceResize &&
                  ((globalProjectionState.hasAnimatedSinceResize = !1),
                  this.nodes.forEach(finishAnimation)));
            });
        }
        G && this.root.registerSharedNode(G, this),
          this.options.animate !== !1 &&
            Q &&
            (G || Y) &&
            this.addEventListener(
              "didUpdate",
              ({
                delta: X,
                hasLayoutChanged: Z,
                hasRelativeLayoutChanged: te,
                layout: ne,
              }) => {
                if (this.isTreeAnimationBlocked()) {
                  (this.target = void 0), (this.relativeTarget = void 0);
                  return;
                }
                const ae =
                    this.options.transition ||
                    Q.getDefaultTransition() ||
                    defaultLayoutTransition,
                  {
                    onLayoutAnimationStart: se,
                    onLayoutAnimationComplete: fe,
                  } = Q.getProps(),
                  ce =
                    !this.targetLayout ||
                    !boxEqualsRounded(this.targetLayout, ne),
                  ue = !Z && te;
                if (
                  this.options.layoutRoot ||
                  this.resumeFrom ||
                  ue ||
                  (Z && (ce || !this.currentAnimation))
                ) {
                  this.resumeFrom &&
                    ((this.resumingFrom = this.resumeFrom),
                    (this.resumingFrom.resumingFrom = void 0));
                  const he = {
                    ...getValueTransition(ae, "layout"),
                    onPlay: se,
                    onComplete: fe,
                  };
                  (Q.shouldReduceMotion || this.options.layoutRoot) &&
                    ((he.delay = 0), (he.type = !1)),
                    this.startAnimation(he),
                    this.setAnimationOrigin(X, ue);
                } else
                  Z || finishAnimation(this),
                    this.isLead() &&
                      this.options.onExitComplete &&
                      this.options.onExitComplete();
                this.targetLayout = ne;
              }
            );
      }
      unmount() {
        this.options.layoutId && this.willUpdate(),
          this.root.nodes.remove(this);
        const H = this.getStack();
        H && H.remove(this),
          this.parent && this.parent.children.delete(this),
          (this.instance = void 0),
          this.eventHandlers.clear(),
          cancelFrame(this.updateProjection);
      }
      blockUpdate() {
        this.updateManuallyBlocked = !0;
      }
      unblockUpdate() {
        this.updateManuallyBlocked = !1;
      }
      isUpdateBlocked() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      }
      isTreeAnimationBlocked() {
        return (
          this.isAnimationBlocked ||
          (this.parent && this.parent.isTreeAnimationBlocked()) ||
          !1
        );
      }
      startUpdate() {
        this.isUpdateBlocked() ||
          ((this.isUpdating = !0),
          this.nodes && this.nodes.forEach(resetSkewAndRotation),
          this.animationId++);
      }
      getTransformTemplate() {
        const { visualElement: H } = this.options;
        return H && H.getProps().transformTemplate;
      }
      willUpdate(H = !0) {
        if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
          this.options.onExitComplete && this.options.onExitComplete();
          return;
        }
        if (
          (window.MotionCancelOptimisedAnimation &&
            !this.hasCheckedOptimisedAppear &&
            cancelTreeOptimisedTransformAnimations(this),
          !this.root.isUpdating && this.root.startUpdate(),
          this.isLayoutDirty)
        )
          return;
        this.isLayoutDirty = !0;
        for (let X = 0; X < this.path.length; X++) {
          const Z = this.path[X];
          (Z.shouldResetTransform = !0),
            Z.updateScroll("snapshot"),
            Z.options.layoutRoot && Z.willUpdate(!1);
        }
        const { layoutId: G, layout: Y } = this.options;
        if (G === void 0 && !Y) return;
        const Q = this.getTransformTemplate();
        (this.prevTransformTemplateValue = Q
          ? Q(this.latestValues, "")
          : void 0),
          this.updateSnapshot(),
          H && this.notifyListeners("willUpdate");
      }
      update() {
        if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
          this.unblockUpdate(),
            this.clearAllSnapshots(),
            this.nodes.forEach(clearMeasurements);
          return;
        }
        if (this.animationId <= this.animationCommitId) {
          this.nodes.forEach(clearIsLayoutDirty);
          return;
        }
        (this.animationCommitId = this.animationId),
          this.isUpdating
            ? ((this.isUpdating = !1),
              this.nodes.forEach(resetTransformStyle),
              this.nodes.forEach(updateLayout),
              this.nodes.forEach(notifyLayoutUpdate))
            : this.nodes.forEach(clearIsLayoutDirty),
          this.clearAllSnapshots();
        const G = time.now();
        (frameData.delta = clamp(0, 1e3 / 60, G - frameData.timestamp)),
          (frameData.timestamp = G),
          (frameData.isProcessing = !0),
          frameSteps.update.process(frameData),
          frameSteps.preRender.process(frameData),
          frameSteps.render.process(frameData),
          (frameData.isProcessing = !1);
      }
      didUpdate() {
        this.updateScheduled ||
          ((this.updateScheduled = !0), microtask.read(this.scheduleUpdate));
      }
      clearAllSnapshots() {
        this.nodes.forEach(clearSnapshot),
          this.sharedNodes.forEach(removeLeadSnapshots);
      }
      scheduleUpdateProjection() {
        this.projectionUpdateScheduled ||
          ((this.projectionUpdateScheduled = !0),
          frame.preRender(this.updateProjection, !1, !0));
      }
      scheduleCheckAfterUnmount() {
        frame.postRender(() => {
          this.isLayoutDirty
            ? this.root.didUpdate()
            : this.root.checkUpdateFailed();
        });
      }
      updateSnapshot() {
        this.snapshot ||
          !this.instance ||
          ((this.snapshot = this.measure()),
          this.snapshot &&
            !calcLength(this.snapshot.measuredBox.x) &&
            !calcLength(this.snapshot.measuredBox.y) &&
            (this.snapshot = void 0));
      }
      updateLayout() {
        if (
          !this.instance ||
          (this.updateScroll(),
          !(this.options.alwaysMeasureLayout && this.isLead()) &&
            !this.isLayoutDirty)
        )
          return;
        if (this.resumeFrom && !this.resumeFrom.instance)
          for (let Y = 0; Y < this.path.length; Y++)
            this.path[Y].updateScroll();
        const H = this.layout;
        (this.layout = this.measure(!1)),
          (this.layoutCorrected = createBox()),
          (this.isLayoutDirty = !1),
          (this.projectionDelta = void 0),
          this.notifyListeners("measure", this.layout.layoutBox);
        const { visualElement: G } = this.options;
        G &&
          G.notify(
            "LayoutMeasure",
            this.layout.layoutBox,
            H ? H.layoutBox : void 0
          );
      }
      updateScroll(H = "measure") {
        let G = !!(this.options.layoutScroll && this.instance);
        if (
          (this.scroll &&
            this.scroll.animationId === this.root.animationId &&
            this.scroll.phase === H &&
            (G = !1),
          G && this.instance)
        ) {
          const Y = B(this.instance);
          this.scroll = {
            animationId: this.root.animationId,
            phase: H,
            isRoot: Y,
            offset: V(this.instance),
            wasRoot: this.scroll ? this.scroll.isRoot : Y,
          };
        }
      }
      resetTransform() {
        if (!q) return;
        const H =
            this.isLayoutDirty ||
            this.shouldResetTransform ||
            this.options.alwaysMeasureLayout,
          G = this.projectionDelta && !isDeltaZero(this.projectionDelta),
          Y = this.getTransformTemplate(),
          Q = Y ? Y(this.latestValues, "") : void 0,
          X = Q !== this.prevTransformTemplateValue;
        H &&
          this.instance &&
          (G || hasTransform(this.latestValues) || X) &&
          (q(this.instance, Q),
          (this.shouldResetTransform = !1),
          this.scheduleRender());
      }
      measure(H = !0) {
        const G = this.measurePageBox();
        let Y = this.removeElementScroll(G);
        return (
          H && (Y = this.removeTransform(Y)),
          roundBox(Y),
          {
            animationId: this.root.animationId,
            measuredBox: G,
            layoutBox: Y,
            latestValues: {},
            source: this.id,
          }
        );
      }
      measurePageBox() {
        const { visualElement: H } = this.options;
        if (!H) return createBox();
        const G = H.measureViewportBox();
        if (!(this.scroll?.wasRoot || this.path.some(checkNodeWasScrollRoot))) {
          const { scroll: Q } = this.root;
          Q && (translateAxis(G.x, Q.offset.x), translateAxis(G.y, Q.offset.y));
        }
        return G;
      }
      removeElementScroll(H) {
        const G = createBox();
        if ((copyBoxInto(G, H), this.scroll?.wasRoot)) return G;
        for (let Y = 0; Y < this.path.length; Y++) {
          const Q = this.path[Y],
            { scroll: X, options: Z } = Q;
          Q !== this.root &&
            X &&
            Z.layoutScroll &&
            (X.wasRoot && copyBoxInto(G, H),
            translateAxis(G.x, X.offset.x),
            translateAxis(G.y, X.offset.y));
        }
        return G;
      }
      applyTransform(H, G = !1) {
        const Y = createBox();
        copyBoxInto(Y, H);
        for (let Q = 0; Q < this.path.length; Q++) {
          const X = this.path[Q];
          !G &&
            X.options.layoutScroll &&
            X.scroll &&
            X !== X.root &&
            transformBox(Y, { x: -X.scroll.offset.x, y: -X.scroll.offset.y }),
            hasTransform(X.latestValues) && transformBox(Y, X.latestValues);
        }
        return (
          hasTransform(this.latestValues) && transformBox(Y, this.latestValues),
          Y
        );
      }
      removeTransform(H) {
        const G = createBox();
        copyBoxInto(G, H);
        for (let Y = 0; Y < this.path.length; Y++) {
          const Q = this.path[Y];
          if (!Q.instance || !hasTransform(Q.latestValues)) continue;
          hasScale(Q.latestValues) && Q.updateSnapshot();
          const X = createBox(),
            Z = Q.measurePageBox();
          copyBoxInto(X, Z),
            removeBoxTransforms(
              G,
              Q.latestValues,
              Q.snapshot ? Q.snapshot.layoutBox : void 0,
              X
            );
        }
        return (
          hasTransform(this.latestValues) &&
            removeBoxTransforms(G, this.latestValues),
          G
        );
      }
      setTargetDelta(H) {
        (this.targetDelta = H),
          this.root.scheduleUpdateProjection(),
          (this.isProjectionDirty = !0);
      }
      setOptions(H) {
        this.options = {
          ...this.options,
          ...H,
          crossfade: H.crossfade !== void 0 ? H.crossfade : !0,
        };
      }
      clearMeasurements() {
        (this.scroll = void 0),
          (this.layout = void 0),
          (this.snapshot = void 0),
          (this.prevTransformTemplateValue = void 0),
          (this.targetDelta = void 0),
          (this.target = void 0),
          (this.isLayoutDirty = !1);
      }
      forceRelativeParentToResolveTarget() {
        this.relativeParent &&
          this.relativeParent.resolvedRelativeTargetAt !==
            frameData.timestamp &&
          this.relativeParent.resolveTargetDelta(!0);
      }
      resolveTargetDelta(H = !1) {
        const G = this.getLead();
        this.isProjectionDirty ||
          (this.isProjectionDirty = G.isProjectionDirty),
          this.isTransformDirty || (this.isTransformDirty = G.isTransformDirty),
          this.isSharedProjectionDirty ||
            (this.isSharedProjectionDirty = G.isSharedProjectionDirty);
        const Y = !!this.resumingFrom || this !== G;
        if (
          !(
            H ||
            (Y && this.isSharedProjectionDirty) ||
            this.isProjectionDirty ||
            this.parent?.isProjectionDirty ||
            this.attemptToResolveRelativeTarget ||
            this.root.updateBlockedByResize
          )
        )
          return;
        const { layout: X, layoutId: Z } = this.options;
        if (!(!this.layout || !(X || Z))) {
          if (
            ((this.resolvedRelativeTargetAt = frameData.timestamp),
            !this.targetDelta && !this.relativeTarget)
          ) {
            const te = this.getClosestProjectingParent();
            te && te.layout && this.animationProgress !== 1
              ? ((this.relativeParent = te),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = createBox()),
                (this.relativeTargetOrigin = createBox()),
                calcRelativePosition(
                  this.relativeTargetOrigin,
                  this.layout.layoutBox,
                  te.layout.layoutBox
                ),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          if (
            !(!this.relativeTarget && !this.targetDelta) &&
            (this.target ||
              ((this.target = createBox()),
              (this.targetWithTransforms = createBox())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                calcRelativeBox(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : copyBoxInto(this.target, this.layout.layoutBox),
                applyBoxDelta(this.target, this.targetDelta))
              : copyBoxInto(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const te = this.getClosestProjectingParent();
            te &&
            !!te.resumingFrom == !!this.resumingFrom &&
            !te.options.layoutScroll &&
            te.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = te),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = createBox()),
                (this.relativeTargetOrigin = createBox()),
                calcRelativePosition(
                  this.relativeTargetOrigin,
                  this.target,
                  te.target
                ),
                copyBoxInto(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
        }
      }
      getClosestProjectingParent() {
        if (
          !(
            !this.parent ||
            hasScale(this.parent.latestValues) ||
            has2DTranslate(this.parent.latestValues)
          )
        )
          return this.parent.isProjecting()
            ? this.parent
            : this.parent.getClosestProjectingParent();
      }
      isProjecting() {
        return !!(
          (this.relativeTarget ||
            this.targetDelta ||
            this.options.layoutRoot) &&
          this.layout
        );
      }
      calcProjection() {
        const H = this.getLead(),
          G = !!this.resumingFrom || this !== H;
        let Y = !0;
        if (
          ((this.isProjectionDirty || this.parent?.isProjectionDirty) &&
            (Y = !1),
          G &&
            (this.isSharedProjectionDirty || this.isTransformDirty) &&
            (Y = !1),
          this.resolvedRelativeTargetAt === frameData.timestamp && (Y = !1),
          Y)
        )
          return;
        const { layout: Q, layoutId: X } = this.options;
        if (
          ((this.isTreeAnimating = !!(
            (this.parent && this.parent.isTreeAnimating) ||
            this.currentAnimation ||
            this.pendingAnimation
          )),
          this.isTreeAnimating ||
            (this.targetDelta = this.relativeTarget = void 0),
          !this.layout || !(Q || X))
        )
          return;
        copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
        const Z = this.treeScale.x,
          te = this.treeScale.y;
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, G),
          H.layout &&
            !H.target &&
            (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
            ((H.target = H.layout.layoutBox),
            (H.targetWithTransforms = createBox()));
        const { target: ne } = H;
        if (!ne) {
          this.prevProjectionDelta &&
            (this.createProjectionDeltas(), this.scheduleRender());
          return;
        }
        !this.projectionDelta || !this.prevProjectionDelta
          ? this.createProjectionDeltas()
          : (copyAxisDeltaInto(
              this.prevProjectionDelta.x,
              this.projectionDelta.x
            ),
            copyAxisDeltaInto(
              this.prevProjectionDelta.y,
              this.projectionDelta.y
            )),
          calcBoxDelta(
            this.projectionDelta,
            this.layoutCorrected,
            ne,
            this.latestValues
          ),
          (this.treeScale.x !== Z ||
            this.treeScale.y !== te ||
            !axisDeltaEquals(
              this.projectionDelta.x,
              this.prevProjectionDelta.x
            ) ||
            !axisDeltaEquals(
              this.projectionDelta.y,
              this.prevProjectionDelta.y
            )) &&
            ((this.hasProjected = !0),
            this.scheduleRender(),
            this.notifyListeners("projectionUpdate", ne));
      }
      hide() {
        this.isVisible = !1;
      }
      show() {
        this.isVisible = !0;
      }
      scheduleRender(H = !0) {
        if ((this.options.visualElement?.scheduleRender(), H)) {
          const G = this.getStack();
          G && G.scheduleRender();
        }
        this.resumingFrom &&
          !this.resumingFrom.instance &&
          (this.resumingFrom = void 0);
      }
      createProjectionDeltas() {
        (this.prevProjectionDelta = createDelta()),
          (this.projectionDelta = createDelta()),
          (this.projectionDeltaWithTransform = createDelta());
      }
      setAnimationOrigin(H, G = !1) {
        const Y = this.snapshot,
          Q = Y ? Y.latestValues : {},
          X = { ...this.latestValues },
          Z = createDelta();
        (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
          (this.relativeTarget = this.relativeTargetOrigin = void 0),
          (this.attemptToResolveRelativeTarget = !G);
        const te = createBox(),
          ne = Y ? Y.source : void 0,
          ae = this.layout ? this.layout.source : void 0,
          se = ne !== ae,
          fe = this.getStack(),
          ce = !fe || fe.members.length <= 1,
          ue = !!(
            se &&
            !ce &&
            this.options.crossfade === !0 &&
            !this.path.some(hasOpacityCrossfade)
          );
        this.animationProgress = 0;
        let he;
        (this.mixTargetDelta = (me) => {
          const ve = me / 1e3;
          mixAxisDelta(Z.x, H.x, ve),
            mixAxisDelta(Z.y, H.y, ve),
            this.setTargetDelta(Z),
            this.relativeTarget &&
              this.relativeTargetOrigin &&
              this.layout &&
              this.relativeParent &&
              this.relativeParent.layout &&
              (calcRelativePosition(
                te,
                this.layout.layoutBox,
                this.relativeParent.layout.layoutBox
              ),
              mixBox(this.relativeTarget, this.relativeTargetOrigin, te, ve),
              he &&
                boxEquals(this.relativeTarget, he) &&
                (this.isProjectionDirty = !1),
              he || (he = createBox()),
              copyBoxInto(he, this.relativeTarget)),
            se &&
              ((this.animationValues = X),
              mixValues(X, Q, this.latestValues, ve, ue, ce)),
            this.root.scheduleUpdateProjection(),
            this.scheduleRender(),
            (this.animationProgress = ve);
        }),
          this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
      }
      startAnimation(H) {
        this.notifyListeners("animationStart"),
          this.currentAnimation?.stop(),
          this.resumingFrom?.currentAnimation?.stop(),
          this.pendingAnimation &&
            (cancelFrame(this.pendingAnimation),
            (this.pendingAnimation = void 0)),
          (this.pendingAnimation = frame.update(() => {
            (globalProjectionState.hasAnimatedSinceResize = !0),
              this.motionValue || (this.motionValue = motionValue(0)),
              (this.currentAnimation = animateSingleValue(
                this.motionValue,
                [0, 1e3],
                {
                  ...H,
                  velocity: 0,
                  isSync: !0,
                  onUpdate: (G) => {
                    this.mixTargetDelta(G), H.onUpdate && H.onUpdate(G);
                  },
                  onStop: () => {},
                  onComplete: () => {
                    H.onComplete && H.onComplete(), this.completeAnimation();
                  },
                }
              )),
              this.resumingFrom &&
                (this.resumingFrom.currentAnimation = this.currentAnimation),
              (this.pendingAnimation = void 0);
          }));
      }
      completeAnimation() {
        this.resumingFrom &&
          ((this.resumingFrom.currentAnimation = void 0),
          (this.resumingFrom.preserveOpacity = void 0));
        const H = this.getStack();
        H && H.exitAnimationComplete(),
          (this.resumingFrom =
            this.currentAnimation =
            this.animationValues =
              void 0),
          this.notifyListeners("animationComplete");
      }
      finishAnimation() {
        this.currentAnimation &&
          (this.mixTargetDelta && this.mixTargetDelta(animationTarget),
          this.currentAnimation.stop()),
          this.completeAnimation();
      }
      applyTransformsToTarget() {
        const H = this.getLead();
        let {
          targetWithTransforms: G,
          target: Y,
          layout: Q,
          latestValues: X,
        } = H;
        if (!(!G || !Y || !Q)) {
          if (
            this !== H &&
            this.layout &&
            Q &&
            shouldAnimatePositionOnly(
              this.options.animationType,
              this.layout.layoutBox,
              Q.layoutBox
            )
          ) {
            Y = this.target || createBox();
            const Z = calcLength(this.layout.layoutBox.x);
            (Y.x.min = H.target.x.min), (Y.x.max = Y.x.min + Z);
            const te = calcLength(this.layout.layoutBox.y);
            (Y.y.min = H.target.y.min), (Y.y.max = Y.y.min + te);
          }
          copyBoxInto(G, Y),
            transformBox(G, X),
            calcBoxDelta(
              this.projectionDeltaWithTransform,
              this.layoutCorrected,
              G,
              X
            );
        }
      }
      registerSharedNode(H, G) {
        this.sharedNodes.has(H) || this.sharedNodes.set(H, new NodeStack()),
          this.sharedNodes.get(H).add(G);
        const Q = G.options.initialPromotionConfig;
        G.promote({
          transition: Q ? Q.transition : void 0,
          preserveFollowOpacity:
            Q && Q.shouldPreserveFollowOpacity
              ? Q.shouldPreserveFollowOpacity(G)
              : void 0,
        });
      }
      isLead() {
        const H = this.getStack();
        return H ? H.lead === this : !0;
      }
      getLead() {
        const { layoutId: H } = this.options;
        return H ? this.getStack()?.lead || this : this;
      }
      getPrevLead() {
        const { layoutId: H } = this.options;
        return H ? this.getStack()?.prevLead : void 0;
      }
      getStack() {
        const { layoutId: H } = this.options;
        if (H) return this.root.sharedNodes.get(H);
      }
      promote({ needsReset: H, transition: G, preserveFollowOpacity: Y } = {}) {
        const Q = this.getStack();
        Q && Q.promote(this, Y),
          H && ((this.projectionDelta = void 0), (this.needsReset = !0)),
          G && this.setOptions({ transition: G });
      }
      relegate() {
        const H = this.getStack();
        return H ? H.relegate(this) : !1;
      }
      resetSkewAndRotation() {
        const { visualElement: H } = this.options;
        if (!H) return;
        let G = !1;
        const { latestValues: Y } = H;
        if (
          ((Y.z ||
            Y.rotate ||
            Y.rotateX ||
            Y.rotateY ||
            Y.rotateZ ||
            Y.skewX ||
            Y.skewY) &&
            (G = !0),
          !G)
        )
          return;
        const Q = {};
        Y.z && resetDistortingTransform("z", H, Q, this.animationValues);
        for (let X = 0; X < transformAxes.length; X++)
          resetDistortingTransform(
            `rotate${transformAxes[X]}`,
            H,
            Q,
            this.animationValues
          ),
            resetDistortingTransform(
              `skew${transformAxes[X]}`,
              H,
              Q,
              this.animationValues
            );
        H.render();
        for (const X in Q)
          H.setStaticValue(X, Q[X]),
            this.animationValues && (this.animationValues[X] = Q[X]);
        H.scheduleRender();
      }
      applyProjectionStyles(H, G) {
        if (!this.instance || this.isSVG) return;
        if (!this.isVisible) {
          H.visibility = "hidden";
          return;
        }
        const Y = this.getTransformTemplate();
        if (this.needsReset) {
          (this.needsReset = !1),
            (H.visibility = ""),
            (H.opacity = ""),
            (H.pointerEvents = resolveMotionValue(G?.pointerEvents) || ""),
            (H.transform = Y ? Y(this.latestValues, "") : "none");
          return;
        }
        const Q = this.getLead();
        if (!this.projectionDelta || !this.layout || !Q.target) {
          this.options.layoutId &&
            ((H.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (H.pointerEvents = resolveMotionValue(G?.pointerEvents) || "")),
            this.hasProjected &&
              !hasTransform(this.latestValues) &&
              ((H.transform = Y ? Y({}, "") : "none"),
              (this.hasProjected = !1));
          return;
        }
        H.visibility = "";
        const X = Q.animationValues || Q.latestValues;
        this.applyTransformsToTarget();
        let Z = buildProjectionTransform(
          this.projectionDeltaWithTransform,
          this.treeScale,
          X
        );
        Y && (Z = Y(X, Z)), (H.transform = Z);
        const { x: te, y: ne } = this.projectionDelta;
        (H.transformOrigin = `${te.origin * 100}% ${ne.origin * 100}% 0`),
          Q.animationValues
            ? (H.opacity =
                Q === this
                  ? X.opacity ?? this.latestValues.opacity ?? 1
                  : this.preserveOpacity
                  ? this.latestValues.opacity
                  : X.opacityExit)
            : (H.opacity =
                Q === this
                  ? X.opacity !== void 0
                    ? X.opacity
                    : ""
                  : X.opacityExit !== void 0
                  ? X.opacityExit
                  : 0);
        for (const ae in scaleCorrectors) {
          if (X[ae] === void 0) continue;
          const {
              correct: se,
              applyTo: fe,
              isCSSVariable: ce,
            } = scaleCorrectors[ae],
            ue = Z === "none" ? X[ae] : se(X[ae], Q);
          if (fe) {
            const he = fe.length;
            for (let me = 0; me < he; me++) H[fe[me]] = ue;
          } else
            ce
              ? (this.options.visualElement.renderState.vars[ae] = ue)
              : (H[ae] = ue);
        }
        this.options.layoutId &&
          (H.pointerEvents =
            Q === this ? resolveMotionValue(G?.pointerEvents) || "" : "none");
      }
      clearSnapshot() {
        this.resumeFrom = this.snapshot = void 0;
      }
      resetTree() {
        this.root.nodes.forEach((H) => H.currentAnimation?.stop()),
          this.root.nodes.forEach(clearMeasurements),
          this.root.sharedNodes.clear();
      }
    };
  }
  function updateLayout(U) {
    U.updateLayout();
  }
  function notifyLayoutUpdate(U) {
    const j = U.resumeFrom?.snapshot || U.snapshot;
    if (U.isLead() && U.layout && j && U.hasListeners("didUpdate")) {
      const { layoutBox: V, measuredBox: B } = U.layout,
        { animationType: q } = U.options,
        $ = j.source !== U.layout.source;
      q === "size"
        ? eachAxis((X) => {
            const Z = $ ? j.measuredBox[X] : j.layoutBox[X],
              te = calcLength(Z);
            (Z.min = V[X].min), (Z.max = Z.min + te);
          })
        : shouldAnimatePositionOnly(q, j.layoutBox, V) &&
          eachAxis((X) => {
            const Z = $ ? j.measuredBox[X] : j.layoutBox[X],
              te = calcLength(V[X]);
            (Z.max = Z.min + te),
              U.relativeTarget &&
                !U.currentAnimation &&
                ((U.isProjectionDirty = !0),
                (U.relativeTarget[X].max = U.relativeTarget[X].min + te));
          });
      const H = createDelta();
      calcBoxDelta(H, V, j.layoutBox);
      const G = createDelta();
      $
        ? calcBoxDelta(G, U.applyTransform(B, !0), j.measuredBox)
        : calcBoxDelta(G, V, j.layoutBox);
      const Y = !isDeltaZero(H);
      let Q = !1;
      if (!U.resumeFrom) {
        const X = U.getClosestProjectingParent();
        if (X && !X.resumeFrom) {
          const { snapshot: Z, layout: te } = X;
          if (Z && te) {
            const ne = createBox();
            calcRelativePosition(ne, j.layoutBox, Z.layoutBox);
            const ae = createBox();
            calcRelativePosition(ae, V, te.layoutBox),
              boxEqualsRounded(ne, ae) || (Q = !0),
              X.options.layoutRoot &&
                ((U.relativeTarget = ae),
                (U.relativeTargetOrigin = ne),
                (U.relativeParent = X));
          }
        }
      }
      U.notifyListeners("didUpdate", {
        layout: V,
        snapshot: j,
        delta: G,
        layoutDelta: H,
        hasLayoutChanged: Y,
        hasRelativeLayoutChanged: Q,
      });
    } else if (U.isLead()) {
      const { onExitComplete: V } = U.options;
      V && V();
    }
    U.options.transition = void 0;
  }
  function propagateDirtyNodes(U) {
    U.parent &&
      (U.isProjecting() || (U.isProjectionDirty = U.parent.isProjectionDirty),
      U.isSharedProjectionDirty ||
        (U.isSharedProjectionDirty = !!(
          U.isProjectionDirty ||
          U.parent.isProjectionDirty ||
          U.parent.isSharedProjectionDirty
        )),
      U.isTransformDirty || (U.isTransformDirty = U.parent.isTransformDirty));
  }
  function cleanDirtyNodes(U) {
    U.isProjectionDirty = U.isSharedProjectionDirty = U.isTransformDirty = !1;
  }
  function clearSnapshot(U) {
    U.clearSnapshot();
  }
  function clearMeasurements(U) {
    U.clearMeasurements();
  }
  function clearIsLayoutDirty(U) {
    U.isLayoutDirty = !1;
  }
  function resetTransformStyle(U) {
    const { visualElement: j } = U.options;
    j && j.getProps().onBeforeLayoutMeasure && j.notify("BeforeLayoutMeasure"),
      U.resetTransform();
  }
  function finishAnimation(U) {
    U.finishAnimation(),
      (U.targetDelta = U.relativeTarget = U.target = void 0),
      (U.isProjectionDirty = !0);
  }
  function resolveTargetDelta(U) {
    U.resolveTargetDelta();
  }
  function calcProjection(U) {
    U.calcProjection();
  }
  function resetSkewAndRotation(U) {
    U.resetSkewAndRotation();
  }
  function removeLeadSnapshots(U) {
    U.removeLeadSnapshot();
  }
  function mixAxisDelta(U, j, V) {
    (U.translate = mixNumber$1(j.translate, 0, V)),
      (U.scale = mixNumber$1(j.scale, 1, V)),
      (U.origin = j.origin),
      (U.originPoint = j.originPoint);
  }
  function mixAxis(U, j, V, B) {
    (U.min = mixNumber$1(j.min, V.min, B)),
      (U.max = mixNumber$1(j.max, V.max, B));
  }
  function mixBox(U, j, V, B) {
    mixAxis(U.x, j.x, V.x, B), mixAxis(U.y, j.y, V.y, B);
  }
  function hasOpacityCrossfade(U) {
    return U.animationValues && U.animationValues.opacityExit !== void 0;
  }
  const defaultLayoutTransition = { duration: 0.45, ease: [0.4, 0, 0.1, 1] },
    userAgentContains = (U) =>
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().includes(U),
    roundPoint =
      userAgentContains("applewebkit/") && !userAgentContains("chrome/")
        ? Math.round
        : noop;
  function roundAxis(U) {
    (U.min = roundPoint(U.min)), (U.max = roundPoint(U.max));
  }
  function roundBox(U) {
    roundAxis(U.x), roundAxis(U.y);
  }
  function shouldAnimatePositionOnly(U, j, V) {
    return (
      U === "position" ||
      (U === "preserve-aspect" && !isNear(aspectRatio(j), aspectRatio(V), 0.2))
    );
  }
  function checkNodeWasScrollRoot(U) {
    return U !== U.root && U.scroll?.wasRoot;
  }
  const DocumentProjectionNode = createProjectionNode({
      attachResizeListener: (U, j) => addDomEvent(U, "resize", j),
      measureScroll: () => ({
        x: document.documentElement.scrollLeft || document.body.scrollLeft,
        y: document.documentElement.scrollTop || document.body.scrollTop,
      }),
      checkIsScrollRoot: () => !0,
    }),
    rootProjectionNode = { current: void 0 },
    HTMLProjectionNode = createProjectionNode({
      measureScroll: (U) => ({ x: U.scrollLeft, y: U.scrollTop }),
      defaultParent: () => {
        if (!rootProjectionNode.current) {
          const U = new DocumentProjectionNode({});
          U.mount(window),
            U.setOptions({ layoutScroll: !0 }),
            (rootProjectionNode.current = U);
        }
        return rootProjectionNode.current;
      },
      resetTransform: (U, j) => {
        U.style.transform = j !== void 0 ? j : "none";
      },
      checkIsScrollRoot: (U) => window.getComputedStyle(U).position === "fixed",
    }),
    drag = {
      pan: { Feature: PanGesture },
      drag: {
        Feature: DragGesture,
        ProjectionNode: HTMLProjectionNode,
        MeasureLayout,
      },
    };
  function handleHoverEvent(U, j, V) {
    const { props: B } = U;
    U.animationState &&
      B.whileHover &&
      U.animationState.setActive("whileHover", V === "Start");
    const q = "onHover" + V,
      $ = B[q];
    $ && frame.postRender(() => $(j, extractEventInfo(j)));
  }
  class HoverGesture extends Feature {
    mount() {
      const { current: j } = this.node;
      j &&
        (this.unmount = hover(
          j,
          (V, B) => (
            handleHoverEvent(this.node, B, "Start"),
            (q) => handleHoverEvent(this.node, q, "End")
          )
        ));
    }
    unmount() {}
  }
  class FocusGesture extends Feature {
    constructor() {
      super(...arguments), (this.isActive = !1);
    }
    onFocus() {
      let j = !1;
      try {
        j = this.node.current.matches(":focus-visible");
      } catch {
        j = !0;
      }
      !j ||
        !this.node.animationState ||
        (this.node.animationState.setActive("whileFocus", !0),
        (this.isActive = !0));
    }
    onBlur() {
      !this.isActive ||
        !this.node.animationState ||
        (this.node.animationState.setActive("whileFocus", !1),
        (this.isActive = !1));
    }
    mount() {
      this.unmount = pipe(
        addDomEvent(this.node.current, "focus", () => this.onFocus()),
        addDomEvent(this.node.current, "blur", () => this.onBlur())
      );
    }
    unmount() {}
  }
  function handlePressEvent(U, j, V) {
    const { props: B } = U;
    if (U.current instanceof HTMLButtonElement && U.current.disabled) return;
    U.animationState &&
      B.whileTap &&
      U.animationState.setActive("whileTap", V === "Start");
    const q = "onTap" + (V === "End" ? "" : V),
      $ = B[q];
    $ && frame.postRender(() => $(j, extractEventInfo(j)));
  }
  class PressGesture extends Feature {
    mount() {
      const { current: j } = this.node;
      j &&
        (this.unmount = press(
          j,
          (V, B) => (
            handlePressEvent(this.node, B, "Start"),
            (q, { success: $ }) =>
              handlePressEvent(this.node, q, $ ? "End" : "Cancel")
          ),
          { useGlobalTarget: this.node.props.globalTapTarget }
        ));
    }
    unmount() {}
  }
  const observerCallbacks = new WeakMap(),
    observers = new WeakMap(),
    fireObserverCallback = (U) => {
      const j = observerCallbacks.get(U.target);
      j && j(U);
    },
    fireAllObserverCallbacks = (U) => {
      U.forEach(fireObserverCallback);
    };
  function initIntersectionObserver({ root: U, ...j }) {
    const V = U || document;
    observers.has(V) || observers.set(V, {});
    const B = observers.get(V),
      q = JSON.stringify(j);
    return (
      B[q] ||
        (B[q] = new IntersectionObserver(fireAllObserverCallbacks, {
          root: U,
          ...j,
        })),
      B[q]
    );
  }
  function observeIntersection(U, j, V) {
    const B = initIntersectionObserver(j);
    return (
      observerCallbacks.set(U, V),
      B.observe(U),
      () => {
        observerCallbacks.delete(U), B.unobserve(U);
      }
    );
  }
  const thresholdNames = { some: 0, all: 1 };
  class InViewFeature extends Feature {
    constructor() {
      super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
    }
    startObserver() {
      this.unmount();
      const { viewport: j = {} } = this.node.getProps(),
        { root: V, margin: B, amount: q = "some", once: $ } = j,
        H = {
          root: V ? V.current : void 0,
          rootMargin: B,
          threshold: typeof q == "number" ? q : thresholdNames[q],
        },
        G = (Y) => {
          const { isIntersecting: Q } = Y;
          if (
            this.isInView === Q ||
            ((this.isInView = Q), $ && !Q && this.hasEnteredView)
          )
            return;
          Q && (this.hasEnteredView = !0),
            this.node.animationState &&
              this.node.animationState.setActive("whileInView", Q);
          const { onViewportEnter: X, onViewportLeave: Z } =
              this.node.getProps(),
            te = Q ? X : Z;
          te && te(Y);
        };
      return observeIntersection(this.node.current, H, G);
    }
    mount() {
      this.startObserver();
    }
    update() {
      if (typeof IntersectionObserver > "u") return;
      const { props: j, prevProps: V } = this.node;
      ["amount", "margin", "root"].some(hasViewportOptionChanged(j, V)) &&
        this.startObserver();
    }
    unmount() {}
  }
  function hasViewportOptionChanged(
    { viewport: U = {} },
    { viewport: j = {} } = {}
  ) {
    return (V) => U[V] !== j[V];
  }
  const gestureAnimations = {
      inView: { Feature: InViewFeature },
      tap: { Feature: PressGesture },
      focus: { Feature: FocusGesture },
      hover: { Feature: HoverGesture },
    },
    layout = { layout: { ProjectionNode: HTMLProjectionNode, MeasureLayout } },
    prefersReducedMotion = { current: null },
    hasReducedMotionListener = { current: !1 };
  function initPrefersReducedMotion() {
    if (((hasReducedMotionListener.current = !0), !!isBrowser))
      if (window.matchMedia) {
        const U = window.matchMedia("(prefers-reduced-motion)"),
          j = () => (prefersReducedMotion.current = U.matches);
        U.addEventListener("change", j), j();
      } else prefersReducedMotion.current = !1;
  }
  const visualElementStore = new WeakMap();
  function updateMotionValuesFromProps(U, j, V) {
    for (const B in j) {
      const q = j[B],
        $ = V[B];
      if (isMotionValue(q)) U.addValue(B, q);
      else if (isMotionValue($)) U.addValue(B, motionValue(q, { owner: U }));
      else if ($ !== q)
        if (U.hasValue(B)) {
          const H = U.getValue(B);
          H.liveStyle === !0 ? H.jump(q) : H.hasAnimated || H.set(q);
        } else {
          const H = U.getStaticValue(B);
          U.addValue(B, motionValue(H !== void 0 ? H : q, { owner: U }));
        }
    }
    for (const B in V) j[B] === void 0 && U.removeValue(B);
    return j;
  }
  const propEventHandlers = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ];
  class VisualElement {
    scrapeMotionValuesFromProps(j, V, B) {
      return {};
    }
    constructor(
      {
        parent: j,
        props: V,
        presenceContext: B,
        reducedMotionConfig: q,
        blockInitialAnimation: $,
        visualState: H,
      },
      G = {}
    ) {
      (this.current = null),
        (this.children = new Set()),
        (this.isVariantNode = !1),
        (this.isControllingVariants = !1),
        (this.shouldReduceMotion = null),
        (this.values = new Map()),
        (this.KeyframeResolver = KeyframeResolver),
        (this.features = {}),
        (this.valueSubscriptions = new Map()),
        (this.prevMotionValues = {}),
        (this.events = {}),
        (this.propEventSubscriptions = {}),
        (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
        (this.render = () => {
          this.current &&
            (this.triggerBuild(),
            this.renderInstance(
              this.current,
              this.renderState,
              this.props.style,
              this.projection
            ));
        }),
        (this.renderScheduledAt = 0),
        (this.scheduleRender = () => {
          const te = time.now();
          this.renderScheduledAt < te &&
            ((this.renderScheduledAt = te), frame.render(this.render, !1, !0));
        });
      const { latestValues: Y, renderState: Q } = H;
      (this.latestValues = Y),
        (this.baseTarget = { ...Y }),
        (this.initialValues = V.initial ? { ...Y } : {}),
        (this.renderState = Q),
        (this.parent = j),
        (this.props = V),
        (this.presenceContext = B),
        (this.depth = j ? j.depth + 1 : 0),
        (this.reducedMotionConfig = q),
        (this.options = G),
        (this.blockInitialAnimation = !!$),
        (this.isControllingVariants = isControllingVariants(V)),
        (this.isVariantNode = isVariantNode(V)),
        this.isVariantNode && (this.variantChildren = new Set()),
        (this.manuallyAnimateOnMount = !!(j && j.current));
      const { willChange: X, ...Z } = this.scrapeMotionValuesFromProps(
        V,
        {},
        this
      );
      for (const te in Z) {
        const ne = Z[te];
        Y[te] !== void 0 && isMotionValue(ne) && ne.set(Y[te], !1);
      }
    }
    mount(j) {
      (this.current = j),
        visualElementStore.set(j, this),
        this.projection &&
          !this.projection.instance &&
          this.projection.mount(j),
        this.parent &&
          this.isVariantNode &&
          !this.isControllingVariants &&
          (this.removeFromVariantTree = this.parent.addVariantChild(this)),
        this.values.forEach((V, B) => this.bindToMotionValue(B, V)),
        hasReducedMotionListener.current || initPrefersReducedMotion(),
        (this.shouldReduceMotion =
          this.reducedMotionConfig === "never"
            ? !1
            : this.reducedMotionConfig === "always"
            ? !0
            : prefersReducedMotion.current),
        this.parent && this.parent.children.add(this),
        this.update(this.props, this.presenceContext);
    }
    unmount() {
      this.projection && this.projection.unmount(),
        cancelFrame(this.notifyUpdate),
        cancelFrame(this.render),
        this.valueSubscriptions.forEach((j) => j()),
        this.valueSubscriptions.clear(),
        this.removeFromVariantTree && this.removeFromVariantTree(),
        this.parent && this.parent.children.delete(this);
      for (const j in this.events) this.events[j].clear();
      for (const j in this.features) {
        const V = this.features[j];
        V && (V.unmount(), (V.isMounted = !1));
      }
      this.current = null;
    }
    bindToMotionValue(j, V) {
      this.valueSubscriptions.has(j) && this.valueSubscriptions.get(j)();
      const B = transformProps.has(j);
      B && this.onBindTransform && this.onBindTransform();
      const q = V.on("change", (G) => {
          (this.latestValues[j] = G),
            this.props.onUpdate && frame.preRender(this.notifyUpdate),
            B && this.projection && (this.projection.isTransformDirty = !0);
        }),
        $ = V.on("renderRequest", this.scheduleRender);
      let H;
      window.MotionCheckAppearSync &&
        (H = window.MotionCheckAppearSync(this, j, V)),
        this.valueSubscriptions.set(j, () => {
          q(), $(), H && H(), V.owner && V.stop();
        });
    }
    sortNodePosition(j) {
      return !this.current ||
        !this.sortInstanceNodePosition ||
        this.type !== j.type
        ? 0
        : this.sortInstanceNodePosition(this.current, j.current);
    }
    updateFeatures() {
      let j = "animation";
      for (j in featureDefinitions) {
        const V = featureDefinitions[j];
        if (!V) continue;
        const { isEnabled: B, Feature: q } = V;
        if (
          (!this.features[j] &&
            q &&
            B(this.props) &&
            (this.features[j] = new q(this)),
          this.features[j])
        ) {
          const $ = this.features[j];
          $.isMounted ? $.update() : ($.mount(), ($.isMounted = !0));
        }
      }
    }
    triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props);
    }
    measureViewportBox() {
      return this.current
        ? this.measureInstanceViewportBox(this.current, this.props)
        : createBox();
    }
    getStaticValue(j) {
      return this.latestValues[j];
    }
    setStaticValue(j, V) {
      this.latestValues[j] = V;
    }
    update(j, V) {
      (j.transformTemplate || this.props.transformTemplate) &&
        this.scheduleRender(),
        (this.prevProps = this.props),
        (this.props = j),
        (this.prevPresenceContext = this.presenceContext),
        (this.presenceContext = V);
      for (let B = 0; B < propEventHandlers.length; B++) {
        const q = propEventHandlers[B];
        this.propEventSubscriptions[q] &&
          (this.propEventSubscriptions[q](),
          delete this.propEventSubscriptions[q]);
        const $ = "on" + q,
          H = j[$];
        H && (this.propEventSubscriptions[q] = this.on(q, H));
      }
      (this.prevMotionValues = updateMotionValuesFromProps(
        this,
        this.scrapeMotionValuesFromProps(j, this.prevProps, this),
        this.prevMotionValues
      )),
        this.handleChildMotionValue && this.handleChildMotionValue();
    }
    getProps() {
      return this.props;
    }
    getVariant(j) {
      return this.props.variants ? this.props.variants[j] : void 0;
    }
    getDefaultTransition() {
      return this.props.transition;
    }
    getTransformPagePoint() {
      return this.props.transformPagePoint;
    }
    getClosestVariantNode() {
      return this.isVariantNode
        ? this
        : this.parent
        ? this.parent.getClosestVariantNode()
        : void 0;
    }
    addVariantChild(j) {
      const V = this.getClosestVariantNode();
      if (V)
        return (
          V.variantChildren && V.variantChildren.add(j),
          () => V.variantChildren.delete(j)
        );
    }
    addValue(j, V) {
      const B = this.values.get(j);
      V !== B &&
        (B && this.removeValue(j),
        this.bindToMotionValue(j, V),
        this.values.set(j, V),
        (this.latestValues[j] = V.get()));
    }
    removeValue(j) {
      this.values.delete(j);
      const V = this.valueSubscriptions.get(j);
      V && (V(), this.valueSubscriptions.delete(j)),
        delete this.latestValues[j],
        this.removeValueFromRenderState(j, this.renderState);
    }
    hasValue(j) {
      return this.values.has(j);
    }
    getValue(j, V) {
      if (this.props.values && this.props.values[j])
        return this.props.values[j];
      let B = this.values.get(j);
      return (
        B === void 0 &&
          V !== void 0 &&
          ((B = motionValue(V === null ? void 0 : V, { owner: this })),
          this.addValue(j, B)),
        B
      );
    }
    readValue(j, V) {
      let B =
        this.latestValues[j] !== void 0 || !this.current
          ? this.latestValues[j]
          : this.getBaseTargetFromProps(this.props, j) ??
            this.readValueFromInstance(this.current, j, this.options);
      return (
        B != null &&
          (typeof B == "string" &&
          (isNumericalString(B) || isZeroValueString(B))
            ? (B = parseFloat(B))
            : !findValueType(B) &&
              complex.test(V) &&
              (B = getAnimatableNone(j, V)),
          this.setBaseTarget(j, isMotionValue(B) ? B.get() : B)),
        isMotionValue(B) ? B.get() : B
      );
    }
    setBaseTarget(j, V) {
      this.baseTarget[j] = V;
    }
    getBaseTarget(j) {
      const { initial: V } = this.props;
      let B;
      if (typeof V == "string" || typeof V == "object") {
        const $ = resolveVariantFromProps(
          this.props,
          V,
          this.presenceContext?.custom
        );
        $ && (B = $[j]);
      }
      if (V && B !== void 0) return B;
      const q = this.getBaseTargetFromProps(this.props, j);
      return q !== void 0 && !isMotionValue(q)
        ? q
        : this.initialValues[j] !== void 0 && B === void 0
        ? void 0
        : this.baseTarget[j];
    }
    on(j, V) {
      return (
        this.events[j] || (this.events[j] = new SubscriptionManager()),
        this.events[j].add(V)
      );
    }
    notify(j, ...V) {
      this.events[j] && this.events[j].notify(...V);
    }
  }
  class DOMVisualElement extends VisualElement {
    constructor() {
      super(...arguments), (this.KeyframeResolver = DOMKeyframesResolver);
    }
    sortInstanceNodePosition(j, V) {
      return j.compareDocumentPosition(V) & 2 ? 1 : -1;
    }
    getBaseTargetFromProps(j, V) {
      return j.style ? j.style[V] : void 0;
    }
    removeValueFromRenderState(j, { vars: V, style: B }) {
      delete V[j], delete B[j];
    }
    handleChildMotionValue() {
      this.childSubscription &&
        (this.childSubscription(), delete this.childSubscription);
      const { children: j } = this.props;
      isMotionValue(j) &&
        (this.childSubscription = j.on("change", (V) => {
          this.current && (this.current.textContent = `${V}`);
        }));
    }
  }
  function renderHTML(U, { style: j, vars: V }, B, q) {
    const $ = U.style;
    let H;
    for (H in j) $[H] = j[H];
    q?.applyProjectionStyles($, B);
    for (H in V) $.setProperty(H, V[H]);
  }
  function getComputedStyle$1(U) {
    return window.getComputedStyle(U);
  }
  class HTMLVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments),
        (this.type = "html"),
        (this.renderInstance = renderHTML);
    }
    readValueFromInstance(j, V) {
      if (transformProps.has(V))
        return this.projection?.isProjecting
          ? defaultTransformValue(V)
          : readTransformValue(j, V);
      {
        const B = getComputedStyle$1(j),
          q = (isCSSVariableName(V) ? B.getPropertyValue(V) : B[V]) || 0;
        return typeof q == "string" ? q.trim() : q;
      }
    }
    measureInstanceViewportBox(j, { transformPagePoint: V }) {
      return measureViewportBox(j, V);
    }
    build(j, V, B) {
      buildHTMLStyles(j, V, B.transformTemplate);
    }
    scrapeMotionValuesFromProps(j, V, B) {
      return scrapeMotionValuesFromProps$1(j, V, B);
    }
  }
  const camelCaseAttributes = new Set([
    "baseFrequency",
    "diffuseConstant",
    "kernelMatrix",
    "kernelUnitLength",
    "keySplines",
    "keyTimes",
    "limitingConeAngle",
    "markerHeight",
    "markerWidth",
    "numOctaves",
    "targetX",
    "targetY",
    "surfaceScale",
    "specularConstant",
    "specularExponent",
    "stdDeviation",
    "tableValues",
    "viewBox",
    "gradientTransform",
    "pathLength",
    "startOffset",
    "textLength",
    "lengthAdjust",
  ]);
  function renderSVG(U, j, V, B) {
    renderHTML(U, j, void 0, B);
    for (const q in j.attrs)
      U.setAttribute(
        camelCaseAttributes.has(q) ? q : camelToDash(q),
        j.attrs[q]
      );
  }
  class SVGVisualElement extends DOMVisualElement {
    constructor() {
      super(...arguments),
        (this.type = "svg"),
        (this.isSVGTag = !1),
        (this.measureInstanceViewportBox = createBox);
    }
    getBaseTargetFromProps(j, V) {
      return j[V];
    }
    readValueFromInstance(j, V) {
      if (transformProps.has(V)) {
        const B = getDefaultValueType(V);
        return (B && B.default) || 0;
      }
      return (
        (V = camelCaseAttributes.has(V) ? V : camelToDash(V)), j.getAttribute(V)
      );
    }
    scrapeMotionValuesFromProps(j, V, B) {
      return scrapeMotionValuesFromProps(j, V, B);
    }
    build(j, V, B) {
      buildSVGAttrs(j, V, this.isSVGTag, B.transformTemplate, B.style);
    }
    renderInstance(j, V, B, q) {
      renderSVG(j, V, B, q);
    }
    mount(j) {
      (this.isSVGTag = isSVGTag(j.tagName)), super.mount(j);
    }
  }
  const createDomVisualElement = (U, j) =>
      isSVGComponent(U)
        ? new SVGVisualElement(j)
        : new HTMLVisualElement(j, {
            allowProjection: U !== reactExports.Fragment,
          }),
    createMotionComponent = createMotionComponentFactory(
      { ...animations, ...gestureAnimations, ...drag, ...layout },
      createDomVisualElement
    ),
    motion = createDOMMotionComponentProxy(createMotionComponent);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const toKebabCase = (U) =>
      U.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(),
    toCamelCase = (U) =>
      U.replace(/^([A-Z])|[\s-_]+(\w)/g, (j, V, B) =>
        B ? B.toUpperCase() : V.toLowerCase()
      ),
    toPascalCase = (U) => {
      const j = toCamelCase(U);
      return j.charAt(0).toUpperCase() + j.slice(1);
    },
    mergeClasses = (...U) =>
      U.filter((j, V, B) => !!j && j.trim() !== "" && B.indexOf(j) === V)
        .join(" ")
        .trim(),
    hasA11yProp = (U) => {
      for (const j in U)
        if (j.startsWith("aria-") || j === "role" || j === "title") return !0;
    };
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
  };
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const Icon = reactExports.forwardRef(
    (
      {
        color: U = "currentColor",
        size: j = 24,
        strokeWidth: V = 2,
        absoluteStrokeWidth: B,
        className: q = "",
        children: $,
        iconNode: H,
        ...G
      },
      Y
    ) =>
      reactExports.createElement(
        "svg",
        {
          ref: Y,
          ...defaultAttributes,
          width: j,
          height: j,
          stroke: U,
          strokeWidth: B ? (Number(V) * 24) / Number(j) : V,
          className: mergeClasses("lucide", q),
          ...(!$ && !hasA11yProp(G) && { "aria-hidden": "true" }),
          ...G,
        },
        [
          ...H.map(([Q, X]) => reactExports.createElement(Q, X)),
          ...(Array.isArray($) ? $ : [$]),
        ]
      )
  );
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const createLucideIcon = (U, j) => {
    const V = reactExports.forwardRef(({ className: B, ...q }, $) =>
      reactExports.createElement(Icon, {
        ref: $,
        iconNode: j,
        className: mergeClasses(
          `lucide-${toKebabCase(toPascalCase(U))}`,
          `lucide-${U}`,
          B
        ),
        ...q,
      })
    );
    return (V.displayName = toPascalCase(U)), V;
  };
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$k = [
      ["path", { d: "M12 8V4H8", key: "hb8ula" }],
      [
        "rect",
        { width: "16", height: "12", x: "4", y: "8", rx: "2", key: "enze0r" },
      ],
      ["path", { d: "M2 14h2", key: "vft8re" }],
      ["path", { d: "M20 14h2", key: "4cs60a" }],
      ["path", { d: "M15 13v2", key: "1xurst" }],
      ["path", { d: "M9 13v2", key: "rq6x2g" }],
    ],
    Bot = createLucideIcon("bot", __iconNode$k);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$j = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]],
    Check = createLucideIcon("check", __iconNode$j);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$i = [
      ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }],
    ],
    LoaderCircle = createLucideIcon("loader-circle", __iconNode$i);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$h = [
      ["path", { d: "m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7", key: "132q7q" }],
      [
        "rect",
        { x: "2", y: "4", width: "20", height: "16", rx: "2", key: "izxlao" },
      ],
    ],
    Mail = createLucideIcon("mail", __iconNode$h);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$g = [
      ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
      ["path", { d: "m21 3-7 7", key: "1l2asr" }],
      ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
      ["path", { d: "M9 21H3v-6", key: "wtvkvv" }],
    ],
    Maximize2 = createLucideIcon("maximize-2", __iconNode$g);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$f = [
      ["path", { d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z", key: "vv11sd" }],
    ],
    MessageCircle = createLucideIcon("message-circle", __iconNode$f);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$e = [
      ["line", { x1: "2", x2: "22", y1: "2", y2: "22", key: "a6p6uj" }],
      ["path", { d: "M18.89 13.23A7.12 7.12 0 0 0 19 12v-2", key: "80xlxr" }],
      ["path", { d: "M5 10v2a7 7 0 0 0 12 5", key: "p2k8kg" }],
      ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
      ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }],
      ["line", { x1: "12", x2: "12", y1: "19", y2: "22", key: "x3vr5v" }],
    ],
    MicOff = createLucideIcon("mic-off", __iconNode$e);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$d = [
      ["path", { d: "M12 19v3", key: "npa21l" }],
      ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
      [
        "rect",
        { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" },
      ],
    ],
    Mic = createLucideIcon("mic", __iconNode$d);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$c = [
      ["path", { d: "m14 10 7-7", key: "oa77jy" }],
      ["path", { d: "M20 10h-6V4", key: "mjg0md" }],
      ["path", { d: "m3 21 7-7", key: "tjx5ai" }],
      ["path", { d: "M4 14h6v6", key: "rmj7iw" }],
    ],
    Minimize2 = createLucideIcon("minimize-2", __iconNode$c);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$b = [
      [
        "path",
        {
          d: "M10.1 13.9a14 14 0 0 0 3.732 2.668 1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2 18 18 0 0 1-12.728-5.272",
          key: "1wngk7",
        },
      ],
      ["path", { d: "M22 2 2 22", key: "y4kqgn" }],
      [
        "path",
        {
          d: "M4.76 13.582A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 .244.473",
          key: "10hv5p",
        },
      ],
    ],
    PhoneOff = createLucideIcon("phone-off", __iconNode$b);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$a = [
      [
        "path",
        {
          d: "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",
          key: "9njp5v",
        },
      ],
    ],
    Phone = createLucideIcon("phone", __iconNode$a);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$9 = [
      [
        "path",
        {
          d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
          key: "1ffxy3",
        },
      ],
      ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }],
    ],
    Send = createLucideIcon("send", __iconNode$9);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$8 = [
      [
        "path",
        {
          d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
          key: "4pj2yx",
        },
      ],
      ["path", { d: "M20 3v4", key: "1olli1" }],
      ["path", { d: "M22 5h-4", key: "1gvqau" }],
      ["path", { d: "M4 17v2", key: "vumght" }],
      ["path", { d: "M5 18H3", key: "zchphs" }],
    ],
    Sparkles = createLucideIcon("sparkles", __iconNode$8);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$7 = [
      ["path", { d: "M3 6h18", key: "d0wm0j" }],
      ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
      ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
      ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
      ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }],
    ],
    Trash2 = createLucideIcon("trash-2", __iconNode$7);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$6 = [
      [
        "path",
        { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" },
      ],
      ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }],
    ],
    User = createLucideIcon("user", __iconNode$6);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$5 = [
      [
        "path",
        {
          d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196",
          key: "w8jjjt",
        },
      ],
      [
        "path",
        {
          d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2",
          key: "1xawa7",
        },
      ],
      ["path", { d: "m2 2 20 20", key: "1ooewy" }],
    ],
    VideoOff = createLucideIcon("video-off", __iconNode$5);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$4 = [
      [
        "path",
        {
          d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
          key: "ftymec",
        },
      ],
      [
        "rect",
        { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" },
      ],
    ],
    Video = createLucideIcon("video", __iconNode$4);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$3 = [
      [
        "path",
        {
          d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
          key: "uqj9uw",
        },
      ],
      ["path", { d: "M16 9a5 5 0 0 1 0 6", key: "1q6k2b" }],
      ["path", { d: "M19.364 18.364a9 9 0 0 0 0-12.728", key: "ijwkga" }],
    ],
    Volume2 = createLucideIcon("volume-2", __iconNode$3);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$2 = [
      [
        "path",
        {
          d: "M11 4.702a.705.705 0 0 0-1.203-.498L6.413 7.587A1.4 1.4 0 0 1 5.416 8H3a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h2.416a1.4 1.4 0 0 1 .997.413l3.383 3.384A.705.705 0 0 0 11 19.298z",
          key: "uqj9uw",
        },
      ],
      ["line", { x1: "22", x2: "16", y1: "9", y2: "15", key: "1ewh16" }],
      ["line", { x1: "16", x2: "22", y1: "9", y2: "15", key: "5ykzw1" }],
    ],
    VolumeX = createLucideIcon("volume-x", __iconNode$2);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode$1 = [
      ["path", { d: "M12 20h.01", key: "zekei9" }],
      ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }],
      ["path", { d: "M5 12.859a10 10 0 0 1 5.17-2.69", key: "1dl1wf" }],
      ["path", { d: "M19 12.859a10 10 0 0 0-2.007-1.523", key: "4k23kn" }],
      ["path", { d: "M2 8.82a15 15 0 0 1 4.177-2.643", key: "1grhjp" }],
      ["path", { d: "M22 8.82a15 15 0 0 0-11.288-3.764", key: "z3jwby" }],
      ["path", { d: "m2 2 20 20", key: "1ooewy" }],
    ],
    WifiOff = createLucideIcon("wifi-off", __iconNode$1);
  /**
   * @license lucide-react v0.525.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   */ const __iconNode = [
      ["path", { d: "M12 20h.01", key: "zekei9" }],
      ["path", { d: "M2 8.82a15 15 0 0 1 20 0", key: "dnpr2z" }],
      ["path", { d: "M5 12.859a10 10 0 0 1 14 0", key: "1x1e6c" }],
      ["path", { d: "M8.5 16.429a5 5 0 0 1 7 0", key: "1bycff" }],
    ],
    Wifi = createLucideIcon("wifi", __iconNode);
  var define_process_env_default = {};
  function _mergeNamespaces$1(U, j) {
    return (
      j.forEach(function (V) {
        V &&
          typeof V != "string" &&
          !Array.isArray(V) &&
          Object.keys(V).forEach(function (B) {
            if (B !== "default" && !(B in U)) {
              var q = Object.getOwnPropertyDescriptor(V, B);
              Object.defineProperty(
                U,
                B,
                q.get
                  ? q
                  : {
                      enumerable: !0,
                      get: function () {
                        return V[B];
                      },
                    }
              );
            }
          });
      }),
      Object.freeze(U)
    );
  }
  var e$1 = Object.defineProperty,
    h$1 = (U, j, V) =>
      j in U
        ? e$1(U, j, {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: V,
          })
        : (U[j] = V),
    o$1 = (U, j, V) => h$1(U, typeof j != "symbol" ? j + "" : j, V);
  let _$1 = class {
    constructor() {
      o$1(this, "_locking"),
        o$1(this, "_locks"),
        (this._locking = Promise.resolve()),
        (this._locks = 0);
    }
    isLocked() {
      return this._locks > 0;
    }
    lock() {
      this._locks += 1;
      let j;
      const V = new Promise(
          (q) =>
            (j = () => {
              (this._locks -= 1), q();
            })
        ),
        B = this._locking.then(() => j);
      return (this._locking = this._locking.then(() => V)), B;
    }
  };
  function assert(U, j) {
    if (!U) throw new Error(j);
  }
  const FLOAT32_MAX = 34028234663852886e22,
    FLOAT32_MIN = -34028234663852886e22,
    UINT32_MAX = 4294967295,
    INT32_MAX = 2147483647,
    INT32_MIN = -2147483648;
  function assertInt32(U) {
    if (typeof U != "number") throw new Error("invalid int 32: " + typeof U);
    if (!Number.isInteger(U) || U > INT32_MAX || U < INT32_MIN)
      throw new Error("invalid int 32: " + U);
  }
  function assertUInt32(U) {
    if (typeof U != "number") throw new Error("invalid uint 32: " + typeof U);
    if (!Number.isInteger(U) || U > UINT32_MAX || U < 0)
      throw new Error("invalid uint 32: " + U);
  }
  function assertFloat32(U) {
    if (typeof U != "number") throw new Error("invalid float 32: " + typeof U);
    if (Number.isFinite(U) && (U > FLOAT32_MAX || U < FLOAT32_MIN))
      throw new Error("invalid float 32: " + U);
  }
  const enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
  function getEnumType(U) {
    const j = U[enumTypeSymbol];
    return assert(j, "missing enum type on enum object"), j;
  }
  function setEnumType(U, j, V, B) {
    U[enumTypeSymbol] = makeEnumType(
      j,
      V.map((q) => ({ no: q.no, name: q.name, localName: U[q.no] }))
    );
  }
  function makeEnumType(U, j, V) {
    const B = Object.create(null),
      q = Object.create(null),
      $ = [];
    for (const H of j) {
      const G = normalizeEnumValue(H);
      $.push(G), (B[H.name] = G), (q[H.no] = G);
    }
    return {
      typeName: U,
      values: $,
      findName(H) {
        return B[H];
      },
      findNumber(H) {
        return q[H];
      },
    };
  }
  function makeEnum(U, j, V) {
    const B = {};
    for (const q of j) {
      const $ = normalizeEnumValue(q);
      (B[$.localName] = $.no), (B[$.no] = $.localName);
    }
    return setEnumType(B, U, j), B;
  }
  function normalizeEnumValue(U) {
    return "localName" in U
      ? U
      : Object.assign(Object.assign({}, U), { localName: U.name });
  }
  class Message {
    equals(j) {
      return this.getType().runtime.util.equals(this.getType(), this, j);
    }
    clone() {
      return this.getType().runtime.util.clone(this);
    }
    fromBinary(j, V) {
      const B = this.getType(),
        q = B.runtime.bin,
        $ = q.makeReadOptions(V);
      return q.readMessage(this, $.readerFactory(j), j.byteLength, $), this;
    }
    fromJson(j, V) {
      const B = this.getType(),
        q = B.runtime.json,
        $ = q.makeReadOptions(V);
      return q.readMessage(B, j, $, this), this;
    }
    fromJsonString(j, V) {
      let B;
      try {
        B = JSON.parse(j);
      } catch (q) {
        throw new Error(
          "cannot decode "
            .concat(this.getType().typeName, " from JSON: ")
            .concat(q instanceof Error ? q.message : String(q))
        );
      }
      return this.fromJson(B, V);
    }
    toBinary(j) {
      const V = this.getType(),
        B = V.runtime.bin,
        q = B.makeWriteOptions(j),
        $ = q.writerFactory();
      return B.writeMessage(this, $, q), $.finish();
    }
    toJson(j) {
      const V = this.getType(),
        B = V.runtime.json,
        q = B.makeWriteOptions(j);
      return B.writeMessage(this, q);
    }
    toJsonString(j) {
      var V;
      const B = this.toJson(j);
      return JSON.stringify(
        B,
        null,
        (V = j?.prettySpaces) !== null && V !== void 0 ? V : 0
      );
    }
    toJSON() {
      return this.toJson({ emitDefaultValues: !0 });
    }
    getType() {
      return Object.getPrototypeOf(this).constructor;
    }
  }
  function makeMessageType(U, j, V, B) {
    var q;
    const $ =
        (q = B?.localName) !== null && q !== void 0
          ? q
          : j.substring(j.lastIndexOf(".") + 1),
      H = {
        [$]: function (G) {
          U.util.initFields(this), U.util.initPartial(G, this);
        },
      }[$];
    return (
      Object.setPrototypeOf(H.prototype, new Message()),
      Object.assign(H, {
        runtime: U,
        typeName: j,
        fields: U.util.newFieldList(V),
        fromBinary(G, Y) {
          return new H().fromBinary(G, Y);
        },
        fromJson(G, Y) {
          return new H().fromJson(G, Y);
        },
        fromJsonString(G, Y) {
          return new H().fromJsonString(G, Y);
        },
        equals(G, Y) {
          return U.util.equals(H, G, Y);
        },
      }),
      H
    );
  }
  function varint64read() {
    let U = 0,
      j = 0;
    for (let B = 0; B < 28; B += 7) {
      let q = this.buf[this.pos++];
      if (((U |= (q & 127) << B), (q & 128) == 0))
        return this.assertBounds(), [U, j];
    }
    let V = this.buf[this.pos++];
    if (((U |= (V & 15) << 28), (j = (V & 112) >> 4), (V & 128) == 0))
      return this.assertBounds(), [U, j];
    for (let B = 3; B <= 31; B += 7) {
      let q = this.buf[this.pos++];
      if (((j |= (q & 127) << B), (q & 128) == 0))
        return this.assertBounds(), [U, j];
    }
    throw new Error("invalid varint");
  }
  function varint64write(U, j, V) {
    for (let $ = 0; $ < 28; $ = $ + 7) {
      const H = U >>> $,
        G = !(!(H >>> 7) && j == 0),
        Y = (G ? H | 128 : H) & 255;
      if ((V.push(Y), !G)) return;
    }
    const B = ((U >>> 28) & 15) | ((j & 7) << 4),
      q = j >> 3 != 0;
    if ((V.push((q ? B | 128 : B) & 255), !!q)) {
      for (let $ = 3; $ < 31; $ = $ + 7) {
        const H = j >>> $,
          G = !!(H >>> 7),
          Y = (G ? H | 128 : H) & 255;
        if ((V.push(Y), !G)) return;
      }
      V.push((j >>> 31) & 1);
    }
  }
  const TWO_PWR_32_DBL = 4294967296;
  function int64FromString(U) {
    const j = U[0] === "-";
    j && (U = U.slice(1));
    const V = 1e6;
    let B = 0,
      q = 0;
    function $(H, G) {
      const Y = Number(U.slice(H, G));
      (q *= V),
        (B = B * V + Y),
        B >= TWO_PWR_32_DBL &&
          ((q = q + ((B / TWO_PWR_32_DBL) | 0)), (B = B % TWO_PWR_32_DBL));
    }
    return (
      $(-24, -18),
      $(-18, -12),
      $(-12, -6),
      $(-6),
      j ? negate(B, q) : newBits(B, q)
    );
  }
  function int64ToString(U, j) {
    let V = newBits(U, j);
    const B = V.hi & 2147483648;
    B && (V = negate(V.lo, V.hi));
    const q = uInt64ToString(V.lo, V.hi);
    return B ? "-" + q : q;
  }
  function uInt64ToString(U, j) {
    if ((({ lo: U, hi: j } = toUnsigned(U, j)), j <= 2097151))
      return String(TWO_PWR_32_DBL * j + U);
    const V = U & 16777215,
      B = ((U >>> 24) | (j << 8)) & 16777215,
      q = (j >> 16) & 65535;
    let $ = V + B * 6777216 + q * 6710656,
      H = B + q * 8147497,
      G = q * 2;
    const Y = 1e7;
    return (
      $ >= Y && ((H += Math.floor($ / Y)), ($ %= Y)),
      H >= Y && ((G += Math.floor(H / Y)), (H %= Y)),
      G.toString() +
        decimalFrom1e7WithLeadingZeros(H) +
        decimalFrom1e7WithLeadingZeros($)
    );
  }
  function toUnsigned(U, j) {
    return { lo: U >>> 0, hi: j >>> 0 };
  }
  function newBits(U, j) {
    return { lo: U | 0, hi: j | 0 };
  }
  function negate(U, j) {
    return (j = ~j), U ? (U = ~U + 1) : (j += 1), newBits(U, j);
  }
  const decimalFrom1e7WithLeadingZeros = (U) => {
    const j = String(U);
    return "0000000".slice(j.length) + j;
  };
  function varint32write(U, j) {
    if (U >= 0) {
      for (; U > 127; ) j.push((U & 127) | 128), (U = U >>> 7);
      j.push(U);
    } else {
      for (let V = 0; V < 9; V++) j.push((U & 127) | 128), (U = U >> 7);
      j.push(1);
    }
  }
  function varint32read() {
    let U = this.buf[this.pos++],
      j = U & 127;
    if ((U & 128) == 0) return this.assertBounds(), j;
    if (((U = this.buf[this.pos++]), (j |= (U & 127) << 7), (U & 128) == 0))
      return this.assertBounds(), j;
    if (((U = this.buf[this.pos++]), (j |= (U & 127) << 14), (U & 128) == 0))
      return this.assertBounds(), j;
    if (((U = this.buf[this.pos++]), (j |= (U & 127) << 21), (U & 128) == 0))
      return this.assertBounds(), j;
    (U = this.buf[this.pos++]), (j |= (U & 15) << 28);
    for (let V = 5; (U & 128) !== 0 && V < 10; V++) U = this.buf[this.pos++];
    if ((U & 128) != 0) throw new Error("invalid varint");
    return this.assertBounds(), j >>> 0;
  }
  function makeInt64Support() {
    const U = new DataView(new ArrayBuffer(8));
    if (
      typeof BigInt == "function" &&
      typeof U.getBigInt64 == "function" &&
      typeof U.getBigUint64 == "function" &&
      typeof U.setBigInt64 == "function" &&
      typeof U.setBigUint64 == "function" &&
      (typeof process != "object" ||
        typeof define_process_env_default != "object" ||
        define_process_env_default.BUF_BIGINT_DISABLE !== "1")
    ) {
      const q = BigInt("-9223372036854775808"),
        $ = BigInt("9223372036854775807"),
        H = BigInt("0"),
        G = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: !0,
        parse(Y) {
          const Q = typeof Y == "bigint" ? Y : BigInt(Y);
          if (Q > $ || Q < q) throw new Error("int64 invalid: ".concat(Y));
          return Q;
        },
        uParse(Y) {
          const Q = typeof Y == "bigint" ? Y : BigInt(Y);
          if (Q > G || Q < H) throw new Error("uint64 invalid: ".concat(Y));
          return Q;
        },
        enc(Y) {
          return (
            U.setBigInt64(0, this.parse(Y), !0),
            { lo: U.getInt32(0, !0), hi: U.getInt32(4, !0) }
          );
        },
        uEnc(Y) {
          return (
            U.setBigInt64(0, this.uParse(Y), !0),
            { lo: U.getInt32(0, !0), hi: U.getInt32(4, !0) }
          );
        },
        dec(Y, Q) {
          return (
            U.setInt32(0, Y, !0), U.setInt32(4, Q, !0), U.getBigInt64(0, !0)
          );
        },
        uDec(Y, Q) {
          return (
            U.setInt32(0, Y, !0), U.setInt32(4, Q, !0), U.getBigUint64(0, !0)
          );
        },
      };
    }
    const V = (q) => assert(/^-?[0-9]+$/.test(q), "int64 invalid: ".concat(q)),
      B = (q) => assert(/^[0-9]+$/.test(q), "uint64 invalid: ".concat(q));
    return {
      zero: "0",
      supported: !1,
      parse(q) {
        return typeof q != "string" && (q = q.toString()), V(q), q;
      },
      uParse(q) {
        return typeof q != "string" && (q = q.toString()), B(q), q;
      },
      enc(q) {
        return (
          typeof q != "string" && (q = q.toString()), V(q), int64FromString(q)
        );
      },
      uEnc(q) {
        return (
          typeof q != "string" && (q = q.toString()), B(q), int64FromString(q)
        );
      },
      dec(q, $) {
        return int64ToString(q, $);
      },
      uDec(q, $) {
        return uInt64ToString(q, $);
      },
    };
  }
  const protoInt64 = makeInt64Support();
  var ScalarType;
  (function (U) {
    (U[(U.DOUBLE = 1)] = "DOUBLE"),
      (U[(U.FLOAT = 2)] = "FLOAT"),
      (U[(U.INT64 = 3)] = "INT64"),
      (U[(U.UINT64 = 4)] = "UINT64"),
      (U[(U.INT32 = 5)] = "INT32"),
      (U[(U.FIXED64 = 6)] = "FIXED64"),
      (U[(U.FIXED32 = 7)] = "FIXED32"),
      (U[(U.BOOL = 8)] = "BOOL"),
      (U[(U.STRING = 9)] = "STRING"),
      (U[(U.BYTES = 12)] = "BYTES"),
      (U[(U.UINT32 = 13)] = "UINT32"),
      (U[(U.SFIXED32 = 15)] = "SFIXED32"),
      (U[(U.SFIXED64 = 16)] = "SFIXED64"),
      (U[(U.SINT32 = 17)] = "SINT32"),
      (U[(U.SINT64 = 18)] = "SINT64");
  })(ScalarType || (ScalarType = {}));
  var LongType;
  (function (U) {
    (U[(U.BIGINT = 0)] = "BIGINT"), (U[(U.STRING = 1)] = "STRING");
  })(LongType || (LongType = {}));
  function scalarEquals(U, j, V) {
    if (j === V) return !0;
    if (U == ScalarType.BYTES) {
      if (
        !(j instanceof Uint8Array) ||
        !(V instanceof Uint8Array) ||
        j.length !== V.length
      )
        return !1;
      for (let B = 0; B < j.length; B++) if (j[B] !== V[B]) return !1;
      return !0;
    }
    switch (U) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return j == V;
    }
    return !1;
  }
  function scalarZeroValue(U, j) {
    switch (U) {
      case ScalarType.BOOL:
        return !1;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return j == 0 ? protoInt64.zero : "0";
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function isScalarZeroValue(U, j) {
    switch (U) {
      case ScalarType.BOOL:
        return j === !1;
      case ScalarType.STRING:
        return j === "";
      case ScalarType.BYTES:
        return j instanceof Uint8Array && !j.byteLength;
      default:
        return j == 0;
    }
  }
  var WireType;
  (function (U) {
    (U[(U.Varint = 0)] = "Varint"),
      (U[(U.Bit64 = 1)] = "Bit64"),
      (U[(U.LengthDelimited = 2)] = "LengthDelimited"),
      (U[(U.StartGroup = 3)] = "StartGroup"),
      (U[(U.EndGroup = 4)] = "EndGroup"),
      (U[(U.Bit32 = 5)] = "Bit32");
  })(WireType || (WireType = {}));
  class BinaryWriter {
    constructor(j) {
      (this.stack = []),
        (this.textEncoder = j ?? new TextEncoder()),
        (this.chunks = []),
        (this.buf = []);
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let j = 0;
      for (let q = 0; q < this.chunks.length; q++) j += this.chunks[q].length;
      let V = new Uint8Array(j),
        B = 0;
      for (let q = 0; q < this.chunks.length; q++)
        V.set(this.chunks[q], B), (B += this.chunks[q].length);
      return (this.chunks = []), V;
    }
    fork() {
      return (
        this.stack.push({ chunks: this.chunks, buf: this.buf }),
        (this.chunks = []),
        (this.buf = []),
        this
      );
    }
    join() {
      let j = this.finish(),
        V = this.stack.pop();
      if (!V) throw new Error("invalid state, fork stack empty");
      return (
        (this.chunks = V.chunks),
        (this.buf = V.buf),
        this.uint32(j.byteLength),
        this.raw(j)
      );
    }
    tag(j, V) {
      return this.uint32(((j << 3) | V) >>> 0);
    }
    raw(j) {
      return (
        this.buf.length &&
          (this.chunks.push(new Uint8Array(this.buf)), (this.buf = [])),
        this.chunks.push(j),
        this
      );
    }
    uint32(j) {
      for (assertUInt32(j); j > 127; )
        this.buf.push((j & 127) | 128), (j = j >>> 7);
      return this.buf.push(j), this;
    }
    int32(j) {
      return assertInt32(j), varint32write(j, this.buf), this;
    }
    bool(j) {
      return this.buf.push(j ? 1 : 0), this;
    }
    bytes(j) {
      return this.uint32(j.byteLength), this.raw(j);
    }
    string(j) {
      let V = this.textEncoder.encode(j);
      return this.uint32(V.byteLength), this.raw(V);
    }
    float(j) {
      assertFloat32(j);
      let V = new Uint8Array(4);
      return new DataView(V.buffer).setFloat32(0, j, !0), this.raw(V);
    }
    double(j) {
      let V = new Uint8Array(8);
      return new DataView(V.buffer).setFloat64(0, j, !0), this.raw(V);
    }
    fixed32(j) {
      assertUInt32(j);
      let V = new Uint8Array(4);
      return new DataView(V.buffer).setUint32(0, j, !0), this.raw(V);
    }
    sfixed32(j) {
      assertInt32(j);
      let V = new Uint8Array(4);
      return new DataView(V.buffer).setInt32(0, j, !0), this.raw(V);
    }
    sint32(j) {
      return (
        assertInt32(j),
        (j = ((j << 1) ^ (j >> 31)) >>> 0),
        varint32write(j, this.buf),
        this
      );
    }
    sfixed64(j) {
      let V = new Uint8Array(8),
        B = new DataView(V.buffer),
        q = protoInt64.enc(j);
      return B.setInt32(0, q.lo, !0), B.setInt32(4, q.hi, !0), this.raw(V);
    }
    fixed64(j) {
      let V = new Uint8Array(8),
        B = new DataView(V.buffer),
        q = protoInt64.uEnc(j);
      return B.setInt32(0, q.lo, !0), B.setInt32(4, q.hi, !0), this.raw(V);
    }
    int64(j) {
      let V = protoInt64.enc(j);
      return varint64write(V.lo, V.hi, this.buf), this;
    }
    sint64(j) {
      let V = protoInt64.enc(j),
        B = V.hi >> 31,
        q = (V.lo << 1) ^ B,
        $ = ((V.hi << 1) | (V.lo >>> 31)) ^ B;
      return varint64write(q, $, this.buf), this;
    }
    uint64(j) {
      let V = protoInt64.uEnc(j);
      return varint64write(V.lo, V.hi, this.buf), this;
    }
  }
  class BinaryReader {
    constructor(j, V) {
      (this.varint64 = varint64read),
        (this.uint32 = varint32read),
        (this.buf = j),
        (this.len = j.length),
        (this.pos = 0),
        (this.view = new DataView(j.buffer, j.byteOffset, j.byteLength)),
        (this.textDecoder = V ?? new TextDecoder());
    }
    tag() {
      let j = this.uint32(),
        V = j >>> 3,
        B = j & 7;
      if (V <= 0 || B < 0 || B > 5)
        throw new Error("illegal tag: field no " + V + " wire type " + B);
      return [V, B];
    }
    skip(j, V) {
      let B = this.pos;
      switch (j) {
        case WireType.Varint:
          for (; this.buf[this.pos++] & 128; );
          break;
        case WireType.Bit64:
          this.pos += 4;
        case WireType.Bit32:
          this.pos += 4;
          break;
        case WireType.LengthDelimited:
          let q = this.uint32();
          this.pos += q;
          break;
        case WireType.StartGroup:
          for (;;) {
            const [$, H] = this.tag();
            if (H === WireType.EndGroup) {
              if (V !== void 0 && $ !== V)
                throw new Error("invalid end group tag");
              break;
            }
            this.skip(H, $);
          }
          break;
        default:
          throw new Error("cant skip wire type " + j);
      }
      return this.assertBounds(), this.buf.subarray(B, this.pos);
    }
    assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF");
    }
    int32() {
      return this.uint32() | 0;
    }
    sint32() {
      let j = this.uint32();
      return (j >>> 1) ^ -(j & 1);
    }
    int64() {
      return protoInt64.dec(...this.varint64());
    }
    uint64() {
      return protoInt64.uDec(...this.varint64());
    }
    sint64() {
      let [j, V] = this.varint64(),
        B = -(j & 1);
      return (
        (j = ((j >>> 1) | ((V & 1) << 31)) ^ B),
        (V = (V >>> 1) ^ B),
        protoInt64.dec(j, V)
      );
    }
    bool() {
      let [j, V] = this.varint64();
      return j !== 0 || V !== 0;
    }
    fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, !0);
    }
    sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, !0);
    }
    fixed64() {
      return protoInt64.uDec(this.sfixed32(), this.sfixed32());
    }
    sfixed64() {
      return protoInt64.dec(this.sfixed32(), this.sfixed32());
    }
    float() {
      return this.view.getFloat32((this.pos += 4) - 4, !0);
    }
    double() {
      return this.view.getFloat64((this.pos += 8) - 8, !0);
    }
    bytes() {
      let j = this.uint32(),
        V = this.pos;
      return (this.pos += j), this.assertBounds(), this.buf.subarray(V, V + j);
    }
    string() {
      return this.textDecoder.decode(this.bytes());
    }
  }
  function makeExtension(U, j, V, B) {
    let q;
    return {
      typeName: j,
      extendee: V,
      get field() {
        if (!q) {
          const $ = typeof B == "function" ? B() : B;
          ($.name = j.split(".").pop()),
            ($.jsonName = "[".concat(j, "]")),
            (q = U.util.newFieldList([$]).list()[0]);
        }
        return q;
      },
      runtime: U,
    };
  }
  function createExtensionContainer(U) {
    const j = U.field.localName,
      V = Object.create(null);
    return (V[j] = initExtensionField(U)), [V, () => V[j]];
  }
  function initExtensionField(U) {
    const j = U.field;
    if (j.repeated) return [];
    if (j.default !== void 0) return j.default;
    switch (j.kind) {
      case "enum":
        return j.T.values[0].no;
      case "scalar":
        return scalarZeroValue(j.T, j.L);
      case "message":
        const V = j.T,
          B = new V();
        return V.fieldWrapper ? V.fieldWrapper.unwrapField(B) : B;
      case "map":
        throw "map fields are not allowed to be extensions";
    }
  }
  function filterUnknownFields(U, j) {
    if (!j.repeated && (j.kind == "enum" || j.kind == "scalar")) {
      for (let V = U.length - 1; V >= 0; --V)
        if (U[V].no == j.no) return [U[V]];
      return [];
    }
    return U.filter((V) => V.no === j.no);
  }
  let encTable =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
        ""
      ),
    decTable = [];
  for (let U = 0; U < encTable.length; U++)
    decTable[encTable[U].charCodeAt(0)] = U;
  (decTable[45] = encTable.indexOf("+")),
    (decTable[95] = encTable.indexOf("/"));
  const protoBase64 = {
    dec(U) {
      let j = (U.length * 3) / 4;
      U[U.length - 2] == "=" ? (j -= 2) : U[U.length - 1] == "=" && (j -= 1);
      let V = new Uint8Array(j),
        B = 0,
        q = 0,
        $,
        H = 0;
      for (let G = 0; G < U.length; G++) {
        if ((($ = decTable[U.charCodeAt(G)]), $ === void 0))
          switch (U[G]) {
            case "=":
              q = 0;
            case `
`:
            case "\r":
            case "	":
            case " ":
              continue;
            default:
              throw Error("invalid base64 string.");
          }
        switch (q) {
          case 0:
            (H = $), (q = 1);
            break;
          case 1:
            (V[B++] = (H << 2) | (($ & 48) >> 4)), (H = $), (q = 2);
            break;
          case 2:
            (V[B++] = ((H & 15) << 4) | (($ & 60) >> 2)), (H = $), (q = 3);
            break;
          case 3:
            (V[B++] = ((H & 3) << 6) | $), (q = 0);
            break;
        }
      }
      if (q == 1) throw Error("invalid base64 string.");
      return V.subarray(0, B);
    },
    enc(U) {
      let j = "",
        V = 0,
        B,
        q = 0;
      for (let $ = 0; $ < U.length; $++)
        switch (((B = U[$]), V)) {
          case 0:
            (j += encTable[B >> 2]), (q = (B & 3) << 4), (V = 1);
            break;
          case 1:
            (j += encTable[q | (B >> 4)]), (q = (B & 15) << 2), (V = 2);
            break;
          case 2:
            (j += encTable[q | (B >> 6)]), (j += encTable[B & 63]), (V = 0);
            break;
        }
      return V && ((j += encTable[q]), (j += "="), V == 1 && (j += "=")), j;
    },
  };
  function getExtension(U, j, V) {
    assertExtendee(j, U);
    const B = j.runtime.bin.makeReadOptions(V),
      q = filterUnknownFields(
        U.getType().runtime.bin.listUnknownFields(U),
        j.field
      ),
      [$, H] = createExtensionContainer(j);
    for (const G of q)
      j.runtime.bin.readField(
        $,
        B.readerFactory(G.data),
        j.field,
        G.wireType,
        B
      );
    return H();
  }
  function setExtension(U, j, V, B) {
    assertExtendee(j, U);
    const q = j.runtime.bin.makeReadOptions(B),
      $ = j.runtime.bin.makeWriteOptions(B);
    if (hasExtension(U, j)) {
      const Q = U.getType()
        .runtime.bin.listUnknownFields(U)
        .filter((X) => X.no != j.field.no);
      U.getType().runtime.bin.discardUnknownFields(U);
      for (const X of Q)
        U.getType().runtime.bin.onUnknownField(U, X.no, X.wireType, X.data);
    }
    const H = $.writerFactory();
    let G = j.field;
    !G.opt &&
      !G.repeated &&
      (G.kind == "enum" || G.kind == "scalar") &&
      (G = Object.assign(Object.assign({}, j.field), { opt: !0 })),
      j.runtime.bin.writeField(G, V, H, $);
    const Y = q.readerFactory(H.finish());
    for (; Y.pos < Y.len; ) {
      const [Q, X] = Y.tag(),
        Z = Y.skip(X, Q);
      U.getType().runtime.bin.onUnknownField(U, Q, X, Z);
    }
  }
  function hasExtension(U, j) {
    const V = U.getType();
    return (
      j.extendee.typeName === V.typeName &&
      !!V.runtime.bin.listUnknownFields(U).find((B) => B.no == j.field.no)
    );
  }
  function assertExtendee(U, j) {
    assert(
      U.extendee.typeName == j.getType().typeName,
      "extension "
        .concat(U.typeName, " can only be applied to message ")
        .concat(U.extendee.typeName)
    );
  }
  function isFieldSet(U, j) {
    const V = U.localName;
    if (U.repeated) return j[V].length > 0;
    if (U.oneof) return j[U.oneof.localName].case === V;
    switch (U.kind) {
      case "enum":
      case "scalar":
        return U.opt || U.req
          ? j[V] !== void 0
          : U.kind == "enum"
          ? j[V] !== U.T.values[0].no
          : !isScalarZeroValue(U.T, j[V]);
      case "message":
        return j[V] !== void 0;
      case "map":
        return Object.keys(j[V]).length > 0;
    }
  }
  function clearField(U, j) {
    const V = U.localName,
      B = !U.opt && !U.req;
    if (U.repeated) j[V] = [];
    else if (U.oneof) j[U.oneof.localName] = { case: void 0 };
    else
      switch (U.kind) {
        case "map":
          j[V] = {};
          break;
        case "enum":
          j[V] = B ? U.T.values[0].no : void 0;
          break;
        case "scalar":
          j[V] = B ? scalarZeroValue(U.T, U.L) : void 0;
          break;
        case "message":
          j[V] = void 0;
          break;
      }
  }
  function isMessage(U, j) {
    if (
      U === null ||
      typeof U != "object" ||
      !Object.getOwnPropertyNames(Message.prototype).every(
        (B) => B in U && typeof U[B] == "function"
      )
    )
      return !1;
    const V = U.getType();
    return V === null ||
      typeof V != "function" ||
      !("typeName" in V) ||
      typeof V.typeName != "string"
      ? !1
      : j === void 0
      ? !0
      : V.typeName == j.typeName;
  }
  function wrapField(U, j) {
    return isMessage(j) || !U.fieldWrapper ? j : U.fieldWrapper.wrapField(j);
  }
  ScalarType.DOUBLE,
    ScalarType.FLOAT,
    ScalarType.INT64,
    ScalarType.UINT64,
    ScalarType.INT32,
    ScalarType.UINT32,
    ScalarType.BOOL,
    ScalarType.STRING,
    ScalarType.BYTES;
  const jsonReadDefaults = { ignoreUnknownFields: !1 },
    jsonWriteDefaults = {
      emitDefaultValues: !1,
      enumAsInteger: !1,
      useProtoFieldName: !1,
      prettySpaces: 0,
    };
  function makeReadOptions$1(U) {
    return U
      ? Object.assign(Object.assign({}, jsonReadDefaults), U)
      : jsonReadDefaults;
  }
  function makeWriteOptions$1(U) {
    return U
      ? Object.assign(Object.assign({}, jsonWriteDefaults), U)
      : jsonWriteDefaults;
  }
  const tokenNull = Symbol(),
    tokenIgnoredUnknownEnum = Symbol();
  function makeJsonFormat() {
    return {
      makeReadOptions: makeReadOptions$1,
      makeWriteOptions: makeWriteOptions$1,
      readMessage(U, j, V, B) {
        if (j == null || Array.isArray(j) || typeof j != "object")
          throw new Error(
            "cannot decode message "
              .concat(U.typeName, " from JSON: ")
              .concat(debugJsonValue(j))
          );
        B = B ?? new U();
        const q = new Map(),
          $ = V.typeRegistry;
        for (const [H, G] of Object.entries(j)) {
          const Y = U.fields.findJsonName(H);
          if (Y) {
            if (Y.oneof) {
              if (G === null && Y.kind == "scalar") continue;
              const Q = q.get(Y.oneof);
              if (Q !== void 0)
                throw new Error(
                  "cannot decode message "
                    .concat(U.typeName, ' from JSON: multiple keys for oneof "')
                    .concat(Y.oneof.name, '" present: "')
                    .concat(Q, '", "')
                    .concat(H, '"')
                );
              q.set(Y.oneof, H);
            }
            readField$1(B, G, Y, V, U);
          } else {
            let Q = !1;
            if ($?.findExtension && H.startsWith("[") && H.endsWith("]")) {
              const X = $.findExtension(H.substring(1, H.length - 1));
              if (X && X.extendee.typeName == U.typeName) {
                Q = !0;
                const [Z, te] = createExtensionContainer(X);
                readField$1(Z, G, X.field, V, X), setExtension(B, X, te(), V);
              }
            }
            if (!Q && !V.ignoreUnknownFields)
              throw new Error(
                "cannot decode message "
                  .concat(U.typeName, ' from JSON: key "')
                  .concat(H, '" is unknown')
              );
          }
        }
        return B;
      },
      writeMessage(U, j) {
        const V = U.getType(),
          B = {};
        let q;
        try {
          for (q of V.fields.byNumber()) {
            if (!isFieldSet(q, U)) {
              if (q.req) throw "required field not set";
              if (!j.emitDefaultValues || !canEmitFieldDefaultValue(q))
                continue;
            }
            const H = q.oneof ? U[q.oneof.localName].value : U[q.localName],
              G = writeField$1(q, H, j);
            G !== void 0 && (B[j.useProtoFieldName ? q.name : q.jsonName] = G);
          }
          const $ = j.typeRegistry;
          if ($?.findExtensionFor)
            for (const H of V.runtime.bin.listUnknownFields(U)) {
              const G = $.findExtensionFor(V.typeName, H.no);
              if (G && hasExtension(U, G)) {
                const Y = getExtension(U, G, j),
                  Q = writeField$1(G.field, Y, j);
                Q !== void 0 && (B[G.field.jsonName] = Q);
              }
            }
        } catch ($) {
          const H = q
              ? "cannot encode field "
                  .concat(V.typeName, ".")
                  .concat(q.name, " to JSON")
              : "cannot encode message ".concat(V.typeName, " to JSON"),
            G = $ instanceof Error ? $.message : String($);
          throw new Error(H + (G.length > 0 ? ": ".concat(G) : ""));
        }
        return B;
      },
      readScalar(U, j, V) {
        return readScalar$1(U, j, V ?? LongType.BIGINT, !0);
      },
      writeScalar(U, j, V) {
        if (j !== void 0 && (V || isScalarZeroValue(U, j)))
          return writeScalar$1(U, j);
      },
      debug: debugJsonValue,
    };
  }
  function debugJsonValue(U) {
    if (U === null) return "null";
    switch (typeof U) {
      case "object":
        return Array.isArray(U) ? "array" : "object";
      case "string":
        return U.length > 100
          ? "string"
          : '"'.concat(U.split('"').join('\\"'), '"');
      default:
        return String(U);
    }
  }
  function readField$1(U, j, V, B, q) {
    let $ = V.localName;
    if (V.repeated) {
      if ((assert(V.kind != "map"), j === null)) return;
      if (!Array.isArray(j))
        throw new Error(
          "cannot decode field "
            .concat(q.typeName, ".")
            .concat(V.name, " from JSON: ")
            .concat(debugJsonValue(j))
        );
      const H = U[$];
      for (const G of j) {
        if (G === null)
          throw new Error(
            "cannot decode field "
              .concat(q.typeName, ".")
              .concat(V.name, " from JSON: ")
              .concat(debugJsonValue(G))
          );
        switch (V.kind) {
          case "message":
            H.push(V.T.fromJson(G, B));
            break;
          case "enum":
            const Y = readEnum(V.T, G, B.ignoreUnknownFields, !0);
            Y !== tokenIgnoredUnknownEnum && H.push(Y);
            break;
          case "scalar":
            try {
              H.push(readScalar$1(V.T, G, V.L, !0));
            } catch (Q) {
              let X = "cannot decode field "
                .concat(q.typeName, ".")
                .concat(V.name, " from JSON: ")
                .concat(debugJsonValue(G));
              throw (
                (Q instanceof Error &&
                  Q.message.length > 0 &&
                  (X += ": ".concat(Q.message)),
                new Error(X))
              );
            }
            break;
        }
      }
    } else if (V.kind == "map") {
      if (j === null) return;
      if (typeof j != "object" || Array.isArray(j))
        throw new Error(
          "cannot decode field "
            .concat(q.typeName, ".")
            .concat(V.name, " from JSON: ")
            .concat(debugJsonValue(j))
        );
      const H = U[$];
      for (const [G, Y] of Object.entries(j)) {
        if (Y === null)
          throw new Error(
            "cannot decode field "
              .concat(q.typeName, ".")
              .concat(V.name, " from JSON: map value null")
          );
        let Q;
        try {
          Q = readMapKey(V.K, G);
        } catch (X) {
          let Z = "cannot decode map key for field "
            .concat(q.typeName, ".")
            .concat(V.name, " from JSON: ")
            .concat(debugJsonValue(j));
          throw (
            (X instanceof Error &&
              X.message.length > 0 &&
              (Z += ": ".concat(X.message)),
            new Error(Z))
          );
        }
        switch (V.V.kind) {
          case "message":
            H[Q] = V.V.T.fromJson(Y, B);
            break;
          case "enum":
            const X = readEnum(V.V.T, Y, B.ignoreUnknownFields, !0);
            X !== tokenIgnoredUnknownEnum && (H[Q] = X);
            break;
          case "scalar":
            try {
              H[Q] = readScalar$1(V.V.T, Y, LongType.BIGINT, !0);
            } catch (Z) {
              let te = "cannot decode map value for field "
                .concat(q.typeName, ".")
                .concat(V.name, " from JSON: ")
                .concat(debugJsonValue(j));
              throw (
                (Z instanceof Error &&
                  Z.message.length > 0 &&
                  (te += ": ".concat(Z.message)),
                new Error(te))
              );
            }
            break;
        }
      }
    } else
      switch (
        (V.oneof && ((U = U[V.oneof.localName] = { case: $ }), ($ = "value")),
        V.kind)
      ) {
        case "message":
          const H = V.T;
          if (j === null && H.typeName != "google.protobuf.Value") return;
          let G = U[$];
          isMessage(G)
            ? G.fromJson(j, B)
            : ((U[$] = G = H.fromJson(j, B)),
              H.fieldWrapper &&
                !V.oneof &&
                (U[$] = H.fieldWrapper.unwrapField(G)));
          break;
        case "enum":
          const Y = readEnum(V.T, j, B.ignoreUnknownFields, !1);
          switch (Y) {
            case tokenNull:
              clearField(V, U);
              break;
            case tokenIgnoredUnknownEnum:
              break;
            default:
              U[$] = Y;
              break;
          }
          break;
        case "scalar":
          try {
            const Q = readScalar$1(V.T, j, V.L, !1);
            switch (Q) {
              case tokenNull:
                clearField(V, U);
                break;
              default:
                U[$] = Q;
                break;
            }
          } catch (Q) {
            let X = "cannot decode field "
              .concat(q.typeName, ".")
              .concat(V.name, " from JSON: ")
              .concat(debugJsonValue(j));
            throw (
              (Q instanceof Error &&
                Q.message.length > 0 &&
                (X += ": ".concat(Q.message)),
              new Error(X))
            );
          }
          break;
      }
  }
  function readMapKey(U, j) {
    if (U === ScalarType.BOOL)
      switch (j) {
        case "true":
          j = !0;
          break;
        case "false":
          j = !1;
          break;
      }
    return readScalar$1(U, j, LongType.BIGINT, !0).toString();
  }
  function readScalar$1(U, j, V, B) {
    if (j === null) return B ? scalarZeroValue(U, V) : tokenNull;
    switch (U) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (j === "NaN") return Number.NaN;
        if (j === "Infinity") return Number.POSITIVE_INFINITY;
        if (j === "-Infinity") return Number.NEGATIVE_INFINITY;
        if (
          j === "" ||
          (typeof j == "string" && j.trim().length !== j.length) ||
          (typeof j != "string" && typeof j != "number")
        )
          break;
        const q = Number(j);
        if (Number.isNaN(q) || !Number.isFinite(q)) break;
        return U == ScalarType.FLOAT && assertFloat32(q), q;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        let $;
        if (
          (typeof j == "number"
            ? ($ = j)
            : typeof j == "string" &&
              j.length > 0 &&
              j.trim().length === j.length &&
              ($ = Number(j)),
          $ === void 0)
        )
          break;
        return (
          U == ScalarType.UINT32 || U == ScalarType.FIXED32
            ? assertUInt32($)
            : assertInt32($),
          $
        );
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (typeof j != "number" && typeof j != "string") break;
        const H = protoInt64.parse(j);
        return V ? H.toString() : H;
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (typeof j != "number" && typeof j != "string") break;
        const G = protoInt64.uParse(j);
        return V ? G.toString() : G;
      case ScalarType.BOOL:
        if (typeof j != "boolean") break;
        return j;
      case ScalarType.STRING:
        if (typeof j != "string") break;
        try {
          encodeURIComponent(j);
        } catch {
          throw new Error("invalid UTF8");
        }
        return j;
      case ScalarType.BYTES:
        if (j === "") return new Uint8Array(0);
        if (typeof j != "string") break;
        return protoBase64.dec(j);
    }
    throw new Error();
  }
  function readEnum(U, j, V, B) {
    if (j === null)
      return U.typeName == "google.protobuf.NullValue"
        ? 0
        : B
        ? U.values[0].no
        : tokenNull;
    switch (typeof j) {
      case "number":
        if (Number.isInteger(j)) return j;
        break;
      case "string":
        const q = U.findName(j);
        if (q !== void 0) return q.no;
        if (V) return tokenIgnoredUnknownEnum;
        break;
    }
    throw new Error(
      "cannot decode enum "
        .concat(U.typeName, " from JSON: ")
        .concat(debugJsonValue(j))
    );
  }
  function canEmitFieldDefaultValue(U) {
    return U.repeated || U.kind == "map"
      ? !0
      : !(U.oneof || U.kind == "message" || U.opt || U.req);
  }
  function writeField$1(U, j, V) {
    if (U.kind == "map") {
      assert(typeof j == "object" && j != null);
      const B = {},
        q = Object.entries(j);
      switch (U.V.kind) {
        case "scalar":
          for (const [H, G] of q) B[H.toString()] = writeScalar$1(U.V.T, G);
          break;
        case "message":
          for (const [H, G] of q) B[H.toString()] = G.toJson(V);
          break;
        case "enum":
          const $ = U.V.T;
          for (const [H, G] of q)
            B[H.toString()] = writeEnum($, G, V.enumAsInteger);
          break;
      }
      return V.emitDefaultValues || q.length > 0 ? B : void 0;
    }
    if (U.repeated) {
      assert(Array.isArray(j));
      const B = [];
      switch (U.kind) {
        case "scalar":
          for (let q = 0; q < j.length; q++) B.push(writeScalar$1(U.T, j[q]));
          break;
        case "enum":
          for (let q = 0; q < j.length; q++)
            B.push(writeEnum(U.T, j[q], V.enumAsInteger));
          break;
        case "message":
          for (let q = 0; q < j.length; q++) B.push(j[q].toJson(V));
          break;
      }
      return V.emitDefaultValues || B.length > 0 ? B : void 0;
    }
    switch (U.kind) {
      case "scalar":
        return writeScalar$1(U.T, j);
      case "enum":
        return writeEnum(U.T, j, V.enumAsInteger);
      case "message":
        return wrapField(U.T, j).toJson(V);
    }
  }
  function writeEnum(U, j, V) {
    var B;
    if (
      (assert(typeof j == "number"), U.typeName == "google.protobuf.NullValue")
    )
      return null;
    if (V) return j;
    const q = U.findNumber(j);
    return (B = q?.name) !== null && B !== void 0 ? B : j;
  }
  function writeScalar$1(U, j) {
    switch (U) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        return assert(typeof j == "number"), j;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        return (
          assert(typeof j == "number"),
          Number.isNaN(j)
            ? "NaN"
            : j === Number.POSITIVE_INFINITY
            ? "Infinity"
            : j === Number.NEGATIVE_INFINITY
            ? "-Infinity"
            : j
        );
      case ScalarType.STRING:
        return assert(typeof j == "string"), j;
      case ScalarType.BOOL:
        return assert(typeof j == "boolean"), j;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return (
          assert(
            typeof j == "bigint" || typeof j == "string" || typeof j == "number"
          ),
          j.toString()
        );
      case ScalarType.BYTES:
        return assert(j instanceof Uint8Array), protoBase64.enc(j);
    }
  }
  const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields"),
    readDefaults = {
      readUnknownFields: !0,
      readerFactory: (U) => new BinaryReader(U),
    },
    writeDefaults = {
      writeUnknownFields: !0,
      writerFactory: () => new BinaryWriter(),
    };
  function makeReadOptions(U) {
    return U ? Object.assign(Object.assign({}, readDefaults), U) : readDefaults;
  }
  function makeWriteOptions(U) {
    return U
      ? Object.assign(Object.assign({}, writeDefaults), U)
      : writeDefaults;
  }
  function makeBinaryFormat() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(U) {
        var j;
        return (j = U[unknownFieldsSymbol]) !== null && j !== void 0 ? j : [];
      },
      discardUnknownFields(U) {
        delete U[unknownFieldsSymbol];
      },
      writeUnknownFields(U, j) {
        const B = U[unknownFieldsSymbol];
        if (B) for (const q of B) j.tag(q.no, q.wireType).raw(q.data);
      },
      onUnknownField(U, j, V, B) {
        const q = U;
        Array.isArray(q[unknownFieldsSymbol]) || (q[unknownFieldsSymbol] = []),
          q[unknownFieldsSymbol].push({ no: j, wireType: V, data: B });
      },
      readMessage(U, j, V, B, q) {
        const $ = U.getType(),
          H = q ? j.len : j.pos + V;
        let G, Y;
        for (
          ;
          j.pos < H &&
          (([G, Y] = j.tag()), !(q === !0 && Y == WireType.EndGroup));

        ) {
          const Q = $.fields.find(G);
          if (!Q) {
            const X = j.skip(Y, G);
            B.readUnknownFields && this.onUnknownField(U, G, Y, X);
            continue;
          }
          readField(U, j, Q, Y, B);
        }
        if (q && (Y != WireType.EndGroup || G !== V))
          throw new Error("invalid end group tag");
      },
      readField,
      writeMessage(U, j, V) {
        const B = U.getType();
        for (const q of B.fields.byNumber()) {
          if (!isFieldSet(q, U)) {
            if (q.req)
              throw new Error(
                "cannot encode field "
                  .concat(B.typeName, ".")
                  .concat(q.name, " to binary: required field not set")
              );
            continue;
          }
          const $ = q.oneof ? U[q.oneof.localName].value : U[q.localName];
          writeField(q, $, j, V);
        }
        return V.writeUnknownFields && this.writeUnknownFields(U, j), j;
      },
      writeField(U, j, V, B) {
        j !== void 0 && writeField(U, j, V, B);
      },
    };
  }
  function readField(U, j, V, B, q) {
    let { repeated: $, localName: H } = V;
    switch (
      (V.oneof &&
        ((U = U[V.oneof.localName]),
        U.case != H && delete U.value,
        (U.case = H),
        (H = "value")),
      V.kind)
    ) {
      case "scalar":
      case "enum":
        const G = V.kind == "enum" ? ScalarType.INT32 : V.T;
        let Y = readScalar;
        if ((V.kind == "scalar" && V.L > 0 && (Y = readScalarLTString), $)) {
          let te = U[H];
          if (
            B == WireType.LengthDelimited &&
            G != ScalarType.STRING &&
            G != ScalarType.BYTES
          ) {
            let ae = j.uint32() + j.pos;
            for (; j.pos < ae; ) te.push(Y(j, G));
          } else te.push(Y(j, G));
        } else U[H] = Y(j, G);
        break;
      case "message":
        const Q = V.T;
        $
          ? U[H].push(readMessageField(j, new Q(), q, V))
          : isMessage(U[H])
          ? readMessageField(j, U[H], q, V)
          : ((U[H] = readMessageField(j, new Q(), q, V)),
            Q.fieldWrapper &&
              !V.oneof &&
              !V.repeated &&
              (U[H] = Q.fieldWrapper.unwrapField(U[H])));
        break;
      case "map":
        let [X, Z] = readMapEntry(V, j, q);
        U[H][X] = Z;
        break;
    }
  }
  function readMessageField(U, j, V, B) {
    const q = j.getType().runtime.bin,
      $ = B?.delimited;
    return q.readMessage(j, U, $ ? B.no : U.uint32(), V, $), j;
  }
  function readMapEntry(U, j, V) {
    const B = j.uint32(),
      q = j.pos + B;
    let $, H;
    for (; j.pos < q; ) {
      const [G] = j.tag();
      switch (G) {
        case 1:
          $ = readScalar(j, U.K);
          break;
        case 2:
          switch (U.V.kind) {
            case "scalar":
              H = readScalar(j, U.V.T);
              break;
            case "enum":
              H = j.int32();
              break;
            case "message":
              H = readMessageField(j, new U.V.T(), V, void 0);
              break;
          }
          break;
      }
    }
    if (
      ($ === void 0 && ($ = scalarZeroValue(U.K, LongType.BIGINT)),
      typeof $ != "string" && typeof $ != "number" && ($ = $.toString()),
      H === void 0)
    )
      switch (U.V.kind) {
        case "scalar":
          H = scalarZeroValue(U.V.T, LongType.BIGINT);
          break;
        case "enum":
          H = U.V.T.values[0].no;
          break;
        case "message":
          H = new U.V.T();
          break;
      }
    return [$, H];
  }
  function readScalarLTString(U, j) {
    const V = readScalar(U, j);
    return typeof V == "bigint" ? V.toString() : V;
  }
  function readScalar(U, j) {
    switch (j) {
      case ScalarType.STRING:
        return U.string();
      case ScalarType.BOOL:
        return U.bool();
      case ScalarType.DOUBLE:
        return U.double();
      case ScalarType.FLOAT:
        return U.float();
      case ScalarType.INT32:
        return U.int32();
      case ScalarType.INT64:
        return U.int64();
      case ScalarType.UINT64:
        return U.uint64();
      case ScalarType.FIXED64:
        return U.fixed64();
      case ScalarType.BYTES:
        return U.bytes();
      case ScalarType.FIXED32:
        return U.fixed32();
      case ScalarType.SFIXED32:
        return U.sfixed32();
      case ScalarType.SFIXED64:
        return U.sfixed64();
      case ScalarType.SINT64:
        return U.sint64();
      case ScalarType.UINT32:
        return U.uint32();
      case ScalarType.SINT32:
        return U.sint32();
    }
  }
  function writeField(U, j, V, B) {
    assert(j !== void 0);
    const q = U.repeated;
    switch (U.kind) {
      case "scalar":
      case "enum":
        let $ = U.kind == "enum" ? ScalarType.INT32 : U.T;
        if (q)
          if ((assert(Array.isArray(j)), U.packed)) writePacked(V, $, U.no, j);
          else for (const H of j) writeScalar(V, $, U.no, H);
        else writeScalar(V, $, U.no, j);
        break;
      case "message":
        if (q) {
          assert(Array.isArray(j));
          for (const H of j) writeMessageField(V, B, U, H);
        } else writeMessageField(V, B, U, j);
        break;
      case "map":
        assert(typeof j == "object" && j != null);
        for (const [H, G] of Object.entries(j)) writeMapEntry(V, B, U, H, G);
        break;
    }
  }
  function writeMapEntry(U, j, V, B, q) {
    U.tag(V.no, WireType.LengthDelimited), U.fork();
    let $ = B;
    switch (V.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        $ = Number.parseInt(B);
        break;
      case ScalarType.BOOL:
        assert(B == "true" || B == "false"), ($ = B == "true");
        break;
    }
    switch ((writeScalar(U, V.K, 1, $), V.V.kind)) {
      case "scalar":
        writeScalar(U, V.V.T, 2, q);
        break;
      case "enum":
        writeScalar(U, ScalarType.INT32, 2, q);
        break;
      case "message":
        assert(q !== void 0),
          U.tag(2, WireType.LengthDelimited).bytes(q.toBinary(j));
        break;
    }
    U.join();
  }
  function writeMessageField(U, j, V, B) {
    const q = wrapField(V.T, B);
    V.delimited
      ? U.tag(V.no, WireType.StartGroup)
          .raw(q.toBinary(j))
          .tag(V.no, WireType.EndGroup)
      : U.tag(V.no, WireType.LengthDelimited).bytes(q.toBinary(j));
  }
  function writeScalar(U, j, V, B) {
    assert(B !== void 0);
    let [q, $] = scalarTypeInfo(j);
    U.tag(V, q)[$](B);
  }
  function writePacked(U, j, V, B) {
    if (!B.length) return;
    U.tag(V, WireType.LengthDelimited).fork();
    let [, q] = scalarTypeInfo(j);
    for (let $ = 0; $ < B.length; $++) U[q](B[$]);
    U.join();
  }
  function scalarTypeInfo(U) {
    let j = WireType.Varint;
    switch (U) {
      case ScalarType.BYTES:
      case ScalarType.STRING:
        j = WireType.LengthDelimited;
        break;
      case ScalarType.DOUBLE:
      case ScalarType.FIXED64:
      case ScalarType.SFIXED64:
        j = WireType.Bit64;
        break;
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.FLOAT:
        j = WireType.Bit32;
        break;
    }
    const V = ScalarType[U].toLowerCase();
    return [j, V];
  }
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(U, j) {
        if (U === void 0) return;
        const V = j.getType();
        for (const B of V.fields.byMember()) {
          const q = B.localName,
            $ = j,
            H = U;
          if (H[q] != null)
            switch (B.kind) {
              case "oneof":
                const G = H[q].case;
                if (G === void 0) continue;
                const Y = B.findField(G);
                let Q = H[q].value;
                Y && Y.kind == "message" && !isMessage(Q, Y.T)
                  ? (Q = new Y.T(Q))
                  : Y &&
                    Y.kind === "scalar" &&
                    Y.T === ScalarType.BYTES &&
                    (Q = toU8Arr(Q)),
                  ($[q] = { case: G, value: Q });
                break;
              case "scalar":
              case "enum":
                let X = H[q];
                B.T === ScalarType.BYTES &&
                  (X = B.repeated ? X.map(toU8Arr) : toU8Arr(X)),
                  ($[q] = X);
                break;
              case "map":
                switch (B.V.kind) {
                  case "scalar":
                  case "enum":
                    if (B.V.T === ScalarType.BYTES)
                      for (const [ne, ae] of Object.entries(H[q]))
                        $[q][ne] = toU8Arr(ae);
                    else Object.assign($[q], H[q]);
                    break;
                  case "message":
                    const te = B.V.T;
                    for (const ne of Object.keys(H[q])) {
                      let ae = H[q][ne];
                      te.fieldWrapper || (ae = new te(ae)), ($[q][ne] = ae);
                    }
                    break;
                }
                break;
              case "message":
                const Z = B.T;
                if (B.repeated)
                  $[q] = H[q].map((te) => (isMessage(te, Z) ? te : new Z(te)));
                else {
                  const te = H[q];
                  Z.fieldWrapper
                    ? Z.typeName === "google.protobuf.BytesValue"
                      ? ($[q] = toU8Arr(te))
                      : ($[q] = te)
                    : ($[q] = isMessage(te, Z) ? te : new Z(te));
                }
                break;
            }
        }
      },
      equals(U, j, V) {
        return j === V
          ? !0
          : !j || !V
          ? !1
          : U.fields.byMember().every((B) => {
              const q = j[B.localName],
                $ = V[B.localName];
              if (B.repeated) {
                if (q.length !== $.length) return !1;
                switch (B.kind) {
                  case "message":
                    return q.every((H, G) => B.T.equals(H, $[G]));
                  case "scalar":
                    return q.every((H, G) => scalarEquals(B.T, H, $[G]));
                  case "enum":
                    return q.every((H, G) =>
                      scalarEquals(ScalarType.INT32, H, $[G])
                    );
                }
                throw new Error("repeated cannot contain ".concat(B.kind));
              }
              switch (B.kind) {
                case "message":
                  let H = q,
                    G = $;
                  return (
                    B.T.fieldWrapper &&
                      (H !== void 0 &&
                        !isMessage(H) &&
                        (H = B.T.fieldWrapper.wrapField(H)),
                      G !== void 0 &&
                        !isMessage(G) &&
                        (G = B.T.fieldWrapper.wrapField(G))),
                    B.T.equals(H, G)
                  );
                case "enum":
                  return scalarEquals(ScalarType.INT32, q, $);
                case "scalar":
                  return scalarEquals(B.T, q, $);
                case "oneof":
                  if (q.case !== $.case) return !1;
                  const Y = B.findField(q.case);
                  if (Y === void 0) return !0;
                  switch (Y.kind) {
                    case "message":
                      return Y.T.equals(q.value, $.value);
                    case "enum":
                      return scalarEquals(ScalarType.INT32, q.value, $.value);
                    case "scalar":
                      return scalarEquals(Y.T, q.value, $.value);
                  }
                  throw new Error("oneof cannot contain ".concat(Y.kind));
                case "map":
                  const Q = Object.keys(q).concat(Object.keys($));
                  switch (B.V.kind) {
                    case "message":
                      const X = B.V.T;
                      return Q.every((te) => X.equals(q[te], $[te]));
                    case "enum":
                      return Q.every((te) =>
                        scalarEquals(ScalarType.INT32, q[te], $[te])
                      );
                    case "scalar":
                      const Z = B.V.T;
                      return Q.every((te) => scalarEquals(Z, q[te], $[te]));
                  }
                  break;
              }
            });
      },
      clone(U) {
        const j = U.getType(),
          V = new j(),
          B = V;
        for (const q of j.fields.byMember()) {
          const $ = U[q.localName];
          let H;
          if (q.repeated) H = $.map(cloneSingularField);
          else if (q.kind == "map") {
            H = B[q.localName];
            for (const [G, Y] of Object.entries($))
              H[G] = cloneSingularField(Y);
          } else
            q.kind == "oneof"
              ? (H = q.findField($.case)
                  ? { case: $.case, value: cloneSingularField($.value) }
                  : { case: void 0 })
              : (H = cloneSingularField($));
          B[q.localName] = H;
        }
        for (const q of j.runtime.bin.listUnknownFields(U))
          j.runtime.bin.onUnknownField(B, q.no, q.wireType, q.data);
        return V;
      },
    };
  }
  function cloneSingularField(U) {
    if (U === void 0) return U;
    if (isMessage(U)) return U.clone();
    if (U instanceof Uint8Array) {
      const j = new Uint8Array(U.byteLength);
      return j.set(U), j;
    }
    return U;
  }
  function toU8Arr(U) {
    return U instanceof Uint8Array ? U : new Uint8Array(U);
  }
  function makeProtoRuntime(U, j, V) {
    return {
      syntax: U,
      json: makeJsonFormat(),
      bin: makeBinaryFormat(),
      util: Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList: j,
        initFields: V,
      }),
      makeMessageType(B, q, $) {
        return makeMessageType(this, B, q, $);
      },
      makeEnum,
      makeEnumType,
      getEnumType,
      makeExtension(B, q, $) {
        return makeExtension(this, B, q, $);
      },
    };
  }
  class InternalFieldList {
    constructor(j, V) {
      (this._fields = j), (this._normalizer = V);
    }
    findJsonName(j) {
      if (!this.jsonNames) {
        const V = {};
        for (const B of this.list()) V[B.jsonName] = V[B.name] = B;
        this.jsonNames = V;
      }
      return this.jsonNames[j];
    }
    find(j) {
      if (!this.numbers) {
        const V = {};
        for (const B of this.list()) V[B.no] = B;
        this.numbers = V;
      }
      return this.numbers[j];
    }
    list() {
      return this.all || (this.all = this._normalizer(this._fields)), this.all;
    }
    byNumber() {
      return (
        this.numbersAsc ||
          (this.numbersAsc = this.list()
            .concat()
            .sort((j, V) => j.no - V.no)),
        this.numbersAsc
      );
    }
    byMember() {
      if (!this.members) {
        this.members = [];
        const j = this.members;
        let V;
        for (const B of this.list())
          B.oneof ? B.oneof !== V && ((V = B.oneof), j.push(V)) : j.push(B);
      }
      return this.members;
    }
  }
  function localFieldName(U, j) {
    const V = protoCamelCase(U);
    return j ? V : safeObjectProperty(safeMessageProperty(V));
  }
  function localOneofName(U) {
    return localFieldName(U, !1);
  }
  const fieldJsonName = protoCamelCase;
  function protoCamelCase(U) {
    let j = !1;
    const V = [];
    for (let B = 0; B < U.length; B++) {
      let q = U.charAt(B);
      switch (q) {
        case "_":
          j = !0;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          V.push(q), (j = !1);
          break;
        default:
          j && ((j = !1), (q = q.toUpperCase())), V.push(q);
          break;
      }
    }
    return V.join("");
  }
  const reservedObjectProperties = new Set([
      "constructor",
      "toString",
      "toJSON",
      "valueOf",
    ]),
    reservedMessageProperties = new Set([
      "getType",
      "clone",
      "equals",
      "fromBinary",
      "fromJson",
      "fromJsonString",
      "toBinary",
      "toJson",
      "toJsonString",
      "toObject",
    ]),
    fallback = (U) => "".concat(U, "$"),
    safeMessageProperty = (U) =>
      reservedMessageProperties.has(U) ? fallback(U) : U,
    safeObjectProperty = (U) =>
      reservedObjectProperties.has(U) ? fallback(U) : U;
  class InternalOneofInfo {
    constructor(j) {
      (this.kind = "oneof"),
        (this.repeated = !1),
        (this.packed = !1),
        (this.opt = !1),
        (this.req = !1),
        (this.default = void 0),
        (this.fields = []),
        (this.name = j),
        (this.localName = localOneofName(j));
    }
    addField(j) {
      assert(
        j.oneof === this,
        "field ".concat(j.name, " not one of ").concat(this.name)
      ),
        this.fields.push(j);
    }
    findField(j) {
      if (!this._lookup) {
        this._lookup = Object.create(null);
        for (let V = 0; V < this.fields.length; V++)
          this._lookup[this.fields[V].localName] = this.fields[V];
      }
      return this._lookup[j];
    }
  }
  function normalizeFieldInfos(U, j) {
    var V, B, q, $, H, G;
    const Y = [];
    let Q;
    for (const X of typeof U == "function" ? U() : U) {
      const Z = X;
      if (
        ((Z.localName = localFieldName(X.name, X.oneof !== void 0)),
        (Z.jsonName =
          (V = X.jsonName) !== null && V !== void 0
            ? V
            : fieldJsonName(X.name)),
        (Z.repeated = (B = X.repeated) !== null && B !== void 0 ? B : !1),
        X.kind == "scalar" &&
          (Z.L = (q = X.L) !== null && q !== void 0 ? q : LongType.BIGINT),
        (Z.delimited = ($ = X.delimited) !== null && $ !== void 0 ? $ : !1),
        (Z.req = (H = X.req) !== null && H !== void 0 ? H : !1),
        (Z.opt = (G = X.opt) !== null && G !== void 0 ? G : !1),
        X.packed === void 0 &&
          (Z.packed =
            X.kind == "enum" ||
            (X.kind == "scalar" &&
              X.T != ScalarType.BYTES &&
              X.T != ScalarType.STRING)),
        X.oneof !== void 0)
      ) {
        const te = typeof X.oneof == "string" ? X.oneof : X.oneof.name;
        (!Q || Q.name != te) && (Q = new InternalOneofInfo(te)),
          (Z.oneof = Q),
          Q.addField(Z);
      }
      Y.push(Z);
    }
    return Y;
  }
  const proto3 = makeProtoRuntime(
    "proto3",
    (U) => new InternalFieldList(U, (j) => normalizeFieldInfos(j)),
    (U) => {
      for (const j of U.getType().fields.byMember()) {
        if (j.opt) continue;
        const V = j.localName,
          B = U;
        if (j.repeated) {
          B[V] = [];
          continue;
        }
        switch (j.kind) {
          case "oneof":
            B[V] = { case: void 0 };
            break;
          case "enum":
            B[V] = 0;
            break;
          case "map":
            B[V] = {};
            break;
          case "scalar":
            B[V] = scalarZeroValue(j.T, j.L);
            break;
        }
      }
    }
  );
  class Timestamp extends Message {
    constructor(j) {
      super(),
        (this.seconds = protoInt64.zero),
        (this.nanos = 0),
        proto3.util.initPartial(j, this);
    }
    fromJson(j, V) {
      if (typeof j != "string")
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: ".concat(
            proto3.json.debug(j)
          )
        );
      const B = j.match(
        /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/
      );
      if (!B)
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string"
        );
      const q = Date.parse(
        B[1] +
          "-" +
          B[2] +
          "-" +
          B[3] +
          "T" +
          B[4] +
          ":" +
          B[5] +
          ":" +
          B[6] +
          (B[8] ? B[8] : "Z")
      );
      if (Number.isNaN(q))
        throw new Error(
          "cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string"
        );
      if (
        q < Date.parse("0001-01-01T00:00:00Z") ||
        q > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive"
        );
      return (
        (this.seconds = protoInt64.parse(q / 1e3)),
        (this.nanos = 0),
        B[7] &&
          (this.nanos =
            parseInt("1" + B[7] + "0".repeat(9 - B[7].length)) - 1e9),
        this
      );
    }
    toJson(j) {
      const V = Number(this.seconds) * 1e3;
      if (
        V < Date.parse("0001-01-01T00:00:00Z") ||
        V > Date.parse("9999-12-31T23:59:59Z")
      )
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive"
        );
      if (this.nanos < 0)
        throw new Error(
          "cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative"
        );
      let B = "Z";
      if (this.nanos > 0) {
        const q = (this.nanos + 1e9).toString().substring(1);
        q.substring(3) === "000000"
          ? (B = "." + q.substring(0, 3) + "Z")
          : q.substring(6) === "000"
          ? (B = "." + q.substring(0, 6) + "Z")
          : (B = "." + q + "Z");
      }
      return new Date(V).toISOString().replace(".000Z", B);
    }
    toDate() {
      return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
    }
    static now() {
      return Timestamp.fromDate(new Date());
    }
    static fromDate(j) {
      const V = j.getTime();
      return new Timestamp({
        seconds: protoInt64.parse(Math.floor(V / 1e3)),
        nanos: (V % 1e3) * 1e6,
      });
    }
    static fromBinary(j, V) {
      return new Timestamp().fromBinary(j, V);
    }
    static fromJson(j, V) {
      return new Timestamp().fromJson(j, V);
    }
    static fromJsonString(j, V) {
      return new Timestamp().fromJsonString(j, V);
    }
    static equals(j, V) {
      return proto3.util.equals(Timestamp, j, V);
    }
  }
  (Timestamp.runtime = proto3),
    (Timestamp.typeName = "google.protobuf.Timestamp"),
    (Timestamp.fields = proto3.util.newFieldList(() => [
      { no: 1, name: "seconds", kind: "scalar", T: 3 },
      { no: 2, name: "nanos", kind: "scalar", T: 5 },
    ]));
  const MetricsBatch = proto3.makeMessageType("livekit.MetricsBatch", () => [
      { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 },
      { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
      { no: 3, name: "str_data", kind: "scalar", T: 9, repeated: !0 },
      {
        no: 4,
        name: "time_series",
        kind: "message",
        T: TimeSeriesMetric,
        repeated: !0,
      },
      { no: 5, name: "events", kind: "message", T: EventMetric, repeated: !0 },
    ]),
    TimeSeriesMetric = proto3.makeMessageType(
      "livekit.TimeSeriesMetric",
      () => [
        { no: 1, name: "label", kind: "scalar", T: 13 },
        { no: 2, name: "participant_identity", kind: "scalar", T: 13 },
        { no: 3, name: "track_sid", kind: "scalar", T: 13 },
        {
          no: 4,
          name: "samples",
          kind: "message",
          T: MetricSample,
          repeated: !0,
        },
        { no: 5, name: "rid", kind: "scalar", T: 13 },
      ]
    ),
    MetricSample = proto3.makeMessageType("livekit.MetricSample", () => [
      { no: 1, name: "timestamp_ms", kind: "scalar", T: 3 },
      { no: 2, name: "normalized_timestamp", kind: "message", T: Timestamp },
      { no: 3, name: "value", kind: "scalar", T: 2 },
    ]),
    EventMetric = proto3.makeMessageType("livekit.EventMetric", () => [
      { no: 1, name: "label", kind: "scalar", T: 13 },
      { no: 2, name: "participant_identity", kind: "scalar", T: 13 },
      { no: 3, name: "track_sid", kind: "scalar", T: 13 },
      { no: 4, name: "start_timestamp_ms", kind: "scalar", T: 3 },
      { no: 5, name: "end_timestamp_ms", kind: "scalar", T: 3, opt: !0 },
      {
        no: 6,
        name: "normalized_start_timestamp",
        kind: "message",
        T: Timestamp,
      },
      {
        no: 7,
        name: "normalized_end_timestamp",
        kind: "message",
        T: Timestamp,
        opt: !0,
      },
      { no: 8, name: "metadata", kind: "scalar", T: 9 },
      { no: 9, name: "rid", kind: "scalar", T: 13 },
    ]),
    BackupCodecPolicy$1 = proto3.makeEnum("livekit.BackupCodecPolicy", [
      { no: 0, name: "PREFER_REGRESSION" },
      { no: 1, name: "SIMULCAST" },
      { no: 2, name: "REGRESSION" },
    ]),
    TrackType = proto3.makeEnum("livekit.TrackType", [
      { no: 0, name: "AUDIO" },
      { no: 1, name: "VIDEO" },
      { no: 2, name: "DATA" },
    ]),
    TrackSource = proto3.makeEnum("livekit.TrackSource", [
      { no: 0, name: "UNKNOWN" },
      { no: 1, name: "CAMERA" },
      { no: 2, name: "MICROPHONE" },
      { no: 3, name: "SCREEN_SHARE" },
      { no: 4, name: "SCREEN_SHARE_AUDIO" },
    ]),
    VideoQuality$1 = proto3.makeEnum("livekit.VideoQuality", [
      { no: 0, name: "LOW" },
      { no: 1, name: "MEDIUM" },
      { no: 2, name: "HIGH" },
      { no: 3, name: "OFF" },
    ]),
    ConnectionQuality$1 = proto3.makeEnum("livekit.ConnectionQuality", [
      { no: 0, name: "POOR" },
      { no: 1, name: "GOOD" },
      { no: 2, name: "EXCELLENT" },
      { no: 3, name: "LOST" },
    ]),
    ClientConfigSetting = proto3.makeEnum("livekit.ClientConfigSetting", [
      { no: 0, name: "UNSET" },
      { no: 1, name: "DISABLED" },
      { no: 2, name: "ENABLED" },
    ]),
    DisconnectReason = proto3.makeEnum("livekit.DisconnectReason", [
      { no: 0, name: "UNKNOWN_REASON" },
      { no: 1, name: "CLIENT_INITIATED" },
      { no: 2, name: "DUPLICATE_IDENTITY" },
      { no: 3, name: "SERVER_SHUTDOWN" },
      { no: 4, name: "PARTICIPANT_REMOVED" },
      { no: 5, name: "ROOM_DELETED" },
      { no: 6, name: "STATE_MISMATCH" },
      { no: 7, name: "JOIN_FAILURE" },
      { no: 8, name: "MIGRATION" },
      { no: 9, name: "SIGNAL_CLOSE" },
      { no: 10, name: "ROOM_CLOSED" },
      { no: 11, name: "USER_UNAVAILABLE" },
      { no: 12, name: "USER_REJECTED" },
      { no: 13, name: "SIP_TRUNK_FAILURE" },
      { no: 14, name: "CONNECTION_TIMEOUT" },
      { no: 15, name: "MEDIA_FAILURE" },
    ]),
    ReconnectReason = proto3.makeEnum("livekit.ReconnectReason", [
      { no: 0, name: "RR_UNKNOWN" },
      { no: 1, name: "RR_SIGNAL_DISCONNECTED" },
      { no: 2, name: "RR_PUBLISHER_FAILED" },
      { no: 3, name: "RR_SUBSCRIBER_FAILED" },
      { no: 4, name: "RR_SWITCH_CANDIDATE" },
    ]),
    SubscriptionError = proto3.makeEnum("livekit.SubscriptionError", [
      { no: 0, name: "SE_UNKNOWN" },
      { no: 1, name: "SE_CODEC_UNSUPPORTED" },
      { no: 2, name: "SE_TRACK_NOTFOUND" },
    ]),
    AudioTrackFeature = proto3.makeEnum("livekit.AudioTrackFeature", [
      { no: 0, name: "TF_STEREO" },
      { no: 1, name: "TF_NO_DTX" },
      { no: 2, name: "TF_AUTO_GAIN_CONTROL" },
      { no: 3, name: "TF_ECHO_CANCELLATION" },
      { no: 4, name: "TF_NOISE_SUPPRESSION" },
      { no: 5, name: "TF_ENHANCED_NOISE_CANCELLATION" },
      { no: 6, name: "TF_PRECONNECT_BUFFER" },
    ]),
    Room$1 = proto3.makeMessageType("livekit.Room", () => [
      { no: 1, name: "sid", kind: "scalar", T: 9 },
      { no: 2, name: "name", kind: "scalar", T: 9 },
      { no: 3, name: "empty_timeout", kind: "scalar", T: 13 },
      { no: 14, name: "departure_timeout", kind: "scalar", T: 13 },
      { no: 4, name: "max_participants", kind: "scalar", T: 13 },
      { no: 5, name: "creation_time", kind: "scalar", T: 3 },
      { no: 15, name: "creation_time_ms", kind: "scalar", T: 3 },
      { no: 6, name: "turn_password", kind: "scalar", T: 9 },
      {
        no: 7,
        name: "enabled_codecs",
        kind: "message",
        T: Codec,
        repeated: !0,
      },
      { no: 8, name: "metadata", kind: "scalar", T: 9 },
      { no: 9, name: "num_participants", kind: "scalar", T: 13 },
      { no: 11, name: "num_publishers", kind: "scalar", T: 13 },
      { no: 10, name: "active_recording", kind: "scalar", T: 8 },
      { no: 13, name: "version", kind: "message", T: TimedVersion },
    ]),
    Codec = proto3.makeMessageType("livekit.Codec", () => [
      { no: 1, name: "mime", kind: "scalar", T: 9 },
      { no: 2, name: "fmtp_line", kind: "scalar", T: 9 },
    ]),
    ParticipantPermission = proto3.makeMessageType(
      "livekit.ParticipantPermission",
      () => [
        { no: 1, name: "can_subscribe", kind: "scalar", T: 8 },
        { no: 2, name: "can_publish", kind: "scalar", T: 8 },
        { no: 3, name: "can_publish_data", kind: "scalar", T: 8 },
        {
          no: 9,
          name: "can_publish_sources",
          kind: "enum",
          T: proto3.getEnumType(TrackSource),
          repeated: !0,
        },
        { no: 7, name: "hidden", kind: "scalar", T: 8 },
        { no: 8, name: "recorder", kind: "scalar", T: 8 },
        { no: 10, name: "can_update_metadata", kind: "scalar", T: 8 },
        { no: 11, name: "agent", kind: "scalar", T: 8 },
        { no: 12, name: "can_subscribe_metrics", kind: "scalar", T: 8 },
      ]
    ),
    ParticipantInfo = proto3.makeMessageType("livekit.ParticipantInfo", () => [
      { no: 1, name: "sid", kind: "scalar", T: 9 },
      { no: 2, name: "identity", kind: "scalar", T: 9 },
      {
        no: 3,
        name: "state",
        kind: "enum",
        T: proto3.getEnumType(ParticipantInfo_State),
      },
      { no: 4, name: "tracks", kind: "message", T: TrackInfo, repeated: !0 },
      { no: 5, name: "metadata", kind: "scalar", T: 9 },
      { no: 6, name: "joined_at", kind: "scalar", T: 3 },
      { no: 17, name: "joined_at_ms", kind: "scalar", T: 3 },
      { no: 9, name: "name", kind: "scalar", T: 9 },
      { no: 10, name: "version", kind: "scalar", T: 13 },
      { no: 11, name: "permission", kind: "message", T: ParticipantPermission },
      { no: 12, name: "region", kind: "scalar", T: 9 },
      { no: 13, name: "is_publisher", kind: "scalar", T: 8 },
      {
        no: 14,
        name: "kind",
        kind: "enum",
        T: proto3.getEnumType(ParticipantInfo_Kind),
      },
      {
        no: 15,
        name: "attributes",
        kind: "map",
        K: 9,
        V: { kind: "scalar", T: 9 },
      },
      {
        no: 16,
        name: "disconnect_reason",
        kind: "enum",
        T: proto3.getEnumType(DisconnectReason),
      },
      {
        no: 18,
        name: "kind_details",
        kind: "enum",
        T: proto3.getEnumType(ParticipantInfo_KindDetail),
        repeated: !0,
      },
    ]),
    ParticipantInfo_State = proto3.makeEnum("livekit.ParticipantInfo.State", [
      { no: 0, name: "JOINING" },
      { no: 1, name: "JOINED" },
      { no: 2, name: "ACTIVE" },
      { no: 3, name: "DISCONNECTED" },
    ]),
    ParticipantInfo_Kind = proto3.makeEnum("livekit.ParticipantInfo.Kind", [
      { no: 0, name: "STANDARD" },
      { no: 1, name: "INGRESS" },
      { no: 2, name: "EGRESS" },
      { no: 3, name: "SIP" },
      { no: 4, name: "AGENT" },
    ]),
    ParticipantInfo_KindDetail = proto3.makeEnum(
      "livekit.ParticipantInfo.KindDetail",
      [
        { no: 0, name: "CLOUD_AGENT" },
        { no: 1, name: "FORWARDED" },
      ]
    ),
    Encryption_Type = proto3.makeEnum("livekit.Encryption.Type", [
      { no: 0, name: "NONE" },
      { no: 1, name: "GCM" },
      { no: 2, name: "CUSTOM" },
    ]),
    SimulcastCodecInfo = proto3.makeMessageType(
      "livekit.SimulcastCodecInfo",
      () => [
        { no: 1, name: "mime_type", kind: "scalar", T: 9 },
        { no: 2, name: "mid", kind: "scalar", T: 9 },
        { no: 3, name: "cid", kind: "scalar", T: 9 },
        { no: 4, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
      ]
    ),
    TrackInfo = proto3.makeMessageType("livekit.TrackInfo", () => [
      { no: 1, name: "sid", kind: "scalar", T: 9 },
      { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
      { no: 3, name: "name", kind: "scalar", T: 9 },
      { no: 4, name: "muted", kind: "scalar", T: 8 },
      { no: 5, name: "width", kind: "scalar", T: 13 },
      { no: 6, name: "height", kind: "scalar", T: 13 },
      { no: 7, name: "simulcast", kind: "scalar", T: 8 },
      { no: 8, name: "disable_dtx", kind: "scalar", T: 8 },
      {
        no: 9,
        name: "source",
        kind: "enum",
        T: proto3.getEnumType(TrackSource),
      },
      { no: 10, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
      { no: 11, name: "mime_type", kind: "scalar", T: 9 },
      { no: 12, name: "mid", kind: "scalar", T: 9 },
      {
        no: 13,
        name: "codecs",
        kind: "message",
        T: SimulcastCodecInfo,
        repeated: !0,
      },
      { no: 14, name: "stereo", kind: "scalar", T: 8 },
      { no: 15, name: "disable_red", kind: "scalar", T: 8 },
      {
        no: 16,
        name: "encryption",
        kind: "enum",
        T: proto3.getEnumType(Encryption_Type),
      },
      { no: 17, name: "stream", kind: "scalar", T: 9 },
      { no: 18, name: "version", kind: "message", T: TimedVersion },
      {
        no: 19,
        name: "audio_features",
        kind: "enum",
        T: proto3.getEnumType(AudioTrackFeature),
        repeated: !0,
      },
      {
        no: 20,
        name: "backup_codec_policy",
        kind: "enum",
        T: proto3.getEnumType(BackupCodecPolicy$1),
      },
    ]),
    VideoLayer = proto3.makeMessageType("livekit.VideoLayer", () => [
      {
        no: 1,
        name: "quality",
        kind: "enum",
        T: proto3.getEnumType(VideoQuality$1),
      },
      { no: 2, name: "width", kind: "scalar", T: 13 },
      { no: 3, name: "height", kind: "scalar", T: 13 },
      { no: 4, name: "bitrate", kind: "scalar", T: 13 },
      { no: 5, name: "ssrc", kind: "scalar", T: 13 },
      { no: 6, name: "spatial_layer", kind: "scalar", T: 5 },
      { no: 7, name: "rid", kind: "scalar", T: 9 },
    ]),
    DataPacket = proto3.makeMessageType("livekit.DataPacket", () => [
      {
        no: 1,
        name: "kind",
        kind: "enum",
        T: proto3.getEnumType(DataPacket_Kind),
      },
      { no: 4, name: "participant_identity", kind: "scalar", T: 9 },
      {
        no: 5,
        name: "destination_identities",
        kind: "scalar",
        T: 9,
        repeated: !0,
      },
      { no: 2, name: "user", kind: "message", T: UserPacket, oneof: "value" },
      {
        no: 3,
        name: "speaker",
        kind: "message",
        T: ActiveSpeakerUpdate,
        oneof: "value",
      },
      { no: 6, name: "sip_dtmf", kind: "message", T: SipDTMF, oneof: "value" },
      {
        no: 7,
        name: "transcription",
        kind: "message",
        T: Transcription,
        oneof: "value",
      },
      {
        no: 8,
        name: "metrics",
        kind: "message",
        T: MetricsBatch,
        oneof: "value",
      },
      {
        no: 9,
        name: "chat_message",
        kind: "message",
        T: ChatMessage,
        oneof: "value",
      },
      {
        no: 10,
        name: "rpc_request",
        kind: "message",
        T: RpcRequest,
        oneof: "value",
      },
      { no: 11, name: "rpc_ack", kind: "message", T: RpcAck, oneof: "value" },
      {
        no: 12,
        name: "rpc_response",
        kind: "message",
        T: RpcResponse,
        oneof: "value",
      },
      {
        no: 13,
        name: "stream_header",
        kind: "message",
        T: DataStream_Header,
        oneof: "value",
      },
      {
        no: 14,
        name: "stream_chunk",
        kind: "message",
        T: DataStream_Chunk,
        oneof: "value",
      },
      {
        no: 15,
        name: "stream_trailer",
        kind: "message",
        T: DataStream_Trailer,
        oneof: "value",
      },
      { no: 16, name: "sequence", kind: "scalar", T: 13 },
      { no: 17, name: "participant_sid", kind: "scalar", T: 9 },
    ]),
    DataPacket_Kind = proto3.makeEnum("livekit.DataPacket.Kind", [
      { no: 0, name: "RELIABLE" },
      { no: 1, name: "LOSSY" },
    ]),
    ActiveSpeakerUpdate = proto3.makeMessageType(
      "livekit.ActiveSpeakerUpdate",
      () => [
        {
          no: 1,
          name: "speakers",
          kind: "message",
          T: SpeakerInfo,
          repeated: !0,
        },
      ]
    ),
    SpeakerInfo = proto3.makeMessageType("livekit.SpeakerInfo", () => [
      { no: 1, name: "sid", kind: "scalar", T: 9 },
      { no: 2, name: "level", kind: "scalar", T: 2 },
      { no: 3, name: "active", kind: "scalar", T: 8 },
    ]),
    UserPacket = proto3.makeMessageType("livekit.UserPacket", () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      { no: 5, name: "participant_identity", kind: "scalar", T: 9 },
      { no: 2, name: "payload", kind: "scalar", T: 12 },
      { no: 3, name: "destination_sids", kind: "scalar", T: 9, repeated: !0 },
      {
        no: 6,
        name: "destination_identities",
        kind: "scalar",
        T: 9,
        repeated: !0,
      },
      { no: 4, name: "topic", kind: "scalar", T: 9, opt: !0 },
      { no: 8, name: "id", kind: "scalar", T: 9, opt: !0 },
      { no: 9, name: "start_time", kind: "scalar", T: 4, opt: !0 },
      { no: 10, name: "end_time", kind: "scalar", T: 4, opt: !0 },
      { no: 11, name: "nonce", kind: "scalar", T: 12 },
    ]),
    SipDTMF = proto3.makeMessageType("livekit.SipDTMF", () => [
      { no: 3, name: "code", kind: "scalar", T: 13 },
      { no: 4, name: "digit", kind: "scalar", T: 9 },
    ]),
    Transcription = proto3.makeMessageType("livekit.Transcription", () => [
      { no: 2, name: "transcribed_participant_identity", kind: "scalar", T: 9 },
      { no: 3, name: "track_id", kind: "scalar", T: 9 },
      {
        no: 4,
        name: "segments",
        kind: "message",
        T: TranscriptionSegment,
        repeated: !0,
      },
    ]),
    TranscriptionSegment = proto3.makeMessageType(
      "livekit.TranscriptionSegment",
      () => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "text", kind: "scalar", T: 9 },
        { no: 3, name: "start_time", kind: "scalar", T: 4 },
        { no: 4, name: "end_time", kind: "scalar", T: 4 },
        { no: 5, name: "final", kind: "scalar", T: 8 },
        { no: 6, name: "language", kind: "scalar", T: 9 },
      ]
    ),
    ChatMessage = proto3.makeMessageType("livekit.ChatMessage", () => [
      { no: 1, name: "id", kind: "scalar", T: 9 },
      { no: 2, name: "timestamp", kind: "scalar", T: 3 },
      { no: 3, name: "edit_timestamp", kind: "scalar", T: 3, opt: !0 },
      { no: 4, name: "message", kind: "scalar", T: 9 },
      { no: 5, name: "deleted", kind: "scalar", T: 8 },
      { no: 6, name: "generated", kind: "scalar", T: 8 },
    ]),
    RpcRequest = proto3.makeMessageType("livekit.RpcRequest", () => [
      { no: 1, name: "id", kind: "scalar", T: 9 },
      { no: 2, name: "method", kind: "scalar", T: 9 },
      { no: 3, name: "payload", kind: "scalar", T: 9 },
      { no: 4, name: "response_timeout_ms", kind: "scalar", T: 13 },
      { no: 5, name: "version", kind: "scalar", T: 13 },
    ]),
    RpcAck = proto3.makeMessageType("livekit.RpcAck", () => [
      { no: 1, name: "request_id", kind: "scalar", T: 9 },
    ]),
    RpcResponse = proto3.makeMessageType("livekit.RpcResponse", () => [
      { no: 1, name: "request_id", kind: "scalar", T: 9 },
      { no: 2, name: "payload", kind: "scalar", T: 9, oneof: "value" },
      { no: 3, name: "error", kind: "message", T: RpcError$1, oneof: "value" },
    ]),
    RpcError$1 = proto3.makeMessageType("livekit.RpcError", () => [
      { no: 1, name: "code", kind: "scalar", T: 13 },
      { no: 2, name: "message", kind: "scalar", T: 9 },
      { no: 3, name: "data", kind: "scalar", T: 9 },
    ]),
    ParticipantTracks = proto3.makeMessageType(
      "livekit.ParticipantTracks",
      () => [
        { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
        { no: 2, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
      ]
    ),
    ServerInfo = proto3.makeMessageType("livekit.ServerInfo", () => [
      {
        no: 1,
        name: "edition",
        kind: "enum",
        T: proto3.getEnumType(ServerInfo_Edition),
      },
      { no: 2, name: "version", kind: "scalar", T: 9 },
      { no: 3, name: "protocol", kind: "scalar", T: 5 },
      { no: 4, name: "region", kind: "scalar", T: 9 },
      { no: 5, name: "node_id", kind: "scalar", T: 9 },
      { no: 6, name: "debug_info", kind: "scalar", T: 9 },
      { no: 7, name: "agent_protocol", kind: "scalar", T: 5 },
    ]),
    ServerInfo_Edition = proto3.makeEnum("livekit.ServerInfo.Edition", [
      { no: 0, name: "Standard" },
      { no: 1, name: "Cloud" },
    ]),
    ClientInfo = proto3.makeMessageType("livekit.ClientInfo", () => [
      {
        no: 1,
        name: "sdk",
        kind: "enum",
        T: proto3.getEnumType(ClientInfo_SDK),
      },
      { no: 2, name: "version", kind: "scalar", T: 9 },
      { no: 3, name: "protocol", kind: "scalar", T: 5 },
      { no: 4, name: "os", kind: "scalar", T: 9 },
      { no: 5, name: "os_version", kind: "scalar", T: 9 },
      { no: 6, name: "device_model", kind: "scalar", T: 9 },
      { no: 7, name: "browser", kind: "scalar", T: 9 },
      { no: 8, name: "browser_version", kind: "scalar", T: 9 },
      { no: 9, name: "address", kind: "scalar", T: 9 },
      { no: 10, name: "network", kind: "scalar", T: 9 },
      { no: 11, name: "other_sdks", kind: "scalar", T: 9 },
    ]),
    ClientInfo_SDK = proto3.makeEnum("livekit.ClientInfo.SDK", [
      { no: 0, name: "UNKNOWN" },
      { no: 1, name: "JS" },
      { no: 2, name: "SWIFT" },
      { no: 3, name: "ANDROID" },
      { no: 4, name: "FLUTTER" },
      { no: 5, name: "GO" },
      { no: 6, name: "UNITY" },
      { no: 7, name: "REACT_NATIVE" },
      { no: 8, name: "RUST" },
      { no: 9, name: "PYTHON" },
      { no: 10, name: "CPP" },
      { no: 11, name: "UNITY_WEB" },
      { no: 12, name: "NODE" },
      { no: 13, name: "UNREAL" },
      { no: 14, name: "ESP32" },
    ]),
    ClientConfiguration = proto3.makeMessageType(
      "livekit.ClientConfiguration",
      () => [
        { no: 1, name: "video", kind: "message", T: VideoConfiguration },
        { no: 2, name: "screen", kind: "message", T: VideoConfiguration },
        {
          no: 3,
          name: "resume_connection",
          kind: "enum",
          T: proto3.getEnumType(ClientConfigSetting),
        },
        { no: 4, name: "disabled_codecs", kind: "message", T: DisabledCodecs },
        {
          no: 5,
          name: "force_relay",
          kind: "enum",
          T: proto3.getEnumType(ClientConfigSetting),
        },
      ]
    ),
    VideoConfiguration = proto3.makeMessageType(
      "livekit.VideoConfiguration",
      () => [
        {
          no: 1,
          name: "hardware_encoder",
          kind: "enum",
          T: proto3.getEnumType(ClientConfigSetting),
        },
      ]
    ),
    DisabledCodecs = proto3.makeMessageType("livekit.DisabledCodecs", () => [
      { no: 1, name: "codecs", kind: "message", T: Codec, repeated: !0 },
      { no: 2, name: "publish", kind: "message", T: Codec, repeated: !0 },
    ]),
    TimedVersion = proto3.makeMessageType("livekit.TimedVersion", () => [
      { no: 1, name: "unix_micro", kind: "scalar", T: 3 },
      { no: 2, name: "ticks", kind: "scalar", T: 5 },
    ]),
    DataStream_OperationType = proto3.makeEnum(
      "livekit.DataStream.OperationType",
      [
        { no: 0, name: "CREATE" },
        { no: 1, name: "UPDATE" },
        { no: 2, name: "DELETE" },
        { no: 3, name: "REACTION" },
      ]
    ),
    DataStream_TextHeader = proto3.makeMessageType(
      "livekit.DataStream.TextHeader",
      () => [
        {
          no: 1,
          name: "operation_type",
          kind: "enum",
          T: proto3.getEnumType(DataStream_OperationType),
        },
        { no: 2, name: "version", kind: "scalar", T: 5 },
        { no: 3, name: "reply_to_stream_id", kind: "scalar", T: 9 },
        {
          no: 4,
          name: "attached_stream_ids",
          kind: "scalar",
          T: 9,
          repeated: !0,
        },
        { no: 5, name: "generated", kind: "scalar", T: 8 },
      ],
      { localName: "DataStream_TextHeader" }
    ),
    DataStream_ByteHeader = proto3.makeMessageType(
      "livekit.DataStream.ByteHeader",
      () => [{ no: 1, name: "name", kind: "scalar", T: 9 }],
      { localName: "DataStream_ByteHeader" }
    ),
    DataStream_Header = proto3.makeMessageType(
      "livekit.DataStream.Header",
      () => [
        { no: 1, name: "stream_id", kind: "scalar", T: 9 },
        { no: 2, name: "timestamp", kind: "scalar", T: 3 },
        { no: 3, name: "topic", kind: "scalar", T: 9 },
        { no: 4, name: "mime_type", kind: "scalar", T: 9 },
        { no: 5, name: "total_length", kind: "scalar", T: 4, opt: !0 },
        {
          no: 7,
          name: "encryption_type",
          kind: "enum",
          T: proto3.getEnumType(Encryption_Type),
        },
        {
          no: 8,
          name: "attributes",
          kind: "map",
          K: 9,
          V: { kind: "scalar", T: 9 },
        },
        {
          no: 9,
          name: "text_header",
          kind: "message",
          T: DataStream_TextHeader,
          oneof: "content_header",
        },
        {
          no: 10,
          name: "byte_header",
          kind: "message",
          T: DataStream_ByteHeader,
          oneof: "content_header",
        },
      ],
      { localName: "DataStream_Header" }
    ),
    DataStream_Chunk = proto3.makeMessageType(
      "livekit.DataStream.Chunk",
      () => [
        { no: 1, name: "stream_id", kind: "scalar", T: 9 },
        { no: 2, name: "chunk_index", kind: "scalar", T: 4 },
        { no: 3, name: "content", kind: "scalar", T: 12 },
        { no: 4, name: "version", kind: "scalar", T: 5 },
        { no: 5, name: "iv", kind: "scalar", T: 12, opt: !0 },
      ],
      { localName: "DataStream_Chunk" }
    ),
    DataStream_Trailer = proto3.makeMessageType(
      "livekit.DataStream.Trailer",
      () => [
        { no: 1, name: "stream_id", kind: "scalar", T: 9 },
        { no: 2, name: "reason", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "attributes",
          kind: "map",
          K: 9,
          V: { kind: "scalar", T: 9 },
        },
      ],
      { localName: "DataStream_Trailer" }
    ),
    SignalTarget = proto3.makeEnum("livekit.SignalTarget", [
      { no: 0, name: "PUBLISHER" },
      { no: 1, name: "SUBSCRIBER" },
    ]),
    StreamState = proto3.makeEnum("livekit.StreamState", [
      { no: 0, name: "ACTIVE" },
      { no: 1, name: "PAUSED" },
    ]),
    CandidateProtocol = proto3.makeEnum("livekit.CandidateProtocol", [
      { no: 0, name: "UDP" },
      { no: 1, name: "TCP" },
      { no: 2, name: "TLS" },
    ]),
    SignalRequest = proto3.makeMessageType("livekit.SignalRequest", () => [
      {
        no: 1,
        name: "offer",
        kind: "message",
        T: SessionDescription,
        oneof: "message",
      },
      {
        no: 2,
        name: "answer",
        kind: "message",
        T: SessionDescription,
        oneof: "message",
      },
      {
        no: 3,
        name: "trickle",
        kind: "message",
        T: TrickleRequest,
        oneof: "message",
      },
      {
        no: 4,
        name: "add_track",
        kind: "message",
        T: AddTrackRequest,
        oneof: "message",
      },
      {
        no: 5,
        name: "mute",
        kind: "message",
        T: MuteTrackRequest,
        oneof: "message",
      },
      {
        no: 6,
        name: "subscription",
        kind: "message",
        T: UpdateSubscription,
        oneof: "message",
      },
      {
        no: 7,
        name: "track_setting",
        kind: "message",
        T: UpdateTrackSettings,
        oneof: "message",
      },
      {
        no: 8,
        name: "leave",
        kind: "message",
        T: LeaveRequest,
        oneof: "message",
      },
      {
        no: 10,
        name: "update_layers",
        kind: "message",
        T: UpdateVideoLayers,
        oneof: "message",
      },
      {
        no: 11,
        name: "subscription_permission",
        kind: "message",
        T: SubscriptionPermission,
        oneof: "message",
      },
      {
        no: 12,
        name: "sync_state",
        kind: "message",
        T: SyncState,
        oneof: "message",
      },
      {
        no: 13,
        name: "simulate",
        kind: "message",
        T: SimulateScenario,
        oneof: "message",
      },
      { no: 14, name: "ping", kind: "scalar", T: 3, oneof: "message" },
      {
        no: 15,
        name: "update_metadata",
        kind: "message",
        T: UpdateParticipantMetadata,
        oneof: "message",
      },
      { no: 16, name: "ping_req", kind: "message", T: Ping, oneof: "message" },
      {
        no: 17,
        name: "update_audio_track",
        kind: "message",
        T: UpdateLocalAudioTrack,
        oneof: "message",
      },
      {
        no: 18,
        name: "update_video_track",
        kind: "message",
        T: UpdateLocalVideoTrack,
        oneof: "message",
      },
    ]),
    SignalResponse = proto3.makeMessageType("livekit.SignalResponse", () => [
      {
        no: 1,
        name: "join",
        kind: "message",
        T: JoinResponse,
        oneof: "message",
      },
      {
        no: 2,
        name: "answer",
        kind: "message",
        T: SessionDescription,
        oneof: "message",
      },
      {
        no: 3,
        name: "offer",
        kind: "message",
        T: SessionDescription,
        oneof: "message",
      },
      {
        no: 4,
        name: "trickle",
        kind: "message",
        T: TrickleRequest,
        oneof: "message",
      },
      {
        no: 5,
        name: "update",
        kind: "message",
        T: ParticipantUpdate,
        oneof: "message",
      },
      {
        no: 6,
        name: "track_published",
        kind: "message",
        T: TrackPublishedResponse,
        oneof: "message",
      },
      {
        no: 8,
        name: "leave",
        kind: "message",
        T: LeaveRequest,
        oneof: "message",
      },
      {
        no: 9,
        name: "mute",
        kind: "message",
        T: MuteTrackRequest,
        oneof: "message",
      },
      {
        no: 10,
        name: "speakers_changed",
        kind: "message",
        T: SpeakersChanged,
        oneof: "message",
      },
      {
        no: 11,
        name: "room_update",
        kind: "message",
        T: RoomUpdate,
        oneof: "message",
      },
      {
        no: 12,
        name: "connection_quality",
        kind: "message",
        T: ConnectionQualityUpdate,
        oneof: "message",
      },
      {
        no: 13,
        name: "stream_state_update",
        kind: "message",
        T: StreamStateUpdate,
        oneof: "message",
      },
      {
        no: 14,
        name: "subscribed_quality_update",
        kind: "message",
        T: SubscribedQualityUpdate,
        oneof: "message",
      },
      {
        no: 15,
        name: "subscription_permission_update",
        kind: "message",
        T: SubscriptionPermissionUpdate,
        oneof: "message",
      },
      { no: 16, name: "refresh_token", kind: "scalar", T: 9, oneof: "message" },
      {
        no: 17,
        name: "track_unpublished",
        kind: "message",
        T: TrackUnpublishedResponse,
        oneof: "message",
      },
      { no: 18, name: "pong", kind: "scalar", T: 3, oneof: "message" },
      {
        no: 19,
        name: "reconnect",
        kind: "message",
        T: ReconnectResponse,
        oneof: "message",
      },
      { no: 20, name: "pong_resp", kind: "message", T: Pong, oneof: "message" },
      {
        no: 21,
        name: "subscription_response",
        kind: "message",
        T: SubscriptionResponse,
        oneof: "message",
      },
      {
        no: 22,
        name: "request_response",
        kind: "message",
        T: RequestResponse,
        oneof: "message",
      },
      {
        no: 23,
        name: "track_subscribed",
        kind: "message",
        T: TrackSubscribed,
        oneof: "message",
      },
      {
        no: 24,
        name: "room_moved",
        kind: "message",
        T: RoomMovedResponse,
        oneof: "message",
      },
    ]),
    SimulcastCodec = proto3.makeMessageType("livekit.SimulcastCodec", () => [
      { no: 1, name: "codec", kind: "scalar", T: 9 },
      { no: 2, name: "cid", kind: "scalar", T: 9 },
    ]),
    AddTrackRequest = proto3.makeMessageType("livekit.AddTrackRequest", () => [
      { no: 1, name: "cid", kind: "scalar", T: 9 },
      { no: 2, name: "name", kind: "scalar", T: 9 },
      { no: 3, name: "type", kind: "enum", T: proto3.getEnumType(TrackType) },
      { no: 4, name: "width", kind: "scalar", T: 13 },
      { no: 5, name: "height", kind: "scalar", T: 13 },
      { no: 6, name: "muted", kind: "scalar", T: 8 },
      { no: 7, name: "disable_dtx", kind: "scalar", T: 8 },
      {
        no: 8,
        name: "source",
        kind: "enum",
        T: proto3.getEnumType(TrackSource),
      },
      { no: 9, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
      {
        no: 10,
        name: "simulcast_codecs",
        kind: "message",
        T: SimulcastCodec,
        repeated: !0,
      },
      { no: 11, name: "sid", kind: "scalar", T: 9 },
      { no: 12, name: "stereo", kind: "scalar", T: 8 },
      { no: 13, name: "disable_red", kind: "scalar", T: 8 },
      {
        no: 14,
        name: "encryption",
        kind: "enum",
        T: proto3.getEnumType(Encryption_Type),
      },
      { no: 15, name: "stream", kind: "scalar", T: 9 },
      {
        no: 16,
        name: "backup_codec_policy",
        kind: "enum",
        T: proto3.getEnumType(BackupCodecPolicy$1),
      },
      {
        no: 17,
        name: "audio_features",
        kind: "enum",
        T: proto3.getEnumType(AudioTrackFeature),
        repeated: !0,
      },
    ]),
    TrickleRequest = proto3.makeMessageType("livekit.TrickleRequest", () => [
      { no: 1, name: "candidateInit", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "target",
        kind: "enum",
        T: proto3.getEnumType(SignalTarget),
      },
      { no: 3, name: "final", kind: "scalar", T: 8 },
    ]),
    MuteTrackRequest = proto3.makeMessageType(
      "livekit.MuteTrackRequest",
      () => [
        { no: 1, name: "sid", kind: "scalar", T: 9 },
        { no: 2, name: "muted", kind: "scalar", T: 8 },
      ]
    ),
    JoinResponse = proto3.makeMessageType("livekit.JoinResponse", () => [
      { no: 1, name: "room", kind: "message", T: Room$1 },
      { no: 2, name: "participant", kind: "message", T: ParticipantInfo },
      {
        no: 3,
        name: "other_participants",
        kind: "message",
        T: ParticipantInfo,
        repeated: !0,
      },
      { no: 4, name: "server_version", kind: "scalar", T: 9 },
      {
        no: 5,
        name: "ice_servers",
        kind: "message",
        T: ICEServer,
        repeated: !0,
      },
      { no: 6, name: "subscriber_primary", kind: "scalar", T: 8 },
      { no: 7, name: "alternative_url", kind: "scalar", T: 9 },
      {
        no: 8,
        name: "client_configuration",
        kind: "message",
        T: ClientConfiguration,
      },
      { no: 9, name: "server_region", kind: "scalar", T: 9 },
      { no: 10, name: "ping_timeout", kind: "scalar", T: 5 },
      { no: 11, name: "ping_interval", kind: "scalar", T: 5 },
      { no: 12, name: "server_info", kind: "message", T: ServerInfo },
      { no: 13, name: "sif_trailer", kind: "scalar", T: 12 },
      {
        no: 14,
        name: "enabled_publish_codecs",
        kind: "message",
        T: Codec,
        repeated: !0,
      },
      { no: 15, name: "fast_publish", kind: "scalar", T: 8 },
    ]),
    ReconnectResponse = proto3.makeMessageType(
      "livekit.ReconnectResponse",
      () => [
        {
          no: 1,
          name: "ice_servers",
          kind: "message",
          T: ICEServer,
          repeated: !0,
        },
        {
          no: 2,
          name: "client_configuration",
          kind: "message",
          T: ClientConfiguration,
        },
        { no: 3, name: "server_info", kind: "message", T: ServerInfo },
        { no: 4, name: "last_message_seq", kind: "scalar", T: 13 },
      ]
    ),
    TrackPublishedResponse = proto3.makeMessageType(
      "livekit.TrackPublishedResponse",
      () => [
        { no: 1, name: "cid", kind: "scalar", T: 9 },
        { no: 2, name: "track", kind: "message", T: TrackInfo },
      ]
    ),
    TrackUnpublishedResponse = proto3.makeMessageType(
      "livekit.TrackUnpublishedResponse",
      () => [{ no: 1, name: "track_sid", kind: "scalar", T: 9 }]
    ),
    SessionDescription = proto3.makeMessageType(
      "livekit.SessionDescription",
      () => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "sdp", kind: "scalar", T: 9 },
        { no: 3, name: "id", kind: "scalar", T: 13 },
      ]
    ),
    ParticipantUpdate = proto3.makeMessageType(
      "livekit.ParticipantUpdate",
      () => [
        {
          no: 1,
          name: "participants",
          kind: "message",
          T: ParticipantInfo,
          repeated: !0,
        },
      ]
    ),
    UpdateSubscription = proto3.makeMessageType(
      "livekit.UpdateSubscription",
      () => [
        { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
        { no: 2, name: "subscribe", kind: "scalar", T: 8 },
        {
          no: 3,
          name: "participant_tracks",
          kind: "message",
          T: ParticipantTracks,
          repeated: !0,
        },
      ]
    ),
    UpdateTrackSettings = proto3.makeMessageType(
      "livekit.UpdateTrackSettings",
      () => [
        { no: 1, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
        { no: 3, name: "disabled", kind: "scalar", T: 8 },
        {
          no: 4,
          name: "quality",
          kind: "enum",
          T: proto3.getEnumType(VideoQuality$1),
        },
        { no: 5, name: "width", kind: "scalar", T: 13 },
        { no: 6, name: "height", kind: "scalar", T: 13 },
        { no: 7, name: "fps", kind: "scalar", T: 13 },
        { no: 8, name: "priority", kind: "scalar", T: 13 },
      ]
    ),
    UpdateLocalAudioTrack = proto3.makeMessageType(
      "livekit.UpdateLocalAudioTrack",
      () => [
        { no: 1, name: "track_sid", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "features",
          kind: "enum",
          T: proto3.getEnumType(AudioTrackFeature),
          repeated: !0,
        },
      ]
    ),
    UpdateLocalVideoTrack = proto3.makeMessageType(
      "livekit.UpdateLocalVideoTrack",
      () => [
        { no: 1, name: "track_sid", kind: "scalar", T: 9 },
        { no: 2, name: "width", kind: "scalar", T: 13 },
        { no: 3, name: "height", kind: "scalar", T: 13 },
      ]
    ),
    LeaveRequest = proto3.makeMessageType("livekit.LeaveRequest", () => [
      { no: 1, name: "can_reconnect", kind: "scalar", T: 8 },
      {
        no: 2,
        name: "reason",
        kind: "enum",
        T: proto3.getEnumType(DisconnectReason),
      },
      {
        no: 3,
        name: "action",
        kind: "enum",
        T: proto3.getEnumType(LeaveRequest_Action),
      },
      { no: 4, name: "regions", kind: "message", T: RegionSettings },
    ]),
    LeaveRequest_Action = proto3.makeEnum("livekit.LeaveRequest.Action", [
      { no: 0, name: "DISCONNECT" },
      { no: 1, name: "RESUME" },
      { no: 2, name: "RECONNECT" },
    ]),
    UpdateVideoLayers = proto3.makeMessageType(
      "livekit.UpdateVideoLayers",
      () => [
        { no: 1, name: "track_sid", kind: "scalar", T: 9 },
        { no: 2, name: "layers", kind: "message", T: VideoLayer, repeated: !0 },
      ]
    ),
    UpdateParticipantMetadata = proto3.makeMessageType(
      "livekit.UpdateParticipantMetadata",
      () => [
        { no: 1, name: "metadata", kind: "scalar", T: 9 },
        { no: 2, name: "name", kind: "scalar", T: 9 },
        {
          no: 3,
          name: "attributes",
          kind: "map",
          K: 9,
          V: { kind: "scalar", T: 9 },
        },
        { no: 4, name: "request_id", kind: "scalar", T: 13 },
      ]
    ),
    ICEServer = proto3.makeMessageType("livekit.ICEServer", () => [
      { no: 1, name: "urls", kind: "scalar", T: 9, repeated: !0 },
      { no: 2, name: "username", kind: "scalar", T: 9 },
      { no: 3, name: "credential", kind: "scalar", T: 9 },
    ]),
    SpeakersChanged = proto3.makeMessageType("livekit.SpeakersChanged", () => [
      {
        no: 1,
        name: "speakers",
        kind: "message",
        T: SpeakerInfo,
        repeated: !0,
      },
    ]),
    RoomUpdate = proto3.makeMessageType("livekit.RoomUpdate", () => [
      { no: 1, name: "room", kind: "message", T: Room$1 },
    ]),
    ConnectionQualityInfo = proto3.makeMessageType(
      "livekit.ConnectionQualityInfo",
      () => [
        { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "quality",
          kind: "enum",
          T: proto3.getEnumType(ConnectionQuality$1),
        },
        { no: 3, name: "score", kind: "scalar", T: 2 },
      ]
    ),
    ConnectionQualityUpdate = proto3.makeMessageType(
      "livekit.ConnectionQualityUpdate",
      () => [
        {
          no: 1,
          name: "updates",
          kind: "message",
          T: ConnectionQualityInfo,
          repeated: !0,
        },
      ]
    ),
    StreamStateInfo = proto3.makeMessageType("livekit.StreamStateInfo", () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      { no: 2, name: "track_sid", kind: "scalar", T: 9 },
      {
        no: 3,
        name: "state",
        kind: "enum",
        T: proto3.getEnumType(StreamState),
      },
    ]),
    StreamStateUpdate = proto3.makeMessageType(
      "livekit.StreamStateUpdate",
      () => [
        {
          no: 1,
          name: "stream_states",
          kind: "message",
          T: StreamStateInfo,
          repeated: !0,
        },
      ]
    ),
    SubscribedQuality = proto3.makeMessageType(
      "livekit.SubscribedQuality",
      () => [
        {
          no: 1,
          name: "quality",
          kind: "enum",
          T: proto3.getEnumType(VideoQuality$1),
        },
        { no: 2, name: "enabled", kind: "scalar", T: 8 },
      ]
    ),
    SubscribedCodec = proto3.makeMessageType("livekit.SubscribedCodec", () => [
      { no: 1, name: "codec", kind: "scalar", T: 9 },
      {
        no: 2,
        name: "qualities",
        kind: "message",
        T: SubscribedQuality,
        repeated: !0,
      },
    ]),
    SubscribedQualityUpdate = proto3.makeMessageType(
      "livekit.SubscribedQualityUpdate",
      () => [
        { no: 1, name: "track_sid", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "subscribed_qualities",
          kind: "message",
          T: SubscribedQuality,
          repeated: !0,
        },
        {
          no: 3,
          name: "subscribed_codecs",
          kind: "message",
          T: SubscribedCodec,
          repeated: !0,
        },
      ]
    ),
    TrackPermission = proto3.makeMessageType("livekit.TrackPermission", () => [
      { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
      { no: 2, name: "all_tracks", kind: "scalar", T: 8 },
      { no: 3, name: "track_sids", kind: "scalar", T: 9, repeated: !0 },
      { no: 4, name: "participant_identity", kind: "scalar", T: 9 },
    ]),
    SubscriptionPermission = proto3.makeMessageType(
      "livekit.SubscriptionPermission",
      () => [
        { no: 1, name: "all_participants", kind: "scalar", T: 8 },
        {
          no: 2,
          name: "track_permissions",
          kind: "message",
          T: TrackPermission,
          repeated: !0,
        },
      ]
    ),
    SubscriptionPermissionUpdate = proto3.makeMessageType(
      "livekit.SubscriptionPermissionUpdate",
      () => [
        { no: 1, name: "participant_sid", kind: "scalar", T: 9 },
        { no: 2, name: "track_sid", kind: "scalar", T: 9 },
        { no: 3, name: "allowed", kind: "scalar", T: 8 },
      ]
    ),
    RoomMovedResponse = proto3.makeMessageType(
      "livekit.RoomMovedResponse",
      () => [
        { no: 1, name: "room", kind: "message", T: Room$1 },
        { no: 2, name: "token", kind: "scalar", T: 9 },
        { no: 3, name: "participant", kind: "message", T: ParticipantInfo },
        {
          no: 4,
          name: "other_participants",
          kind: "message",
          T: ParticipantInfo,
          repeated: !0,
        },
      ]
    ),
    SyncState = proto3.makeMessageType("livekit.SyncState", () => [
      { no: 1, name: "answer", kind: "message", T: SessionDescription },
      { no: 2, name: "subscription", kind: "message", T: UpdateSubscription },
      {
        no: 3,
        name: "publish_tracks",
        kind: "message",
        T: TrackPublishedResponse,
        repeated: !0,
      },
      {
        no: 4,
        name: "data_channels",
        kind: "message",
        T: DataChannelInfo,
        repeated: !0,
      },
      { no: 5, name: "offer", kind: "message", T: SessionDescription },
      {
        no: 6,
        name: "track_sids_disabled",
        kind: "scalar",
        T: 9,
        repeated: !0,
      },
      {
        no: 7,
        name: "datachannel_receive_states",
        kind: "message",
        T: DataChannelReceiveState,
        repeated: !0,
      },
    ]),
    DataChannelReceiveState = proto3.makeMessageType(
      "livekit.DataChannelReceiveState",
      () => [
        { no: 1, name: "publisher_sid", kind: "scalar", T: 9 },
        { no: 2, name: "last_seq", kind: "scalar", T: 13 },
      ]
    ),
    DataChannelInfo = proto3.makeMessageType("livekit.DataChannelInfo", () => [
      { no: 1, name: "label", kind: "scalar", T: 9 },
      { no: 2, name: "id", kind: "scalar", T: 13 },
      {
        no: 3,
        name: "target",
        kind: "enum",
        T: proto3.getEnumType(SignalTarget),
      },
    ]),
    SimulateScenario = proto3.makeMessageType(
      "livekit.SimulateScenario",
      () => [
        {
          no: 1,
          name: "speaker_update",
          kind: "scalar",
          T: 5,
          oneof: "scenario",
        },
        {
          no: 2,
          name: "node_failure",
          kind: "scalar",
          T: 8,
          oneof: "scenario",
        },
        { no: 3, name: "migration", kind: "scalar", T: 8, oneof: "scenario" },
        {
          no: 4,
          name: "server_leave",
          kind: "scalar",
          T: 8,
          oneof: "scenario",
        },
        {
          no: 5,
          name: "switch_candidate_protocol",
          kind: "enum",
          T: proto3.getEnumType(CandidateProtocol),
          oneof: "scenario",
        },
        {
          no: 6,
          name: "subscriber_bandwidth",
          kind: "scalar",
          T: 3,
          oneof: "scenario",
        },
        {
          no: 7,
          name: "disconnect_signal_on_resume",
          kind: "scalar",
          T: 8,
          oneof: "scenario",
        },
        {
          no: 8,
          name: "disconnect_signal_on_resume_no_messages",
          kind: "scalar",
          T: 8,
          oneof: "scenario",
        },
        {
          no: 9,
          name: "leave_request_full_reconnect",
          kind: "scalar",
          T: 8,
          oneof: "scenario",
        },
      ]
    ),
    Ping = proto3.makeMessageType("livekit.Ping", () => [
      { no: 1, name: "timestamp", kind: "scalar", T: 3 },
      { no: 2, name: "rtt", kind: "scalar", T: 3 },
    ]),
    Pong = proto3.makeMessageType("livekit.Pong", () => [
      { no: 1, name: "last_ping_timestamp", kind: "scalar", T: 3 },
      { no: 2, name: "timestamp", kind: "scalar", T: 3 },
    ]),
    RegionSettings = proto3.makeMessageType("livekit.RegionSettings", () => [
      { no: 1, name: "regions", kind: "message", T: RegionInfo, repeated: !0 },
    ]),
    RegionInfo = proto3.makeMessageType("livekit.RegionInfo", () => [
      { no: 1, name: "region", kind: "scalar", T: 9 },
      { no: 2, name: "url", kind: "scalar", T: 9 },
      { no: 3, name: "distance", kind: "scalar", T: 3 },
    ]),
    SubscriptionResponse = proto3.makeMessageType(
      "livekit.SubscriptionResponse",
      () => [
        { no: 1, name: "track_sid", kind: "scalar", T: 9 },
        {
          no: 2,
          name: "err",
          kind: "enum",
          T: proto3.getEnumType(SubscriptionError),
        },
      ]
    ),
    RequestResponse = proto3.makeMessageType("livekit.RequestResponse", () => [
      { no: 1, name: "request_id", kind: "scalar", T: 13 },
      {
        no: 2,
        name: "reason",
        kind: "enum",
        T: proto3.getEnumType(RequestResponse_Reason),
      },
      { no: 3, name: "message", kind: "scalar", T: 9 },
    ]),
    RequestResponse_Reason = proto3.makeEnum("livekit.RequestResponse.Reason", [
      { no: 0, name: "OK" },
      { no: 1, name: "NOT_FOUND" },
      { no: 2, name: "NOT_ALLOWED" },
      { no: 3, name: "LIMIT_EXCEEDED" },
    ]),
    TrackSubscribed = proto3.makeMessageType("livekit.TrackSubscribed", () => [
      { no: 1, name: "track_sid", kind: "scalar", T: 9 },
    ]);
  function getDefaultExportFromCjs(U) {
    return U &&
      U.__esModule &&
      Object.prototype.hasOwnProperty.call(U, "default")
      ? U.default
      : U;
  }
  var loglevel$1 = { exports: {} },
    loglevel = loglevel$1.exports,
    hasRequiredLoglevel;
  function requireLoglevel() {
    return (
      hasRequiredLoglevel ||
        ((hasRequiredLoglevel = 1),
        (function (U) {
          (function (j, V) {
            U.exports ? (U.exports = V()) : (j.log = V());
          })(loglevel, function () {
            var j = function () {},
              V = "undefined",
              B =
                typeof window !== V &&
                typeof window.navigator !== V &&
                /Trident\/|MSIE /.test(window.navigator.userAgent),
              q = ["trace", "debug", "info", "warn", "error"],
              $ = {},
              H = null;
            function G(se, fe) {
              var ce = se[fe];
              if (typeof ce.bind == "function") return ce.bind(se);
              try {
                return Function.prototype.bind.call(ce, se);
              } catch {
                return function () {
                  return Function.prototype.apply.apply(ce, [se, arguments]);
                };
              }
            }
            function Y() {
              console.log &&
                (console.log.apply
                  ? console.log.apply(console, arguments)
                  : Function.prototype.apply.apply(console.log, [
                      console,
                      arguments,
                    ])),
                console.trace && console.trace();
            }
            function Q(se) {
              return (
                se === "debug" && (se = "log"),
                typeof console === V
                  ? !1
                  : se === "trace" && B
                  ? Y
                  : console[se] !== void 0
                  ? G(console, se)
                  : console.log !== void 0
                  ? G(console, "log")
                  : j
              );
            }
            function X() {
              for (var se = this.getLevel(), fe = 0; fe < q.length; fe++) {
                var ce = q[fe];
                this[ce] = fe < se ? j : this.methodFactory(ce, se, this.name);
              }
              if (
                ((this.log = this.debug),
                typeof console === V && se < this.levels.SILENT)
              )
                return "No console available for logging";
            }
            function Z(se) {
              return function () {
                typeof console !== V &&
                  (X.call(this), this[se].apply(this, arguments));
              };
            }
            function te(se, fe, ce) {
              return Q(se) || Z.apply(this, arguments);
            }
            function ne(se, fe) {
              var ce = this,
                ue,
                he,
                me,
                ve = "loglevel";
              typeof se == "string"
                ? (ve += ":" + se)
                : typeof se == "symbol" && (ve = void 0);
              function ge(be) {
                var Le = (q[be] || "silent").toUpperCase();
                if (!(typeof window === V || !ve)) {
                  try {
                    window.localStorage[ve] = Le;
                    return;
                  } catch {}
                  try {
                    window.document.cookie =
                      encodeURIComponent(ve) + "=" + Le + ";";
                  } catch {}
                }
              }
              function Ee() {
                var be;
                if (!(typeof window === V || !ve)) {
                  try {
                    be = window.localStorage[ve];
                  } catch {}
                  if (typeof be === V)
                    try {
                      var Le = window.document.cookie,
                        Fe = encodeURIComponent(ve),
                        Me = Le.indexOf(Fe + "=");
                      Me !== -1 &&
                        (be = /^([^;]+)/.exec(Le.slice(Me + Fe.length + 1))[1]);
                    } catch {}
                  return ce.levels[be] === void 0 && (be = void 0), be;
                }
              }
              function Ce() {
                if (!(typeof window === V || !ve)) {
                  try {
                    window.localStorage.removeItem(ve);
                  } catch {}
                  try {
                    window.document.cookie =
                      encodeURIComponent(ve) +
                      "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
                  } catch {}
                }
              }
              function Re(be) {
                var Le = be;
                if (
                  (typeof Le == "string" &&
                    ce.levels[Le.toUpperCase()] !== void 0 &&
                    (Le = ce.levels[Le.toUpperCase()]),
                  typeof Le == "number" && Le >= 0 && Le <= ce.levels.SILENT)
                )
                  return Le;
                throw new TypeError(
                  "log.setLevel() called with invalid level: " + be
                );
              }
              (ce.name = se),
                (ce.levels = {
                  TRACE: 0,
                  DEBUG: 1,
                  INFO: 2,
                  WARN: 3,
                  ERROR: 4,
                  SILENT: 5,
                }),
                (ce.methodFactory = fe || te),
                (ce.getLevel = function () {
                  return me ?? he ?? ue;
                }),
                (ce.setLevel = function (be, Le) {
                  return (me = Re(be)), Le !== !1 && ge(me), X.call(ce);
                }),
                (ce.setDefaultLevel = function (be) {
                  (he = Re(be)), Ee() || ce.setLevel(be, !1);
                }),
                (ce.resetLevel = function () {
                  (me = null), Ce(), X.call(ce);
                }),
                (ce.enableAll = function (be) {
                  ce.setLevel(ce.levels.TRACE, be);
                }),
                (ce.disableAll = function (be) {
                  ce.setLevel(ce.levels.SILENT, be);
                }),
                (ce.rebuild = function () {
                  if (
                    (H !== ce && (ue = Re(H.getLevel())), X.call(ce), H === ce)
                  )
                    for (var be in $) $[be].rebuild();
                }),
                (ue = Re(H ? H.getLevel() : "WARN"));
              var Ae = Ee();
              Ae != null && (me = Re(Ae)), X.call(ce);
            }
            (H = new ne()),
              (H.getLogger = function (fe) {
                if (
                  (typeof fe != "symbol" && typeof fe != "string") ||
                  fe === ""
                )
                  throw new TypeError(
                    "You must supply a name when creating a logger."
                  );
                var ce = $[fe];
                return ce || (ce = $[fe] = new ne(fe, H.methodFactory)), ce;
              });
            var ae = typeof window !== V ? window.log : void 0;
            return (
              (H.noConflict = function () {
                return (
                  typeof window !== V && window.log === H && (window.log = ae),
                  H
                );
              }),
              (H.getLoggers = function () {
                return $;
              }),
              (H.default = H),
              H
            );
          });
        })(loglevel$1)),
      loglevel$1.exports
    );
  }
  var loglevelExports = requireLoglevel(),
    LogLevel;
  (function (U) {
    (U[(U.trace = 0)] = "trace"),
      (U[(U.debug = 1)] = "debug"),
      (U[(U.info = 2)] = "info"),
      (U[(U.warn = 3)] = "warn"),
      (U[(U.error = 4)] = "error"),
      (U[(U.silent = 5)] = "silent");
  })(LogLevel || (LogLevel = {}));
  var LoggerNames;
  (function (U) {
    (U.Default = "livekit"),
      (U.Room = "livekit-room"),
      (U.Participant = "livekit-participant"),
      (U.Track = "livekit-track"),
      (U.Publication = "livekit-track-publication"),
      (U.Engine = "livekit-engine"),
      (U.Signal = "livekit-signal"),
      (U.PCManager = "livekit-pc-manager"),
      (U.PCTransport = "livekit-pc-transport"),
      (U.E2EE = "lk-e2ee");
  })(LoggerNames || (LoggerNames = {}));
  let livekitLogger = loglevelExports.getLogger("livekit");
  Object.values(LoggerNames).map((U) => loglevelExports.getLogger(U)),
    livekitLogger.setDefaultLevel(LogLevel.info);
  function getLogger(U) {
    const j = loglevelExports.getLogger(U);
    return j.setDefaultLevel(livekitLogger.getLevel()), j;
  }
  const workerLogger = loglevelExports.getLogger("lk-e2ee"),
    maxRetryDelay = 7e3,
    DEFAULT_RETRY_DELAYS_IN_MS = [
      0,
      300,
      2 * 2 * 300,
      3 * 3 * 300,
      4 * 4 * 300,
      maxRetryDelay,
      maxRetryDelay,
      maxRetryDelay,
      maxRetryDelay,
      maxRetryDelay,
    ];
  class DefaultReconnectPolicy {
    constructor(j) {
      this._retryDelays = j !== void 0 ? [...j] : DEFAULT_RETRY_DELAYS_IN_MS;
    }
    nextRetryDelayInMs(j) {
      if (j.retryCount >= this._retryDelays.length) return null;
      const V = this._retryDelays[j.retryCount];
      return j.retryCount <= 1 ? V : V + Math.random() * 1e3;
    }
  }
  function __rest(U, j) {
    var V = {};
    for (var B in U)
      Object.prototype.hasOwnProperty.call(U, B) &&
        j.indexOf(B) < 0 &&
        (V[B] = U[B]);
    if (U != null && typeof Object.getOwnPropertySymbols == "function")
      for (var q = 0, B = Object.getOwnPropertySymbols(U); q < B.length; q++)
        j.indexOf(B[q]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(U, B[q]) &&
          (V[B[q]] = U[B[q]]);
    return V;
  }
  function __awaiter$1(U, j, V, B) {
    function q($) {
      return $ instanceof V
        ? $
        : new V(function (H) {
            H($);
          });
    }
    return new (V || (V = Promise))(function ($, H) {
      function G(X) {
        try {
          Q(B.next(X));
        } catch (Z) {
          H(Z);
        }
      }
      function Y(X) {
        try {
          Q(B.throw(X));
        } catch (Z) {
          H(Z);
        }
      }
      function Q(X) {
        X.done ? $(X.value) : q(X.value).then(G, Y);
      }
      Q((B = B.apply(U, j || [])).next());
    });
  }
  function __values(U) {
    var j = typeof Symbol == "function" && Symbol.iterator,
      V = j && U[j],
      B = 0;
    if (V) return V.call(U);
    if (U && typeof U.length == "number")
      return {
        next: function () {
          return (
            U && B >= U.length && (U = void 0), { value: U && U[B++], done: !U }
          );
        },
      };
    throw new TypeError(
      j ? "Object is not iterable." : "Symbol.iterator is not defined."
    );
  }
  function __asyncValues(U) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var j = U[Symbol.asyncIterator],
      V;
    return j
      ? j.call(U)
      : ((U =
          typeof __values == "function" ? __values(U) : U[Symbol.iterator]()),
        (V = {}),
        B("next"),
        B("throw"),
        B("return"),
        (V[Symbol.asyncIterator] = function () {
          return this;
        }),
        V);
    function B($) {
      V[$] =
        U[$] &&
        function (H) {
          return new Promise(function (G, Y) {
            (H = U[$](H)), q(G, Y, H.done, H.value);
          });
        };
    }
    function q($, H, G, Y) {
      Promise.resolve(Y).then(function (Q) {
        $({ value: Q, done: G });
      }, H);
    }
  }
  typeof SuppressedError == "function" && SuppressedError;
  var events = { exports: {} },
    hasRequiredEvents;
  function requireEvents() {
    if (hasRequiredEvents) return events.exports;
    hasRequiredEvents = 1;
    var U = typeof Reflect == "object" ? Reflect : null,
      j =
        U && typeof U.apply == "function"
          ? U.apply
          : function (ve, ge, Ee) {
              return Function.prototype.apply.call(ve, ge, Ee);
            },
      V;
    U && typeof U.ownKeys == "function"
      ? (V = U.ownKeys)
      : Object.getOwnPropertySymbols
      ? (V = function (ve) {
          return Object.getOwnPropertyNames(ve).concat(
            Object.getOwnPropertySymbols(ve)
          );
        })
      : (V = function (ve) {
          return Object.getOwnPropertyNames(ve);
        });
    function B(me) {
      console && console.warn && console.warn(me);
    }
    var q =
      Number.isNaN ||
      function (ve) {
        return ve !== ve;
      };
    function $() {
      $.init.call(this);
    }
    (events.exports = $),
      (events.exports.once = ce),
      ($.EventEmitter = $),
      ($.prototype._events = void 0),
      ($.prototype._eventsCount = 0),
      ($.prototype._maxListeners = void 0);
    var H = 10;
    function G(me) {
      if (typeof me != "function")
        throw new TypeError(
          'The "listener" argument must be of type Function. Received type ' +
            typeof me
        );
    }
    Object.defineProperty($, "defaultMaxListeners", {
      enumerable: !0,
      get: function () {
        return H;
      },
      set: function (me) {
        if (typeof me != "number" || me < 0 || q(me))
          throw new RangeError(
            'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
              me +
              "."
          );
        H = me;
      },
    }),
      ($.init = function () {
        (this._events === void 0 ||
          this._events === Object.getPrototypeOf(this)._events) &&
          ((this._events = Object.create(null)), (this._eventsCount = 0)),
          (this._maxListeners = this._maxListeners || void 0);
      }),
      ($.prototype.setMaxListeners = function (ve) {
        if (typeof ve != "number" || ve < 0 || q(ve))
          throw new RangeError(
            'The value of "n" is out of range. It must be a non-negative number. Received ' +
              ve +
              "."
          );
        return (this._maxListeners = ve), this;
      });
    function Y(me) {
      return me._maxListeners === void 0
        ? $.defaultMaxListeners
        : me._maxListeners;
    }
    ($.prototype.getMaxListeners = function () {
      return Y(this);
    }),
      ($.prototype.emit = function (ve) {
        for (var ge = [], Ee = 1; Ee < arguments.length; Ee++)
          ge.push(arguments[Ee]);
        var Ce = ve === "error",
          Re = this._events;
        if (Re !== void 0) Ce = Ce && Re.error === void 0;
        else if (!Ce) return !1;
        if (Ce) {
          var Ae;
          if ((ge.length > 0 && (Ae = ge[0]), Ae instanceof Error)) throw Ae;
          var be = new Error(
            "Unhandled error." + (Ae ? " (" + Ae.message + ")" : "")
          );
          throw ((be.context = Ae), be);
        }
        var Le = Re[ve];
        if (Le === void 0) return !1;
        if (typeof Le == "function") j(Le, this, ge);
        else
          for (var Fe = Le.length, Me = ae(Le, Fe), Ee = 0; Ee < Fe; ++Ee)
            j(Me[Ee], this, ge);
        return !0;
      });
    function Q(me, ve, ge, Ee) {
      var Ce, Re, Ae;
      if (
        (G(ge),
        (Re = me._events),
        Re === void 0
          ? ((Re = me._events = Object.create(null)), (me._eventsCount = 0))
          : (Re.newListener !== void 0 &&
              (me.emit("newListener", ve, ge.listener ? ge.listener : ge),
              (Re = me._events)),
            (Ae = Re[ve])),
        Ae === void 0)
      )
        (Ae = Re[ve] = ge), ++me._eventsCount;
      else if (
        (typeof Ae == "function"
          ? (Ae = Re[ve] = Ee ? [ge, Ae] : [Ae, ge])
          : Ee
          ? Ae.unshift(ge)
          : Ae.push(ge),
        (Ce = Y(me)),
        Ce > 0 && Ae.length > Ce && !Ae.warned)
      ) {
        Ae.warned = !0;
        var be = new Error(
          "Possible EventEmitter memory leak detected. " +
            Ae.length +
            " " +
            String(ve) +
            " listeners added. Use emitter.setMaxListeners() to increase limit"
        );
        (be.name = "MaxListenersExceededWarning"),
          (be.emitter = me),
          (be.type = ve),
          (be.count = Ae.length),
          B(be);
      }
      return me;
    }
    ($.prototype.addListener = function (ve, ge) {
      return Q(this, ve, ge, !1);
    }),
      ($.prototype.on = $.prototype.addListener),
      ($.prototype.prependListener = function (ve, ge) {
        return Q(this, ve, ge, !0);
      });
    function X() {
      if (!this.fired)
        return (
          this.target.removeListener(this.type, this.wrapFn),
          (this.fired = !0),
          arguments.length === 0
            ? this.listener.call(this.target)
            : this.listener.apply(this.target, arguments)
        );
    }
    function Z(me, ve, ge) {
      var Ee = {
          fired: !1,
          wrapFn: void 0,
          target: me,
          type: ve,
          listener: ge,
        },
        Ce = X.bind(Ee);
      return (Ce.listener = ge), (Ee.wrapFn = Ce), Ce;
    }
    ($.prototype.once = function (ve, ge) {
      return G(ge), this.on(ve, Z(this, ve, ge)), this;
    }),
      ($.prototype.prependOnceListener = function (ve, ge) {
        return G(ge), this.prependListener(ve, Z(this, ve, ge)), this;
      }),
      ($.prototype.removeListener = function (ve, ge) {
        var Ee, Ce, Re, Ae, be;
        if ((G(ge), (Ce = this._events), Ce === void 0)) return this;
        if (((Ee = Ce[ve]), Ee === void 0)) return this;
        if (Ee === ge || Ee.listener === ge)
          --this._eventsCount === 0
            ? (this._events = Object.create(null))
            : (delete Ce[ve],
              Ce.removeListener &&
                this.emit("removeListener", ve, Ee.listener || ge));
        else if (typeof Ee != "function") {
          for (Re = -1, Ae = Ee.length - 1; Ae >= 0; Ae--)
            if (Ee[Ae] === ge || Ee[Ae].listener === ge) {
              (be = Ee[Ae].listener), (Re = Ae);
              break;
            }
          if (Re < 0) return this;
          Re === 0 ? Ee.shift() : se(Ee, Re),
            Ee.length === 1 && (Ce[ve] = Ee[0]),
            Ce.removeListener !== void 0 &&
              this.emit("removeListener", ve, be || ge);
        }
        return this;
      }),
      ($.prototype.off = $.prototype.removeListener),
      ($.prototype.removeAllListeners = function (ve) {
        var ge, Ee, Ce;
        if (((Ee = this._events), Ee === void 0)) return this;
        if (Ee.removeListener === void 0)
          return (
            arguments.length === 0
              ? ((this._events = Object.create(null)), (this._eventsCount = 0))
              : Ee[ve] !== void 0 &&
                (--this._eventsCount === 0
                  ? (this._events = Object.create(null))
                  : delete Ee[ve]),
            this
          );
        if (arguments.length === 0) {
          var Re = Object.keys(Ee),
            Ae;
          for (Ce = 0; Ce < Re.length; ++Ce)
            (Ae = Re[Ce]),
              Ae !== "removeListener" && this.removeAllListeners(Ae);
          return (
            this.removeAllListeners("removeListener"),
            (this._events = Object.create(null)),
            (this._eventsCount = 0),
            this
          );
        }
        if (((ge = Ee[ve]), typeof ge == "function"))
          this.removeListener(ve, ge);
        else if (ge !== void 0)
          for (Ce = ge.length - 1; Ce >= 0; Ce--)
            this.removeListener(ve, ge[Ce]);
        return this;
      });
    function te(me, ve, ge) {
      var Ee = me._events;
      if (Ee === void 0) return [];
      var Ce = Ee[ve];
      return Ce === void 0
        ? []
        : typeof Ce == "function"
        ? ge
          ? [Ce.listener || Ce]
          : [Ce]
        : ge
        ? fe(Ce)
        : ae(Ce, Ce.length);
    }
    ($.prototype.listeners = function (ve) {
      return te(this, ve, !0);
    }),
      ($.prototype.rawListeners = function (ve) {
        return te(this, ve, !1);
      }),
      ($.listenerCount = function (me, ve) {
        return typeof me.listenerCount == "function"
          ? me.listenerCount(ve)
          : ne.call(me, ve);
      }),
      ($.prototype.listenerCount = ne);
    function ne(me) {
      var ve = this._events;
      if (ve !== void 0) {
        var ge = ve[me];
        if (typeof ge == "function") return 1;
        if (ge !== void 0) return ge.length;
      }
      return 0;
    }
    $.prototype.eventNames = function () {
      return this._eventsCount > 0 ? V(this._events) : [];
    };
    function ae(me, ve) {
      for (var ge = new Array(ve), Ee = 0; Ee < ve; ++Ee) ge[Ee] = me[Ee];
      return ge;
    }
    function se(me, ve) {
      for (; ve + 1 < me.length; ve++) me[ve] = me[ve + 1];
      me.pop();
    }
    function fe(me) {
      for (var ve = new Array(me.length), ge = 0; ge < ve.length; ++ge)
        ve[ge] = me[ge].listener || me[ge];
      return ve;
    }
    function ce(me, ve) {
      return new Promise(function (ge, Ee) {
        function Ce(Ae) {
          me.removeListener(ve, Re), Ee(Ae);
        }
        function Re() {
          typeof me.removeListener == "function" &&
            me.removeListener("error", Ce),
            ge([].slice.call(arguments));
        }
        he(me, ve, Re, { once: !0 }),
          ve !== "error" && ue(me, Ce, { once: !0 });
      });
    }
    function ue(me, ve, ge) {
      typeof me.on == "function" && he(me, "error", ve, ge);
    }
    function he(me, ve, ge, Ee) {
      if (typeof me.on == "function") Ee.once ? me.once(ve, ge) : me.on(ve, ge);
      else if (typeof me.addEventListener == "function")
        me.addEventListener(ve, function Ce(Re) {
          Ee.once && me.removeEventListener(ve, Ce), ge(Re);
        });
      else
        throw new TypeError(
          'The "emitter" argument must be of type EventEmitter. Received type ' +
            typeof me
        );
    }
    return events.exports;
  }
  var eventsExports = requireEvents();
  let logDisabled_ = !0,
    deprecationWarnings_ = !0;
  function extractVersion(U, j, V) {
    const B = U.match(j);
    return B && B.length >= V && parseFloat(B[V], 10);
  }
  function wrapPeerConnectionEvent(U, j, V) {
    if (!U.RTCPeerConnection) return;
    const B = U.RTCPeerConnection.prototype,
      q = B.addEventListener;
    B.addEventListener = function (H, G) {
      if (H !== j) return q.apply(this, arguments);
      const Y = (Q) => {
        const X = V(Q);
        X && (G.handleEvent ? G.handleEvent(X) : G(X));
      };
      return (
        (this._eventMap = this._eventMap || {}),
        this._eventMap[j] || (this._eventMap[j] = new Map()),
        this._eventMap[j].set(G, Y),
        q.apply(this, [H, Y])
      );
    };
    const $ = B.removeEventListener;
    (B.removeEventListener = function (H, G) {
      if (H !== j || !this._eventMap || !this._eventMap[j])
        return $.apply(this, arguments);
      if (!this._eventMap[j].has(G)) return $.apply(this, arguments);
      const Y = this._eventMap[j].get(G);
      return (
        this._eventMap[j].delete(G),
        this._eventMap[j].size === 0 && delete this._eventMap[j],
        Object.keys(this._eventMap).length === 0 && delete this._eventMap,
        $.apply(this, [H, Y])
      );
    }),
      Object.defineProperty(B, "on" + j, {
        get() {
          return this["_on" + j];
        },
        set(H) {
          this["_on" + j] &&
            (this.removeEventListener(j, this["_on" + j]),
            delete this["_on" + j]),
            H && this.addEventListener(j, (this["_on" + j] = H));
        },
        enumerable: !0,
        configurable: !0,
      });
  }
  function disableLog(U) {
    return typeof U != "boolean"
      ? new Error("Argument type: " + typeof U + ". Please use a boolean.")
      : ((logDisabled_ = U),
        U ? "adapter.js logging disabled" : "adapter.js logging enabled");
  }
  function disableWarnings(U) {
    return typeof U != "boolean"
      ? new Error("Argument type: " + typeof U + ". Please use a boolean.")
      : ((deprecationWarnings_ = !U),
        "adapter.js deprecation warnings " + (U ? "disabled" : "enabled"));
  }
  function log() {
    if (typeof window == "object") {
      if (logDisabled_) return;
      typeof console < "u" &&
        typeof console.log == "function" &&
        console.log.apply(console, arguments);
    }
  }
  function deprecated(U, j) {
    deprecationWarnings_ &&
      console.warn(U + " is deprecated, please use " + j + " instead.");
  }
  function detectBrowser(U) {
    const j = { browser: null, version: null };
    if (typeof U > "u" || !U.navigator || !U.navigator.userAgent)
      return (j.browser = "Not a browser."), j;
    const { navigator: V } = U;
    if (V.userAgentData && V.userAgentData.brands) {
      const B = V.userAgentData.brands.find((q) => q.brand === "Chromium");
      if (B) return { browser: "chrome", version: parseInt(B.version, 10) };
    }
    if (V.mozGetUserMedia)
      (j.browser = "firefox"),
        (j.version = parseInt(
          extractVersion(V.userAgent, /Firefox\/(\d+)\./, 1)
        ));
    else if (
      V.webkitGetUserMedia ||
      (U.isSecureContext === !1 && U.webkitRTCPeerConnection)
    )
      (j.browser = "chrome"),
        (j.version = parseInt(
          extractVersion(V.userAgent, /Chrom(e|ium)\/(\d+)\./, 2)
        ));
    else if (U.RTCPeerConnection && V.userAgent.match(/AppleWebKit\/(\d+)\./))
      (j.browser = "safari"),
        (j.version = parseInt(
          extractVersion(V.userAgent, /AppleWebKit\/(\d+)\./, 1)
        )),
        (j.supportsUnifiedPlan =
          U.RTCRtpTransceiver &&
          "currentDirection" in U.RTCRtpTransceiver.prototype),
        (j._safariVersion = extractVersion(
          V.userAgent,
          /Version\/(\d+(\.?\d+))/,
          1
        ));
    else return (j.browser = "Not a supported browser."), j;
    return j;
  }
  function isObject(U) {
    return Object.prototype.toString.call(U) === "[object Object]";
  }
  function compactObject(U) {
    return isObject(U)
      ? Object.keys(U).reduce(function (j, V) {
          const B = isObject(U[V]),
            q = B ? compactObject(U[V]) : U[V],
            $ = B && !Object.keys(q).length;
          return q === void 0 || $ ? j : Object.assign(j, { [V]: q });
        }, {})
      : U;
  }
  function walkStats(U, j, V) {
    !j ||
      V.has(j.id) ||
      (V.set(j.id, j),
      Object.keys(j).forEach((B) => {
        B.endsWith("Id")
          ? walkStats(U, U.get(j[B]), V)
          : B.endsWith("Ids") &&
            j[B].forEach((q) => {
              walkStats(U, U.get(q), V);
            });
      }));
  }
  function filterStats(U, j, V) {
    const B = V ? "outbound-rtp" : "inbound-rtp",
      q = new Map();
    if (j === null) return q;
    const $ = [];
    return (
      U.forEach((H) => {
        H.type === "track" && H.trackIdentifier === j.id && $.push(H);
      }),
      $.forEach((H) => {
        U.forEach((G) => {
          G.type === B && G.trackId === H.id && walkStats(U, G, q);
        });
      }),
      q
    );
  }
  const logging = log;
  function shimGetUserMedia$2(U, j) {
    const V = U && U.navigator;
    if (!V.mediaDevices) return;
    const B = function (G) {
        if (typeof G != "object" || G.mandatory || G.optional) return G;
        const Y = {};
        return (
          Object.keys(G).forEach((Q) => {
            if (Q === "require" || Q === "advanced" || Q === "mediaSource")
              return;
            const X = typeof G[Q] == "object" ? G[Q] : { ideal: G[Q] };
            X.exact !== void 0 &&
              typeof X.exact == "number" &&
              (X.min = X.max = X.exact);
            const Z = function (te, ne) {
              return te
                ? te + ne.charAt(0).toUpperCase() + ne.slice(1)
                : ne === "deviceId"
                ? "sourceId"
                : ne;
            };
            if (X.ideal !== void 0) {
              Y.optional = Y.optional || [];
              let te = {};
              typeof X.ideal == "number"
                ? ((te[Z("min", Q)] = X.ideal),
                  Y.optional.push(te),
                  (te = {}),
                  (te[Z("max", Q)] = X.ideal),
                  Y.optional.push(te))
                : ((te[Z("", Q)] = X.ideal), Y.optional.push(te));
            }
            X.exact !== void 0 && typeof X.exact != "number"
              ? ((Y.mandatory = Y.mandatory || {}),
                (Y.mandatory[Z("", Q)] = X.exact))
              : ["min", "max"].forEach((te) => {
                  X[te] !== void 0 &&
                    ((Y.mandatory = Y.mandatory || {}),
                    (Y.mandatory[Z(te, Q)] = X[te]));
                });
          }),
          G.advanced && (Y.optional = (Y.optional || []).concat(G.advanced)),
          Y
        );
      },
      q = function (G, Y) {
        if (j.version >= 61) return Y(G);
        if (
          ((G = JSON.parse(JSON.stringify(G))), G && typeof G.audio == "object")
        ) {
          const Q = function (X, Z, te) {
            Z in X && !(te in X) && ((X[te] = X[Z]), delete X[Z]);
          };
          (G = JSON.parse(JSON.stringify(G))),
            Q(G.audio, "autoGainControl", "googAutoGainControl"),
            Q(G.audio, "noiseSuppression", "googNoiseSuppression"),
            (G.audio = B(G.audio));
        }
        if (G && typeof G.video == "object") {
          let Q = G.video.facingMode;
          Q = Q && (typeof Q == "object" ? Q : { ideal: Q });
          const X = j.version < 66;
          if (
            Q &&
            (Q.exact === "user" ||
              Q.exact === "environment" ||
              Q.ideal === "user" ||
              Q.ideal === "environment") &&
            !(
              V.mediaDevices.getSupportedConstraints &&
              V.mediaDevices.getSupportedConstraints().facingMode &&
              !X
            )
          ) {
            delete G.video.facingMode;
            let Z;
            if (
              (Q.exact === "environment" || Q.ideal === "environment"
                ? (Z = ["back", "rear"])
                : (Q.exact === "user" || Q.ideal === "user") && (Z = ["front"]),
              Z)
            )
              return V.mediaDevices.enumerateDevices().then((te) => {
                te = te.filter((ae) => ae.kind === "videoinput");
                let ne = te.find((ae) =>
                  Z.some((se) => ae.label.toLowerCase().includes(se))
                );
                return (
                  !ne &&
                    te.length &&
                    Z.includes("back") &&
                    (ne = te[te.length - 1]),
                  ne &&
                    (G.video.deviceId = Q.exact
                      ? { exact: ne.deviceId }
                      : { ideal: ne.deviceId }),
                  (G.video = B(G.video)),
                  logging("chrome: " + JSON.stringify(G)),
                  Y(G)
                );
              });
          }
          G.video = B(G.video);
        }
        return logging("chrome: " + JSON.stringify(G)), Y(G);
      },
      $ = function (G) {
        return j.version >= 64
          ? G
          : {
              name:
                {
                  PermissionDeniedError: "NotAllowedError",
                  PermissionDismissedError: "NotAllowedError",
                  InvalidStateError: "NotAllowedError",
                  DevicesNotFoundError: "NotFoundError",
                  ConstraintNotSatisfiedError: "OverconstrainedError",
                  TrackStartError: "NotReadableError",
                  MediaDeviceFailedDueToShutdown: "NotAllowedError",
                  MediaDeviceKillSwitchOn: "NotAllowedError",
                  TabCaptureError: "AbortError",
                  ScreenCaptureError: "AbortError",
                  DeviceCaptureError: "AbortError",
                }[G.name] || G.name,
              message: G.message,
              constraint: G.constraint || G.constraintName,
              toString() {
                return this.name + (this.message && ": ") + this.message;
              },
            };
      },
      H = function (G, Y, Q) {
        q(G, (X) => {
          V.webkitGetUserMedia(X, Y, (Z) => {
            Q && Q($(Z));
          });
        });
      };
    if (((V.getUserMedia = H.bind(V)), V.mediaDevices.getUserMedia)) {
      const G = V.mediaDevices.getUserMedia.bind(V.mediaDevices);
      V.mediaDevices.getUserMedia = function (Y) {
        return q(Y, (Q) =>
          G(Q).then(
            (X) => {
              if (
                (Q.audio && !X.getAudioTracks().length) ||
                (Q.video && !X.getVideoTracks().length)
              )
                throw (
                  (X.getTracks().forEach((Z) => {
                    Z.stop();
                  }),
                  new DOMException("", "NotFoundError"))
                );
              return X;
            },
            (X) => Promise.reject($(X))
          )
        );
      };
    }
  }
  function shimMediaStream(U) {
    U.MediaStream = U.MediaStream || U.webkitMediaStream;
  }
  function shimOnTrack$1(U) {
    if (
      typeof U == "object" &&
      U.RTCPeerConnection &&
      !("ontrack" in U.RTCPeerConnection.prototype)
    ) {
      Object.defineProperty(U.RTCPeerConnection.prototype, "ontrack", {
        get() {
          return this._ontrack;
        },
        set(V) {
          this._ontrack && this.removeEventListener("track", this._ontrack),
            this.addEventListener("track", (this._ontrack = V));
        },
        enumerable: !0,
        configurable: !0,
      });
      const j = U.RTCPeerConnection.prototype.setRemoteDescription;
      U.RTCPeerConnection.prototype.setRemoteDescription = function () {
        return (
          this._ontrackpoly ||
            ((this._ontrackpoly = (B) => {
              B.stream.addEventListener("addtrack", (q) => {
                let $;
                U.RTCPeerConnection.prototype.getReceivers
                  ? ($ = this.getReceivers().find(
                      (G) => G.track && G.track.id === q.track.id
                    ))
                  : ($ = { track: q.track });
                const H = new Event("track");
                (H.track = q.track),
                  (H.receiver = $),
                  (H.transceiver = { receiver: $ }),
                  (H.streams = [B.stream]),
                  this.dispatchEvent(H);
              }),
                B.stream.getTracks().forEach((q) => {
                  let $;
                  U.RTCPeerConnection.prototype.getReceivers
                    ? ($ = this.getReceivers().find(
                        (G) => G.track && G.track.id === q.id
                      ))
                    : ($ = { track: q });
                  const H = new Event("track");
                  (H.track = q),
                    (H.receiver = $),
                    (H.transceiver = { receiver: $ }),
                    (H.streams = [B.stream]),
                    this.dispatchEvent(H);
                });
            }),
            this.addEventListener("addstream", this._ontrackpoly)),
          j.apply(this, arguments)
        );
      };
    } else
      wrapPeerConnectionEvent(
        U,
        "track",
        (j) => (
          j.transceiver ||
            Object.defineProperty(j, "transceiver", {
              value: { receiver: j.receiver },
            }),
          j
        )
      );
  }
  function shimGetSendersWithDtmf(U) {
    if (
      typeof U == "object" &&
      U.RTCPeerConnection &&
      !("getSenders" in U.RTCPeerConnection.prototype) &&
      "createDTMFSender" in U.RTCPeerConnection.prototype
    ) {
      const j = function (q, $) {
        return {
          track: $,
          get dtmf() {
            return (
              this._dtmf === void 0 &&
                ($.kind === "audio"
                  ? (this._dtmf = q.createDTMFSender($))
                  : (this._dtmf = null)),
              this._dtmf
            );
          },
          _pc: q,
        };
      };
      if (!U.RTCPeerConnection.prototype.getSenders) {
        U.RTCPeerConnection.prototype.getSenders = function () {
          return (this._senders = this._senders || []), this._senders.slice();
        };
        const q = U.RTCPeerConnection.prototype.addTrack;
        U.RTCPeerConnection.prototype.addTrack = function (G, Y) {
          let Q = q.apply(this, arguments);
          return Q || ((Q = j(this, G)), this._senders.push(Q)), Q;
        };
        const $ = U.RTCPeerConnection.prototype.removeTrack;
        U.RTCPeerConnection.prototype.removeTrack = function (G) {
          $.apply(this, arguments);
          const Y = this._senders.indexOf(G);
          Y !== -1 && this._senders.splice(Y, 1);
        };
      }
      const V = U.RTCPeerConnection.prototype.addStream;
      U.RTCPeerConnection.prototype.addStream = function ($) {
        (this._senders = this._senders || []),
          V.apply(this, [$]),
          $.getTracks().forEach((H) => {
            this._senders.push(j(this, H));
          });
      };
      const B = U.RTCPeerConnection.prototype.removeStream;
      U.RTCPeerConnection.prototype.removeStream = function ($) {
        (this._senders = this._senders || []),
          B.apply(this, [$]),
          $.getTracks().forEach((H) => {
            const G = this._senders.find((Y) => Y.track === H);
            G && this._senders.splice(this._senders.indexOf(G), 1);
          });
      };
    } else if (
      typeof U == "object" &&
      U.RTCPeerConnection &&
      "getSenders" in U.RTCPeerConnection.prototype &&
      "createDTMFSender" in U.RTCPeerConnection.prototype &&
      U.RTCRtpSender &&
      !("dtmf" in U.RTCRtpSender.prototype)
    ) {
      const j = U.RTCPeerConnection.prototype.getSenders;
      (U.RTCPeerConnection.prototype.getSenders = function () {
        const B = j.apply(this, []);
        return B.forEach((q) => (q._pc = this)), B;
      }),
        Object.defineProperty(U.RTCRtpSender.prototype, "dtmf", {
          get() {
            return (
              this._dtmf === void 0 &&
                (this.track.kind === "audio"
                  ? (this._dtmf = this._pc.createDTMFSender(this.track))
                  : (this._dtmf = null)),
              this._dtmf
            );
          },
        });
    }
  }
  function shimSenderReceiverGetStats(U) {
    if (
      !(
        typeof U == "object" &&
        U.RTCPeerConnection &&
        U.RTCRtpSender &&
        U.RTCRtpReceiver
      )
    )
      return;
    if (!("getStats" in U.RTCRtpSender.prototype)) {
      const V = U.RTCPeerConnection.prototype.getSenders;
      V &&
        (U.RTCPeerConnection.prototype.getSenders = function () {
          const $ = V.apply(this, []);
          return $.forEach((H) => (H._pc = this)), $;
        });
      const B = U.RTCPeerConnection.prototype.addTrack;
      B &&
        (U.RTCPeerConnection.prototype.addTrack = function () {
          const $ = B.apply(this, arguments);
          return ($._pc = this), $;
        }),
        (U.RTCRtpSender.prototype.getStats = function () {
          const $ = this;
          return this._pc.getStats().then((H) => filterStats(H, $.track, !0));
        });
    }
    if (!("getStats" in U.RTCRtpReceiver.prototype)) {
      const V = U.RTCPeerConnection.prototype.getReceivers;
      V &&
        (U.RTCPeerConnection.prototype.getReceivers = function () {
          const q = V.apply(this, []);
          return q.forEach(($) => ($._pc = this)), q;
        }),
        wrapPeerConnectionEvent(
          U,
          "track",
          (B) => ((B.receiver._pc = B.srcElement), B)
        ),
        (U.RTCRtpReceiver.prototype.getStats = function () {
          const q = this;
          return this._pc.getStats().then(($) => filterStats($, q.track, !1));
        });
    }
    if (
      !(
        "getStats" in U.RTCRtpSender.prototype &&
        "getStats" in U.RTCRtpReceiver.prototype
      )
    )
      return;
    const j = U.RTCPeerConnection.prototype.getStats;
    U.RTCPeerConnection.prototype.getStats = function () {
      if (arguments.length > 0 && arguments[0] instanceof U.MediaStreamTrack) {
        const B = arguments[0];
        let q, $, H;
        return (
          this.getSenders().forEach((G) => {
            G.track === B && (q ? (H = !0) : (q = G));
          }),
          this.getReceivers().forEach(
            (G) => (G.track === B && ($ ? (H = !0) : ($ = G)), G.track === B)
          ),
          H || (q && $)
            ? Promise.reject(
                new DOMException(
                  "There are more than one sender or receiver for the track.",
                  "InvalidAccessError"
                )
              )
            : q
            ? q.getStats()
            : $
            ? $.getStats()
            : Promise.reject(
                new DOMException(
                  "There is no sender or receiver for the track.",
                  "InvalidAccessError"
                )
              )
        );
      }
      return j.apply(this, arguments);
    };
  }
  function shimAddTrackRemoveTrackWithNative(U) {
    U.RTCPeerConnection.prototype.getLocalStreams = function () {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        Object.keys(this._shimmedLocalStreams).map(
          (H) => this._shimmedLocalStreams[H][0]
        )
      );
    };
    const j = U.RTCPeerConnection.prototype.addTrack;
    U.RTCPeerConnection.prototype.addTrack = function (H, G) {
      if (!G) return j.apply(this, arguments);
      this._shimmedLocalStreams = this._shimmedLocalStreams || {};
      const Y = j.apply(this, arguments);
      return (
        this._shimmedLocalStreams[G.id]
          ? this._shimmedLocalStreams[G.id].indexOf(Y) === -1 &&
            this._shimmedLocalStreams[G.id].push(Y)
          : (this._shimmedLocalStreams[G.id] = [G, Y]),
        Y
      );
    };
    const V = U.RTCPeerConnection.prototype.addStream;
    U.RTCPeerConnection.prototype.addStream = function (H) {
      (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        H.getTracks().forEach((Q) => {
          if (this.getSenders().find((Z) => Z.track === Q))
            throw new DOMException(
              "Track already exists.",
              "InvalidAccessError"
            );
        });
      const G = this.getSenders();
      V.apply(this, arguments);
      const Y = this.getSenders().filter((Q) => G.indexOf(Q) === -1);
      this._shimmedLocalStreams[H.id] = [H].concat(Y);
    };
    const B = U.RTCPeerConnection.prototype.removeStream;
    U.RTCPeerConnection.prototype.removeStream = function (H) {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        delete this._shimmedLocalStreams[H.id],
        B.apply(this, arguments)
      );
    };
    const q = U.RTCPeerConnection.prototype.removeTrack;
    U.RTCPeerConnection.prototype.removeTrack = function (H) {
      return (
        (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),
        H &&
          Object.keys(this._shimmedLocalStreams).forEach((G) => {
            const Y = this._shimmedLocalStreams[G].indexOf(H);
            Y !== -1 && this._shimmedLocalStreams[G].splice(Y, 1),
              this._shimmedLocalStreams[G].length === 1 &&
                delete this._shimmedLocalStreams[G];
          }),
        q.apply(this, arguments)
      );
    };
  }
  function shimAddTrackRemoveTrack(U, j) {
    if (!U.RTCPeerConnection) return;
    if (U.RTCPeerConnection.prototype.addTrack && j.version >= 65)
      return shimAddTrackRemoveTrackWithNative(U);
    const V = U.RTCPeerConnection.prototype.getLocalStreams;
    U.RTCPeerConnection.prototype.getLocalStreams = function () {
      const X = V.apply(this);
      return (
        (this._reverseStreams = this._reverseStreams || {}),
        X.map((Z) => this._reverseStreams[Z.id])
      );
    };
    const B = U.RTCPeerConnection.prototype.addStream;
    U.RTCPeerConnection.prototype.addStream = function (X) {
      if (
        ((this._streams = this._streams || {}),
        (this._reverseStreams = this._reverseStreams || {}),
        X.getTracks().forEach((Z) => {
          if (this.getSenders().find((ne) => ne.track === Z))
            throw new DOMException(
              "Track already exists.",
              "InvalidAccessError"
            );
        }),
        !this._reverseStreams[X.id])
      ) {
        const Z = new U.MediaStream(X.getTracks());
        (this._streams[X.id] = Z), (this._reverseStreams[Z.id] = X), (X = Z);
      }
      B.apply(this, [X]);
    };
    const q = U.RTCPeerConnection.prototype.removeStream;
    (U.RTCPeerConnection.prototype.removeStream = function (X) {
      (this._streams = this._streams || {}),
        (this._reverseStreams = this._reverseStreams || {}),
        q.apply(this, [this._streams[X.id] || X]),
        delete this._reverseStreams[
          this._streams[X.id] ? this._streams[X.id].id : X.id
        ],
        delete this._streams[X.id];
    }),
      (U.RTCPeerConnection.prototype.addTrack = function (X, Z) {
        if (this.signalingState === "closed")
          throw new DOMException(
            "The RTCPeerConnection's signalingState is 'closed'.",
            "InvalidStateError"
          );
        const te = [].slice.call(arguments, 1);
        if (te.length !== 1 || !te[0].getTracks().find((se) => se === X))
          throw new DOMException(
            "The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.",
            "NotSupportedError"
          );
        if (this.getSenders().find((se) => se.track === X))
          throw new DOMException("Track already exists.", "InvalidAccessError");
        (this._streams = this._streams || {}),
          (this._reverseStreams = this._reverseStreams || {});
        const ae = this._streams[Z.id];
        if (ae)
          ae.addTrack(X),
            Promise.resolve().then(() => {
              this.dispatchEvent(new Event("negotiationneeded"));
            });
        else {
          const se = new U.MediaStream([X]);
          (this._streams[Z.id] = se),
            (this._reverseStreams[se.id] = Z),
            this.addStream(se);
        }
        return this.getSenders().find((se) => se.track === X);
      });
    function $(Q, X) {
      let Z = X.sdp;
      return (
        Object.keys(Q._reverseStreams || []).forEach((te) => {
          const ne = Q._reverseStreams[te],
            ae = Q._streams[ne.id];
          Z = Z.replace(new RegExp(ae.id, "g"), ne.id);
        }),
        new RTCSessionDescription({ type: X.type, sdp: Z })
      );
    }
    function H(Q, X) {
      let Z = X.sdp;
      return (
        Object.keys(Q._reverseStreams || []).forEach((te) => {
          const ne = Q._reverseStreams[te],
            ae = Q._streams[ne.id];
          Z = Z.replace(new RegExp(ne.id, "g"), ae.id);
        }),
        new RTCSessionDescription({ type: X.type, sdp: Z })
      );
    }
    ["createOffer", "createAnswer"].forEach(function (Q) {
      const X = U.RTCPeerConnection.prototype[Q],
        Z = {
          [Q]() {
            const te = arguments;
            return arguments.length && typeof arguments[0] == "function"
              ? X.apply(this, [
                  (ae) => {
                    const se = $(this, ae);
                    te[0].apply(null, [se]);
                  },
                  (ae) => {
                    te[1] && te[1].apply(null, ae);
                  },
                  arguments[2],
                ])
              : X.apply(this, arguments).then((ae) => $(this, ae));
          },
        };
      U.RTCPeerConnection.prototype[Q] = Z[Q];
    });
    const G = U.RTCPeerConnection.prototype.setLocalDescription;
    U.RTCPeerConnection.prototype.setLocalDescription = function () {
      return !arguments.length || !arguments[0].type
        ? G.apply(this, arguments)
        : ((arguments[0] = H(this, arguments[0])), G.apply(this, arguments));
    };
    const Y = Object.getOwnPropertyDescriptor(
      U.RTCPeerConnection.prototype,
      "localDescription"
    );
    Object.defineProperty(U.RTCPeerConnection.prototype, "localDescription", {
      get() {
        const Q = Y.get.apply(this);
        return Q.type === "" ? Q : $(this, Q);
      },
    }),
      (U.RTCPeerConnection.prototype.removeTrack = function (X) {
        if (this.signalingState === "closed")
          throw new DOMException(
            "The RTCPeerConnection's signalingState is 'closed'.",
            "InvalidStateError"
          );
        if (!X._pc)
          throw new DOMException(
            "Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.",
            "TypeError"
          );
        if (!(X._pc === this))
          throw new DOMException(
            "Sender was not created by this connection.",
            "InvalidAccessError"
          );
        this._streams = this._streams || {};
        let te;
        Object.keys(this._streams).forEach((ne) => {
          this._streams[ne].getTracks().find((se) => X.track === se) &&
            (te = this._streams[ne]);
        }),
          te &&
            (te.getTracks().length === 1
              ? this.removeStream(this._reverseStreams[te.id])
              : te.removeTrack(X.track),
            this.dispatchEvent(new Event("negotiationneeded")));
      });
  }
  function shimPeerConnection$1(U, j) {
    !U.RTCPeerConnection &&
      U.webkitRTCPeerConnection &&
      (U.RTCPeerConnection = U.webkitRTCPeerConnection),
      U.RTCPeerConnection &&
        j.version < 53 &&
        [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate",
        ].forEach(function (V) {
          const B = U.RTCPeerConnection.prototype[V],
            q = {
              [V]() {
                return (
                  (arguments[0] = new (
                    V === "addIceCandidate"
                      ? U.RTCIceCandidate
                      : U.RTCSessionDescription
                  )(arguments[0])),
                  B.apply(this, arguments)
                );
              },
            };
          U.RTCPeerConnection.prototype[V] = q[V];
        });
  }
  function fixNegotiationNeeded(U, j) {
    wrapPeerConnectionEvent(U, "negotiationneeded", (V) => {
      const B = V.target;
      if (
        !(
          (j.version < 72 ||
            (B.getConfiguration &&
              B.getConfiguration().sdpSemantics === "plan-b")) &&
          B.signalingState !== "stable"
        )
      )
        return V;
    });
  }
  var chromeShim = Object.freeze({
    __proto__: null,
    fixNegotiationNeeded,
    shimAddTrackRemoveTrack,
    shimAddTrackRemoveTrackWithNative,
    shimGetSendersWithDtmf,
    shimGetUserMedia: shimGetUserMedia$2,
    shimMediaStream,
    shimOnTrack: shimOnTrack$1,
    shimPeerConnection: shimPeerConnection$1,
    shimSenderReceiverGetStats,
  });
  function shimGetUserMedia$1(U, j) {
    const V = U && U.navigator,
      B = U && U.MediaStreamTrack;
    if (
      ((V.getUserMedia = function (q, $, H) {
        deprecated(
          "navigator.getUserMedia",
          "navigator.mediaDevices.getUserMedia"
        ),
          V.mediaDevices.getUserMedia(q).then($, H);
      }),
      !(
        j.version > 55 &&
        "autoGainControl" in V.mediaDevices.getSupportedConstraints()
      ))
    ) {
      const q = function (H, G, Y) {
          G in H && !(Y in H) && ((H[Y] = H[G]), delete H[G]);
        },
        $ = V.mediaDevices.getUserMedia.bind(V.mediaDevices);
      if (
        ((V.mediaDevices.getUserMedia = function (H) {
          return (
            typeof H == "object" &&
              typeof H.audio == "object" &&
              ((H = JSON.parse(JSON.stringify(H))),
              q(H.audio, "autoGainControl", "mozAutoGainControl"),
              q(H.audio, "noiseSuppression", "mozNoiseSuppression")),
            $(H)
          );
        }),
        B && B.prototype.getSettings)
      ) {
        const H = B.prototype.getSettings;
        B.prototype.getSettings = function () {
          const G = H.apply(this, arguments);
          return (
            q(G, "mozAutoGainControl", "autoGainControl"),
            q(G, "mozNoiseSuppression", "noiseSuppression"),
            G
          );
        };
      }
      if (B && B.prototype.applyConstraints) {
        const H = B.prototype.applyConstraints;
        B.prototype.applyConstraints = function (G) {
          return (
            this.kind === "audio" &&
              typeof G == "object" &&
              ((G = JSON.parse(JSON.stringify(G))),
              q(G, "autoGainControl", "mozAutoGainControl"),
              q(G, "noiseSuppression", "mozNoiseSuppression")),
            H.apply(this, [G])
          );
        };
      }
    }
  }
  function shimGetDisplayMedia(U, j) {
    (U.navigator.mediaDevices &&
      "getDisplayMedia" in U.navigator.mediaDevices) ||
      (U.navigator.mediaDevices &&
        (U.navigator.mediaDevices.getDisplayMedia = function (B) {
          if (!(B && B.video)) {
            const q = new DOMException(
              "getDisplayMedia without video constraints is undefined"
            );
            return (q.name = "NotFoundError"), (q.code = 8), Promise.reject(q);
          }
          return (
            B.video === !0
              ? (B.video = { mediaSource: j })
              : (B.video.mediaSource = j),
            U.navigator.mediaDevices.getUserMedia(B)
          );
        }));
  }
  function shimOnTrack(U) {
    typeof U == "object" &&
      U.RTCTrackEvent &&
      "receiver" in U.RTCTrackEvent.prototype &&
      !("transceiver" in U.RTCTrackEvent.prototype) &&
      Object.defineProperty(U.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        },
      });
  }
  function shimPeerConnection(U, j) {
    if (
      typeof U != "object" ||
      !(U.RTCPeerConnection || U.mozRTCPeerConnection)
    )
      return;
    !U.RTCPeerConnection &&
      U.mozRTCPeerConnection &&
      (U.RTCPeerConnection = U.mozRTCPeerConnection),
      j.version < 53 &&
        [
          "setLocalDescription",
          "setRemoteDescription",
          "addIceCandidate",
        ].forEach(function (q) {
          const $ = U.RTCPeerConnection.prototype[q],
            H = {
              [q]() {
                return (
                  (arguments[0] = new (
                    q === "addIceCandidate"
                      ? U.RTCIceCandidate
                      : U.RTCSessionDescription
                  )(arguments[0])),
                  $.apply(this, arguments)
                );
              },
            };
          U.RTCPeerConnection.prototype[q] = H[q];
        });
    const V = {
        inboundrtp: "inbound-rtp",
        outboundrtp: "outbound-rtp",
        candidatepair: "candidate-pair",
        localcandidate: "local-candidate",
        remotecandidate: "remote-candidate",
      },
      B = U.RTCPeerConnection.prototype.getStats;
    U.RTCPeerConnection.prototype.getStats = function () {
      const [$, H, G] = arguments;
      return B.apply(this, [$ || null])
        .then((Y) => {
          if (j.version < 53 && !H)
            try {
              Y.forEach((Q) => {
                Q.type = V[Q.type] || Q.type;
              });
            } catch (Q) {
              if (Q.name !== "TypeError") throw Q;
              Y.forEach((X, Z) => {
                Y.set(Z, Object.assign({}, X, { type: V[X.type] || X.type }));
              });
            }
          return Y;
        })
        .then(H, G);
    };
  }
  function shimSenderGetStats(U) {
    if (
      !(typeof U == "object" && U.RTCPeerConnection && U.RTCRtpSender) ||
      (U.RTCRtpSender && "getStats" in U.RTCRtpSender.prototype)
    )
      return;
    const j = U.RTCPeerConnection.prototype.getSenders;
    j &&
      (U.RTCPeerConnection.prototype.getSenders = function () {
        const q = j.apply(this, []);
        return q.forEach(($) => ($._pc = this)), q;
      });
    const V = U.RTCPeerConnection.prototype.addTrack;
    V &&
      (U.RTCPeerConnection.prototype.addTrack = function () {
        const q = V.apply(this, arguments);
        return (q._pc = this), q;
      }),
      (U.RTCRtpSender.prototype.getStats = function () {
        return this.track
          ? this._pc.getStats(this.track)
          : Promise.resolve(new Map());
      });
  }
  function shimReceiverGetStats(U) {
    if (
      !(typeof U == "object" && U.RTCPeerConnection && U.RTCRtpSender) ||
      (U.RTCRtpSender && "getStats" in U.RTCRtpReceiver.prototype)
    )
      return;
    const j = U.RTCPeerConnection.prototype.getReceivers;
    j &&
      (U.RTCPeerConnection.prototype.getReceivers = function () {
        const B = j.apply(this, []);
        return B.forEach((q) => (q._pc = this)), B;
      }),
      wrapPeerConnectionEvent(
        U,
        "track",
        (V) => ((V.receiver._pc = V.srcElement), V)
      ),
      (U.RTCRtpReceiver.prototype.getStats = function () {
        return this._pc.getStats(this.track);
      });
  }
  function shimRemoveStream(U) {
    !U.RTCPeerConnection ||
      "removeStream" in U.RTCPeerConnection.prototype ||
      (U.RTCPeerConnection.prototype.removeStream = function (V) {
        deprecated("removeStream", "removeTrack"),
          this.getSenders().forEach((B) => {
            B.track && V.getTracks().includes(B.track) && this.removeTrack(B);
          });
      });
  }
  function shimRTCDataChannel(U) {
    U.DataChannel && !U.RTCDataChannel && (U.RTCDataChannel = U.DataChannel);
  }
  function shimAddTransceiver(U) {
    if (!(typeof U == "object" && U.RTCPeerConnection)) return;
    const j = U.RTCPeerConnection.prototype.addTransceiver;
    j &&
      (U.RTCPeerConnection.prototype.addTransceiver = function () {
        this.setParametersPromises = [];
        let B = arguments[1] && arguments[1].sendEncodings;
        B === void 0 && (B = []), (B = [...B]);
        const q = B.length > 0;
        q &&
          B.forEach((H) => {
            if ("rid" in H && !/^[a-z0-9]{0,16}$/i.test(H.rid))
              throw new TypeError("Invalid RID value provided.");
            if (
              "scaleResolutionDownBy" in H &&
              !(parseFloat(H.scaleResolutionDownBy) >= 1)
            )
              throw new RangeError("scale_resolution_down_by must be >= 1.0");
            if ("maxFramerate" in H && !(parseFloat(H.maxFramerate) >= 0))
              throw new RangeError("max_framerate must be >= 0.0");
          });
        const $ = j.apply(this, arguments);
        if (q) {
          const { sender: H } = $,
            G = H.getParameters();
          (!("encodings" in G) ||
            (G.encodings.length === 1 &&
              Object.keys(G.encodings[0]).length === 0)) &&
            ((G.encodings = B),
            (H.sendEncodings = B),
            this.setParametersPromises.push(
              H.setParameters(G)
                .then(() => {
                  delete H.sendEncodings;
                })
                .catch(() => {
                  delete H.sendEncodings;
                })
            ));
        }
        return $;
      });
  }
  function shimGetParameters(U) {
    if (!(typeof U == "object" && U.RTCRtpSender)) return;
    const j = U.RTCRtpSender.prototype.getParameters;
    j &&
      (U.RTCRtpSender.prototype.getParameters = function () {
        const B = j.apply(this, arguments);
        return (
          "encodings" in B ||
            (B.encodings = [].concat(this.sendEncodings || [{}])),
          B
        );
      });
  }
  function shimCreateOffer(U) {
    if (!(typeof U == "object" && U.RTCPeerConnection)) return;
    const j = U.RTCPeerConnection.prototype.createOffer;
    U.RTCPeerConnection.prototype.createOffer = function () {
      return this.setParametersPromises && this.setParametersPromises.length
        ? Promise.all(this.setParametersPromises)
            .then(() => j.apply(this, arguments))
            .finally(() => {
              this.setParametersPromises = [];
            })
        : j.apply(this, arguments);
    };
  }
  function shimCreateAnswer(U) {
    if (!(typeof U == "object" && U.RTCPeerConnection)) return;
    const j = U.RTCPeerConnection.prototype.createAnswer;
    U.RTCPeerConnection.prototype.createAnswer = function () {
      return this.setParametersPromises && this.setParametersPromises.length
        ? Promise.all(this.setParametersPromises)
            .then(() => j.apply(this, arguments))
            .finally(() => {
              this.setParametersPromises = [];
            })
        : j.apply(this, arguments);
    };
  }
  var firefoxShim = Object.freeze({
    __proto__: null,
    shimAddTransceiver,
    shimCreateAnswer,
    shimCreateOffer,
    shimGetDisplayMedia,
    shimGetParameters,
    shimGetUserMedia: shimGetUserMedia$1,
    shimOnTrack,
    shimPeerConnection,
    shimRTCDataChannel,
    shimReceiverGetStats,
    shimRemoveStream,
    shimSenderGetStats,
  });
  function shimLocalStreamsAPI(U) {
    if (!(typeof U != "object" || !U.RTCPeerConnection)) {
      if (
        ("getLocalStreams" in U.RTCPeerConnection.prototype ||
          (U.RTCPeerConnection.prototype.getLocalStreams = function () {
            return (
              this._localStreams || (this._localStreams = []),
              this._localStreams
            );
          }),
        !("addStream" in U.RTCPeerConnection.prototype))
      ) {
        const j = U.RTCPeerConnection.prototype.addTrack;
        (U.RTCPeerConnection.prototype.addStream = function (B) {
          this._localStreams || (this._localStreams = []),
            this._localStreams.includes(B) || this._localStreams.push(B),
            B.getAudioTracks().forEach((q) => j.call(this, q, B)),
            B.getVideoTracks().forEach((q) => j.call(this, q, B));
        }),
          (U.RTCPeerConnection.prototype.addTrack = function (B) {
            for (
              var q = arguments.length, $ = new Array(q > 1 ? q - 1 : 0), H = 1;
              H < q;
              H++
            )
              $[H - 1] = arguments[H];
            return (
              $ &&
                $.forEach((G) => {
                  this._localStreams
                    ? this._localStreams.includes(G) ||
                      this._localStreams.push(G)
                    : (this._localStreams = [G]);
                }),
              j.apply(this, arguments)
            );
          });
      }
      "removeStream" in U.RTCPeerConnection.prototype ||
        (U.RTCPeerConnection.prototype.removeStream = function (V) {
          this._localStreams || (this._localStreams = []);
          const B = this._localStreams.indexOf(V);
          if (B === -1) return;
          this._localStreams.splice(B, 1);
          const q = V.getTracks();
          this.getSenders().forEach(($) => {
            q.includes($.track) && this.removeTrack($);
          });
        });
    }
  }
  function shimRemoteStreamsAPI(U) {
    if (
      !(typeof U != "object" || !U.RTCPeerConnection) &&
      ("getRemoteStreams" in U.RTCPeerConnection.prototype ||
        (U.RTCPeerConnection.prototype.getRemoteStreams = function () {
          return this._remoteStreams ? this._remoteStreams : [];
        }),
      !("onaddstream" in U.RTCPeerConnection.prototype))
    ) {
      Object.defineProperty(U.RTCPeerConnection.prototype, "onaddstream", {
        get() {
          return this._onaddstream;
        },
        set(V) {
          this._onaddstream &&
            (this.removeEventListener("addstream", this._onaddstream),
            this.removeEventListener("track", this._onaddstreampoly)),
            this.addEventListener("addstream", (this._onaddstream = V)),
            this.addEventListener(
              "track",
              (this._onaddstreampoly = (B) => {
                B.streams.forEach((q) => {
                  if (
                    (this._remoteStreams || (this._remoteStreams = []),
                    this._remoteStreams.includes(q))
                  )
                    return;
                  this._remoteStreams.push(q);
                  const $ = new Event("addstream");
                  ($.stream = q), this.dispatchEvent($);
                });
              })
            );
        },
      });
      const j = U.RTCPeerConnection.prototype.setRemoteDescription;
      U.RTCPeerConnection.prototype.setRemoteDescription = function () {
        const B = this;
        return (
          this._onaddstreampoly ||
            this.addEventListener(
              "track",
              (this._onaddstreampoly = function (q) {
                q.streams.forEach(($) => {
                  if (
                    (B._remoteStreams || (B._remoteStreams = []),
                    B._remoteStreams.indexOf($) >= 0)
                  )
                    return;
                  B._remoteStreams.push($);
                  const H = new Event("addstream");
                  (H.stream = $), B.dispatchEvent(H);
                });
              })
            ),
          j.apply(B, arguments)
        );
      };
    }
  }
  function shimCallbacksAPI(U) {
    if (typeof U != "object" || !U.RTCPeerConnection) return;
    const j = U.RTCPeerConnection.prototype,
      V = j.createOffer,
      B = j.createAnswer,
      q = j.setLocalDescription,
      $ = j.setRemoteDescription,
      H = j.addIceCandidate;
    (j.createOffer = function (Q, X) {
      const Z = arguments.length >= 2 ? arguments[2] : arguments[0],
        te = V.apply(this, [Z]);
      return X ? (te.then(Q, X), Promise.resolve()) : te;
    }),
      (j.createAnswer = function (Q, X) {
        const Z = arguments.length >= 2 ? arguments[2] : arguments[0],
          te = B.apply(this, [Z]);
        return X ? (te.then(Q, X), Promise.resolve()) : te;
      });
    let G = function (Y, Q, X) {
      const Z = q.apply(this, [Y]);
      return X ? (Z.then(Q, X), Promise.resolve()) : Z;
    };
    (j.setLocalDescription = G),
      (G = function (Y, Q, X) {
        const Z = $.apply(this, [Y]);
        return X ? (Z.then(Q, X), Promise.resolve()) : Z;
      }),
      (j.setRemoteDescription = G),
      (G = function (Y, Q, X) {
        const Z = H.apply(this, [Y]);
        return X ? (Z.then(Q, X), Promise.resolve()) : Z;
      }),
      (j.addIceCandidate = G);
  }
  function shimGetUserMedia(U) {
    const j = U && U.navigator;
    if (j.mediaDevices && j.mediaDevices.getUserMedia) {
      const V = j.mediaDevices,
        B = V.getUserMedia.bind(V);
      j.mediaDevices.getUserMedia = (q) => B(shimConstraints(q));
    }
    !j.getUserMedia &&
      j.mediaDevices &&
      j.mediaDevices.getUserMedia &&
      (j.getUserMedia = function (B, q, $) {
        j.mediaDevices.getUserMedia(B).then(q, $);
      }.bind(j));
  }
  function shimConstraints(U) {
    return U && U.video !== void 0
      ? Object.assign({}, U, { video: compactObject(U.video) })
      : U;
  }
  function shimRTCIceServerUrls(U) {
    if (!U.RTCPeerConnection) return;
    const j = U.RTCPeerConnection;
    (U.RTCPeerConnection = function (B, q) {
      if (B && B.iceServers) {
        const $ = [];
        for (let H = 0; H < B.iceServers.length; H++) {
          let G = B.iceServers[H];
          G.urls === void 0 && G.url
            ? (deprecated("RTCIceServer.url", "RTCIceServer.urls"),
              (G = JSON.parse(JSON.stringify(G))),
              (G.urls = G.url),
              delete G.url,
              $.push(G))
            : $.push(B.iceServers[H]);
        }
        B.iceServers = $;
      }
      return new j(B, q);
    }),
      (U.RTCPeerConnection.prototype = j.prototype),
      "generateCertificate" in j &&
        Object.defineProperty(U.RTCPeerConnection, "generateCertificate", {
          get() {
            return j.generateCertificate;
          },
        });
  }
  function shimTrackEventTransceiver(U) {
    typeof U == "object" &&
      U.RTCTrackEvent &&
      "receiver" in U.RTCTrackEvent.prototype &&
      !("transceiver" in U.RTCTrackEvent.prototype) &&
      Object.defineProperty(U.RTCTrackEvent.prototype, "transceiver", {
        get() {
          return { receiver: this.receiver };
        },
      });
  }
  function shimCreateOfferLegacy(U) {
    const j = U.RTCPeerConnection.prototype.createOffer;
    U.RTCPeerConnection.prototype.createOffer = function (B) {
      if (B) {
        typeof B.offerToReceiveAudio < "u" &&
          (B.offerToReceiveAudio = !!B.offerToReceiveAudio);
        const q = this.getTransceivers().find(
          (H) => H.receiver.track.kind === "audio"
        );
        B.offerToReceiveAudio === !1 && q
          ? q.direction === "sendrecv"
            ? q.setDirection
              ? q.setDirection("sendonly")
              : (q.direction = "sendonly")
            : q.direction === "recvonly" &&
              (q.setDirection
                ? q.setDirection("inactive")
                : (q.direction = "inactive"))
          : B.offerToReceiveAudio === !0 &&
            !q &&
            this.addTransceiver("audio", { direction: "recvonly" }),
          typeof B.offerToReceiveVideo < "u" &&
            (B.offerToReceiveVideo = !!B.offerToReceiveVideo);
        const $ = this.getTransceivers().find(
          (H) => H.receiver.track.kind === "video"
        );
        B.offerToReceiveVideo === !1 && $
          ? $.direction === "sendrecv"
            ? $.setDirection
              ? $.setDirection("sendonly")
              : ($.direction = "sendonly")
            : $.direction === "recvonly" &&
              ($.setDirection
                ? $.setDirection("inactive")
                : ($.direction = "inactive"))
          : B.offerToReceiveVideo === !0 &&
            !$ &&
            this.addTransceiver("video", { direction: "recvonly" });
      }
      return j.apply(this, arguments);
    };
  }
  function shimAudioContext(U) {
    typeof U != "object" ||
      U.AudioContext ||
      (U.AudioContext = U.webkitAudioContext);
  }
  var safariShim = Object.freeze({
      __proto__: null,
      shimAudioContext,
      shimCallbacksAPI,
      shimConstraints,
      shimCreateOfferLegacy,
      shimGetUserMedia,
      shimLocalStreamsAPI,
      shimRTCIceServerUrls,
      shimRemoteStreamsAPI,
      shimTrackEventTransceiver,
    }),
    sdp$1 = { exports: {} },
    hasRequiredSdp;
  function requireSdp() {
    return (
      hasRequiredSdp ||
        ((hasRequiredSdp = 1),
        (function (U) {
          const j = {};
          (j.generateIdentifier = function () {
            return Math.random().toString(36).substring(2, 12);
          }),
            (j.localCName = j.generateIdentifier()),
            (j.splitLines = function (V) {
              return V.trim()
                .split(
                  `
`
                )
                .map((B) => B.trim());
            }),
            (j.splitSections = function (V) {
              return V.split(
                `
m=`
              ).map(
                (q, $) =>
                  ($ > 0 ? "m=" + q : q).trim() +
                  `\r
`
              );
            }),
            (j.getDescription = function (V) {
              const B = j.splitSections(V);
              return B && B[0];
            }),
            (j.getMediaSections = function (V) {
              const B = j.splitSections(V);
              return B.shift(), B;
            }),
            (j.matchPrefix = function (V, B) {
              return j.splitLines(V).filter((q) => q.indexOf(B) === 0);
            }),
            (j.parseCandidate = function (V) {
              let B;
              V.indexOf("a=candidate:") === 0
                ? (B = V.substring(12).split(" "))
                : (B = V.substring(10).split(" "));
              const q = {
                foundation: B[0],
                component: { 1: "rtp", 2: "rtcp" }[B[1]] || B[1],
                protocol: B[2].toLowerCase(),
                priority: parseInt(B[3], 10),
                ip: B[4],
                address: B[4],
                port: parseInt(B[5], 10),
                type: B[7],
              };
              for (let $ = 8; $ < B.length; $ += 2)
                switch (B[$]) {
                  case "raddr":
                    q.relatedAddress = B[$ + 1];
                    break;
                  case "rport":
                    q.relatedPort = parseInt(B[$ + 1], 10);
                    break;
                  case "tcptype":
                    q.tcpType = B[$ + 1];
                    break;
                  case "ufrag":
                    (q.ufrag = B[$ + 1]), (q.usernameFragment = B[$ + 1]);
                    break;
                  default:
                    q[B[$]] === void 0 && (q[B[$]] = B[$ + 1]);
                    break;
                }
              return q;
            }),
            (j.writeCandidate = function (V) {
              const B = [];
              B.push(V.foundation);
              const q = V.component;
              q === "rtp" ? B.push(1) : q === "rtcp" ? B.push(2) : B.push(q),
                B.push(V.protocol.toUpperCase()),
                B.push(V.priority),
                B.push(V.address || V.ip),
                B.push(V.port);
              const $ = V.type;
              return (
                B.push("typ"),
                B.push($),
                $ !== "host" &&
                  V.relatedAddress &&
                  V.relatedPort &&
                  (B.push("raddr"),
                  B.push(V.relatedAddress),
                  B.push("rport"),
                  B.push(V.relatedPort)),
                V.tcpType &&
                  V.protocol.toLowerCase() === "tcp" &&
                  (B.push("tcptype"), B.push(V.tcpType)),
                (V.usernameFragment || V.ufrag) &&
                  (B.push("ufrag"), B.push(V.usernameFragment || V.ufrag)),
                "candidate:" + B.join(" ")
              );
            }),
            (j.parseIceOptions = function (V) {
              return V.substring(14).split(" ");
            }),
            (j.parseRtpMap = function (V) {
              let B = V.substring(9).split(" ");
              const q = { payloadType: parseInt(B.shift(), 10) };
              return (
                (B = B[0].split("/")),
                (q.name = B[0]),
                (q.clockRate = parseInt(B[1], 10)),
                (q.channels = B.length === 3 ? parseInt(B[2], 10) : 1),
                (q.numChannels = q.channels),
                q
              );
            }),
            (j.writeRtpMap = function (V) {
              let B = V.payloadType;
              V.preferredPayloadType !== void 0 && (B = V.preferredPayloadType);
              const q = V.channels || V.numChannels || 1;
              return (
                "a=rtpmap:" +
                B +
                " " +
                V.name +
                "/" +
                V.clockRate +
                (q !== 1 ? "/" + q : "") +
                `\r
`
              );
            }),
            (j.parseExtmap = function (V) {
              const B = V.substring(9).split(" ");
              return {
                id: parseInt(B[0], 10),
                direction:
                  B[0].indexOf("/") > 0 ? B[0].split("/")[1] : "sendrecv",
                uri: B[1],
                attributes: B.slice(2).join(" "),
              };
            }),
            (j.writeExtmap = function (V) {
              return (
                "a=extmap:" +
                (V.id || V.preferredId) +
                (V.direction && V.direction !== "sendrecv"
                  ? "/" + V.direction
                  : "") +
                " " +
                V.uri +
                (V.attributes ? " " + V.attributes : "") +
                `\r
`
              );
            }),
            (j.parseFmtp = function (V) {
              const B = {};
              let q;
              const $ = V.substring(V.indexOf(" ") + 1).split(";");
              for (let H = 0; H < $.length; H++)
                (q = $[H].trim().split("=")), (B[q[0].trim()] = q[1]);
              return B;
            }),
            (j.writeFmtp = function (V) {
              let B = "",
                q = V.payloadType;
              if (
                (V.preferredPayloadType !== void 0 &&
                  (q = V.preferredPayloadType),
                V.parameters && Object.keys(V.parameters).length)
              ) {
                const $ = [];
                Object.keys(V.parameters).forEach((H) => {
                  V.parameters[H] !== void 0
                    ? $.push(H + "=" + V.parameters[H])
                    : $.push(H);
                }),
                  (B +=
                    "a=fmtp:" +
                    q +
                    " " +
                    $.join(";") +
                    `\r
`);
              }
              return B;
            }),
            (j.parseRtcpFb = function (V) {
              const B = V.substring(V.indexOf(" ") + 1).split(" ");
              return { type: B.shift(), parameter: B.join(" ") };
            }),
            (j.writeRtcpFb = function (V) {
              let B = "",
                q = V.payloadType;
              return (
                V.preferredPayloadType !== void 0 &&
                  (q = V.preferredPayloadType),
                V.rtcpFeedback &&
                  V.rtcpFeedback.length &&
                  V.rtcpFeedback.forEach(($) => {
                    B +=
                      "a=rtcp-fb:" +
                      q +
                      " " +
                      $.type +
                      ($.parameter && $.parameter.length
                        ? " " + $.parameter
                        : "") +
                      `\r
`;
                  }),
                B
              );
            }),
            (j.parseSsrcMedia = function (V) {
              const B = V.indexOf(" "),
                q = { ssrc: parseInt(V.substring(7, B), 10) },
                $ = V.indexOf(":", B);
              return (
                $ > -1
                  ? ((q.attribute = V.substring(B + 1, $)),
                    (q.value = V.substring($ + 1)))
                  : (q.attribute = V.substring(B + 1)),
                q
              );
            }),
            (j.parseSsrcGroup = function (V) {
              const B = V.substring(13).split(" ");
              return {
                semantics: B.shift(),
                ssrcs: B.map((q) => parseInt(q, 10)),
              };
            }),
            (j.getMid = function (V) {
              const B = j.matchPrefix(V, "a=mid:")[0];
              if (B) return B.substring(6);
            }),
            (j.parseFingerprint = function (V) {
              const B = V.substring(14).split(" ");
              return {
                algorithm: B[0].toLowerCase(),
                value: B[1].toUpperCase(),
              };
            }),
            (j.getDtlsParameters = function (V, B) {
              return {
                role: "auto",
                fingerprints: j
                  .matchPrefix(V + B, "a=fingerprint:")
                  .map(j.parseFingerprint),
              };
            }),
            (j.writeDtlsParameters = function (V, B) {
              let q =
                "a=setup:" +
                B +
                `\r
`;
              return (
                V.fingerprints.forEach(($) => {
                  q +=
                    "a=fingerprint:" +
                    $.algorithm +
                    " " +
                    $.value +
                    `\r
`;
                }),
                q
              );
            }),
            (j.parseCryptoLine = function (V) {
              const B = V.substring(9).split(" ");
              return {
                tag: parseInt(B[0], 10),
                cryptoSuite: B[1],
                keyParams: B[2],
                sessionParams: B.slice(3),
              };
            }),
            (j.writeCryptoLine = function (V) {
              return (
                "a=crypto:" +
                V.tag +
                " " +
                V.cryptoSuite +
                " " +
                (typeof V.keyParams == "object"
                  ? j.writeCryptoKeyParams(V.keyParams)
                  : V.keyParams) +
                (V.sessionParams ? " " + V.sessionParams.join(" ") : "") +
                `\r
`
              );
            }),
            (j.parseCryptoKeyParams = function (V) {
              if (V.indexOf("inline:") !== 0) return null;
              const B = V.substring(7).split("|");
              return {
                keyMethod: "inline",
                keySalt: B[0],
                lifeTime: B[1],
                mkiValue: B[2] ? B[2].split(":")[0] : void 0,
                mkiLength: B[2] ? B[2].split(":")[1] : void 0,
              };
            }),
            (j.writeCryptoKeyParams = function (V) {
              return (
                V.keyMethod +
                ":" +
                V.keySalt +
                (V.lifeTime ? "|" + V.lifeTime : "") +
                (V.mkiValue && V.mkiLength
                  ? "|" + V.mkiValue + ":" + V.mkiLength
                  : "")
              );
            }),
            (j.getCryptoParameters = function (V, B) {
              return j.matchPrefix(V + B, "a=crypto:").map(j.parseCryptoLine);
            }),
            (j.getIceParameters = function (V, B) {
              const q = j.matchPrefix(V + B, "a=ice-ufrag:")[0],
                $ = j.matchPrefix(V + B, "a=ice-pwd:")[0];
              return q && $
                ? {
                    usernameFragment: q.substring(12),
                    password: $.substring(10),
                  }
                : null;
            }),
            (j.writeIceParameters = function (V) {
              let B =
                "a=ice-ufrag:" +
                V.usernameFragment +
                `\r
a=ice-pwd:` +
                V.password +
                `\r
`;
              return (
                V.iceLite &&
                  (B += `a=ice-lite\r
`),
                B
              );
            }),
            (j.parseRtpParameters = function (V) {
              const B = {
                  codecs: [],
                  headerExtensions: [],
                  fecMechanisms: [],
                  rtcp: [],
                },
                $ = j.splitLines(V)[0].split(" ");
              B.profile = $[2];
              for (let G = 3; G < $.length; G++) {
                const Y = $[G],
                  Q = j.matchPrefix(V, "a=rtpmap:" + Y + " ")[0];
                if (Q) {
                  const X = j.parseRtpMap(Q),
                    Z = j.matchPrefix(V, "a=fmtp:" + Y + " ");
                  switch (
                    ((X.parameters = Z.length ? j.parseFmtp(Z[0]) : {}),
                    (X.rtcpFeedback = j
                      .matchPrefix(V, "a=rtcp-fb:" + Y + " ")
                      .map(j.parseRtcpFb)),
                    B.codecs.push(X),
                    X.name.toUpperCase())
                  ) {
                    case "RED":
                    case "ULPFEC":
                      B.fecMechanisms.push(X.name.toUpperCase());
                      break;
                  }
                }
              }
              j.matchPrefix(V, "a=extmap:").forEach((G) => {
                B.headerExtensions.push(j.parseExtmap(G));
              });
              const H = j.matchPrefix(V, "a=rtcp-fb:* ").map(j.parseRtcpFb);
              return (
                B.codecs.forEach((G) => {
                  H.forEach((Y) => {
                    G.rtcpFeedback.find(
                      (X) => X.type === Y.type && X.parameter === Y.parameter
                    ) || G.rtcpFeedback.push(Y);
                  });
                }),
                B
              );
            }),
            (j.writeRtpDescription = function (V, B) {
              let q = "";
              (q += "m=" + V + " "),
                (q += B.codecs.length > 0 ? "9" : "0"),
                (q += " " + (B.profile || "UDP/TLS/RTP/SAVPF") + " "),
                (q +=
                  B.codecs
                    .map((H) =>
                      H.preferredPayloadType !== void 0
                        ? H.preferredPayloadType
                        : H.payloadType
                    )
                    .join(" ") +
                  `\r
`),
                (q += `c=IN IP4 0.0.0.0\r
`),
                (q += `a=rtcp:9 IN IP4 0.0.0.0\r
`),
                B.codecs.forEach((H) => {
                  (q += j.writeRtpMap(H)),
                    (q += j.writeFmtp(H)),
                    (q += j.writeRtcpFb(H));
                });
              let $ = 0;
              return (
                B.codecs.forEach((H) => {
                  H.maxptime > $ && ($ = H.maxptime);
                }),
                $ > 0 &&
                  (q +=
                    "a=maxptime:" +
                    $ +
                    `\r
`),
                B.headerExtensions &&
                  B.headerExtensions.forEach((H) => {
                    q += j.writeExtmap(H);
                  }),
                q
              );
            }),
            (j.parseRtpEncodingParameters = function (V) {
              const B = [],
                q = j.parseRtpParameters(V),
                $ = q.fecMechanisms.indexOf("RED") !== -1,
                H = q.fecMechanisms.indexOf("ULPFEC") !== -1,
                G = j
                  .matchPrefix(V, "a=ssrc:")
                  .map((te) => j.parseSsrcMedia(te))
                  .filter((te) => te.attribute === "cname"),
                Y = G.length > 0 && G[0].ssrc;
              let Q;
              const X = j.matchPrefix(V, "a=ssrc-group:FID").map((te) =>
                te
                  .substring(17)
                  .split(" ")
                  .map((ae) => parseInt(ae, 10))
              );
              X.length > 0 && X[0].length > 1 && X[0][0] === Y && (Q = X[0][1]),
                q.codecs.forEach((te) => {
                  if (te.name.toUpperCase() === "RTX" && te.parameters.apt) {
                    let ne = {
                      ssrc: Y,
                      codecPayloadType: parseInt(te.parameters.apt, 10),
                    };
                    Y && Q && (ne.rtx = { ssrc: Q }),
                      B.push(ne),
                      $ &&
                        ((ne = JSON.parse(JSON.stringify(ne))),
                        (ne.fec = {
                          ssrc: Y,
                          mechanism: H ? "red+ulpfec" : "red",
                        }),
                        B.push(ne));
                  }
                }),
                B.length === 0 && Y && B.push({ ssrc: Y });
              let Z = j.matchPrefix(V, "b=");
              return (
                Z.length &&
                  (Z[0].indexOf("b=TIAS:") === 0
                    ? (Z = parseInt(Z[0].substring(7), 10))
                    : Z[0].indexOf("b=AS:") === 0
                    ? (Z =
                        parseInt(Z[0].substring(5), 10) * 1e3 * 0.95 -
                        50 * 40 * 8)
                    : (Z = void 0),
                  B.forEach((te) => {
                    te.maxBitrate = Z;
                  })),
                B
              );
            }),
            (j.parseRtcpParameters = function (V) {
              const B = {},
                q = j
                  .matchPrefix(V, "a=ssrc:")
                  .map((G) => j.parseSsrcMedia(G))
                  .filter((G) => G.attribute === "cname")[0];
              q && ((B.cname = q.value), (B.ssrc = q.ssrc));
              const $ = j.matchPrefix(V, "a=rtcp-rsize");
              (B.reducedSize = $.length > 0), (B.compound = $.length === 0);
              const H = j.matchPrefix(V, "a=rtcp-mux");
              return (B.mux = H.length > 0), B;
            }),
            (j.writeRtcpParameters = function (V) {
              let B = "";
              return (
                V.reducedSize &&
                  (B += `a=rtcp-rsize\r
`),
                V.mux &&
                  (B += `a=rtcp-mux\r
`),
                V.ssrc !== void 0 &&
                  V.cname &&
                  (B +=
                    "a=ssrc:" +
                    V.ssrc +
                    " cname:" +
                    V.cname +
                    `\r
`),
                B
              );
            }),
            (j.parseMsid = function (V) {
              let B;
              const q = j.matchPrefix(V, "a=msid:");
              if (q.length === 1)
                return (
                  (B = q[0].substring(7).split(" ")),
                  { stream: B[0], track: B[1] }
                );
              const $ = j
                .matchPrefix(V, "a=ssrc:")
                .map((H) => j.parseSsrcMedia(H))
                .filter((H) => H.attribute === "msid");
              if ($.length > 0)
                return (
                  (B = $[0].value.split(" ")), { stream: B[0], track: B[1] }
                );
            }),
            (j.parseSctpDescription = function (V) {
              const B = j.parseMLine(V),
                q = j.matchPrefix(V, "a=max-message-size:");
              let $;
              q.length > 0 && ($ = parseInt(q[0].substring(19), 10)),
                isNaN($) && ($ = 65536);
              const H = j.matchPrefix(V, "a=sctp-port:");
              if (H.length > 0)
                return {
                  port: parseInt(H[0].substring(12), 10),
                  protocol: B.fmt,
                  maxMessageSize: $,
                };
              const G = j.matchPrefix(V, "a=sctpmap:");
              if (G.length > 0) {
                const Y = G[0].substring(10).split(" ");
                return {
                  port: parseInt(Y[0], 10),
                  protocol: Y[1],
                  maxMessageSize: $,
                };
              }
            }),
            (j.writeSctpDescription = function (V, B) {
              let q = [];
              return (
                V.protocol !== "DTLS/SCTP"
                  ? (q = [
                      "m=" +
                        V.kind +
                        " 9 " +
                        V.protocol +
                        " " +
                        B.protocol +
                        `\r
`,
                      `c=IN IP4 0.0.0.0\r
`,
                      "a=sctp-port:" +
                        B.port +
                        `\r
`,
                    ])
                  : (q = [
                      "m=" +
                        V.kind +
                        " 9 " +
                        V.protocol +
                        " " +
                        B.port +
                        `\r
`,
                      `c=IN IP4 0.0.0.0\r
`,
                      "a=sctpmap:" +
                        B.port +
                        " " +
                        B.protocol +
                        ` 65535\r
`,
                    ]),
                B.maxMessageSize !== void 0 &&
                  q.push(
                    "a=max-message-size:" +
                      B.maxMessageSize +
                      `\r
`
                  ),
                q.join("")
              );
            }),
            (j.generateSessionId = function () {
              return Math.random().toString().substr(2, 22);
            }),
            (j.writeSessionBoilerplate = function (V, B, q) {
              let $;
              const H = B !== void 0 ? B : 2;
              return (
                V ? ($ = V) : ($ = j.generateSessionId()),
                `v=0\r
o=` +
                  (q || "thisisadapterortc") +
                  " " +
                  $ +
                  " " +
                  H +
                  ` IN IP4 127.0.0.1\r
s=-\r
t=0 0\r
`
              );
            }),
            (j.getDirection = function (V, B) {
              const q = j.splitLines(V);
              for (let $ = 0; $ < q.length; $++)
                switch (q[$]) {
                  case "a=sendrecv":
                  case "a=sendonly":
                  case "a=recvonly":
                  case "a=inactive":
                    return q[$].substring(2);
                }
              return B ? j.getDirection(B) : "sendrecv";
            }),
            (j.getKind = function (V) {
              return j.splitLines(V)[0].split(" ")[0].substring(2);
            }),
            (j.isRejected = function (V) {
              return V.split(" ", 2)[1] === "0";
            }),
            (j.parseMLine = function (V) {
              const q = j.splitLines(V)[0].substring(2).split(" ");
              return {
                kind: q[0],
                port: parseInt(q[1], 10),
                protocol: q[2],
                fmt: q.slice(3).join(" "),
              };
            }),
            (j.parseOLine = function (V) {
              const q = j.matchPrefix(V, "o=")[0].substring(2).split(" ");
              return {
                username: q[0],
                sessionId: q[1],
                sessionVersion: parseInt(q[2], 10),
                netType: q[3],
                addressType: q[4],
                address: q[5],
              };
            }),
            (j.isValidSDP = function (V) {
              if (typeof V != "string" || V.length === 0) return !1;
              const B = j.splitLines(V);
              for (let q = 0; q < B.length; q++)
                if (B[q].length < 2 || B[q].charAt(1) !== "=") return !1;
              return !0;
            }),
            (U.exports = j);
        })(sdp$1)),
      sdp$1.exports
    );
  }
  var sdpExports = requireSdp(),
    SDPUtils = getDefaultExportFromCjs(sdpExports),
    sdp = _mergeNamespaces$1({ __proto__: null, default: SDPUtils }, [
      sdpExports,
    ]);
  function shimRTCIceCandidate(U) {
    if (
      !U.RTCIceCandidate ||
      (U.RTCIceCandidate && "foundation" in U.RTCIceCandidate.prototype)
    )
      return;
    const j = U.RTCIceCandidate;
    (U.RTCIceCandidate = function (B) {
      if (
        (typeof B == "object" &&
          B.candidate &&
          B.candidate.indexOf("a=") === 0 &&
          ((B = JSON.parse(JSON.stringify(B))),
          (B.candidate = B.candidate.substring(2))),
        B.candidate && B.candidate.length)
      ) {
        const q = new j(B),
          $ = SDPUtils.parseCandidate(B.candidate);
        for (const H in $)
          H in q || Object.defineProperty(q, H, { value: $[H] });
        return (
          (q.toJSON = function () {
            return {
              candidate: q.candidate,
              sdpMid: q.sdpMid,
              sdpMLineIndex: q.sdpMLineIndex,
              usernameFragment: q.usernameFragment,
            };
          }),
          q
        );
      }
      return new j(B);
    }),
      (U.RTCIceCandidate.prototype = j.prototype),
      wrapPeerConnectionEvent(
        U,
        "icecandidate",
        (V) => (
          V.candidate &&
            Object.defineProperty(V, "candidate", {
              value: new U.RTCIceCandidate(V.candidate),
              writable: "false",
            }),
          V
        )
      );
  }
  function shimRTCIceCandidateRelayProtocol(U) {
    !U.RTCIceCandidate ||
      (U.RTCIceCandidate && "relayProtocol" in U.RTCIceCandidate.prototype) ||
      wrapPeerConnectionEvent(U, "icecandidate", (j) => {
        if (j.candidate) {
          const V = SDPUtils.parseCandidate(j.candidate.candidate);
          V.type === "relay" &&
            (j.candidate.relayProtocol = { 0: "tls", 1: "tcp", 2: "udp" }[
              V.priority >> 24
            ]);
        }
        return j;
      });
  }
  function shimMaxMessageSize(U, j) {
    if (!U.RTCPeerConnection) return;
    "sctp" in U.RTCPeerConnection.prototype ||
      Object.defineProperty(U.RTCPeerConnection.prototype, "sctp", {
        get() {
          return typeof this._sctp > "u" ? null : this._sctp;
        },
      });
    const V = function (G) {
        if (!G || !G.sdp) return !1;
        const Y = SDPUtils.splitSections(G.sdp);
        return (
          Y.shift(),
          Y.some((Q) => {
            const X = SDPUtils.parseMLine(Q);
            return (
              X && X.kind === "application" && X.protocol.indexOf("SCTP") !== -1
            );
          })
        );
      },
      B = function (G) {
        const Y = G.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);
        if (Y === null || Y.length < 2) return -1;
        const Q = parseInt(Y[1], 10);
        return Q !== Q ? -1 : Q;
      },
      q = function (G) {
        let Y = 65536;
        return (
          j.browser === "firefox" &&
            (j.version < 57
              ? G === -1
                ? (Y = 16384)
                : (Y = 2147483637)
              : j.version < 60
              ? (Y = j.version === 57 ? 65535 : 65536)
              : (Y = 2147483637)),
          Y
        );
      },
      $ = function (G, Y) {
        let Q = 65536;
        j.browser === "firefox" && j.version === 57 && (Q = 65535);
        const X = SDPUtils.matchPrefix(G.sdp, "a=max-message-size:");
        return (
          X.length > 0
            ? (Q = parseInt(X[0].substring(19), 10))
            : j.browser === "firefox" && Y !== -1 && (Q = 2147483637),
          Q
        );
      },
      H = U.RTCPeerConnection.prototype.setRemoteDescription;
    U.RTCPeerConnection.prototype.setRemoteDescription = function () {
      if (((this._sctp = null), j.browser === "chrome" && j.version >= 76)) {
        const { sdpSemantics: Y } = this.getConfiguration();
        Y === "plan-b" &&
          Object.defineProperty(this, "sctp", {
            get() {
              return typeof this._sctp > "u" ? null : this._sctp;
            },
            enumerable: !0,
            configurable: !0,
          });
      }
      if (V(arguments[0])) {
        const Y = B(arguments[0]),
          Q = q(Y),
          X = $(arguments[0], Y);
        let Z;
        Q === 0 && X === 0
          ? (Z = Number.POSITIVE_INFINITY)
          : Q === 0 || X === 0
          ? (Z = Math.max(Q, X))
          : (Z = Math.min(Q, X));
        const te = {};
        Object.defineProperty(te, "maxMessageSize", {
          get() {
            return Z;
          },
        }),
          (this._sctp = te);
      }
      return H.apply(this, arguments);
    };
  }
  function shimSendThrowTypeError(U) {
    if (
      !(
        U.RTCPeerConnection &&
        "createDataChannel" in U.RTCPeerConnection.prototype
      )
    )
      return;
    function j(B, q) {
      const $ = B.send;
      B.send = function () {
        const G = arguments[0],
          Y = G.length || G.size || G.byteLength;
        if (B.readyState === "open" && q.sctp && Y > q.sctp.maxMessageSize)
          throw new TypeError(
            "Message too large (can send a maximum of " +
              q.sctp.maxMessageSize +
              " bytes)"
          );
        return $.apply(B, arguments);
      };
    }
    const V = U.RTCPeerConnection.prototype.createDataChannel;
    (U.RTCPeerConnection.prototype.createDataChannel = function () {
      const q = V.apply(this, arguments);
      return j(q, this), q;
    }),
      wrapPeerConnectionEvent(
        U,
        "datachannel",
        (B) => (j(B.channel, B.target), B)
      );
  }
  function shimConnectionState(U) {
    if (
      !U.RTCPeerConnection ||
      "connectionState" in U.RTCPeerConnection.prototype
    )
      return;
    const j = U.RTCPeerConnection.prototype;
    Object.defineProperty(j, "connectionState", {
      get() {
        return (
          { completed: "connected", checking: "connecting" }[
            this.iceConnectionState
          ] || this.iceConnectionState
        );
      },
      enumerable: !0,
      configurable: !0,
    }),
      Object.defineProperty(j, "onconnectionstatechange", {
        get() {
          return this._onconnectionstatechange || null;
        },
        set(V) {
          this._onconnectionstatechange &&
            (this.removeEventListener(
              "connectionstatechange",
              this._onconnectionstatechange
            ),
            delete this._onconnectionstatechange),
            V &&
              this.addEventListener(
                "connectionstatechange",
                (this._onconnectionstatechange = V)
              );
        },
        enumerable: !0,
        configurable: !0,
      }),
      ["setLocalDescription", "setRemoteDescription"].forEach((V) => {
        const B = j[V];
        j[V] = function () {
          return (
            this._connectionstatechangepoly ||
              ((this._connectionstatechangepoly = (q) => {
                const $ = q.target;
                if ($._lastConnectionState !== $.connectionState) {
                  $._lastConnectionState = $.connectionState;
                  const H = new Event("connectionstatechange", q);
                  $.dispatchEvent(H);
                }
                return q;
              }),
              this.addEventListener(
                "iceconnectionstatechange",
                this._connectionstatechangepoly
              )),
            B.apply(this, arguments)
          );
        };
      });
  }
  function removeExtmapAllowMixed(U, j) {
    if (
      !U.RTCPeerConnection ||
      (j.browser === "chrome" && j.version >= 71) ||
      (j.browser === "safari" && j._safariVersion >= 13.1)
    )
      return;
    const V = U.RTCPeerConnection.prototype.setRemoteDescription;
    U.RTCPeerConnection.prototype.setRemoteDescription = function (q) {
      if (
        q &&
        q.sdp &&
        q.sdp.indexOf(`
a=extmap-allow-mixed`) !== -1
      ) {
        const $ = q.sdp
          .split(
            `
`
          )
          .filter((H) => H.trim() !== "a=extmap-allow-mixed").join(`
`);
        U.RTCSessionDescription && q instanceof U.RTCSessionDescription
          ? (arguments[0] = new U.RTCSessionDescription({
              type: q.type,
              sdp: $,
            }))
          : (q.sdp = $);
      }
      return V.apply(this, arguments);
    };
  }
  function shimAddIceCandidateNullOrEmpty(U, j) {
    if (!(U.RTCPeerConnection && U.RTCPeerConnection.prototype)) return;
    const V = U.RTCPeerConnection.prototype.addIceCandidate;
    !V ||
      V.length === 0 ||
      (U.RTCPeerConnection.prototype.addIceCandidate = function () {
        return arguments[0]
          ? ((j.browser === "chrome" && j.version < 78) ||
              (j.browser === "firefox" && j.version < 68) ||
              j.browser === "safari") &&
            arguments[0] &&
            arguments[0].candidate === ""
            ? Promise.resolve()
            : V.apply(this, arguments)
          : (arguments[1] && arguments[1].apply(null), Promise.resolve());
      });
  }
  function shimParameterlessSetLocalDescription(U, j) {
    if (!(U.RTCPeerConnection && U.RTCPeerConnection.prototype)) return;
    const V = U.RTCPeerConnection.prototype.setLocalDescription;
    !V ||
      V.length === 0 ||
      (U.RTCPeerConnection.prototype.setLocalDescription = function () {
        let q = arguments[0] || {};
        if (typeof q != "object" || (q.type && q.sdp))
          return V.apply(this, arguments);
        if (((q = { type: q.type, sdp: q.sdp }), !q.type))
          switch (this.signalingState) {
            case "stable":
            case "have-local-offer":
            case "have-remote-pranswer":
              q.type = "offer";
              break;
            default:
              q.type = "answer";
              break;
          }
        return q.sdp || (q.type !== "offer" && q.type !== "answer")
          ? V.apply(this, [q])
          : (q.type === "offer" ? this.createOffer : this.createAnswer)
              .apply(this)
              .then((H) => V.apply(this, [H]));
      });
  }
  var commonShim = Object.freeze({
    __proto__: null,
    removeExtmapAllowMixed,
    shimAddIceCandidateNullOrEmpty,
    shimConnectionState,
    shimMaxMessageSize,
    shimParameterlessSetLocalDescription,
    shimRTCIceCandidate,
    shimRTCIceCandidateRelayProtocol,
    shimSendThrowTypeError,
  });
  function adapterFactory() {
    let { window: U } =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      j =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : { shimChrome: !0, shimFirefox: !0, shimSafari: !0 };
    const V = log,
      B = detectBrowser(U),
      q = {
        browserDetails: B,
        commonShim,
        extractVersion,
        disableLog,
        disableWarnings,
        sdp,
      };
    switch (B.browser) {
      case "chrome":
        if (!chromeShim || !shimPeerConnection$1 || !j.shimChrome)
          return V("Chrome shim is not included in this adapter release."), q;
        if (B.version === null)
          return V("Chrome shim can not determine version, not shimming."), q;
        V("adapter.js shimming chrome."),
          (q.browserShim = chromeShim),
          shimAddIceCandidateNullOrEmpty(U, B),
          shimParameterlessSetLocalDescription(U),
          shimGetUserMedia$2(U, B),
          shimMediaStream(U),
          shimPeerConnection$1(U, B),
          shimOnTrack$1(U),
          shimAddTrackRemoveTrack(U, B),
          shimGetSendersWithDtmf(U),
          shimSenderReceiverGetStats(U),
          fixNegotiationNeeded(U, B),
          shimRTCIceCandidate(U),
          shimRTCIceCandidateRelayProtocol(U),
          shimConnectionState(U),
          shimMaxMessageSize(U, B),
          shimSendThrowTypeError(U),
          removeExtmapAllowMixed(U, B);
        break;
      case "firefox":
        if (!firefoxShim || !shimPeerConnection || !j.shimFirefox)
          return V("Firefox shim is not included in this adapter release."), q;
        V("adapter.js shimming firefox."),
          (q.browserShim = firefoxShim),
          shimAddIceCandidateNullOrEmpty(U, B),
          shimParameterlessSetLocalDescription(U),
          shimGetUserMedia$1(U, B),
          shimPeerConnection(U, B),
          shimOnTrack(U),
          shimRemoveStream(U),
          shimSenderGetStats(U),
          shimReceiverGetStats(U),
          shimRTCDataChannel(U),
          shimAddTransceiver(U),
          shimGetParameters(U),
          shimCreateOffer(U),
          shimCreateAnswer(U),
          shimRTCIceCandidate(U),
          shimConnectionState(U),
          shimMaxMessageSize(U, B),
          shimSendThrowTypeError(U);
        break;
      case "safari":
        if (!safariShim || !j.shimSafari)
          return V("Safari shim is not included in this adapter release."), q;
        V("adapter.js shimming safari."),
          (q.browserShim = safariShim),
          shimAddIceCandidateNullOrEmpty(U, B),
          shimParameterlessSetLocalDescription(U),
          shimRTCIceServerUrls(U),
          shimCreateOfferLegacy(U),
          shimCallbacksAPI(U),
          shimLocalStreamsAPI(U),
          shimRemoteStreamsAPI(U),
          shimTrackEventTransceiver(U),
          shimGetUserMedia(U),
          shimAudioContext(U),
          shimRTCIceCandidate(U),
          shimRTCIceCandidateRelayProtocol(U),
          shimMaxMessageSize(U, B),
          shimSendThrowTypeError(U),
          removeExtmapAllowMixed(U, B);
        break;
      default:
        V("Unsupported browser!");
        break;
    }
    return q;
  }
  adapterFactory({ window: typeof window > "u" ? void 0 : window });
  const DECRYPTION_FAILURE_TOLERANCE = 10,
    E2EE_FLAG = "lk_e2ee",
    SALT = "LKFrameEncryptionKey",
    KEY_PROVIDER_DEFAULTS = {
      sharedKey: !1,
      ratchetSalt: SALT,
      ratchetWindowSize: 8,
      failureTolerance: DECRYPTION_FAILURE_TOLERANCE,
      keyringSize: 16,
    };
  var KeyProviderEvent;
  (function (U) {
    (U.SetKey = "setKey"),
      (U.RatchetRequest = "ratchetRequest"),
      (U.KeyRatcheted = "keyRatcheted");
  })(KeyProviderEvent || (KeyProviderEvent = {}));
  var KeyHandlerEvent;
  (function (U) {
    U.KeyRatcheted = "keyRatcheted";
  })(KeyHandlerEvent || (KeyHandlerEvent = {}));
  var EncryptionEvent;
  (function (U) {
    (U.ParticipantEncryptionStatusChanged =
      "participantEncryptionStatusChanged"),
      (U.EncryptionError = "encryptionError");
  })(EncryptionEvent || (EncryptionEvent = {}));
  var CryptorEvent;
  (function (U) {
    U.Error = "cryptorError";
  })(CryptorEvent || (CryptorEvent = {}));
  function isE2EESupported() {
    return isInsertableStreamSupported() || isScriptTransformSupported();
  }
  function isScriptTransformSupported() {
    return typeof window.RTCRtpScriptTransform < "u";
  }
  function isInsertableStreamSupported() {
    return (
      typeof window.RTCRtpSender < "u" &&
      typeof window.RTCRtpSender.prototype.createEncodedStreams < "u"
    );
  }
  class BaseKeyProvider extends eventsExports.EventEmitter {
    constructor() {
      let j =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      super(),
        (this.onKeyRatcheted = (V, B, q) => {
          livekitLogger.debug("key ratcheted event received", {
            ratchetResult: V,
            participantId: B,
            keyIndex: q,
          });
        }),
        (this.keyInfoMap = new Map()),
        (this.options = Object.assign(
          Object.assign({}, KEY_PROVIDER_DEFAULTS),
          j
        )),
        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);
    }
    onSetEncryptionKey(j, V, B) {
      const q = { key: j, participantIdentity: V, keyIndex: B };
      if (!this.options.sharedKey && !V)
        throw new Error(
          "participant identity needs to be passed for encryption key if sharedKey option is false"
        );
      this.keyInfoMap.set("".concat(V ?? "shared", "-").concat(B ?? 0), q),
        this.emit(KeyProviderEvent.SetKey, q);
    }
    getKeys() {
      return Array.from(this.keyInfoMap.values());
    }
    getOptions() {
      return this.options;
    }
    ratchetKey(j, V) {
      this.emit(KeyProviderEvent.RatchetRequest, j, V);
    }
  }
  class LivekitError extends Error {
    constructor(j, V) {
      super(V || "an error has occured"),
        (this.name = "LiveKitError"),
        (this.code = j);
    }
  }
  var ConnectionErrorReason;
  (function (U) {
    (U[(U.NotAllowed = 0)] = "NotAllowed"),
      (U[(U.ServerUnreachable = 1)] = "ServerUnreachable"),
      (U[(U.InternalError = 2)] = "InternalError"),
      (U[(U.Cancelled = 3)] = "Cancelled"),
      (U[(U.LeaveRequest = 4)] = "LeaveRequest"),
      (U[(U.Timeout = 5)] = "Timeout");
  })(ConnectionErrorReason || (ConnectionErrorReason = {}));
  class ConnectionError extends LivekitError {
    constructor(j, V, B, q) {
      super(1, j),
        (this.name = "ConnectionError"),
        (this.status = B),
        (this.reason = V),
        (this.context = q),
        (this.reasonName = ConnectionErrorReason[V]);
    }
  }
  class DeviceUnsupportedError extends LivekitError {
    constructor(j) {
      super(21, j ?? "device is unsupported"),
        (this.name = "DeviceUnsupportedError");
    }
  }
  class TrackInvalidError extends LivekitError {
    constructor(j) {
      super(20, j ?? "track is invalid"), (this.name = "TrackInvalidError");
    }
  }
  class UnsupportedServer extends LivekitError {
    constructor(j) {
      super(10, j ?? "unsupported server"), (this.name = "UnsupportedServer");
    }
  }
  class UnexpectedConnectionState extends LivekitError {
    constructor(j) {
      super(12, j ?? "unexpected connection state"),
        (this.name = "UnexpectedConnectionState");
    }
  }
  class NegotiationError extends LivekitError {
    constructor(j) {
      super(13, j ?? "unable to negotiate"), (this.name = "NegotiationError");
    }
  }
  class PublishTrackError extends LivekitError {
    constructor(j, V) {
      super(15, j), (this.name = "PublishTrackError"), (this.status = V);
    }
  }
  class SignalRequestError extends LivekitError {
    constructor(j, V) {
      super(15, j),
        (this.reason = V),
        (this.reasonName =
          typeof V == "string" ? V : RequestResponse_Reason[V]);
    }
  }
  var MediaDeviceFailure;
  (function (U) {
    (U.PermissionDenied = "PermissionDenied"),
      (U.NotFound = "NotFound"),
      (U.DeviceInUse = "DeviceInUse"),
      (U.Other = "Other");
  })(MediaDeviceFailure || (MediaDeviceFailure = {})),
    (function (U) {
      function j(V) {
        if (V && "name" in V)
          return V.name === "NotFoundError" || V.name === "DevicesNotFoundError"
            ? U.NotFound
            : V.name === "NotAllowedError" || V.name === "PermissionDeniedError"
            ? U.PermissionDenied
            : V.name === "NotReadableError" || V.name === "TrackStartError"
            ? U.DeviceInUse
            : U.Other;
      }
      U.getFailure = j;
    })(MediaDeviceFailure || (MediaDeviceFailure = {}));
  var CryptorErrorReason;
  (function (U) {
    (U[(U.InvalidKey = 0)] = "InvalidKey"),
      (U[(U.MissingKey = 1)] = "MissingKey"),
      (U[(U.InternalError = 2)] = "InternalError");
  })(CryptorErrorReason || (CryptorErrorReason = {}));
  var RoomEvent;
  (function (U) {
    (U.Connected = "connected"),
      (U.Reconnecting = "reconnecting"),
      (U.SignalReconnecting = "signalReconnecting"),
      (U.Reconnected = "reconnected"),
      (U.Disconnected = "disconnected"),
      (U.ConnectionStateChanged = "connectionStateChanged"),
      (U.Moved = "moved"),
      (U.MediaDevicesChanged = "mediaDevicesChanged"),
      (U.ParticipantConnected = "participantConnected"),
      (U.ParticipantDisconnected = "participantDisconnected"),
      (U.TrackPublished = "trackPublished"),
      (U.TrackSubscribed = "trackSubscribed"),
      (U.TrackSubscriptionFailed = "trackSubscriptionFailed"),
      (U.TrackUnpublished = "trackUnpublished"),
      (U.TrackUnsubscribed = "trackUnsubscribed"),
      (U.TrackMuted = "trackMuted"),
      (U.TrackUnmuted = "trackUnmuted"),
      (U.LocalTrackPublished = "localTrackPublished"),
      (U.LocalTrackUnpublished = "localTrackUnpublished"),
      (U.LocalAudioSilenceDetected = "localAudioSilenceDetected"),
      (U.ActiveSpeakersChanged = "activeSpeakersChanged"),
      (U.ParticipantMetadataChanged = "participantMetadataChanged"),
      (U.ParticipantNameChanged = "participantNameChanged"),
      (U.ParticipantAttributesChanged = "participantAttributesChanged"),
      (U.ParticipantActive = "participantActive"),
      (U.RoomMetadataChanged = "roomMetadataChanged"),
      (U.DataReceived = "dataReceived"),
      (U.SipDTMFReceived = "sipDTMFReceived"),
      (U.TranscriptionReceived = "transcriptionReceived"),
      (U.ConnectionQualityChanged = "connectionQualityChanged"),
      (U.TrackStreamStateChanged = "trackStreamStateChanged"),
      (U.TrackSubscriptionPermissionChanged =
        "trackSubscriptionPermissionChanged"),
      (U.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged"),
      (U.AudioPlaybackStatusChanged = "audioPlaybackChanged"),
      (U.VideoPlaybackStatusChanged = "videoPlaybackChanged"),
      (U.MediaDevicesError = "mediaDevicesError"),
      (U.ParticipantPermissionsChanged = "participantPermissionsChanged"),
      (U.SignalConnected = "signalConnected"),
      (U.RecordingStatusChanged = "recordingStatusChanged"),
      (U.ParticipantEncryptionStatusChanged =
        "participantEncryptionStatusChanged"),
      (U.EncryptionError = "encryptionError"),
      (U.DCBufferStatusChanged = "dcBufferStatusChanged"),
      (U.ActiveDeviceChanged = "activeDeviceChanged"),
      (U.ChatMessage = "chatMessage"),
      (U.LocalTrackSubscribed = "localTrackSubscribed"),
      (U.MetricsReceived = "metricsReceived");
  })(RoomEvent || (RoomEvent = {}));
  var ParticipantEvent;
  (function (U) {
    (U.TrackPublished = "trackPublished"),
      (U.TrackSubscribed = "trackSubscribed"),
      (U.TrackSubscriptionFailed = "trackSubscriptionFailed"),
      (U.TrackUnpublished = "trackUnpublished"),
      (U.TrackUnsubscribed = "trackUnsubscribed"),
      (U.TrackMuted = "trackMuted"),
      (U.TrackUnmuted = "trackUnmuted"),
      (U.LocalTrackPublished = "localTrackPublished"),
      (U.LocalTrackUnpublished = "localTrackUnpublished"),
      (U.LocalTrackCpuConstrained = "localTrackCpuConstrained"),
      (U.LocalSenderCreated = "localSenderCreated"),
      (U.ParticipantMetadataChanged = "participantMetadataChanged"),
      (U.ParticipantNameChanged = "participantNameChanged"),
      (U.DataReceived = "dataReceived"),
      (U.SipDTMFReceived = "sipDTMFReceived"),
      (U.TranscriptionReceived = "transcriptionReceived"),
      (U.IsSpeakingChanged = "isSpeakingChanged"),
      (U.ConnectionQualityChanged = "connectionQualityChanged"),
      (U.TrackStreamStateChanged = "trackStreamStateChanged"),
      (U.TrackSubscriptionPermissionChanged =
        "trackSubscriptionPermissionChanged"),
      (U.TrackSubscriptionStatusChanged = "trackSubscriptionStatusChanged"),
      (U.TrackCpuConstrained = "trackCpuConstrained"),
      (U.MediaDevicesError = "mediaDevicesError"),
      (U.AudioStreamAcquired = "audioStreamAcquired"),
      (U.ParticipantPermissionsChanged = "participantPermissionsChanged"),
      (U.PCTrackAdded = "pcTrackAdded"),
      (U.AttributesChanged = "attributesChanged"),
      (U.LocalTrackSubscribed = "localTrackSubscribed"),
      (U.ChatMessage = "chatMessage"),
      (U.Active = "active");
  })(ParticipantEvent || (ParticipantEvent = {}));
  var EngineEvent;
  (function (U) {
    (U.TransportsCreated = "transportsCreated"),
      (U.Connected = "connected"),
      (U.Disconnected = "disconnected"),
      (U.Resuming = "resuming"),
      (U.Resumed = "resumed"),
      (U.Restarting = "restarting"),
      (U.Restarted = "restarted"),
      (U.SignalResumed = "signalResumed"),
      (U.SignalRestarted = "signalRestarted"),
      (U.Closing = "closing"),
      (U.MediaTrackAdded = "mediaTrackAdded"),
      (U.ActiveSpeakersUpdate = "activeSpeakersUpdate"),
      (U.DataPacketReceived = "dataPacketReceived"),
      (U.RTPVideoMapUpdate = "rtpVideoMapUpdate"),
      (U.DCBufferStatusChanged = "dcBufferStatusChanged"),
      (U.ParticipantUpdate = "participantUpdate"),
      (U.RoomUpdate = "roomUpdate"),
      (U.SpeakersChanged = "speakersChanged"),
      (U.StreamStateChanged = "streamStateChanged"),
      (U.ConnectionQualityUpdate = "connectionQualityUpdate"),
      (U.SubscriptionError = "subscriptionError"),
      (U.SubscriptionPermissionUpdate = "subscriptionPermissionUpdate"),
      (U.RemoteMute = "remoteMute"),
      (U.SubscribedQualityUpdate = "subscribedQualityUpdate"),
      (U.LocalTrackUnpublished = "localTrackUnpublished"),
      (U.LocalTrackSubscribed = "localTrackSubscribed"),
      (U.Offline = "offline"),
      (U.SignalRequestResponse = "signalRequestResponse"),
      (U.SignalConnected = "signalConnected"),
      (U.RoomMoved = "roomMoved");
  })(EngineEvent || (EngineEvent = {}));
  var TrackEvent;
  (function (U) {
    (U.Message = "message"),
      (U.Muted = "muted"),
      (U.Unmuted = "unmuted"),
      (U.Restarted = "restarted"),
      (U.Ended = "ended"),
      (U.Subscribed = "subscribed"),
      (U.Unsubscribed = "unsubscribed"),
      (U.CpuConstrained = "cpuConstrained"),
      (U.UpdateSettings = "updateSettings"),
      (U.UpdateSubscription = "updateSubscription"),
      (U.AudioPlaybackStarted = "audioPlaybackStarted"),
      (U.AudioPlaybackFailed = "audioPlaybackFailed"),
      (U.AudioSilenceDetected = "audioSilenceDetected"),
      (U.VisibilityChanged = "visibilityChanged"),
      (U.VideoDimensionsChanged = "videoDimensionsChanged"),
      (U.VideoPlaybackStarted = "videoPlaybackStarted"),
      (U.VideoPlaybackFailed = "videoPlaybackFailed"),
      (U.ElementAttached = "elementAttached"),
      (U.ElementDetached = "elementDetached"),
      (U.UpstreamPaused = "upstreamPaused"),
      (U.UpstreamResumed = "upstreamResumed"),
      (U.SubscriptionPermissionChanged = "subscriptionPermissionChanged"),
      (U.SubscriptionStatusChanged = "subscriptionStatusChanged"),
      (U.SubscriptionFailed = "subscriptionFailed"),
      (U.TrackProcessorUpdate = "trackProcessorUpdate"),
      (U.AudioTrackFeatureUpdate = "audioTrackFeatureUpdate"),
      (U.TranscriptionReceived = "transcriptionReceived"),
      (U.TimeSyncUpdate = "timeSyncUpdate"),
      (U.PreConnectBufferFlushed = "preConnectBufferFlushed");
  })(TrackEvent || (TrackEvent = {}));
  function cloneDeep(U) {
    return typeof U > "u"
      ? U
      : typeof structuredClone == "function"
      ? typeof U == "object" && U !== null
        ? structuredClone(Object.assign({}, U))
        : structuredClone(U)
      : JSON.parse(JSON.stringify(U));
  }
  const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
  let browserDetails;
  function getBrowser(U) {
    let j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    if (typeof navigator > "u") return;
    const V = navigator.userAgent.toLowerCase();
    if (browserDetails === void 0 || j) {
      const B = browsersList.find((q) => {
        let { test: $ } = q;
        return $.test(V);
      });
      browserDetails = B?.describe(V);
    }
    return browserDetails;
  }
  const browsersList = [
    {
      test: /firefox|iceweasel|fxios/i,
      describe(U) {
        return {
          name: "Firefox",
          version: getMatch(
            /(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,
            U
          ),
          os: U.toLowerCase().includes("fxios") ? "iOS" : void 0,
          osVersion: getOSVersion(U),
        };
      },
    },
    {
      test: /chrom|crios|crmo/i,
      describe(U) {
        return {
          name: "Chrome",
          version: getMatch(
            /(?:chrome|chromium|crios|crmo)\/(\d+(\.?_?\d+)+)/i,
            U
          ),
          os: U.toLowerCase().includes("crios") ? "iOS" : void 0,
          osVersion: getOSVersion(U),
        };
      },
    },
    {
      test: /safari|applewebkit/i,
      describe(U) {
        return {
          name: "Safari",
          version: getMatch(commonVersionIdentifier, U),
          os: U.includes("mobile/") ? "iOS" : "macOS",
          osVersion: getOSVersion(U),
        };
      },
    },
  ];
  function getMatch(U, j) {
    let V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const B = j.match(U);
    return (B && B.length >= V && B[V]) || "";
  }
  function getOSVersion(U) {
    return U.includes("mac os")
      ? getMatch(/\(.+?(\d+_\d+(:?_\d+)?)/, U, 1).replace(/_/g, ".")
      : void 0;
  }
  var version$1 = "2.15.3";
  const version = version$1,
    protocolVersion = 16;
  class CriticalTimers {}
  (CriticalTimers.setTimeout = function () {
    return setTimeout(...arguments);
  }),
    (CriticalTimers.setInterval = function () {
      return setInterval(...arguments);
    }),
    (CriticalTimers.clearTimeout = function () {
      return clearTimeout(...arguments);
    }),
    (CriticalTimers.clearInterval = function () {
      return clearInterval(...arguments);
    });
  const BACKGROUND_REACTION_DELAY = 5e3,
    recycledElements = [];
  var VideoQuality;
  (function (U) {
    (U[(U.LOW = 0)] = "LOW"),
      (U[(U.MEDIUM = 1)] = "MEDIUM"),
      (U[(U.HIGH = 2)] = "HIGH");
  })(VideoQuality || (VideoQuality = {}));
  class Track extends eventsExports.EventEmitter {
    constructor(j, V) {
      let B =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var q;
      super(),
        (this.attachedElements = []),
        (this.isMuted = !1),
        (this.streamState = Track.StreamState.Active),
        (this.isInBackground = !1),
        (this._currentBitrate = 0),
        (this.log = livekitLogger),
        (this.appVisibilityChangedListener = () => {
          this.backgroundTimeout && clearTimeout(this.backgroundTimeout),
            document.visibilityState === "hidden"
              ? (this.backgroundTimeout = setTimeout(
                  () => this.handleAppVisibilityChanged(),
                  BACKGROUND_REACTION_DELAY
                ))
              : this.handleAppVisibilityChanged();
        }),
        (this.log = getLogger(
          (q = B.loggerName) !== null && q !== void 0 ? q : LoggerNames.Track
        )),
        (this.loggerContextCb = B.loggerContextCb),
        this.setMaxListeners(100),
        (this.kind = V),
        (this._mediaStreamTrack = j),
        (this._mediaStreamID = j.id),
        (this.source = Track.Source.Unknown);
    }
    get logContext() {
      var j;
      return Object.assign(
        Object.assign(
          {},
          (j = this.loggerContextCb) === null || j === void 0
            ? void 0
            : j.call(this)
        ),
        getLogContextFromTrack(this)
      );
    }
    get currentBitrate() {
      return this._currentBitrate;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    get mediaStreamID() {
      return this._mediaStreamID;
    }
    attach(j) {
      let V = "audio";
      this.kind === Track.Kind.Video && (V = "video"),
        this.attachedElements.length === 0 &&
          this.kind === Track.Kind.Video &&
          this.addAppVisibilityListener(),
        j ||
          (V === "audio" &&
            (recycledElements.forEach(($) => {
              $.parentElement === null && !j && (j = $);
            }),
            j && recycledElements.splice(recycledElements.indexOf(j), 1)),
          j || (j = document.createElement(V))),
        this.attachedElements.includes(j) || this.attachedElements.push(j),
        attachToElement(this.mediaStreamTrack, j);
      const B = j.srcObject.getTracks(),
        q = B.some(($) => $.kind === "audio");
      return (
        j
          .play()
          .then(() => {
            this.emit(
              q
                ? TrackEvent.AudioPlaybackStarted
                : TrackEvent.VideoPlaybackStarted
            );
          })
          .catch(($) => {
            $.name === "NotAllowedError"
              ? this.emit(
                  q
                    ? TrackEvent.AudioPlaybackFailed
                    : TrackEvent.VideoPlaybackFailed,
                  $
                )
              : $.name === "AbortError"
              ? livekitLogger.debug(
                  "".concat(
                    q ? "audio" : "video",
                    " playback aborted, likely due to new play request"
                  )
                )
              : livekitLogger.warn(
                  "could not playback ".concat(q ? "audio" : "video"),
                  $
                ),
              q &&
                j &&
                B.some((H) => H.kind === "video") &&
                $.name === "NotAllowedError" &&
                ((j.muted = !0), j.play().catch(() => {}));
          }),
        this.emit(TrackEvent.ElementAttached, j),
        j
      );
    }
    detach(j) {
      try {
        if (j) {
          detachTrack(this.mediaStreamTrack, j);
          const B = this.attachedElements.indexOf(j);
          return (
            B >= 0 &&
              (this.attachedElements.splice(B, 1),
              this.recycleElement(j),
              this.emit(TrackEvent.ElementDetached, j)),
            j
          );
        }
        const V = [];
        return (
          this.attachedElements.forEach((B) => {
            detachTrack(this.mediaStreamTrack, B),
              V.push(B),
              this.recycleElement(B),
              this.emit(TrackEvent.ElementDetached, B);
          }),
          (this.attachedElements = []),
          V
        );
      } finally {
        this.attachedElements.length === 0 &&
          this.removeAppVisibilityListener();
      }
    }
    stop() {
      this.stopMonitor(), this._mediaStreamTrack.stop();
    }
    enable() {
      this._mediaStreamTrack.enabled = !0;
    }
    disable() {
      this._mediaStreamTrack.enabled = !1;
    }
    stopMonitor() {
      this.monitorInterval && clearInterval(this.monitorInterval),
        this.timeSyncHandle && cancelAnimationFrame(this.timeSyncHandle);
    }
    updateLoggerOptions(j) {
      j.loggerName && (this.log = getLogger(j.loggerName)),
        j.loggerContextCb && (this.loggerContextCb = j.loggerContextCb);
    }
    recycleElement(j) {
      if (j instanceof HTMLAudioElement) {
        let V = !0;
        j.pause(),
          recycledElements.forEach((B) => {
            B.parentElement || (V = !1);
          }),
          V && recycledElements.push(j);
      }
    }
    handleAppVisibilityChanged() {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.isInBackground = document.visibilityState === "hidden"),
          !this.isInBackground &&
            this.kind === Track.Kind.Video &&
            setTimeout(
              () =>
                this.attachedElements.forEach((j) => j.play().catch(() => {})),
              0
            );
      });
    }
    addAppVisibilityListener() {
      isWeb()
        ? ((this.isInBackground = document.visibilityState === "hidden"),
          document.addEventListener(
            "visibilitychange",
            this.appVisibilityChangedListener
          ))
        : (this.isInBackground = !1);
    }
    removeAppVisibilityListener() {
      isWeb() &&
        document.removeEventListener(
          "visibilitychange",
          this.appVisibilityChangedListener
        );
    }
  }
  function attachToElement(U, j) {
    let V;
    j.srcObject instanceof MediaStream
      ? (V = j.srcObject)
      : (V = new MediaStream());
    let B;
    U.kind === "audio" ? (B = V.getAudioTracks()) : (B = V.getVideoTracks()),
      B.includes(U) ||
        (B.forEach((q) => {
          V.removeTrack(q);
        }),
        V.addTrack(U)),
      (!isSafari() || !(j instanceof HTMLVideoElement)) && (j.autoplay = !0),
      (j.muted = V.getAudioTracks().length === 0),
      j instanceof HTMLVideoElement && (j.playsInline = !0),
      j.srcObject !== V &&
        ((j.srcObject = V),
        (isSafari() || isFireFox()) &&
          j instanceof HTMLVideoElement &&
          setTimeout(() => {
            (j.srcObject = V), j.play().catch(() => {});
          }, 0));
  }
  function detachTrack(U, j) {
    if (j.srcObject instanceof MediaStream) {
      const V = j.srcObject;
      V.removeTrack(U),
        V.getTracks().length > 0 ? (j.srcObject = V) : (j.srcObject = null);
    }
  }
  (function (U) {
    let j;
    (function (Q) {
      (Q.Audio = "audio"), (Q.Video = "video"), (Q.Unknown = "unknown");
    })((j = U.Kind || (U.Kind = {})));
    let V;
    (function (Q) {
      (Q.Camera = "camera"),
        (Q.Microphone = "microphone"),
        (Q.ScreenShare = "screen_share"),
        (Q.ScreenShareAudio = "screen_share_audio"),
        (Q.Unknown = "unknown");
    })((V = U.Source || (U.Source = {})));
    let B;
    (function (Q) {
      (Q.Active = "active"), (Q.Paused = "paused"), (Q.Unknown = "unknown");
    })((B = U.StreamState || (U.StreamState = {})));
    function q(Q) {
      switch (Q) {
        case j.Audio:
          return TrackType.AUDIO;
        case j.Video:
          return TrackType.VIDEO;
        default:
          return TrackType.DATA;
      }
    }
    U.kindToProto = q;
    function $(Q) {
      switch (Q) {
        case TrackType.AUDIO:
          return j.Audio;
        case TrackType.VIDEO:
          return j.Video;
        default:
          return j.Unknown;
      }
    }
    U.kindFromProto = $;
    function H(Q) {
      switch (Q) {
        case V.Camera:
          return TrackSource.CAMERA;
        case V.Microphone:
          return TrackSource.MICROPHONE;
        case V.ScreenShare:
          return TrackSource.SCREEN_SHARE;
        case V.ScreenShareAudio:
          return TrackSource.SCREEN_SHARE_AUDIO;
        default:
          return TrackSource.UNKNOWN;
      }
    }
    U.sourceToProto = H;
    function G(Q) {
      switch (Q) {
        case TrackSource.CAMERA:
          return V.Camera;
        case TrackSource.MICROPHONE:
          return V.Microphone;
        case TrackSource.SCREEN_SHARE:
          return V.ScreenShare;
        case TrackSource.SCREEN_SHARE_AUDIO:
          return V.ScreenShareAudio;
        default:
          return V.Unknown;
      }
    }
    U.sourceFromProto = G;
    function Y(Q) {
      switch (Q) {
        case StreamState.ACTIVE:
          return B.Active;
        case StreamState.PAUSED:
          return B.Paused;
        default:
          return B.Unknown;
      }
    }
    U.streamStateFromProto = Y;
  })(Track || (Track = {}));
  class VideoPreset {
    constructor(j, V, B, q, $) {
      if (typeof j == "object")
        (this.width = j.width),
          (this.height = j.height),
          (this.aspectRatio = j.aspectRatio),
          (this.encoding = {
            maxBitrate: j.maxBitrate,
            maxFramerate: j.maxFramerate,
            priority: j.priority,
          });
      else if (V !== void 0 && B !== void 0)
        (this.width = j),
          (this.height = V),
          (this.aspectRatio = j / V),
          (this.encoding = { maxBitrate: B, maxFramerate: q, priority: $ });
      else
        throw new TypeError(
          "Unsupported options: provide at least width, height and maxBitrate"
        );
    }
    get resolution() {
      return {
        width: this.width,
        height: this.height,
        frameRate: this.encoding.maxFramerate,
        aspectRatio: this.aspectRatio,
      };
    }
  }
  const backupCodecs = ["vp8", "h264"],
    videoCodecs = ["vp8", "h264", "vp9", "av1", "h265"];
  function isBackupCodec(U) {
    return !!backupCodecs.find((j) => j === U);
  }
  var BackupCodecPolicy;
  (function (U) {
    (U[(U.PREFER_REGRESSION = 0)] = "PREFER_REGRESSION"),
      (U[(U.SIMULCAST = 1)] = "SIMULCAST"),
      (U[(U.REGRESSION = 2)] = "REGRESSION");
  })(BackupCodecPolicy || (BackupCodecPolicy = {}));
  var AudioPresets;
  (function (U) {
    (U.telephone = { maxBitrate: 12e3 }),
      (U.speech = { maxBitrate: 24e3 }),
      (U.music = { maxBitrate: 48e3 }),
      (U.musicStereo = { maxBitrate: 64e3 }),
      (U.musicHighQuality = { maxBitrate: 96e3 }),
      (U.musicHighQualityStereo = { maxBitrate: 128e3 });
  })(AudioPresets || (AudioPresets = {}));
  const VideoPresets = {
      h90: new VideoPreset(160, 90, 9e4, 20),
      h180: new VideoPreset(320, 180, 16e4, 20),
      h216: new VideoPreset(384, 216, 18e4, 20),
      h360: new VideoPreset(640, 360, 45e4, 20),
      h540: new VideoPreset(960, 540, 8e5, 25),
      h720: new VideoPreset(1280, 720, 17e5, 30),
      h1080: new VideoPreset(1920, 1080, 3e6, 30),
      h1440: new VideoPreset(2560, 1440, 5e6, 30),
      h2160: new VideoPreset(3840, 2160, 8e6, 30),
    },
    VideoPresets43 = {
      h120: new VideoPreset(160, 120, 7e4, 20),
      h180: new VideoPreset(240, 180, 125e3, 20),
      h240: new VideoPreset(320, 240, 14e4, 20),
      h360: new VideoPreset(480, 360, 33e4, 20),
      h480: new VideoPreset(640, 480, 5e5, 20),
      h540: new VideoPreset(720, 540, 6e5, 25),
      h720: new VideoPreset(960, 720, 13e5, 30),
      h1080: new VideoPreset(1440, 1080, 23e5, 30),
      h1440: new VideoPreset(1920, 1440, 38e5, 30),
    },
    ScreenSharePresets = {
      h360fps3: new VideoPreset(640, 360, 2e5, 3, "medium"),
      h360fps15: new VideoPreset(640, 360, 4e5, 15, "medium"),
      h720fps5: new VideoPreset(1280, 720, 8e5, 5, "medium"),
      h720fps15: new VideoPreset(1280, 720, 15e5, 15, "medium"),
      h720fps30: new VideoPreset(1280, 720, 2e6, 30, "medium"),
      h1080fps15: new VideoPreset(1920, 1080, 25e5, 15, "medium"),
      h1080fps30: new VideoPreset(1920, 1080, 5e6, 30, "medium"),
      original: new VideoPreset(0, 0, 7e6, 30, "medium"),
    },
    separator = "|",
    ddExtensionURI =
      "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension";
  function unpackStreamId(U) {
    const j = U.split(separator);
    return j.length > 1 ? [j[0], U.substr(j[0].length + 1)] : [U, ""];
  }
  function sleep$1(U) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return new Promise((j) => CriticalTimers.setTimeout(j, U));
    });
  }
  function supportsTransceiver() {
    return "addTransceiver" in RTCPeerConnection.prototype;
  }
  function supportsAddTrack() {
    return "addTrack" in RTCPeerConnection.prototype;
  }
  function supportsAV1() {
    if (!("getCapabilities" in RTCRtpSender) || isSafari()) return !1;
    const U = RTCRtpSender.getCapabilities("video");
    let j = !1;
    if (U) {
      for (const V of U.codecs)
        if (V.mimeType === "video/AV1") {
          j = !0;
          break;
        }
    }
    return j;
  }
  function supportsVP9() {
    if (!("getCapabilities" in RTCRtpSender) || isFireFox()) return !1;
    if (isSafari()) {
      const V = getBrowser();
      if (
        (V?.version && compareVersions(V.version, "16") < 0) ||
        (V?.os === "iOS" &&
          V?.osVersion &&
          compareVersions(V.osVersion, "16") < 0)
      )
        return !1;
    }
    const U = RTCRtpSender.getCapabilities("video");
    let j = !1;
    if (U) {
      for (const V of U.codecs)
        if (V.mimeType === "video/VP9") {
          j = !0;
          break;
        }
    }
    return j;
  }
  function isSVCCodec(U) {
    return U === "av1" || U === "vp9";
  }
  function supportsSetSinkId(U) {
    return document
      ? (U || (U = document.createElement("audio")), "setSinkId" in U)
      : !1;
  }
  function isBrowserSupported() {
    return typeof RTCPeerConnection > "u"
      ? !1
      : supportsTransceiver() || supportsAddTrack();
  }
  function isFireFox() {
    var U;
    return (
      ((U = getBrowser()) === null || U === void 0 ? void 0 : U.name) ===
      "Firefox"
    );
  }
  function isSafari() {
    var U;
    return (
      ((U = getBrowser()) === null || U === void 0 ? void 0 : U.name) ===
      "Safari"
    );
  }
  function isSafariBased() {
    const U = getBrowser();
    return U?.name === "Safari" || U?.os === "iOS";
  }
  function isSafari17Based() {
    const U = getBrowser();
    return (
      (U?.name === "Safari" && U.version.startsWith("17.")) ||
      (U?.os === "iOS" &&
        !!U?.osVersion &&
        compareVersions(U.osVersion, "17") >= 0)
    );
  }
  function isSafariSvcApi(U) {
    return (
      U || (U = getBrowser()),
      (U?.name === "Safari" && compareVersions(U.version, "18.3") > 0) ||
        (U?.os === "iOS" &&
          !!U?.osVersion &&
          compareVersions(U.osVersion, "18.3") > 0)
    );
  }
  function isMobile() {
    var U, j;
    return isWeb()
      ? (j =
          (U = navigator.userAgentData) === null || U === void 0
            ? void 0
            : U.mobile) !== null && j !== void 0
        ? j
        : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent)
      : !1;
  }
  function isE2EESimulcastSupported() {
    const U = getBrowser(),
      j = "17.2";
    if (U)
      return (U.name !== "Safari" && U.os !== "iOS") ||
        (U.os === "iOS" && U.osVersion && compareVersions(j, U.osVersion) >= 0)
        ? !0
        : U.name === "Safari" && compareVersions(j, U.version) >= 0;
  }
  function isWeb() {
    return typeof document < "u";
  }
  function isReactNative() {
    return navigator.product == "ReactNative";
  }
  function isCloud(U) {
    return (
      U.hostname.endsWith(".livekit.cloud") ||
      U.hostname.endsWith(".livekit.run")
    );
  }
  function getLKReactNativeInfo() {
    if (global && global.LiveKitReactNativeGlobal)
      return global.LiveKitReactNativeGlobal;
  }
  function getReactNativeOs() {
    if (!isReactNative()) return;
    let U = getLKReactNativeInfo();
    if (U) return U.platform;
  }
  function getDevicePixelRatio() {
    if (isWeb()) return window.devicePixelRatio;
    if (isReactNative()) {
      let U = getLKReactNativeInfo();
      if (U) return U.devicePixelRatio;
    }
    return 1;
  }
  function compareVersions(U, j) {
    const V = U.split("."),
      B = j.split("."),
      q = Math.min(V.length, B.length);
    for (let $ = 0; $ < q; ++$) {
      const H = parseInt(V[$], 10),
        G = parseInt(B[$], 10);
      if (H > G) return 1;
      if (H < G) return -1;
      if ($ === q - 1 && H === G) return 0;
    }
    return U === "" && j !== ""
      ? -1
      : j === ""
      ? 1
      : V.length == B.length
      ? 0
      : V.length < B.length
      ? -1
      : 1;
  }
  function roDispatchCallback(U) {
    for (const j of U) j.target.handleResize(j);
  }
  function ioDispatchCallback(U) {
    for (const j of U) j.target.handleVisibilityChanged(j);
  }
  let resizeObserver = null;
  const getResizeObserver = () => (
    resizeObserver || (resizeObserver = new ResizeObserver(roDispatchCallback)),
    resizeObserver
  );
  let intersectionObserver = null;
  const getIntersectionObserver = () => (
    intersectionObserver ||
      (intersectionObserver = new IntersectionObserver(ioDispatchCallback, {
        root: null,
        rootMargin: "0px",
      })),
    intersectionObserver
  );
  function getClientInfo() {
    var U;
    const j = new ClientInfo({
      sdk: ClientInfo_SDK.JS,
      protocol: protocolVersion,
      version,
    });
    return (
      isReactNative() &&
        (j.os = (U = getReactNativeOs()) !== null && U !== void 0 ? U : ""),
      j
    );
  }
  function createDummyVideoStreamTrack() {
    let U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16,
      j = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 16,
      V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1,
      B = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    const q = document.createElement("canvas");
    (q.width = U), (q.height = j);
    const $ = q.getContext("2d");
    $?.fillRect(0, 0, q.width, q.height),
      B &&
        $ &&
        ($.beginPath(),
        $.arc(U / 2, j / 2, 50, 0, Math.PI * 2, !0),
        $.closePath(),
        ($.fillStyle = "grey"),
        $.fill());
    const H = q.captureStream(),
      [G] = H.getTracks();
    if (!G) throw Error("Could not get empty media stream video track");
    return (G.enabled = V), G;
  }
  let emptyAudioStreamTrack;
  function getEmptyAudioStreamTrack() {
    if (!emptyAudioStreamTrack) {
      const U = new AudioContext(),
        j = U.createOscillator(),
        V = U.createGain();
      V.gain.setValueAtTime(0, 0);
      const B = U.createMediaStreamDestination();
      if (
        (j.connect(V),
        V.connect(B),
        j.start(),
        ([emptyAudioStreamTrack] = B.stream.getAudioTracks()),
        !emptyAudioStreamTrack)
      )
        throw Error("Could not get empty media stream audio track");
      emptyAudioStreamTrack.enabled = !1;
    }
    return emptyAudioStreamTrack.clone();
  }
  class Future {
    get isResolved() {
      return this._isResolved;
    }
    constructor(j, V) {
      (this._isResolved = !1),
        (this.onFinally = V),
        (this.promise = new Promise((B, q) =>
          __awaiter$1(this, void 0, void 0, function* () {
            (this.resolve = B), (this.reject = q), j && (yield j(B, q));
          })
        ).finally(() => {
          var B;
          (this._isResolved = !0),
            (B = this.onFinally) === null || B === void 0 || B.call(this);
        }));
    }
  }
  function isVideoCodec(U) {
    return videoCodecs.includes(U);
  }
  function unwrapConstraint(U) {
    if (typeof U == "string" || typeof U == "number") return U;
    if (Array.isArray(U)) return U[0];
    if (U.exact) return Array.isArray(U.exact) ? U.exact[0] : U.exact;
    if (U.ideal) return Array.isArray(U.ideal) ? U.ideal[0] : U.ideal;
    throw Error("could not unwrap constraint");
  }
  function toWebsocketUrl(U) {
    return U.startsWith("http") ? U.replace(/^(http)/, "ws") : U;
  }
  function toHttpUrl(U) {
    return U.startsWith("ws") ? U.replace(/^(ws)/, "http") : U;
  }
  function extractTranscriptionSegments(U, j) {
    return U.segments.map((V) => {
      let {
        id: B,
        text: q,
        language: $,
        startTime: H,
        endTime: G,
        final: Y,
      } = V;
      var Q;
      const X = (Q = j.get(B)) !== null && Q !== void 0 ? Q : Date.now(),
        Z = Date.now();
      return (
        Y ? j.delete(B) : j.set(B, X),
        {
          id: B,
          text: q,
          startTime: Number.parseInt(H.toString()),
          endTime: Number.parseInt(G.toString()),
          final: Y,
          language: $,
          firstReceivedTime: X,
          lastReceivedTime: Z,
        }
      );
    });
  }
  function extractChatMessage(U) {
    const { id: j, timestamp: V, message: B, editTimestamp: q } = U;
    return {
      id: j,
      timestamp: Number.parseInt(V.toString()),
      editTimestamp: q ? Number.parseInt(q.toString()) : void 0,
      message: B,
    };
  }
  function getDisconnectReasonFromConnectionError(U) {
    switch (U.reason) {
      case ConnectionErrorReason.LeaveRequest:
        return U.context;
      case ConnectionErrorReason.Cancelled:
        return DisconnectReason.CLIENT_INITIATED;
      case ConnectionErrorReason.NotAllowed:
        return DisconnectReason.USER_REJECTED;
      case ConnectionErrorReason.ServerUnreachable:
        return DisconnectReason.JOIN_FAILURE;
      default:
        return DisconnectReason.UNKNOWN_REASON;
    }
  }
  function bigIntToNumber(U) {
    return U !== void 0 ? Number(U) : void 0;
  }
  function numberToBigInt(U) {
    return U !== void 0 ? BigInt(U) : void 0;
  }
  function isLocalTrack(U) {
    return !!U && !(U instanceof MediaStreamTrack) && U.isLocal;
  }
  function isAudioTrack(U) {
    return !!U && U.kind == Track.Kind.Audio;
  }
  function isVideoTrack(U) {
    return !!U && U.kind == Track.Kind.Video;
  }
  function isLocalVideoTrack(U) {
    return isLocalTrack(U) && isVideoTrack(U);
  }
  function isLocalAudioTrack(U) {
    return isLocalTrack(U) && isAudioTrack(U);
  }
  function isRemoteTrack(U) {
    return !!U && !U.isLocal;
  }
  function isRemotePub(U) {
    return !!U && !U.isLocal;
  }
  function isRemoteVideoTrack(U) {
    return isRemoteTrack(U) && isVideoTrack(U);
  }
  function isLocalParticipant(U) {
    return U.isLocal;
  }
  function splitUtf8(U, j) {
    const V = [];
    let B = new TextEncoder().encode(U);
    for (; B.length > j; ) {
      let q = j;
      for (; q > 0; ) {
        const $ = B[q];
        if ($ !== void 0 && ($ & 192) !== 128) break;
        q--;
      }
      V.push(B.slice(0, q)), (B = B.slice(q));
    }
    return B.length > 0 && V.push(B), V;
  }
  function mergeDefaultOptions(U, j, V) {
    var B, q, $, H;
    const {
        optionsWithoutProcessor: G,
        audioProcessor: Y,
        videoProcessor: Q,
      } = extractProcessorsFromOptions(U ?? {}),
      X = j?.processor,
      Z = V?.processor,
      te = G ?? {};
    return (
      te.audio === !0 && (te.audio = {}),
      te.video === !0 && (te.video = {}),
      te.audio &&
        (mergeObjectWithoutOverwriting(te.audio, j),
        ((B = ($ = te.audio).deviceId) !== null && B !== void 0) ||
          ($.deviceId = { ideal: "default" }),
        (Y || X) && (te.audio.processor = Y ?? X)),
      te.video &&
        (mergeObjectWithoutOverwriting(te.video, V),
        ((q = (H = te.video).deviceId) !== null && q !== void 0) ||
          (H.deviceId = { ideal: "default" }),
        (Q || Z) && (te.video.processor = Q ?? Z)),
      te
    );
  }
  function mergeObjectWithoutOverwriting(U, j) {
    return (
      Object.keys(j).forEach((V) => {
        U[V] === void 0 && (U[V] = j[V]);
      }),
      U
    );
  }
  function constraintsForOptions(U) {
    var j, V, B, q;
    const $ = {};
    if (U.video)
      if (typeof U.video == "object") {
        const H = {},
          G = H,
          Y = U.video;
        Object.keys(Y).forEach((Q) => {
          switch (Q) {
            case "resolution":
              mergeObjectWithoutOverwriting(G, Y.resolution);
              break;
            default:
              G[Q] = Y[Q];
          }
        }),
          ($.video = H),
          ((j = (B = $.video).deviceId) !== null && j !== void 0) ||
            (B.deviceId = { ideal: "default" });
      } else $.video = U.video ? { deviceId: { ideal: "default" } } : !1;
    else $.video = !1;
    return (
      U.audio
        ? typeof U.audio == "object"
          ? (($.audio = U.audio),
            ((V = (q = $.audio).deviceId) !== null && V !== void 0) ||
              (q.deviceId = { ideal: "default" }))
          : ($.audio = { deviceId: { ideal: "default" } })
        : ($.audio = !1),
      $
    );
  }
  function detectSilence(U) {
    return __awaiter$1(this, arguments, void 0, function (j) {
      let V =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 200;
      return (function* () {
        const B = getNewAudioContext();
        if (B) {
          const q = B.createAnalyser();
          q.fftSize = 2048;
          const $ = q.frequencyBinCount,
            H = new Uint8Array($);
          B.createMediaStreamSource(
            new MediaStream([j.mediaStreamTrack])
          ).connect(q),
            yield sleep$1(V),
            q.getByteTimeDomainData(H);
          const Y = H.some((Q) => Q !== 128 && Q !== 0);
          return B.close(), !Y;
        }
        return !1;
      })();
    });
  }
  function getNewAudioContext() {
    var U;
    const j =
      typeof window < "u" && (window.AudioContext || window.webkitAudioContext);
    if (j) {
      const V = new j({ latencyHint: "interactive" });
      if (
        V.state === "suspended" &&
        typeof window < "u" &&
        !((U = window.document) === null || U === void 0) &&
        U.body
      ) {
        const B = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            var q;
            try {
              V.state === "suspended" && (yield V.resume());
            } catch ($) {
              console.warn("Error trying to auto-resume audio context", $);
            }
            (q = window.document.body) === null ||
              q === void 0 ||
              q.removeEventListener("click", B);
          });
        window.document.body.addEventListener("click", B);
      }
      return V;
    }
  }
  function kindToSource(U) {
    return U === "audioinput"
      ? Track.Source.Microphone
      : U === "videoinput"
      ? Track.Source.Camera
      : Track.Source.Unknown;
  }
  function sourceToKind(U) {
    return U === Track.Source.Microphone
      ? "audioinput"
      : U === Track.Source.Camera
      ? "videoinput"
      : void 0;
  }
  function screenCaptureToDisplayMediaStreamOptions(U) {
    var j, V;
    let B = (j = U.video) !== null && j !== void 0 ? j : !0;
    return (
      U.resolution &&
        U.resolution.width > 0 &&
        U.resolution.height > 0 &&
        ((B = typeof B == "boolean" ? {} : B),
        isSafari()
          ? (B = Object.assign(Object.assign({}, B), {
              width: { max: U.resolution.width },
              height: { max: U.resolution.height },
              frameRate: U.resolution.frameRate,
            }))
          : (B = Object.assign(Object.assign({}, B), {
              width: { ideal: U.resolution.width },
              height: { ideal: U.resolution.height },
              frameRate: U.resolution.frameRate,
            }))),
      {
        audio: (V = U.audio) !== null && V !== void 0 ? V : !1,
        video: B,
        controller: U.controller,
        selfBrowserSurface: U.selfBrowserSurface,
        surfaceSwitching: U.surfaceSwitching,
        systemAudio: U.systemAudio,
        preferCurrentTab: U.preferCurrentTab,
      }
    );
  }
  function mimeTypeToVideoCodecString(U) {
    return U.split("/")[1].toLowerCase();
  }
  function getTrackPublicationInfo(U) {
    const j = [];
    return (
      U.forEach((V) => {
        V.track !== void 0 &&
          j.push(
            new TrackPublishedResponse({
              cid: V.track.mediaStreamID,
              track: V.trackInfo,
            })
          );
      }),
      j
    );
  }
  function getLogContextFromTrack(U) {
    return "mediaStreamTrack" in U
      ? {
          trackID: U.sid,
          source: U.source,
          muted: U.isMuted,
          enabled: U.mediaStreamTrack.enabled,
          kind: U.kind,
          streamID: U.mediaStreamID,
          streamTrackID: U.mediaStreamTrack.id,
        }
      : {
          trackID: U.trackSid,
          enabled: U.isEnabled,
          muted: U.isMuted,
          trackInfo: Object.assign(
            {
              mimeType: U.mimeType,
              name: U.trackName,
              encrypted: U.isEncrypted,
              kind: U.kind,
              source: U.source,
            },
            U.track ? getLogContextFromTrack(U.track) : {}
          ),
        };
  }
  function supportsSynchronizationSources() {
    return (
      typeof RTCRtpReceiver < "u" &&
      "getSynchronizationSources" in RTCRtpReceiver
    );
  }
  function diffAttributes(U, j) {
    var V;
    U === void 0 && (U = {}), j === void 0 && (j = {});
    const B = [...Object.keys(j), ...Object.keys(U)],
      q = {};
    for (const $ of B)
      U[$] !== j[$] && (q[$] = (V = j[$]) !== null && V !== void 0 ? V : "");
    return q;
  }
  function extractProcessorsFromOptions(U) {
    const j = Object.assign({}, U);
    let V, B;
    return (
      typeof j.audio == "object" &&
        j.audio.processor &&
        ((V = j.audio.processor),
        (j.audio = Object.assign(Object.assign({}, j.audio), {
          processor: void 0,
        }))),
      typeof j.video == "object" &&
        j.video.processor &&
        ((B = j.video.processor),
        (j.video = Object.assign(Object.assign({}, j.video), {
          processor: void 0,
        }))),
      {
        audioProcessor: V,
        videoProcessor: B,
        optionsWithoutProcessor: cloneDeep(j),
      }
    );
  }
  function getTrackSourceFromProto(U) {
    switch (U) {
      case TrackSource.CAMERA:
        return Track.Source.Camera;
      case TrackSource.MICROPHONE:
        return Track.Source.Microphone;
      case TrackSource.SCREEN_SHARE:
        return Track.Source.ScreenShare;
      case TrackSource.SCREEN_SHARE_AUDIO:
        return Track.Source.ScreenShareAudio;
      default:
        return Track.Source.Unknown;
    }
  }
  function areDimensionsSmaller(U, j) {
    return U.width * U.height < j.width * j.height;
  }
  function layerDimensionsFor(U, j) {
    var V;
    return (V = U.layers) === null || V === void 0
      ? void 0
      : V.find((B) => B.quality === j);
  }
  class E2EEManager extends eventsExports.EventEmitter {
    constructor(j) {
      super(),
        (this.onWorkerMessage = (V) => {
          var B, q;
          const { kind: $, data: H } = V.data;
          switch ($) {
            case "error":
              livekitLogger.error(H.error.message),
                this.emit(EncryptionEvent.EncryptionError, H.error);
              break;
            case "initAck":
              H.enabled &&
                this.keyProvider.getKeys().forEach((G) => {
                  this.postKey(G);
                });
              break;
            case "enable":
              if (
                (H.enabled &&
                  this.keyProvider.getKeys().forEach((G) => {
                    this.postKey(G);
                  }),
                this.encryptionEnabled !== H.enabled &&
                  H.participantIdentity ===
                    ((B = this.room) === null || B === void 0
                      ? void 0
                      : B.localParticipant.identity))
              )
                this.emit(
                  EncryptionEvent.ParticipantEncryptionStatusChanged,
                  H.enabled,
                  this.room.localParticipant
                ),
                  (this.encryptionEnabled = H.enabled);
              else if (H.participantIdentity) {
                const G =
                  (q = this.room) === null || q === void 0
                    ? void 0
                    : q.getParticipantByIdentity(H.participantIdentity);
                if (!G)
                  throw TypeError(
                    "couldn't set encryption status, participant not found".concat(
                      H.participantIdentity
                    )
                  );
                this.emit(
                  EncryptionEvent.ParticipantEncryptionStatusChanged,
                  H.enabled,
                  G
                );
              }
              break;
            case "ratchetKey":
              this.keyProvider.emit(
                KeyProviderEvent.KeyRatcheted,
                H.ratchetResult,
                H.participantIdentity,
                H.keyIndex
              );
              break;
          }
        }),
        (this.onWorkerError = (V) => {
          livekitLogger.error("e2ee worker encountered an error:", {
            error: V.error,
          }),
            this.emit(EncryptionEvent.EncryptionError, V.error);
        }),
        (this.keyProvider = j.keyProvider),
        (this.worker = j.worker),
        (this.encryptionEnabled = !1);
    }
    setup(j) {
      if (!isE2EESupported())
        throw new DeviceUnsupportedError(
          "tried to setup end-to-end encryption on an unsupported browser"
        );
      if ((livekitLogger.info("setting up e2ee"), j !== this.room)) {
        (this.room = j), this.setupEventListeners(j, this.keyProvider);
        const V = {
          kind: "init",
          data: {
            keyProviderOptions: this.keyProvider.getOptions(),
            loglevel: workerLogger.getLevel(),
          },
        };
        this.worker &&
          (livekitLogger.info("initializing worker", { worker: this.worker }),
          (this.worker.onmessage = this.onWorkerMessage),
          (this.worker.onerror = this.onWorkerError),
          this.worker.postMessage(V));
      }
    }
    setParticipantCryptorEnabled(j, V) {
      livekitLogger.debug(
        "set e2ee to ".concat(j, " for participant ").concat(V)
      ),
        this.postEnable(j, V);
    }
    setSifTrailer(j) {
      !j || j.length === 0
        ? livekitLogger.warn("ignoring server sent trailer as it's empty")
        : this.postSifTrailer(j);
    }
    setupEngine(j) {
      j.on(EngineEvent.RTPVideoMapUpdate, (V) => {
        this.postRTPMap(V);
      });
    }
    setupEventListeners(j, V) {
      j.on(RoomEvent.TrackPublished, (B, q) =>
        this.setParticipantCryptorEnabled(
          B.trackInfo.encryption !== Encryption_Type.NONE,
          q.identity
        )
      ),
        j
          .on(RoomEvent.ConnectionStateChanged, (B) => {
            B === ConnectionState.Connected &&
              j.remoteParticipants.forEach((q) => {
                q.trackPublications.forEach(($) => {
                  this.setParticipantCryptorEnabled(
                    $.trackInfo.encryption !== Encryption_Type.NONE,
                    q.identity
                  );
                });
              });
          })
          .on(RoomEvent.TrackUnsubscribed, (B, q, $) => {
            var H;
            const G = {
              kind: "removeTransform",
              data: {
                participantIdentity: $.identity,
                trackId: B.mediaStreamID,
              },
            };
            (H = this.worker) === null || H === void 0 || H.postMessage(G);
          })
          .on(RoomEvent.TrackSubscribed, (B, q, $) => {
            this.setupE2EEReceiver(B, $.identity, q.trackInfo);
          })
          .on(RoomEvent.SignalConnected, () => {
            if (!this.room)
              throw new TypeError(
                "expected room to be present on signal connect"
              );
            V.getKeys().forEach((B) => {
              this.postKey(B);
            }),
              this.setParticipantCryptorEnabled(
                this.room.localParticipant.isE2EEEnabled,
                this.room.localParticipant.identity
              );
          }),
        j.localParticipant.on(ParticipantEvent.LocalSenderCreated, (B, q) =>
          __awaiter$1(this, void 0, void 0, function* () {
            this.setupE2EESender(q, B);
          })
        ),
        V.on(KeyProviderEvent.SetKey, (B) => this.postKey(B)).on(
          KeyProviderEvent.RatchetRequest,
          (B, q) => this.postRatchetRequest(B, q)
        );
    }
    postRatchetRequest(j, V) {
      if (!this.worker) throw Error("could not ratchet key, worker is missing");
      const B = {
        kind: "ratchetRequest",
        data: { participantIdentity: j, keyIndex: V },
      };
      this.worker.postMessage(B);
    }
    postKey(j) {
      let { key: V, participantIdentity: B, keyIndex: q } = j;
      var $;
      if (!this.worker) throw Error("could not set key, worker is missing");
      const H = {
        kind: "setKey",
        data: {
          participantIdentity: B,
          isPublisher:
            B ===
            (($ = this.room) === null || $ === void 0
              ? void 0
              : $.localParticipant.identity),
          key: V,
          keyIndex: q,
        },
      };
      this.worker.postMessage(H);
    }
    postEnable(j, V) {
      if (this.worker) {
        const B = {
          kind: "enable",
          data: { enabled: j, participantIdentity: V },
        };
        this.worker.postMessage(B);
      } else
        throw new ReferenceError("failed to enable e2ee, worker is not ready");
    }
    postRTPMap(j) {
      var V;
      if (!this.worker)
        throw TypeError("could not post rtp map, worker is missing");
      if (
        !(
          !((V = this.room) === null || V === void 0) &&
          V.localParticipant.identity
        )
      )
        throw TypeError(
          "could not post rtp map, local participant identity is missing"
        );
      const B = {
        kind: "setRTPMap",
        data: {
          map: j,
          participantIdentity: this.room.localParticipant.identity,
        },
      };
      this.worker.postMessage(B);
    }
    postSifTrailer(j) {
      if (!this.worker)
        throw Error("could not post SIF trailer, worker is missing");
      const V = { kind: "setSifTrailer", data: { trailer: j } };
      this.worker.postMessage(V);
    }
    setupE2EEReceiver(j, V, B) {
      if (j.receiver) {
        if (!B?.mimeType || B.mimeType === "")
          throw new TypeError(
            "MimeType missing from trackInfo, cannot set up E2EE cryptor"
          );
        this.handleReceiver(
          j.receiver,
          j.mediaStreamID,
          V,
          j.kind === "video" ? mimeTypeToVideoCodecString(B.mimeType) : void 0
        );
      }
    }
    setupE2EESender(j, V) {
      if (!isLocalTrack(j) || !V) {
        V || livekitLogger.warn("early return because sender is not ready");
        return;
      }
      this.handleSender(V, j.mediaStreamID, void 0);
    }
    handleReceiver(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.worker) {
          if (isScriptTransformSupported()) {
            const $ = {
              kind: "decode",
              participantIdentity: B,
              trackId: V,
              codec: q,
            };
            j.transform = new RTCRtpScriptTransform(this.worker, $);
          } else {
            if (E2EE_FLAG in j && q) {
              const Y = {
                kind: "updateCodec",
                data: { trackId: V, codec: q, participantIdentity: B },
              };
              this.worker.postMessage(Y);
              return;
            }
            let $ = j.writableStream,
              H = j.readableStream;
            if (!$ || !H) {
              const Y = j.createEncodedStreams();
              (j.writableStream = Y.writable),
                ($ = Y.writable),
                (j.readableStream = Y.readable),
                (H = Y.readable);
            }
            const G = {
              kind: "decode",
              data: {
                readableStream: H,
                writableStream: $,
                trackId: V,
                codec: q,
                participantIdentity: B,
                isReuse: E2EE_FLAG in j,
              },
            };
            this.worker.postMessage(G, [H, $]);
          }
          j[E2EE_FLAG] = !0;
        }
      });
    }
    handleSender(j, V, B) {
      var q;
      if (!(E2EE_FLAG in j || !this.worker)) {
        if (
          !(
            !((q = this.room) === null || q === void 0) &&
            q.localParticipant.identity
          ) ||
          this.room.localParticipant.identity === ""
        )
          throw TypeError(
            "local identity needs to be known in order to set up encrypted sender"
          );
        if (isScriptTransformSupported()) {
          livekitLogger.info("initialize script transform");
          const $ = {
            kind: "encode",
            participantIdentity: this.room.localParticipant.identity,
            trackId: V,
            codec: B,
          };
          j.transform = new RTCRtpScriptTransform(this.worker, $);
        } else {
          livekitLogger.info("initialize encoded streams");
          const $ = j.createEncodedStreams(),
            H = {
              kind: "encode",
              data: {
                readableStream: $.readable,
                writableStream: $.writable,
                codec: B,
                trackId: V,
                participantIdentity: this.room.localParticipant.identity,
                isReuse: !1,
              },
            };
          this.worker.postMessage(H, [$.readable, $.writable]);
        }
        j[E2EE_FLAG] = !0;
      }
    }
  }
  const defaultId = "default";
  class DeviceManager {
    constructor() {
      this._previousDevices = [];
    }
    static getInstance() {
      return (
        this.instance === void 0 && (this.instance = new DeviceManager()),
        this.instance
      );
    }
    get previousDevices() {
      return this._previousDevices;
    }
    getDevices(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return (function* () {
          var $;
          if (
            (($ = DeviceManager.userMediaPromiseMap) === null || $ === void 0
              ? void 0
              : $.size) > 0
          ) {
            livekitLogger.debug("awaiting getUserMedia promise");
            try {
              V
                ? yield DeviceManager.userMediaPromiseMap.get(V)
                : yield Promise.all(DeviceManager.userMediaPromiseMap.values());
            } catch {
              livekitLogger.warn("error waiting for media permissons");
            }
          }
          let H = yield navigator.mediaDevices.enumerateDevices();
          if (
            q &&
            !(isSafari() && B.hasDeviceInUse(V)) &&
            (H.filter((Y) => Y.kind === V).length === 0 ||
              H.some((Y) => {
                const Q = Y.label === "",
                  X = V ? Y.kind === V : !0;
                return Q && X;
              }))
          ) {
            const Y = {
                video: V !== "audioinput" && V !== "audiooutput",
                audio: V !== "videoinput" && { deviceId: { ideal: "default" } },
              },
              Q = yield navigator.mediaDevices.getUserMedia(Y);
            (H = yield navigator.mediaDevices.enumerateDevices()),
              Q.getTracks().forEach((X) => {
                X.stop();
              });
          }
          return (
            (B._previousDevices = H),
            V && (H = H.filter((G) => G.kind === V)),
            H
          );
        })();
      });
    }
    normalizeDeviceId(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (V !== defaultId) return V;
        const q = yield this.getDevices(j),
          $ = q.find((G) => G.deviceId === defaultId);
        if (!$) {
          livekitLogger.warn("could not reliably determine default device");
          return;
        }
        const H = q.find(
          (G) => G.deviceId !== defaultId && G.groupId === (B ?? $.groupId)
        );
        if (!H) {
          livekitLogger.warn("could not reliably determine default device");
          return;
        }
        return H?.deviceId;
      });
    }
    hasDeviceInUse(j) {
      return j
        ? DeviceManager.userMediaPromiseMap.has(j)
        : DeviceManager.userMediaPromiseMap.size > 0;
    }
  }
  (DeviceManager.mediaDeviceKinds = [
    "audioinput",
    "audiooutput",
    "videoinput",
  ]),
    (DeviceManager.userMediaPromiseMap = new Map());
  var QueueTaskStatus;
  (function (U) {
    (U[(U.WAITING = 0)] = "WAITING"),
      (U[(U.RUNNING = 1)] = "RUNNING"),
      (U[(U.COMPLETED = 2)] = "COMPLETED");
  })(QueueTaskStatus || (QueueTaskStatus = {}));
  class AsyncQueue {
    constructor() {
      (this.pendingTasks = new Map()),
        (this.taskMutex = new _$1()),
        (this.nextTaskIndex = 0);
    }
    run(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = {
          id: this.nextTaskIndex++,
          enqueuedAt: Date.now(),
          status: QueueTaskStatus.WAITING,
        };
        this.pendingTasks.set(V.id, V);
        const B = yield this.taskMutex.lock();
        try {
          return (
            (V.executedAt = Date.now()),
            (V.status = QueueTaskStatus.RUNNING),
            yield j()
          );
        } finally {
          (V.status = QueueTaskStatus.COMPLETED),
            this.pendingTasks.delete(V.id),
            B();
        }
      });
    }
    flush() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.run(() =>
          __awaiter$1(this, void 0, void 0, function* () {})
        );
      });
    }
    snapshot() {
      return Array.from(this.pendingTasks.values());
    }
  }
  function createRtcUrl(U, j) {
    const V = new URL(toWebsocketUrl(U));
    return (
      j.forEach((B, q) => {
        V.searchParams.set(q, B);
      }),
      appendUrlPath(V, "rtc")
    );
  }
  function createValidateUrl(U) {
    const j = new URL(toHttpUrl(U));
    return appendUrlPath(j, "validate");
  }
  function ensureTrailingSlash(U) {
    return U.endsWith("/") ? U : "".concat(U, "/");
  }
  function appendUrlPath(U, j) {
    return (
      (U.pathname = "".concat(ensureTrailingSlash(U.pathname)).concat(j)),
      U.toString()
    );
  }
  const passThroughQueueSignals = [
    "syncState",
    "trickle",
    "offer",
    "answer",
    "simulate",
    "leave",
  ];
  function canPassThroughQueue(U) {
    const j = passThroughQueueSignals.indexOf(U.case) >= 0;
    return (
      livekitLogger.trace("request allowed to bypass queue:", {
        canPass: j,
        req: U,
      }),
      j
    );
  }
  var SignalConnectionState;
  (function (U) {
    (U[(U.CONNECTING = 0)] = "CONNECTING"),
      (U[(U.CONNECTED = 1)] = "CONNECTED"),
      (U[(U.RECONNECTING = 2)] = "RECONNECTING"),
      (U[(U.DISCONNECTING = 3)] = "DISCONNECTING"),
      (U[(U.DISCONNECTED = 4)] = "DISCONNECTED");
  })(SignalConnectionState || (SignalConnectionState = {}));
  class SignalClient {
    get currentState() {
      return this.state;
    }
    get isDisconnected() {
      return (
        this.state === SignalConnectionState.DISCONNECTING ||
        this.state === SignalConnectionState.DISCONNECTED
      );
    }
    get isEstablishingConnection() {
      return (
        this.state === SignalConnectionState.CONNECTING ||
        this.state === SignalConnectionState.RECONNECTING
      );
    }
    getNextRequestId() {
      return (this._requestId += 1), this._requestId;
    }
    constructor() {
      let j =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1,
        V = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var B;
      (this.rtt = 0),
        (this.state = SignalConnectionState.DISCONNECTED),
        (this.log = livekitLogger),
        (this._requestId = 0),
        (this.resetCallbacks = () => {
          (this.onAnswer = void 0),
            (this.onLeave = void 0),
            (this.onLocalTrackPublished = void 0),
            (this.onLocalTrackUnpublished = void 0),
            (this.onNegotiateRequested = void 0),
            (this.onOffer = void 0),
            (this.onRemoteMuteChanged = void 0),
            (this.onSubscribedQualityUpdate = void 0),
            (this.onTokenRefresh = void 0),
            (this.onTrickle = void 0),
            (this.onClose = void 0);
        }),
        (this.log = getLogger(
          (B = V.loggerName) !== null && B !== void 0 ? B : LoggerNames.Signal
        )),
        (this.loggerContextCb = V.loggerContextCb),
        (this.useJSON = j),
        (this.requestQueue = new AsyncQueue()),
        (this.queuedRequests = []),
        (this.closingLock = new _$1()),
        (this.connectionLock = new _$1()),
        (this.state = SignalConnectionState.DISCONNECTED);
    }
    get logContext() {
      var j, V;
      return (V =
        (j = this.loggerContextCb) === null || j === void 0
          ? void 0
          : j.call(this)) !== null && V !== void 0
        ? V
        : {};
    }
    join(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return (
          (this.state = SignalConnectionState.CONNECTING),
          (this.options = B),
          yield this.connect(j, V, B, q)
        );
      });
    }
    reconnect(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.options) {
          this.log.warn(
            "attempted to reconnect without signal options being set, ignoring",
            this.logContext
          );
          return;
        }
        return (
          (this.state = SignalConnectionState.RECONNECTING),
          this.clearPingInterval(),
          yield this.connect(
            j,
            V,
            Object.assign(Object.assign({}, this.options), {
              reconnect: !0,
              sid: B,
              reconnectReason: q,
            })
          )
        );
      });
    }
    connect(j, V, B, q) {
      this.connectOptions = B;
      const $ = getClientInfo(),
        H = createConnectionParams(V, $, B),
        G = createRtcUrl(j, H),
        Y = createValidateUrl(G);
      return new Promise((Q, X) =>
        __awaiter$1(this, void 0, void 0, function* () {
          const Z = yield this.connectionLock.lock();
          try {
            const te = () =>
                __awaiter$1(this, void 0, void 0, function* () {
                  this.close(),
                    clearTimeout(ne),
                    X(
                      new ConnectionError(
                        "room connection has been cancelled (signal)",
                        ConnectionErrorReason.Cancelled
                      )
                    );
                }),
              ne = setTimeout(() => {
                this.close(),
                  X(
                    new ConnectionError(
                      "room connection has timed out (signal)",
                      ConnectionErrorReason.ServerUnreachable
                    )
                  );
              }, B.websocketTimeout);
            q?.aborted && te(), q?.addEventListener("abort", te);
            const ae = new URL(G);
            ae.searchParams.has("access_token") &&
              ae.searchParams.set("access_token", "<redacted>"),
              this.log.debug(
                "connecting to ".concat(ae),
                Object.assign(
                  {
                    reconnect: B.reconnect,
                    reconnectReason: B.reconnectReason,
                  },
                  this.logContext
                )
              ),
              this.ws && (yield this.close(!1)),
              (this.ws = new WebSocket(G)),
              (this.ws.binaryType = "arraybuffer"),
              (this.ws.onopen = () => {
                clearTimeout(ne);
              }),
              (this.ws.onerror = (se) =>
                __awaiter$1(this, void 0, void 0, function* () {
                  if (this.state !== SignalConnectionState.CONNECTED) {
                    (this.state = SignalConnectionState.DISCONNECTED),
                      clearTimeout(ne);
                    try {
                      const fe = yield fetch(Y);
                      if (fe.status.toFixed(0).startsWith("4")) {
                        const ce = yield fe.text();
                        X(
                          new ConnectionError(
                            ce,
                            ConnectionErrorReason.NotAllowed,
                            fe.status
                          )
                        );
                      } else
                        X(
                          new ConnectionError(
                            "Encountered unknown websocket error during connection: ".concat(
                              se.toString()
                            ),
                            ConnectionErrorReason.InternalError,
                            fe.status
                          )
                        );
                    } catch (fe) {
                      X(
                        new ConnectionError(
                          fe instanceof Error
                            ? fe.message
                            : "server was not reachable",
                          ConnectionErrorReason.ServerUnreachable
                        )
                      );
                    }
                    return;
                  }
                  this.handleWSError(se);
                })),
              (this.ws.onmessage = (se) =>
                __awaiter$1(this, void 0, void 0, function* () {
                  var fe, ce, ue;
                  let he;
                  if (typeof se.data == "string") {
                    const me = JSON.parse(se.data);
                    he = SignalResponse.fromJson(me, {
                      ignoreUnknownFields: !0,
                    });
                  } else if (se.data instanceof ArrayBuffer)
                    he = SignalResponse.fromBinary(new Uint8Array(se.data));
                  else {
                    this.log.error(
                      "could not decode websocket message: ".concat(
                        typeof se.data
                      ),
                      this.logContext
                    );
                    return;
                  }
                  if (this.state !== SignalConnectionState.CONNECTED) {
                    let me = !1;
                    if (
                      (((fe = he.message) === null || fe === void 0
                        ? void 0
                        : fe.case) === "join"
                        ? ((this.state = SignalConnectionState.CONNECTED),
                          q?.removeEventListener("abort", te),
                          (this.pingTimeoutDuration =
                            he.message.value.pingTimeout),
                          (this.pingIntervalDuration =
                            he.message.value.pingInterval),
                          this.pingTimeoutDuration &&
                            this.pingTimeoutDuration > 0 &&
                            (this.log.debug(
                              "ping config",
                              Object.assign(
                                Object.assign({}, this.logContext),
                                {
                                  timeout: this.pingTimeoutDuration,
                                  interval: this.pingIntervalDuration,
                                }
                              )
                            ),
                            this.startPingInterval()),
                          Q(he.message.value))
                        : this.state === SignalConnectionState.RECONNECTING &&
                          he.message.case !== "leave"
                        ? ((this.state = SignalConnectionState.CONNECTED),
                          q?.removeEventListener("abort", te),
                          this.startPingInterval(),
                          ((ce = he.message) === null || ce === void 0
                            ? void 0
                            : ce.case) === "reconnect"
                            ? Q(he.message.value)
                            : (this.log.debug(
                                "declaring signal reconnected without reconnect response received",
                                this.logContext
                              ),
                              Q(void 0),
                              (me = !0)))
                        : this.isEstablishingConnection &&
                          he.message.case === "leave"
                        ? X(
                            new ConnectionError(
                              "Received leave request while trying to (re)connect",
                              ConnectionErrorReason.LeaveRequest,
                              void 0,
                              he.message.value.reason
                            )
                          )
                        : B.reconnect ||
                          X(
                            new ConnectionError(
                              "did not receive join response, got ".concat(
                                (ue = he.message) === null || ue === void 0
                                  ? void 0
                                  : ue.case,
                                " instead"
                              ),
                              ConnectionErrorReason.InternalError
                            )
                          ),
                      !me)
                    )
                      return;
                  }
                  this.signalLatency && (yield sleep$1(this.signalLatency)),
                    this.handleSignalResponse(he);
                })),
              (this.ws.onclose = (se) => {
                this.isEstablishingConnection &&
                  X(
                    new ConnectionError(
                      "Websocket got closed during a (re)connection attempt",
                      ConnectionErrorReason.InternalError
                    )
                  ),
                  this.log.warn(
                    "websocket closed",
                    Object.assign(Object.assign({}, this.logContext), {
                      reason: se.reason,
                      code: se.code,
                      wasClean: se.wasClean,
                      state: this.state,
                    })
                  ),
                  this.handleOnClose(se.reason);
              });
          } finally {
            Z();
          }
        })
      );
    }
    close() {
      return __awaiter$1(this, arguments, void 0, function () {
        var j = this;
        let V =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
        return (function* () {
          const B = yield j.closingLock.lock();
          try {
            if (
              (j.clearPingInterval(),
              V && (j.state = SignalConnectionState.DISCONNECTING),
              j.ws)
            ) {
              (j.ws.onmessage = null),
                (j.ws.onopen = null),
                (j.ws.onclose = null);
              const q = new Promise(($) => {
                j.ws
                  ? (j.ws.onclose = () => {
                      $();
                    })
                  : $();
              });
              j.ws.readyState < j.ws.CLOSING &&
                (j.ws.close(), yield Promise.race([q, sleep$1(250)])),
                (j.ws = void 0);
            }
          } finally {
            V && (j.state = SignalConnectionState.DISCONNECTED), B();
          }
        })();
      });
    }
    sendOffer(j, V) {
      this.log.debug(
        "sending offer",
        Object.assign(Object.assign({}, this.logContext), { offerSdp: j.sdp })
      ),
        this.sendRequest({
          case: "offer",
          value: toProtoSessionDescription(j, V),
        });
    }
    sendAnswer(j, V) {
      return (
        this.log.debug(
          "sending answer",
          Object.assign(Object.assign({}, this.logContext), {
            answerSdp: j.sdp,
          })
        ),
        this.sendRequest({
          case: "answer",
          value: toProtoSessionDescription(j, V),
        })
      );
    }
    sendIceCandidate(j, V) {
      return (
        this.log.debug(
          "sending ice candidate",
          Object.assign(Object.assign({}, this.logContext), { candidate: j })
        ),
        this.sendRequest({
          case: "trickle",
          value: new TrickleRequest({
            candidateInit: JSON.stringify(j),
            target: V,
          }),
        })
      );
    }
    sendMuteTrack(j, V) {
      return this.sendRequest({
        case: "mute",
        value: new MuteTrackRequest({ sid: j, muted: V }),
      });
    }
    sendAddTrack(j) {
      return this.sendRequest({ case: "addTrack", value: j });
    }
    sendUpdateLocalMetadata(j, V) {
      return __awaiter$1(this, arguments, void 0, function (B, q) {
        var $ = this;
        let H =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        return (function* () {
          const G = $.getNextRequestId();
          return (
            yield $.sendRequest({
              case: "updateMetadata",
              value: new UpdateParticipantMetadata({
                requestId: G,
                metadata: B,
                name: q,
                attributes: H,
              }),
            }),
            G
          );
        })();
      });
    }
    sendUpdateTrackSettings(j) {
      this.sendRequest({ case: "trackSetting", value: j });
    }
    sendUpdateSubscription(j) {
      return this.sendRequest({ case: "subscription", value: j });
    }
    sendSyncState(j) {
      return this.sendRequest({ case: "syncState", value: j });
    }
    sendUpdateVideoLayers(j, V) {
      return this.sendRequest({
        case: "updateLayers",
        value: new UpdateVideoLayers({ trackSid: j, layers: V }),
      });
    }
    sendUpdateSubscriptionPermissions(j, V) {
      return this.sendRequest({
        case: "subscriptionPermission",
        value: new SubscriptionPermission({
          allParticipants: j,
          trackPermissions: V,
        }),
      });
    }
    sendSimulateScenario(j) {
      return this.sendRequest({ case: "simulate", value: j });
    }
    sendPing() {
      return Promise.all([
        this.sendRequest({ case: "ping", value: protoInt64.parse(Date.now()) }),
        this.sendRequest({
          case: "pingReq",
          value: new Ping({
            timestamp: protoInt64.parse(Date.now()),
            rtt: protoInt64.parse(this.rtt),
          }),
        }),
      ]);
    }
    sendUpdateLocalAudioTrack(j, V) {
      return this.sendRequest({
        case: "updateAudioTrack",
        value: new UpdateLocalAudioTrack({ trackSid: j, features: V }),
      });
    }
    sendLeave() {
      return this.sendRequest({
        case: "leave",
        value: new LeaveRequest({
          reason: DisconnectReason.CLIENT_INITIATED,
          action: LeaveRequest_Action.DISCONNECT,
        }),
      });
    }
    sendRequest(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        return (function* () {
          if (
            !q &&
            !canPassThroughQueue(V) &&
            B.state === SignalConnectionState.RECONNECTING
          ) {
            B.queuedRequests.push(() =>
              __awaiter$1(B, void 0, void 0, function* () {
                yield this.sendRequest(V, !0);
              })
            );
            return;
          }
          if (
            (q || (yield B.requestQueue.flush()),
            B.signalLatency && (yield sleep$1(B.signalLatency)),
            !B.ws || B.ws.readyState !== B.ws.OPEN)
          ) {
            B.log.error(
              "cannot send signal request before connected, type: ".concat(
                V?.case
              ),
              B.logContext
            );
            return;
          }
          const H = new SignalRequest({ message: V });
          try {
            B.useJSON ? B.ws.send(H.toJsonString()) : B.ws.send(H.toBinary());
          } catch (G) {
            B.log.error(
              "error sending signal message",
              Object.assign(Object.assign({}, B.logContext), { error: G })
            );
          }
        })();
      });
    }
    handleSignalResponse(j) {
      var V, B;
      const q = j.message;
      if (q == null) {
        this.log.debug("received unsupported message", this.logContext);
        return;
      }
      let $ = !1;
      if (q.case === "answer") {
        const H = fromProtoSessionDescription(q.value);
        this.onAnswer && this.onAnswer(H, q.value.id);
      } else if (q.case === "offer") {
        const H = fromProtoSessionDescription(q.value);
        this.onOffer && this.onOffer(H, q.value.id);
      } else if (q.case === "trickle") {
        const H = JSON.parse(q.value.candidateInit);
        this.onTrickle && this.onTrickle(H, q.value.target);
      } else
        q.case === "update"
          ? this.onParticipantUpdate &&
            this.onParticipantUpdate(
              (V = q.value.participants) !== null && V !== void 0 ? V : []
            )
          : q.case === "trackPublished"
          ? this.onLocalTrackPublished && this.onLocalTrackPublished(q.value)
          : q.case === "speakersChanged"
          ? this.onSpeakersChanged &&
            this.onSpeakersChanged(
              (B = q.value.speakers) !== null && B !== void 0 ? B : []
            )
          : q.case === "leave"
          ? this.onLeave && this.onLeave(q.value)
          : q.case === "mute"
          ? this.onRemoteMuteChanged &&
            this.onRemoteMuteChanged(q.value.sid, q.value.muted)
          : q.case === "roomUpdate"
          ? this.onRoomUpdate && q.value.room && this.onRoomUpdate(q.value.room)
          : q.case === "connectionQuality"
          ? this.onConnectionQuality && this.onConnectionQuality(q.value)
          : q.case === "streamStateUpdate"
          ? this.onStreamStateUpdate && this.onStreamStateUpdate(q.value)
          : q.case === "subscribedQualityUpdate"
          ? this.onSubscribedQualityUpdate &&
            this.onSubscribedQualityUpdate(q.value)
          : q.case === "subscriptionPermissionUpdate"
          ? this.onSubscriptionPermissionUpdate &&
            this.onSubscriptionPermissionUpdate(q.value)
          : q.case === "refreshToken"
          ? this.onTokenRefresh && this.onTokenRefresh(q.value)
          : q.case === "trackUnpublished"
          ? this.onLocalTrackUnpublished &&
            this.onLocalTrackUnpublished(q.value)
          : q.case === "subscriptionResponse"
          ? this.onSubscriptionError && this.onSubscriptionError(q.value)
          : q.case === "pong" ||
            (q.case === "pongResp"
              ? ((this.rtt =
                  Date.now() -
                  Number.parseInt(q.value.lastPingTimestamp.toString())),
                this.resetPingTimeout(),
                ($ = !0))
              : q.case === "requestResponse"
              ? this.onRequestResponse && this.onRequestResponse(q.value)
              : q.case === "trackSubscribed"
              ? this.onLocalTrackSubscribed &&
                this.onLocalTrackSubscribed(q.value.trackSid)
              : q.case === "roomMoved"
              ? (this.onTokenRefresh && this.onTokenRefresh(q.value.token),
                this.onRoomMoved && this.onRoomMoved(q.value))
              : this.log.debug(
                  "unsupported message",
                  Object.assign(Object.assign({}, this.logContext), {
                    msgCase: q.case,
                  })
                ));
      $ || this.resetPingTimeout();
    }
    setReconnected() {
      for (; this.queuedRequests.length > 0; ) {
        const j = this.queuedRequests.shift();
        j && this.requestQueue.run(j);
      }
    }
    handleOnClose(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.state === SignalConnectionState.DISCONNECTED) return;
        const V = this.onClose;
        yield this.close(),
          this.log.debug(
            "websocket connection closed: ".concat(j),
            Object.assign(Object.assign({}, this.logContext), { reason: j })
          ),
          V && V(j);
      });
    }
    handleWSError(j) {
      this.log.error(
        "websocket error",
        Object.assign(Object.assign({}, this.logContext), { error: j })
      );
    }
    resetPingTimeout() {
      if ((this.clearPingTimeout(), !this.pingTimeoutDuration)) {
        this.log.warn("ping timeout duration not set", this.logContext);
        return;
      }
      this.pingTimeout = CriticalTimers.setTimeout(() => {
        this.log.warn(
          "ping timeout triggered. last pong received at: ".concat(
            new Date(Date.now() - this.pingTimeoutDuration * 1e3).toUTCString()
          ),
          this.logContext
        ),
          this.handleOnClose("ping timeout");
      }, this.pingTimeoutDuration * 1e3);
    }
    clearPingTimeout() {
      this.pingTimeout && CriticalTimers.clearTimeout(this.pingTimeout);
    }
    startPingInterval() {
      if (
        (this.clearPingInterval(),
        this.resetPingTimeout(),
        !this.pingIntervalDuration)
      ) {
        this.log.warn("ping interval duration not set", this.logContext);
        return;
      }
      this.log.debug("start ping interval", this.logContext),
        (this.pingInterval = CriticalTimers.setInterval(() => {
          this.sendPing();
        }, this.pingIntervalDuration * 1e3));
    }
    clearPingInterval() {
      this.log.debug("clearing ping interval", this.logContext),
        this.clearPingTimeout(),
        this.pingInterval && CriticalTimers.clearInterval(this.pingInterval);
    }
  }
  function fromProtoSessionDescription(U) {
    const j = { type: "offer", sdp: U.sdp };
    switch (U.type) {
      case "answer":
      case "offer":
      case "pranswer":
      case "rollback":
        j.type = U.type;
        break;
    }
    return j;
  }
  function toProtoSessionDescription(U, j) {
    return new SessionDescription({ sdp: U.sdp, type: U.type, id: j });
  }
  function createConnectionParams(U, j, V) {
    var B;
    const q = new URLSearchParams();
    return (
      q.set("access_token", U),
      V.reconnect && (q.set("reconnect", "1"), V.sid && q.set("sid", V.sid)),
      q.set("auto_subscribe", V.autoSubscribe ? "1" : "0"),
      q.set("sdk", isReactNative() ? "reactnative" : "js"),
      q.set("version", j.version),
      q.set("protocol", j.protocol.toString()),
      j.deviceModel && q.set("device_model", j.deviceModel),
      j.os && q.set("os", j.os),
      j.osVersion && q.set("os_version", j.osVersion),
      j.browser && q.set("browser", j.browser),
      j.browserVersion && q.set("browser_version", j.browserVersion),
      V.adaptiveStream && q.set("adaptive_stream", "1"),
      V.reconnectReason &&
        q.set("reconnect_reason", V.reconnectReason.toString()),
      !((B = navigator.connection) === null || B === void 0) &&
        B.type &&
        q.set("network", navigator.connection.type),
      q
    );
  }
  class DataPacketBuffer {
    constructor() {
      (this.buffer = []), (this._totalSize = 0);
    }
    push(j) {
      this.buffer.push(j), (this._totalSize += j.data.byteLength);
    }
    pop() {
      const j = this.buffer.shift();
      return j && (this._totalSize -= j.data.byteLength), j;
    }
    getAll() {
      return this.buffer.slice();
    }
    popToSequence(j) {
      for (; this.buffer.length > 0 && this.buffer[0].sequence <= j; )
        this.pop();
    }
    alignBufferedAmount(j) {
      for (; this.buffer.length > 0; ) {
        const V = this.buffer[0];
        if (this._totalSize - V.data.byteLength <= j) break;
        this.pop();
      }
    }
    get length() {
      return this.buffer.length;
    }
  }
  class TTLMap {
    constructor(j) {
      (this._map = new Map()), (this._lastCleanup = 0), (this.ttl = j);
    }
    set(j, V) {
      const B = Date.now();
      B - this._lastCleanup > this.ttl / 2 && this.cleanup();
      const q = B + this.ttl;
      return this._map.set(j, { value: V, expiresAt: q }), this;
    }
    get(j) {
      const V = this._map.get(j);
      if (V) {
        if (V.expiresAt < Date.now()) {
          this._map.delete(j);
          return;
        }
        return V.value;
      }
    }
    has(j) {
      const V = this._map.get(j);
      return V
        ? V.expiresAt < Date.now()
          ? (this._map.delete(j), !1)
          : !0
        : !1;
    }
    delete(j) {
      return this._map.delete(j);
    }
    clear() {
      this._map.clear();
    }
    cleanup() {
      const j = Date.now();
      for (const [V, B] of this._map.entries())
        B.expiresAt < j && this._map.delete(V);
      this._lastCleanup = j;
    }
    get size() {
      return this.cleanup(), this._map.size;
    }
    forEach(j) {
      this.cleanup();
      for (const [V, B] of this._map.entries())
        B.expiresAt >= Date.now() && j(B.value, V, this.asValueMap());
    }
    map(j) {
      this.cleanup();
      const V = [],
        B = this.asValueMap();
      for (const [q, $] of B.entries()) V.push(j($, q, B));
      return V;
    }
    asValueMap() {
      const j = new Map();
      for (const [V, B] of this._map.entries())
        B.expiresAt >= Date.now() && j.set(V, B.value);
      return j;
    }
  }
  var lib = {},
    parser = {},
    grammar = { exports: {} },
    hasRequiredGrammar;
  function requireGrammar() {
    if (hasRequiredGrammar) return grammar.exports;
    hasRequiredGrammar = 1;
    var U = (grammar.exports = {
      v: [{ name: "version", reg: /^(\d*)$/ }],
      o: [
        {
          name: "origin",
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: [
            "username",
            "sessionId",
            "sessionVersion",
            "netType",
            "ipVer",
            "address",
          ],
          format: "%s %s %d %s IP%d %s",
        },
      ],
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      r: [{ name: "repeats" }],
      t: [
        {
          name: "timing",
          reg: /^(\d*) (\d*)/,
          names: ["start", "stop"],
          format: "%d %d",
        },
      ],
      c: [
        {
          name: "connection",
          reg: /^IN IP(\d) (\S*)/,
          names: ["version", "ip"],
          format: "IN IP%d %s",
        },
      ],
      b: [
        {
          push: "bandwidth",
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ["type", "limit"],
          format: "%s:%s",
        },
      ],
      m: [
        {
          reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
          names: ["type", "port", "protocol", "payloads"],
          format: "%s %d %s %s",
        },
      ],
      a: [
        {
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function (j) {
            return j.encoding
              ? "rtpmap:%d %s/%s/%s"
              : j.rate
              ? "rtpmap:%d %s/%s"
              : "rtpmap:%d %s";
          },
        },
        {
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s",
        },
        { name: "control", reg: /^control:(.*)/, format: "control:%s" },
        {
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function (j) {
            return j.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          },
        },
        {
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d",
        },
        {
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function (j) {
            return j.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          },
        },
        {
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function (j) {
            return (
              "extmap:%d" +
              (j.direction ? "/%s" : "%v") +
              (j["encrypt-uri"] ? " %s" : "%v") +
              " %s" +
              (j.config ? " %s" : "")
            );
          },
        },
        { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ },
        {
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function (j) {
            return j.sessionConfig != null
              ? "crypto:%d %s %s %s"
              : "crypto:%d %s %s";
          },
        },
        { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" },
        {
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s",
        },
        { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" },
        { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" },
        { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" },
        {
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d",
        },
        { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ },
        { name: "icelite", reg: /^(ice-lite)/ },
        { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" },
        { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" },
        {
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s",
        },
        {
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: [
            "foundation",
            "component",
            "transport",
            "priority",
            "ip",
            "port",
            "type",
            "raddr",
            "rport",
            "tcptype",
            "generation",
            "network-id",
            "network-cost",
          ],
          format: function (j) {
            var V = "candidate:%s %d %s %d %s %d typ %s";
            return (
              (V += j.raddr != null ? " raddr %s rport %d" : "%v%v"),
              (V += j.tcptype != null ? " tcptype %s" : "%v"),
              j.generation != null && (V += " generation %d"),
              (V += j["network-id"] != null ? " network-id %d" : "%v"),
              (V += j["network-cost"] != null ? " network-cost %d" : "%v"),
              V
            );
          },
        },
        { name: "endOfCandidates", reg: /^(end-of-candidates)/ },
        {
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s",
        },
        {
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s",
        },
        {
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function (j) {
            var V = "ssrc:%d";
            return (
              j.attribute != null &&
                ((V += " %s"), j.value != null && (V += ":%s")),
              V
            );
          },
        },
        {
          push: "ssrcGroups",
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s",
        },
        {
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s",
        },
        {
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s",
        },
        { name: "rtcpMux", reg: /^(rtcp-mux)/ },
        { name: "rtcpRsize", reg: /^(rtcp-rsize)/ },
        {
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function (j) {
            return j.maxMessageSize != null
              ? "sctpmap:%s %s %s"
              : "sctpmap:%s %s";
          },
        },
        {
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s",
        },
        {
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function (j) {
            return j.params ? "rid:%s %s %s" : "rid:%s %s";
          },
        },
        {
          push: "imageattrs",
          reg: new RegExp(
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function (j) {
            return "imageattr:%s %s %s" + (j.dir2 ? " %s %s" : "");
          },
        },
        {
          name: "simulcast",
          reg: new RegExp(
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function (j) {
            return "simulcast:%s %s" + (j.dir2 ? " %s %s" : "");
          },
        },
        {
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s",
        },
        {
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s",
        },
        {
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: [
            "filterMode",
            "netType",
            "addressTypes",
            "destAddress",
            "srcList",
          ],
          format: "source-filter: %s %s %s %s %s",
        },
        { name: "bundleOnly", reg: /^(bundle-only)/ },
        { name: "label", reg: /^label:(.+)/, format: "label:%s" },
        { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" },
        {
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s",
        },
        {
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function (j) {
            return "ts-refclk:%s" + (j.clksrcExt != null ? "=%s" : "");
          },
        },
        {
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: [
            "id",
            "mediaClockName",
            "mediaClockValue",
            "rateNumerator",
            "rateDenominator",
          ],
          format: function (j) {
            var V = "mediaclk:";
            return (
              (V += j.id != null ? "id=%s %s" : "%v%s"),
              (V += j.mediaClockValue != null ? "=%s" : ""),
              (V += j.rateNumerator != null ? " rate=%s" : ""),
              (V += j.rateDenominator != null ? "/%s" : ""),
              V
            );
          },
        },
        { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" },
        { name: "content", reg: /^content:(.+)/, format: "content:%s" },
        {
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s",
        },
        { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" },
        { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" },
        {
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s",
        },
        { push: "invalid", names: ["value"] },
      ],
    });
    return (
      Object.keys(U).forEach(function (j) {
        var V = U[j];
        V.forEach(function (B) {
          B.reg || (B.reg = /(.*)/), B.format || (B.format = "%s");
        });
      }),
      grammar.exports
    );
  }
  var hasRequiredParser;
  function requireParser() {
    return (
      hasRequiredParser ||
        ((hasRequiredParser = 1),
        (function (U) {
          var j = function (G) {
              return String(Number(G)) === G ? Number(G) : G;
            },
            V = function (G, Y, Q, X) {
              if (X && !Q) Y[X] = j(G[1]);
              else
                for (var Z = 0; Z < Q.length; Z += 1)
                  G[Z + 1] != null && (Y[Q[Z]] = j(G[Z + 1]));
            },
            B = function (G, Y, Q) {
              var X = G.name && G.names;
              G.push && !Y[G.push]
                ? (Y[G.push] = [])
                : X && !Y[G.name] && (Y[G.name] = {});
              var Z = G.push ? {} : X ? Y[G.name] : Y;
              V(Q.match(G.reg), Z, G.names, G.name),
                G.push && Y[G.push].push(Z);
            },
            q = requireGrammar(),
            $ = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
          U.parse = function (G) {
            var Y = {},
              Q = [],
              X = Y;
            return (
              G.split(/(\r\n|\r|\n)/)
                .filter($)
                .forEach(function (Z) {
                  var te = Z[0],
                    ne = Z.slice(2);
                  te === "m" &&
                    (Q.push({ rtp: [], fmtp: [] }), (X = Q[Q.length - 1]));
                  for (var ae = 0; ae < (q[te] || []).length; ae += 1) {
                    var se = q[te][ae];
                    if (se.reg.test(ne)) return B(se, X, ne);
                  }
                }),
              (Y.media = Q),
              Y
            );
          };
          var H = function (G, Y) {
            var Q = Y.split(/=(.+)/, 2);
            return (
              Q.length === 2
                ? (G[Q[0]] = j(Q[1]))
                : Q.length === 1 && Y.length > 1 && (G[Q[0]] = void 0),
              G
            );
          };
          (U.parseParams = function (G) {
            return G.split(/;\s?/).reduce(H, {});
          }),
            (U.parseFmtpConfig = U.parseParams),
            (U.parsePayloads = function (G) {
              return G.toString().split(" ").map(Number);
            }),
            (U.parseRemoteCandidates = function (G) {
              for (
                var Y = [], Q = G.split(" ").map(j), X = 0;
                X < Q.length;
                X += 3
              )
                Y.push({ component: Q[X], ip: Q[X + 1], port: Q[X + 2] });
              return Y;
            }),
            (U.parseImageAttributes = function (G) {
              return G.split(" ").map(function (Y) {
                return Y.substring(1, Y.length - 1)
                  .split(",")
                  .reduce(H, {});
              });
            }),
            (U.parseSimulcastStreamList = function (G) {
              return G.split(";").map(function (Y) {
                return Y.split(",").map(function (Q) {
                  var X,
                    Z = !1;
                  return (
                    Q[0] !== "~"
                      ? (X = j(Q))
                      : ((X = j(Q.substring(1, Q.length))), (Z = !0)),
                    { scid: X, paused: Z }
                  );
                });
              });
            });
        })(parser)),
      parser
    );
  }
  var writer$1, hasRequiredWriter$1;
  function requireWriter$1() {
    if (hasRequiredWriter$1) return writer$1;
    hasRequiredWriter$1 = 1;
    var U = requireGrammar(),
      j = /%[sdv%]/g,
      V = function (H) {
        var G = 1,
          Y = arguments,
          Q = Y.length;
        return H.replace(j, function (X) {
          if (G >= Q) return X;
          var Z = Y[G];
          switch (((G += 1), X)) {
            case "%%":
              return "%";
            case "%s":
              return String(Z);
            case "%d":
              return Number(Z);
            case "%v":
              return "";
          }
        });
      },
      B = function (H, G, Y) {
        var Q =
            G.format instanceof Function
              ? G.format(G.push ? Y : Y[G.name])
              : G.format,
          X = [H + "=" + Q];
        if (G.names)
          for (var Z = 0; Z < G.names.length; Z += 1) {
            var te = G.names[Z];
            G.name ? X.push(Y[G.name][te]) : X.push(Y[G.names[Z]]);
          }
        else X.push(Y[G.name]);
        return V.apply(null, X);
      },
      q = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"],
      $ = ["i", "c", "b", "a"];
    return (
      (writer$1 = function (H, G) {
        (G = G || {}),
          H.version == null && (H.version = 0),
          H.name == null && (H.name = " "),
          H.media.forEach(function (Z) {
            Z.payloads == null && (Z.payloads = "");
          });
        var Y = G.outerOrder || q,
          Q = G.innerOrder || $,
          X = [];
        return (
          Y.forEach(function (Z) {
            U[Z].forEach(function (te) {
              te.name in H && H[te.name] != null
                ? X.push(B(Z, te, H))
                : te.push in H &&
                  H[te.push] != null &&
                  H[te.push].forEach(function (ne) {
                    X.push(B(Z, te, ne));
                  });
            });
          }),
          H.media.forEach(function (Z) {
            X.push(B("m", U.m[0], Z)),
              Q.forEach(function (te) {
                U[te].forEach(function (ne) {
                  ne.name in Z && Z[ne.name] != null
                    ? X.push(B(te, ne, Z))
                    : ne.push in Z &&
                      Z[ne.push] != null &&
                      Z[ne.push].forEach(function (ae) {
                        X.push(B(te, ne, ae));
                      });
                });
              });
          }),
          X.join(`\r
`) +
            `\r
`
        );
      }),
      writer$1
    );
  }
  var hasRequiredLib;
  function requireLib() {
    if (hasRequiredLib) return lib;
    hasRequiredLib = 1;
    var U = requireParser(),
      j = requireWriter$1(),
      V = requireGrammar();
    return (
      (lib.grammar = V),
      (lib.write = j),
      (lib.parse = U.parse),
      (lib.parseParams = U.parseParams),
      (lib.parseFmtpConfig = U.parseFmtpConfig),
      (lib.parsePayloads = U.parsePayloads),
      (lib.parseRemoteCandidates = U.parseRemoteCandidates),
      (lib.parseImageAttributes = U.parseImageAttributes),
      (lib.parseSimulcastStreamList = U.parseSimulcastStreamList),
      lib
    );
  }
  var libExports = requireLib();
  function r$1(U, j, V) {
    var B, q, $;
    j === void 0 && (j = 50), V === void 0 && (V = {});
    var H = (B = V.isImmediate) != null && B,
      G = (q = V.callback) != null && q,
      Y = V.maxWait,
      Q = Date.now(),
      X = [];
    function Z() {
      if (Y !== void 0) {
        var ne = Date.now() - Q;
        if (ne + j >= Y) return Y - ne;
      }
      return j;
    }
    var te = function () {
      var ne = [].slice.call(arguments),
        ae = this;
      return new Promise(function (se, fe) {
        var ce = H && $ === void 0;
        if (
          ($ !== void 0 && clearTimeout($),
          ($ = setTimeout(function () {
            if ((($ = void 0), (Q = Date.now()), !H)) {
              var he = U.apply(ae, ne);
              G && G(he),
                X.forEach(function (me) {
                  return (0, me.resolve)(he);
                }),
                (X = []);
            }
          }, Z())),
          ce)
        ) {
          var ue = U.apply(ae, ne);
          return G && G(ue), se(ue);
        }
        X.push({ resolve: se, reject: fe });
      });
    };
    return (
      (te.cancel = function (ne) {
        $ !== void 0 && clearTimeout($),
          X.forEach(function (ae) {
            return (0, ae.reject)(ne);
          }),
          (X = []);
      }),
      te
    );
  }
  const startBitrateForSVC = 0.7,
    debounceInterval = 20,
    PCEvents = {
      NegotiationStarted: "negotiationStarted",
      NegotiationComplete: "negotiationComplete",
      RTPVideoPayloadTypes: "rtpVideoPayloadTypes",
    };
  class PCTransport extends eventsExports.EventEmitter {
    get pc() {
      return this._pc || (this._pc = this.createPC()), this._pc;
    }
    constructor(j) {
      let V =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var B;
      super(),
        (this.log = livekitLogger),
        (this.ddExtID = 0),
        (this.latestOfferId = 0),
        (this.pendingCandidates = []),
        (this.restartingIce = !1),
        (this.renegotiate = !1),
        (this.trackBitrates = []),
        (this.remoteStereoMids = []),
        (this.remoteNackMids = []),
        (this.negotiate = r$1(
          (q) =>
            __awaiter$1(this, void 0, void 0, function* () {
              this.emit(PCEvents.NegotiationStarted);
              try {
                yield this.createAndSendOffer();
              } catch ($) {
                if (q) q($);
                else throw $;
              }
            }),
          debounceInterval
        )),
        (this.close = () => {
          this._pc &&
            (this._pc.close(),
            (this._pc.onconnectionstatechange = null),
            (this._pc.oniceconnectionstatechange = null),
            (this._pc.onicegatheringstatechange = null),
            (this._pc.ondatachannel = null),
            (this._pc.onnegotiationneeded = null),
            (this._pc.onsignalingstatechange = null),
            (this._pc.onicecandidate = null),
            (this._pc.ondatachannel = null),
            (this._pc.ontrack = null),
            (this._pc.onconnectionstatechange = null),
            (this._pc.oniceconnectionstatechange = null),
            (this._pc = null));
        }),
        (this.log = getLogger(
          (B = V.loggerName) !== null && B !== void 0
            ? B
            : LoggerNames.PCTransport
        )),
        (this.loggerOptions = V),
        (this.config = j),
        (this._pc = this.createPC()),
        (this.offerLock = new _$1());
    }
    createPC() {
      const j = new RTCPeerConnection(this.config);
      return (
        (j.onicecandidate = (V) => {
          var B;
          V.candidate &&
            ((B = this.onIceCandidate) === null ||
              B === void 0 ||
              B.call(this, V.candidate));
        }),
        (j.onicecandidateerror = (V) => {
          var B;
          (B = this.onIceCandidateError) === null ||
            B === void 0 ||
            B.call(this, V);
        }),
        (j.oniceconnectionstatechange = () => {
          var V;
          (V = this.onIceConnectionStateChange) === null ||
            V === void 0 ||
            V.call(this, j.iceConnectionState);
        }),
        (j.onsignalingstatechange = () => {
          var V;
          (V = this.onSignalingStatechange) === null ||
            V === void 0 ||
            V.call(this, j.signalingState);
        }),
        (j.onconnectionstatechange = () => {
          var V;
          (V = this.onConnectionStateChange) === null ||
            V === void 0 ||
            V.call(this, j.connectionState);
        }),
        (j.ondatachannel = (V) => {
          var B;
          (B = this.onDataChannel) === null || B === void 0 || B.call(this, V);
        }),
        (j.ontrack = (V) => {
          var B;
          (B = this.onTrack) === null || B === void 0 || B.call(this, V);
        }),
        j
      );
    }
    get logContext() {
      var j, V;
      return Object.assign(
        {},
        (V = (j = this.loggerOptions).loggerContextCb) === null || V === void 0
          ? void 0
          : V.call(j)
      );
    }
    get isICEConnected() {
      return (
        this._pc !== null &&
        (this.pc.iceConnectionState === "connected" ||
          this.pc.iceConnectionState === "completed")
      );
    }
    addIceCandidate(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.pc.remoteDescription && !this.restartingIce)
          return this.pc.addIceCandidate(j);
        this.pendingCandidates.push(j);
      });
    }
    setRemoteDescription(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B;
        if (
          j.type === "answer" &&
          this.latestOfferId > 0 &&
          V > 0 &&
          V !== this.latestOfferId
        )
          return (
            this.log.warn(
              "ignoring answer for old offer",
              Object.assign(Object.assign({}, this.logContext), {
                offerId: V,
                latestOfferId: this.latestOfferId,
              })
            ),
            !1
          );
        let q;
        if (j.type === "offer") {
          let { stereoMids: $, nackMids: H } =
            extractStereoAndNackAudioFromOffer(j);
          (this.remoteStereoMids = $), (this.remoteNackMids = H);
        } else if (j.type === "answer") {
          const $ = libExports.parse(
            (B = j.sdp) !== null && B !== void 0 ? B : ""
          );
          $.media.forEach((H) => {
            H.type === "audio" &&
              this.trackBitrates.some((G) => {
                if (!G.transceiver || H.mid != G.transceiver.mid) return !1;
                let Y = 0;
                if (
                  (H.rtp.some((X) =>
                    X.codec.toUpperCase() === G.codec.toUpperCase()
                      ? ((Y = X.payload), !0)
                      : !1
                  ),
                  Y === 0)
                )
                  return !0;
                let Q = !1;
                for (const X of H.fmtp)
                  if (X.payload === Y) {
                    (X.config = X.config
                      .split(";")
                      .filter((Z) => !Z.includes("maxaveragebitrate"))
                      .join(";")),
                      G.maxbr > 0 &&
                        (X.config += ";maxaveragebitrate=".concat(
                          G.maxbr * 1e3
                        )),
                      (Q = !0);
                    break;
                  }
                return (
                  Q ||
                    (G.maxbr > 0 &&
                      H.fmtp.push({
                        payload: Y,
                        config: "maxaveragebitrate=".concat(G.maxbr * 1e3),
                      })),
                  !0
                );
              });
          }),
            (q = libExports.write($));
        }
        return (
          yield this.setMungedSDP(j, q, !0),
          this.pendingCandidates.forEach(($) => {
            this.pc.addIceCandidate($);
          }),
          (this.pendingCandidates = []),
          (this.restartingIce = !1),
          this.renegotiate
            ? ((this.renegotiate = !1), yield this.createAndSendOffer())
            : j.type === "answer" &&
              (this.emit(PCEvents.NegotiationComplete),
              j.sdp &&
                libExports.parse(j.sdp).media.forEach((H) => {
                  H.type === "video" &&
                    this.emit(PCEvents.RTPVideoPayloadTypes, H.rtp);
                })),
          !0
        );
      });
    }
    createAndSendOffer(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V;
        const B = yield this.offerLock.lock();
        try {
          if (this.onOffer === void 0) return;
          if (
            (j?.iceRestart &&
              (this.log.debug("restarting ICE", this.logContext),
              (this.restartingIce = !0)),
            this._pc && this._pc.signalingState === "have-local-offer")
          ) {
            const G = this._pc.remoteDescription;
            if (j?.iceRestart && G) yield this._pc.setRemoteDescription(G);
            else {
              this.renegotiate = !0;
              return;
            }
          } else if (!this._pc || this._pc.signalingState === "closed") {
            this.log.warn(
              "could not createOffer with closed peer connection",
              this.logContext
            );
            return;
          }
          this.log.debug("starting to negotiate", this.logContext);
          const q = this.latestOfferId + 1;
          this.latestOfferId = q;
          const $ = yield this.pc.createOffer(j);
          this.log.debug(
            "original offer",
            Object.assign({ sdp: $.sdp }, this.logContext)
          );
          const H = libExports.parse(
            (V = $.sdp) !== null && V !== void 0 ? V : ""
          );
          if (
            (H.media.forEach((G) => {
              ensureIPAddrMatchVersion(G),
                G.type === "audio"
                  ? ensureAudioNackAndStereo(G, [], [])
                  : G.type === "video" &&
                    this.trackBitrates.some((Y) => {
                      if (!G.msid || !Y.cid || !G.msid.includes(Y.cid))
                        return !1;
                      let Q = 0;
                      if (
                        (G.rtp.some((Z) =>
                          Z.codec.toUpperCase() === Y.codec.toUpperCase()
                            ? ((Q = Z.payload), !0)
                            : !1
                        ),
                        Q === 0 ||
                          (isSVCCodec(Y.codec) &&
                            !isSafari() &&
                            this.ensureVideoDDExtensionForSVC(G, H),
                          Y.codec !== "av1"))
                      )
                        return !0;
                      const X = Math.round(Y.maxbr * startBitrateForSVC);
                      for (const Z of G.fmtp)
                        if (Z.payload === Q) {
                          Z.config.includes("x-google-start-bitrate") ||
                            (Z.config += ";x-google-start-bitrate=".concat(X));
                          break;
                        }
                      return !0;
                    });
            }),
            this.latestOfferId > q)
          ) {
            this.log.warn(
              "latestOfferId mismatch",
              Object.assign(Object.assign({}, this.logContext), {
                latestOfferId: this.latestOfferId,
                offerId: q,
              })
            );
            return;
          }
          yield this.setMungedSDP($, libExports.write(H)),
            this.onOffer($, this.latestOfferId);
        } finally {
          B();
        }
      });
    }
    createAndSetAnswer() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.pc.createAnswer(),
          B = libExports.parse((j = V.sdp) !== null && j !== void 0 ? j : "");
        return (
          B.media.forEach((q) => {
            ensureIPAddrMatchVersion(q),
              q.type === "audio" &&
                ensureAudioNackAndStereo(
                  q,
                  this.remoteStereoMids,
                  this.remoteNackMids
                );
          }),
          yield this.setMungedSDP(V, libExports.write(B)),
          V
        );
      });
    }
    createDataChannel(j, V) {
      return this.pc.createDataChannel(j, V);
    }
    addTransceiver(j, V) {
      return this.pc.addTransceiver(j, V);
    }
    addTrack(j) {
      if (!this._pc)
        throw new UnexpectedConnectionState("PC closed, cannot add track");
      return this._pc.addTrack(j);
    }
    setTrackCodecBitrate(j) {
      this.trackBitrates.push(j);
    }
    setConfiguration(j) {
      var V;
      if (!this._pc)
        throw new UnexpectedConnectionState("PC closed, cannot configure");
      return (V = this._pc) === null || V === void 0
        ? void 0
        : V.setConfiguration(j);
    }
    canRemoveTrack() {
      var j;
      return !!(!((j = this._pc) === null || j === void 0) && j.removeTrack);
    }
    removeTrack(j) {
      var V;
      return (V = this._pc) === null || V === void 0
        ? void 0
        : V.removeTrack(j);
    }
    getConnectionState() {
      var j, V;
      return (V =
        (j = this._pc) === null || j === void 0
          ? void 0
          : j.connectionState) !== null && V !== void 0
        ? V
        : "closed";
    }
    getICEConnectionState() {
      var j, V;
      return (V =
        (j = this._pc) === null || j === void 0
          ? void 0
          : j.iceConnectionState) !== null && V !== void 0
        ? V
        : "closed";
    }
    getSignallingState() {
      var j, V;
      return (V =
        (j = this._pc) === null || j === void 0 ? void 0 : j.signalingState) !==
        null && V !== void 0
        ? V
        : "closed";
    }
    getTransceivers() {
      var j, V;
      return (V =
        (j = this._pc) === null || j === void 0
          ? void 0
          : j.getTransceivers()) !== null && V !== void 0
        ? V
        : [];
    }
    getSenders() {
      var j, V;
      return (V =
        (j = this._pc) === null || j === void 0 ? void 0 : j.getSenders()) !==
        null && V !== void 0
        ? V
        : [];
    }
    getLocalDescription() {
      var j;
      return (j = this._pc) === null || j === void 0
        ? void 0
        : j.localDescription;
    }
    getRemoteDescription() {
      var j;
      return (j = this.pc) === null || j === void 0
        ? void 0
        : j.remoteDescription;
    }
    getStats() {
      return this.pc.getStats();
    }
    getConnectedAddress() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        if (!this._pc) return;
        let V = "";
        const B = new Map(),
          q = new Map();
        if (
          ((yield this._pc.getStats()).forEach((G) => {
            switch (G.type) {
              case "transport":
                V = G.selectedCandidatePairId;
                break;
              case "candidate-pair":
                V === "" && G.selected && (V = G.id), B.set(G.id, G);
                break;
              case "remote-candidate":
                q.set(G.id, "".concat(G.address, ":").concat(G.port));
                break;
            }
          }),
          V === "")
        )
          return;
        const H =
          (j = B.get(V)) === null || j === void 0
            ? void 0
            : j.remoteCandidateId;
        if (H !== void 0) return q.get(H);
      });
    }
    setMungedSDP(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (V) {
          const q = j.sdp;
          j.sdp = V;
          try {
            this.log.debug(
              "setting munged ".concat(B ? "remote" : "local", " description"),
              this.logContext
            ),
              B
                ? yield this.pc.setRemoteDescription(j)
                : yield this.pc.setLocalDescription(j);
            return;
          } catch ($) {
            this.log.warn(
              "not able to set ".concat(
                j.type,
                ", falling back to unmodified sdp"
              ),
              Object.assign(Object.assign({}, this.logContext), {
                error: $,
                sdp: V,
              })
            ),
              (j.sdp = q);
          }
        }
        try {
          B
            ? yield this.pc.setRemoteDescription(j)
            : yield this.pc.setLocalDescription(j);
        } catch (q) {
          let $ = "unknown error";
          q instanceof Error
            ? ($ = q.message)
            : typeof q == "string" && ($ = q);
          const H = { error: $, sdp: j.sdp };
          throw (
            (!B &&
              this.pc.remoteDescription &&
              (H.remoteSdp = this.pc.remoteDescription),
            this.log.error(
              "unable to set ".concat(j.type),
              Object.assign(Object.assign({}, this.logContext), { fields: H })
            ),
            new NegotiationError($))
          );
        }
      });
    }
    ensureVideoDDExtensionForSVC(j, V) {
      var B, q;
      if (
        !((B = j.ext) === null || B === void 0
          ? void 0
          : B.some((H) => H.uri === ddExtensionURI))
      ) {
        if (this.ddExtID === 0) {
          let H = 0;
          V.media.forEach((G) => {
            var Y;
            G.type === "video" &&
              ((Y = G.ext) === null ||
                Y === void 0 ||
                Y.forEach((Q) => {
                  Q.value > H && (H = Q.value);
                }));
          }),
            (this.ddExtID = H + 1);
        }
        (q = j.ext) === null ||
          q === void 0 ||
          q.push({ value: this.ddExtID, uri: ddExtensionURI });
      }
    }
  }
  function ensureAudioNackAndStereo(U, j, V) {
    let B = 0;
    U.rtp.some((q) => (q.codec === "opus" ? ((B = q.payload), !0) : !1)),
      B > 0 &&
        (U.rtcpFb || (U.rtcpFb = []),
        V.includes(U.mid) &&
          !U.rtcpFb.some((q) => q.payload === B && q.type === "nack") &&
          U.rtcpFb.push({ payload: B, type: "nack" }),
        j.includes(U.mid) &&
          U.fmtp.some((q) =>
            q.payload === B
              ? (q.config.includes("stereo=1") || (q.config += ";stereo=1"), !0)
              : !1
          ));
  }
  function extractStereoAndNackAudioFromOffer(U) {
    var j;
    const V = [],
      B = [],
      q = libExports.parse((j = U.sdp) !== null && j !== void 0 ? j : "");
    let $ = 0;
    return (
      q.media.forEach((H) => {
        var G;
        H.type === "audio" &&
          (H.rtp.some((Y) => (Y.codec === "opus" ? (($ = Y.payload), !0) : !1)),
          !((G = H.rtcpFb) === null || G === void 0) &&
            G.some((Y) => Y.payload === $ && Y.type === "nack") &&
            B.push(H.mid),
          H.fmtp.some((Y) =>
            Y.payload === $
              ? (Y.config.includes("sprop-stereo=1") && V.push(H.mid), !0)
              : !1
          ));
      }),
      { stereoMids: V, nackMids: B }
    );
  }
  function ensureIPAddrMatchVersion(U) {
    if (U.connection) {
      const j = U.connection.ip.indexOf(":") >= 0;
      ((U.connection.version === 4 && j) ||
        (U.connection.version === 6 && !j)) &&
        ((U.connection.ip = "0.0.0.0"), (U.connection.version = 4));
    }
  }
  const defaultVideoCodec = "vp8",
    publishDefaults = {
      audioPreset: AudioPresets.music,
      dtx: !0,
      red: !0,
      forceStereo: !1,
      simulcast: !0,
      screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,
      stopMicTrackOnMute: !1,
      videoCodec: defaultVideoCodec,
      backupCodec: !0,
      preConnectBuffer: !1,
    },
    audioDefaults = {
      deviceId: { ideal: "default" },
      autoGainControl: !0,
      echoCancellation: !0,
      noiseSuppression: !0,
      voiceIsolation: !0,
    },
    videoDefaults = {
      deviceId: { ideal: "default" },
      resolution: VideoPresets.h720.resolution,
    },
    roomOptionDefaults = {
      adaptiveStream: !1,
      dynacast: !1,
      stopLocalTrackOnUnpublish: !0,
      reconnectPolicy: new DefaultReconnectPolicy(),
      disconnectOnPageLeave: !0,
      webAudioMix: !1,
    },
    roomConnectOptionDefaults = {
      autoSubscribe: !0,
      maxRetries: 1,
      peerConnectionTimeout: 15e3,
      websocketTimeout: 15e3,
    };
  var PCTransportState;
  (function (U) {
    (U[(U.NEW = 0)] = "NEW"),
      (U[(U.CONNECTING = 1)] = "CONNECTING"),
      (U[(U.CONNECTED = 2)] = "CONNECTED"),
      (U[(U.FAILED = 3)] = "FAILED"),
      (U[(U.CLOSING = 4)] = "CLOSING"),
      (U[(U.CLOSED = 5)] = "CLOSED");
  })(PCTransportState || (PCTransportState = {}));
  class PCTransportManager {
    get needsPublisher() {
      return this.isPublisherConnectionRequired;
    }
    get needsSubscriber() {
      return this.isSubscriberConnectionRequired;
    }
    get currentState() {
      return this.state;
    }
    constructor(j, V, B) {
      var q;
      (this.peerConnectionTimeout =
        roomConnectOptionDefaults.peerConnectionTimeout),
        (this.log = livekitLogger),
        (this.updateState = () => {
          var $;
          const H = this.state,
            G = this.requiredTransports.map((Y) => Y.getConnectionState());
          G.every((Y) => Y === "connected")
            ? (this.state = PCTransportState.CONNECTED)
            : G.some((Y) => Y === "failed")
            ? (this.state = PCTransportState.FAILED)
            : G.some((Y) => Y === "connecting")
            ? (this.state = PCTransportState.CONNECTING)
            : G.every((Y) => Y === "closed")
            ? (this.state = PCTransportState.CLOSED)
            : G.some((Y) => Y === "closed")
            ? (this.state = PCTransportState.CLOSING)
            : G.every((Y) => Y === "new") &&
              (this.state = PCTransportState.NEW),
            H !== this.state &&
              (this.log.debug(
                "pc state change: from "
                  .concat(PCTransportState[H], " to ")
                  .concat(PCTransportState[this.state]),
                this.logContext
              ),
              ($ = this.onStateChange) === null ||
                $ === void 0 ||
                $.call(
                  this,
                  this.state,
                  this.publisher.getConnectionState(),
                  this.subscriber.getConnectionState()
                ));
        }),
        (this.log = getLogger(
          (q = B.loggerName) !== null && q !== void 0
            ? q
            : LoggerNames.PCManager
        )),
        (this.loggerOptions = B),
        (this.isPublisherConnectionRequired = !V),
        (this.isSubscriberConnectionRequired = V),
        (this.publisher = new PCTransport(j, B)),
        (this.subscriber = new PCTransport(j, B)),
        (this.publisher.onConnectionStateChange = this.updateState),
        (this.subscriber.onConnectionStateChange = this.updateState),
        (this.publisher.onIceConnectionStateChange = this.updateState),
        (this.subscriber.onIceConnectionStateChange = this.updateState),
        (this.publisher.onSignalingStatechange = this.updateState),
        (this.subscriber.onSignalingStatechange = this.updateState),
        (this.publisher.onIceCandidate = ($) => {
          var H;
          (H = this.onIceCandidate) === null ||
            H === void 0 ||
            H.call(this, $, SignalTarget.PUBLISHER);
        }),
        (this.subscriber.onIceCandidate = ($) => {
          var H;
          (H = this.onIceCandidate) === null ||
            H === void 0 ||
            H.call(this, $, SignalTarget.SUBSCRIBER);
        }),
        (this.subscriber.onDataChannel = ($) => {
          var H;
          (H = this.onDataChannel) === null || H === void 0 || H.call(this, $);
        }),
        (this.subscriber.onTrack = ($) => {
          var H;
          (H = this.onTrack) === null || H === void 0 || H.call(this, $);
        }),
        (this.publisher.onOffer = ($, H) => {
          var G;
          (G = this.onPublisherOffer) === null ||
            G === void 0 ||
            G.call(this, $, H);
        }),
        (this.state = PCTransportState.NEW),
        (this.connectionLock = new _$1()),
        (this.remoteOfferLock = new _$1());
    }
    get logContext() {
      var j, V;
      return Object.assign(
        {},
        (V = (j = this.loggerOptions).loggerContextCb) === null || V === void 0
          ? void 0
          : V.call(j)
      );
    }
    requirePublisher() {
      let j =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      (this.isPublisherConnectionRequired = j), this.updateState();
    }
    requireSubscriber() {
      let j =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      (this.isSubscriberConnectionRequired = j), this.updateState();
    }
    createAndSendPublisherOffer(j) {
      return this.publisher.createAndSendOffer(j);
    }
    setPublisherAnswer(j, V) {
      return this.publisher.setRemoteDescription(j, V);
    }
    removeTrack(j) {
      return this.publisher.removeTrack(j);
    }
    close() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (
          this.publisher &&
          this.publisher.getSignallingState() !== "closed"
        ) {
          const j = this.publisher;
          for (const V of j.getSenders())
            try {
              j.canRemoveTrack() && j.removeTrack(V);
            } catch (B) {
              this.log.warn(
                "could not removeTrack",
                Object.assign(Object.assign({}, this.logContext), { error: B })
              );
            }
        }
        yield Promise.all([this.publisher.close(), this.subscriber.close()]),
          this.updateState();
      });
    }
    triggerIceRestart() {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.subscriber.restartingIce = !0),
          this.needsPublisher &&
            (yield this.createAndSendPublisherOffer({ iceRestart: !0 }));
      });
    }
    addIceCandidate(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        V === SignalTarget.PUBLISHER
          ? yield this.publisher.addIceCandidate(j)
          : yield this.subscriber.addIceCandidate(j);
      });
    }
    createSubscriberAnswerFromOffer(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.log.debug(
          "received server offer",
          Object.assign(Object.assign({}, this.logContext), {
            RTCSdpType: j.type,
            sdp: j.sdp,
            signalingState: this.subscriber.getSignallingState().toString(),
          })
        );
        const B = yield this.remoteOfferLock.lock();
        try {
          return (yield this.subscriber.setRemoteDescription(j, V))
            ? yield this.subscriber.createAndSetAnswer()
            : void 0;
        } finally {
          B();
        }
      });
    }
    updateConfiguration(j, V) {
      this.publisher.setConfiguration(j),
        this.subscriber.setConfiguration(j),
        V && this.triggerIceRestart();
    }
    ensurePCTransportConnection(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B;
        const q = yield this.connectionLock.lock();
        try {
          this.isPublisherConnectionRequired &&
            this.publisher.getConnectionState() !== "connected" &&
            this.publisher.getConnectionState() !== "connecting" &&
            (this.log.debug(
              "negotiation required, start negotiating",
              this.logContext
            ),
            this.publisher.negotiate()),
            yield Promise.all(
              (B = this.requiredTransports) === null || B === void 0
                ? void 0
                : B.map(($) => this.ensureTransportConnected($, j, V))
            );
        } finally {
          q();
        }
      });
    }
    negotiate(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return new Promise((V, B) =>
          __awaiter$1(this, void 0, void 0, function* () {
            const q = setTimeout(() => {
                B("negotiation timed out");
              }, this.peerConnectionTimeout),
              $ = () => {
                clearTimeout(q), B("negotiation aborted");
              };
            j.signal.addEventListener("abort", $),
              this.publisher.once(PCEvents.NegotiationStarted, () => {
                j.signal.aborted ||
                  this.publisher.once(PCEvents.NegotiationComplete, () => {
                    clearTimeout(q), V();
                  });
              }),
              yield this.publisher.negotiate((H) => {
                clearTimeout(q), B(H);
              });
          })
        );
      });
    }
    addPublisherTransceiver(j, V) {
      return this.publisher.addTransceiver(j, V);
    }
    addPublisherTrack(j) {
      return this.publisher.addTrack(j);
    }
    createPublisherDataChannel(j, V) {
      return this.publisher.createDataChannel(j, V);
    }
    getConnectedAddress(j) {
      return j === SignalTarget.PUBLISHER
        ? this.publisher.getConnectedAddress()
        : j === SignalTarget.SUBSCRIBER
        ? this.publisher.getConnectedAddress()
        : this.requiredTransports[0].getConnectedAddress();
    }
    get requiredTransports() {
      const j = [];
      return (
        this.isPublisherConnectionRequired && j.push(this.publisher),
        this.isSubscriberConnectionRequired && j.push(this.subscriber),
        j
      );
    }
    ensureTransportConnected(j, V) {
      return __awaiter$1(this, arguments, void 0, function (B, q) {
        var $ = this;
        let H =
          arguments.length > 2 && arguments[2] !== void 0
            ? arguments[2]
            : this.peerConnectionTimeout;
        return (function* () {
          if (B.getConnectionState() !== "connected")
            return new Promise((Y, Q) =>
              __awaiter$1($, void 0, void 0, function* () {
                const X = () => {
                  this.log.warn("abort transport connection", this.logContext),
                    CriticalTimers.clearTimeout(Z),
                    Q(
                      new ConnectionError(
                        "room connection has been cancelled",
                        ConnectionErrorReason.Cancelled
                      )
                    );
                };
                q?.signal.aborted && X(),
                  q?.signal.addEventListener("abort", X);
                const Z = CriticalTimers.setTimeout(() => {
                  q?.signal.removeEventListener("abort", X),
                    Q(
                      new ConnectionError(
                        "could not establish pc connection",
                        ConnectionErrorReason.InternalError
                      )
                    );
                }, H);
                for (; this.state !== PCTransportState.CONNECTED; )
                  if ((yield sleep$1(50), q?.signal.aborted)) {
                    Q(
                      new ConnectionError(
                        "room connection has been cancelled",
                        ConnectionErrorReason.Cancelled
                      )
                    );
                    return;
                  }
                CriticalTimers.clearTimeout(Z),
                  q?.signal.removeEventListener("abort", X),
                  Y();
              })
            );
        })();
      });
    }
  }
  class RpcError extends Error {
    constructor(j, V, B) {
      super(V),
        (this.code = j),
        (this.message = truncateBytes(V, RpcError.MAX_MESSAGE_BYTES)),
        (this.data = B ? truncateBytes(B, RpcError.MAX_DATA_BYTES) : void 0);
    }
    static fromProto(j) {
      return new RpcError(j.code, j.message, j.data);
    }
    toProto() {
      return new RpcError$1({
        code: this.code,
        message: this.message,
        data: this.data,
      });
    }
    static builtIn(j, V) {
      return new RpcError(RpcError.ErrorCode[j], RpcError.ErrorMessage[j], V);
    }
  }
  (RpcError.MAX_MESSAGE_BYTES = 256),
    (RpcError.MAX_DATA_BYTES = 15360),
    (RpcError.ErrorCode = {
      APPLICATION_ERROR: 1500,
      CONNECTION_TIMEOUT: 1501,
      RESPONSE_TIMEOUT: 1502,
      RECIPIENT_DISCONNECTED: 1503,
      RESPONSE_PAYLOAD_TOO_LARGE: 1504,
      SEND_FAILED: 1505,
      UNSUPPORTED_METHOD: 1400,
      RECIPIENT_NOT_FOUND: 1401,
      REQUEST_PAYLOAD_TOO_LARGE: 1402,
      UNSUPPORTED_SERVER: 1403,
      UNSUPPORTED_VERSION: 1404,
    }),
    (RpcError.ErrorMessage = {
      APPLICATION_ERROR: "Application error in method handler",
      CONNECTION_TIMEOUT: "Connection timeout",
      RESPONSE_TIMEOUT: "Response timeout",
      RECIPIENT_DISCONNECTED: "Recipient disconnected",
      RESPONSE_PAYLOAD_TOO_LARGE: "Response payload too large",
      SEND_FAILED: "Failed to send",
      UNSUPPORTED_METHOD: "Method not supported at destination",
      RECIPIENT_NOT_FOUND: "Recipient not found",
      REQUEST_PAYLOAD_TOO_LARGE: "Request payload too large",
      UNSUPPORTED_SERVER: "RPC not supported by server",
      UNSUPPORTED_VERSION: "Unsupported RPC version",
    });
  const MAX_PAYLOAD_BYTES = 15360;
  function byteLength(U) {
    return new TextEncoder().encode(U).length;
  }
  function truncateBytes(U, j) {
    if (byteLength(U) <= j) return U;
    let V = 0,
      B = U.length;
    const q = new TextEncoder();
    for (; V < B; ) {
      const $ = Math.floor((V + B + 1) / 2);
      q.encode(U.slice(0, $)).length <= j ? (V = $) : (B = $ - 1);
    }
    return U.slice(0, V);
  }
  const monitorFrequency = 2e3;
  function computeBitrate(U, j) {
    if (!j) return 0;
    let V, B;
    return (
      "bytesReceived" in U
        ? ((V = U.bytesReceived), (B = j.bytesReceived))
        : "bytesSent" in U && ((V = U.bytesSent), (B = j.bytesSent)),
      V === void 0 ||
      B === void 0 ||
      U.timestamp === void 0 ||
      j.timestamp === void 0
        ? 0
        : ((V - B) * 8 * 1e3) / (U.timestamp - j.timestamp)
    );
  }
  const isMediaRecorderAvailable = typeof MediaRecorder < "u";
  class FallbackRecorder {
    constructor() {
      throw new Error("MediaRecorder is not available in this environment");
    }
  }
  const RecorderBase = isMediaRecorderAvailable
    ? MediaRecorder
    : FallbackRecorder;
  class LocalTrackRecorder extends RecorderBase {
    constructor(j, V) {
      if (!isMediaRecorderAvailable)
        throw new Error("MediaRecorder is not available in this environment");
      super(new MediaStream([j.mediaStreamTrack]), V);
      let B, q;
      const $ = () => q === void 0,
        H = () => {
          this.removeEventListener("dataavailable", B),
            this.removeEventListener("stop", H),
            this.removeEventListener("error", G),
            q?.close(),
            (q = void 0);
        },
        G = (Y) => {
          q?.error(Y),
            this.removeEventListener("dataavailable", B),
            this.removeEventListener("stop", H),
            this.removeEventListener("error", G),
            (q = void 0);
        };
      (this.byteStream = new ReadableStream({
        start: (Y) => {
          (q = Y),
            (B = (Q) =>
              __awaiter$1(this, void 0, void 0, function* () {
                const X = yield Q.data.arrayBuffer();
                $() || Y.enqueue(new Uint8Array(X));
              })),
            this.addEventListener("dataavailable", B);
        },
        cancel: () => {
          H();
        },
      })),
        this.addEventListener("stop", H),
        this.addEventListener("error", G);
    }
  }
  function isRecordingSupported() {
    return isMediaRecorderAvailable;
  }
  const DEFAULT_DIMENSIONS_TIMEOUT = 1e3,
    PRE_CONNECT_BUFFER_TIMEOUT = 1e4;
  class LocalTrack extends Track {
    get sender() {
      return this._sender;
    }
    set sender(j) {
      this._sender = j;
    }
    get constraints() {
      return this._constraints;
    }
    get hasPreConnectBuffer() {
      return !!this.localTrackRecorder;
    }
    constructor(j, V, B) {
      let q =
          arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1,
        $ = arguments.length > 4 ? arguments[4] : void 0;
      super(j, V, $),
        (this.manuallyStopped = !1),
        (this._isUpstreamPaused = !1),
        (this.handleTrackMuteEvent = () =>
          this.debouncedTrackMuteHandler().catch(() =>
            this.log.debug(
              "track mute bounce got cancelled by an unmute event",
              this.logContext
            )
          )),
        (this.debouncedTrackMuteHandler = r$1(
          () =>
            __awaiter$1(this, void 0, void 0, function* () {
              yield this.pauseUpstream();
            }),
          5e3
        )),
        (this.handleTrackUnmuteEvent = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            this.debouncedTrackMuteHandler.cancel("unmute"),
              yield this.resumeUpstream();
          })),
        (this.handleEnded = () => {
          this.isInBackground && (this.reacquireTrack = !0),
            this._mediaStreamTrack.removeEventListener(
              "mute",
              this.handleTrackMuteEvent
            ),
            this._mediaStreamTrack.removeEventListener(
              "unmute",
              this.handleTrackUnmuteEvent
            ),
            this.emit(TrackEvent.Ended, this);
        }),
        (this.reacquireTrack = !1),
        (this.providedByUser = q),
        (this.muteLock = new _$1()),
        (this.pauseUpstreamLock = new _$1()),
        (this.processorLock = new _$1()),
        (this.restartLock = new _$1()),
        this.setMediaStreamTrack(j, !0),
        (this._constraints = j.getConstraints()),
        B && (this._constraints = B);
    }
    get id() {
      return this._mediaStreamTrack.id;
    }
    get dimensions() {
      if (this.kind !== Track.Kind.Video) return;
      const { width: j, height: V } = this._mediaStreamTrack.getSettings();
      if (j && V) return { width: j, height: V };
    }
    get isUpstreamPaused() {
      return this._isUpstreamPaused;
    }
    get isUserProvided() {
      return this.providedByUser;
    }
    get mediaStreamTrack() {
      var j, V;
      return (V =
        (j = this.processor) === null || j === void 0
          ? void 0
          : j.processedTrack) !== null && V !== void 0
        ? V
        : this._mediaStreamTrack;
    }
    get isLocal() {
      return !0;
    }
    getSourceTrackSettings() {
      return this._mediaStreamTrack.getSettings();
    }
    setMediaStreamTrack(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B;
        if (j === this._mediaStreamTrack && !V) return;
        this._mediaStreamTrack &&
          (this.attachedElements.forEach(($) => {
            detachTrack(this._mediaStreamTrack, $);
          }),
          this.debouncedTrackMuteHandler.cancel("new-track"),
          this._mediaStreamTrack.removeEventListener("ended", this.handleEnded),
          this._mediaStreamTrack.removeEventListener(
            "mute",
            this.handleTrackMuteEvent
          ),
          this._mediaStreamTrack.removeEventListener(
            "unmute",
            this.handleTrackUnmuteEvent
          )),
          (this.mediaStream = new MediaStream([j])),
          j &&
            (j.addEventListener("ended", this.handleEnded),
            j.addEventListener("mute", this.handleTrackMuteEvent),
            j.addEventListener("unmute", this.handleTrackUnmuteEvent),
            (this._constraints = j.getConstraints()));
        let q;
        if (this.processor && j) {
          const $ = yield this.processorLock.lock();
          try {
            if (
              (this.log.debug("restarting processor", this.logContext),
              this.kind === "unknown")
            )
              throw TypeError("cannot set processor on track of unknown kind");
            this.processorElement &&
              (attachToElement(j, this.processorElement),
              (this.processorElement.muted = !0)),
              yield this.processor.restart({
                track: j,
                kind: this.kind,
                element: this.processorElement,
              }),
              (q = this.processor.processedTrack);
          } finally {
            $();
          }
        }
        this.sender &&
          ((B = this.sender.transport) === null || B === void 0
            ? void 0
            : B.state) !== "closed" &&
          (yield this.sender.replaceTrack(q ?? j)),
          !this.providedByUser &&
            this._mediaStreamTrack !== j &&
            this._mediaStreamTrack.stop(),
          (this._mediaStreamTrack = j),
          j &&
            ((this._mediaStreamTrack.enabled = !this.isMuted),
            yield this.resumeUpstream(),
            this.attachedElements.forEach(($) => {
              attachToElement(q ?? j, $);
            }));
      });
    }
    waitForDimensions() {
      return __awaiter$1(this, arguments, void 0, function () {
        var j = this;
        let V =
          arguments.length > 0 && arguments[0] !== void 0
            ? arguments[0]
            : DEFAULT_DIMENSIONS_TIMEOUT;
        return (function* () {
          var B;
          if (j.kind === Track.Kind.Audio)
            throw new Error("cannot get dimensions for audio tracks");
          ((B = getBrowser()) === null || B === void 0 ? void 0 : B.os) ===
            "iOS" && (yield sleep$1(10));
          const q = Date.now();
          for (; Date.now() - q < V; ) {
            const $ = j.dimensions;
            if ($) return $;
            yield sleep$1(50);
          }
          throw new TrackInvalidError(
            "unable to get track dimensions after timeout"
          );
        })();
      });
    }
    setDeviceId(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return (this._constraints.deviceId === j &&
          this._mediaStreamTrack.getSettings().deviceId ===
            unwrapConstraint(j)) ||
          ((this._constraints.deviceId = j), this.isMuted)
          ? !0
          : (yield this.restartTrack(),
            unwrapConstraint(j) ===
              this._mediaStreamTrack.getSettings().deviceId);
      });
    }
    getDeviceId() {
      return __awaiter$1(this, arguments, void 0, function () {
        var j = this;
        let V =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
        return (function* () {
          if (j.source === Track.Source.ScreenShare) return;
          const { deviceId: B, groupId: q } = j._mediaStreamTrack.getSettings(),
            $ = j.kind === Track.Kind.Audio ? "audioinput" : "videoinput";
          return V ? DeviceManager.getInstance().normalizeDeviceId($, B, q) : B;
        })();
      });
    }
    mute() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.setTrackMuted(!0), this;
      });
    }
    unmute() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.setTrackMuted(!1), this;
      });
    }
    replaceTrack(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.sender)
          throw new TrackInvalidError("unable to replace an unpublished track");
        let B, q;
        return (
          typeof V == "boolean"
            ? (B = V)
            : V !== void 0 &&
              ((B = V.userProvidedTrack), (q = V.stopProcessor)),
          (this.providedByUser = B ?? !0),
          this.log.debug("replace MediaStreamTrack", this.logContext),
          yield this.setMediaStreamTrack(j),
          q && this.processor && (yield this.stopProcessor()),
          this
        );
      });
    }
    restart(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.manuallyStopped = !1;
        const V = yield this.restartLock.lock();
        try {
          j || (j = this._constraints);
          const { deviceId: B, facingMode: q } = j,
            $ = __rest(j, ["deviceId", "facingMode"]);
          this.log.debug(
            "restarting track with constraints",
            Object.assign(Object.assign({}, this.logContext), {
              constraints: j,
            })
          );
          const H = { audio: !1, video: !1 };
          this.kind === Track.Kind.Video
            ? (H.video = B || q ? { deviceId: B, facingMode: q } : !0)
            : (H.audio = B ? { deviceId: B } : !0),
            this.attachedElements.forEach((Q) => {
              detachTrack(this.mediaStreamTrack, Q);
            }),
            this._mediaStreamTrack.removeEventListener(
              "ended",
              this.handleEnded
            ),
            this._mediaStreamTrack.stop();
          const Y = (yield navigator.mediaDevices.getUserMedia(
            H
          )).getTracks()[0];
          return (
            yield Y.applyConstraints($),
            Y.addEventListener("ended", this.handleEnded),
            this.log.debug("re-acquired MediaStreamTrack", this.logContext),
            yield this.setMediaStreamTrack(Y),
            (this._constraints = j),
            this.emit(TrackEvent.Restarted, this),
            this.manuallyStopped &&
              (this.log.warn(
                "track was stopped during a restart, stopping restarted track",
                this.logContext
              ),
              this.stop()),
            this
          );
        } finally {
          V();
        }
      });
    }
    setTrackMuted(j) {
      this.log.debug(
        "setting ".concat(this.kind, " track ").concat(j ? "muted" : "unmuted"),
        this.logContext
      ),
        !(this.isMuted === j && this._mediaStreamTrack.enabled !== j) &&
          ((this.isMuted = j),
          (this._mediaStreamTrack.enabled = !j),
          this.emit(j ? TrackEvent.Muted : TrackEvent.Unmuted, this));
    }
    get needsReAcquisition() {
      return (
        this._mediaStreamTrack.readyState !== "live" ||
        this._mediaStreamTrack.muted ||
        !this._mediaStreamTrack.enabled ||
        this.reacquireTrack
      );
    }
    handleAppVisibilityChanged() {
      const j = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter$1(this, void 0, void 0, function* () {
        yield j.handleAppVisibilityChanged.call(this),
          isMobile() &&
            (this.log.debug(
              "visibility changed, is in Background: ".concat(
                this.isInBackground
              ),
              this.logContext
            ),
            !this.isInBackground &&
              this.needsReAcquisition &&
              !this.isUserProvided &&
              !this.isMuted &&
              (this.log.debug(
                "track needs to be reacquired, restarting ".concat(this.source),
                this.logContext
              ),
              yield this.restart(),
              (this.reacquireTrack = !1)));
      });
    }
    stop() {
      var j;
      (this.manuallyStopped = !0),
        super.stop(),
        this._mediaStreamTrack.removeEventListener("ended", this.handleEnded),
        this._mediaStreamTrack.removeEventListener(
          "mute",
          this.handleTrackMuteEvent
        ),
        this._mediaStreamTrack.removeEventListener(
          "unmute",
          this.handleTrackUnmuteEvent
        ),
        (j = this.processor) === null || j === void 0 || j.destroy(),
        (this.processor = void 0);
    }
    pauseUpstream() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === !0) return;
          if (!this.sender) {
            this.log.warn(
              "unable to pause upstream for an unpublished track",
              this.logContext
            );
            return;
          }
          (this._isUpstreamPaused = !0),
            this.emit(TrackEvent.UpstreamPaused, this);
          const B = getBrowser();
          if (B?.name === "Safari" && compareVersions(B.version, "12.0") < 0)
            throw new DeviceUnsupportedError(
              "pauseUpstream is not supported on Safari < 12."
            );
          ((j = this.sender.transport) === null || j === void 0
            ? void 0
            : j.state) !== "closed" && (yield this.sender.replaceTrack(null));
        } finally {
          V();
        }
      });
    }
    resumeUpstream() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.pauseUpstreamLock.lock();
        try {
          if (this._isUpstreamPaused === !1) return;
          if (!this.sender) {
            this.log.warn(
              "unable to resume upstream for an unpublished track",
              this.logContext
            );
            return;
          }
          (this._isUpstreamPaused = !1),
            this.emit(TrackEvent.UpstreamResumed, this),
            ((j = this.sender.transport) === null || j === void 0
              ? void 0
              : j.state) !== "closed" &&
              (yield this.sender.replaceTrack(this.mediaStreamTrack));
        } finally {
          V();
        }
      });
    }
    getRTCStatsReport() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        return !((j = this.sender) === null || j === void 0) && j.getStats
          ? yield this.sender.getStats()
          : void 0;
      });
    }
    setProcessor(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return (function* () {
          var $;
          const H = yield B.processorLock.lock();
          try {
            B.log.debug("setting up processor", B.logContext);
            const G = document.createElement(B.kind),
              Y = {
                kind: B.kind,
                track: B._mediaStreamTrack,
                element: G,
                audioContext: B.audioContext,
              };
            if (
              (yield V.init(Y),
              B.log.debug("processor initialized", B.logContext),
              B.processor && (yield B.stopProcessor()),
              B.kind === "unknown")
            )
              throw TypeError("cannot set processor on track of unknown kind");
            if (
              (attachToElement(B._mediaStreamTrack, G),
              (G.muted = !0),
              G.play().catch((Q) => {
                Q instanceof DOMException && Q.name === "AbortError"
                  ? (B.log.warn(
                      "failed to play processor element, retrying",
                      Object.assign(Object.assign({}, B.logContext), {
                        error: Q,
                      })
                    ),
                    setTimeout(() => {
                      G.play().catch((X) => {
                        B.log.error(
                          "failed to play processor element",
                          Object.assign(Object.assign({}, B.logContext), {
                            err: X,
                          })
                        );
                      });
                    }, 100))
                  : B.log.error(
                      "failed to play processor element",
                      Object.assign(Object.assign({}, B.logContext), {
                        error: Q,
                      })
                    );
              }),
              (B.processor = V),
              (B.processorElement = G),
              B.processor.processedTrack)
            ) {
              for (const Q of B.attachedElements)
                Q !== B.processorElement &&
                  q &&
                  (detachTrack(B._mediaStreamTrack, Q),
                  attachToElement(B.processor.processedTrack, Q));
              yield ($ = B.sender) === null || $ === void 0
                ? void 0
                : $.replaceTrack(B.processor.processedTrack);
            }
            B.emit(TrackEvent.TrackProcessorUpdate, B.processor);
          } finally {
            H();
          }
        })();
      });
    }
    getProcessor() {
      return this.processor;
    }
    stopProcessor() {
      return __awaiter$1(this, arguments, void 0, function () {
        var j = this;
        let V =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
        return (function* () {
          var B, q;
          j.processor &&
            (j.log.debug("stopping processor", j.logContext),
            (B = j.processor.processedTrack) === null ||
              B === void 0 ||
              B.stop(),
            yield j.processor.destroy(),
            (j.processor = void 0),
            V ||
              ((q = j.processorElement) === null || q === void 0 || q.remove(),
              (j.processorElement = void 0)),
            yield j._mediaStreamTrack.applyConstraints(j._constraints),
            yield j.setMediaStreamTrack(j._mediaStreamTrack, !0),
            j.emit(TrackEvent.TrackProcessorUpdate));
        })();
      });
    }
    startPreConnectBuffer() {
      let j =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
      if (!isRecordingSupported()) {
        this.log.warn(
          "MediaRecorder is not available, cannot start preconnect buffer",
          this.logContext
        );
        return;
      }
      if (!this.localTrackRecorder)
        this.localTrackRecorder = new LocalTrackRecorder(this, {
          mimeType: "audio/webm;codecs=opus",
        });
      else {
        this.log.warn("preconnect buffer already started");
        return;
      }
      this.localTrackRecorder.start(j),
        (this.autoStopPreConnectBuffer = setTimeout(() => {
          this.log.warn(
            "preconnect buffer timed out, stopping recording automatically",
            this.logContext
          ),
            this.stopPreConnectBuffer();
        }, PRE_CONNECT_BUFFER_TIMEOUT));
    }
    stopPreConnectBuffer() {
      clearTimeout(this.autoStopPreConnectBuffer),
        this.localTrackRecorder &&
          (this.localTrackRecorder.stop(), (this.localTrackRecorder = void 0));
    }
    getPreConnectBuffer() {
      var j;
      return (j = this.localTrackRecorder) === null || j === void 0
        ? void 0
        : j.byteStream;
    }
  }
  class LocalAudioTrack extends LocalTrack {
    get enhancedNoiseCancellation() {
      return this.isKrispNoiseFilterEnabled;
    }
    constructor(j, V) {
      let B =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        q = arguments.length > 3 ? arguments[3] : void 0,
        $ = arguments.length > 4 ? arguments[4] : void 0;
      super(j, Track.Kind.Audio, V, B, $),
        (this.stopOnMute = !1),
        (this.isKrispNoiseFilterEnabled = !1),
        (this.monitorSender = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (!this.sender) {
              this._currentBitrate = 0;
              return;
            }
            let H;
            try {
              H = yield this.getSenderStats();
            } catch (G) {
              this.log.error(
                "could not get audio sender stats",
                Object.assign(Object.assign({}, this.logContext), { error: G })
              );
              return;
            }
            H &&
              this.prevStats &&
              (this._currentBitrate = computeBitrate(H, this.prevStats)),
              (this.prevStats = H);
          })),
        (this.handleKrispNoiseFilterEnable = () => {
          (this.isKrispNoiseFilterEnabled = !0),
            this.log.debug("Krisp noise filter enabled", this.logContext),
            this.emit(
              TrackEvent.AudioTrackFeatureUpdate,
              this,
              AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
              !0
            );
        }),
        (this.handleKrispNoiseFilterDisable = () => {
          (this.isKrispNoiseFilterEnabled = !1),
            this.log.debug("Krisp noise filter disabled", this.logContext),
            this.emit(
              TrackEvent.AudioTrackFeatureUpdate,
              this,
              AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION,
              !1
            );
        }),
        (this.audioContext = q),
        this.checkForSilence();
    }
    mute() {
      const j = Object.create(null, { mute: { get: () => super.mute } });
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = yield this.muteLock.lock();
        try {
          return this.isMuted
            ? (this.log.debug("Track already muted", this.logContext), this)
            : (this.source === Track.Source.Microphone &&
                this.stopOnMute &&
                !this.isUserProvided &&
                (this.log.debug("stopping mic track", this.logContext),
                this._mediaStreamTrack.stop()),
              yield j.mute.call(this),
              this);
        } finally {
          V();
        }
      });
    }
    unmute() {
      const j = Object.create(null, { unmute: { get: () => super.unmute } });
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = yield this.muteLock.lock();
        try {
          if (!this.isMuted)
            return (
              this.log.debug("Track already unmuted", this.logContext), this
            );
          const B =
            this._constraints.deviceId &&
            this._mediaStreamTrack.getSettings().deviceId !==
              unwrapConstraint(this._constraints.deviceId);
          return (
            this.source === Track.Source.Microphone &&
              (this.stopOnMute ||
                this._mediaStreamTrack.readyState === "ended" ||
                B) &&
              !this.isUserProvided &&
              (this.log.debug("reacquiring mic track", this.logContext),
              yield this.restartTrack()),
            yield j.unmute.call(this),
            this
          );
        } finally {
          V();
        }
      });
    }
    restartTrack(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        let V;
        if (j) {
          const B = constraintsForOptions({ audio: j });
          typeof B.audio != "boolean" && (V = B.audio);
        }
        yield this.restart(V);
      });
    }
    restart(j) {
      const V = Object.create(null, { restart: { get: () => super.restart } });
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = yield V.restart.call(this, j);
        return this.checkForSilence(), B;
      });
    }
    startMonitor() {
      isWeb() &&
        (this.monitorInterval ||
          (this.monitorInterval = setInterval(() => {
            this.monitorSender();
          }, monitorFrequency)));
    }
    setProcessor(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V;
        const B = yield this.processorLock.lock();
        try {
          if (!isReactNative() && !this.audioContext)
            throw Error(
              "Audio context needs to be set on LocalAudioTrack in order to enable processors"
            );
          this.processor && (yield this.stopProcessor());
          const q = {
            kind: this.kind,
            track: this._mediaStreamTrack,
            audioContext: this.audioContext,
          };
          this.log.debug(
            "setting up audio processor ".concat(j.name),
            this.logContext
          ),
            yield j.init(q),
            (this.processor = j),
            this.processor.processedTrack &&
              (yield (V = this.sender) === null || V === void 0
                ? void 0
                : V.replaceTrack(this.processor.processedTrack),
              this.processor.processedTrack.addEventListener(
                "enable-lk-krisp-noise-filter",
                this.handleKrispNoiseFilterEnable
              ),
              this.processor.processedTrack.addEventListener(
                "disable-lk-krisp-noise-filter",
                this.handleKrispNoiseFilterDisable
              )),
            this.emit(TrackEvent.TrackProcessorUpdate, this.processor);
        } finally {
          B();
        }
      });
    }
    setAudioContext(j) {
      this.audioContext = j;
    }
    getSenderStats() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        if (!(!((j = this.sender) === null || j === void 0) && j.getStats))
          return;
        const V = yield this.sender.getStats();
        let B;
        return (
          V.forEach((q) => {
            q.type === "outbound-rtp" &&
              (B = {
                type: "audio",
                streamId: q.id,
                packetsSent: q.packetsSent,
                packetsLost: q.packetsLost,
                bytesSent: q.bytesSent,
                timestamp: q.timestamp,
                roundTripTime: q.roundTripTime,
                jitter: q.jitter,
              });
          }),
          B
        );
      });
    }
    checkForSilence() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const j = yield detectSilence(this);
        return (
          j &&
            (this.isMuted ||
              this.log.warn(
                "silence detected on local audio track",
                this.logContext
              ),
            this.emit(TrackEvent.AudioSilenceDetected)),
          j
        );
      });
    }
  }
  function mediaTrackToLocalTrack(U, j, V) {
    switch (U.kind) {
      case "audio":
        return new LocalAudioTrack(U, j, !1, void 0, V);
      case "video":
        return new LocalVideoTrack(U, j, !1, V);
      default:
        throw new TrackInvalidError("unsupported track type: ".concat(U.kind));
    }
  }
  const presets169 = Object.values(VideoPresets),
    presets43 = Object.values(VideoPresets43),
    presetsScreenShare = Object.values(ScreenSharePresets),
    defaultSimulcastPresets169 = [VideoPresets.h180, VideoPresets.h360],
    defaultSimulcastPresets43 = [VideoPresets43.h180, VideoPresets43.h360],
    computeDefaultScreenShareSimulcastPresets = (U) =>
      [{ scaleResolutionDownBy: 2, fps: U.encoding.maxFramerate }].map((V) => {
        var B, q;
        return new VideoPreset(
          Math.floor(U.width / V.scaleResolutionDownBy),
          Math.floor(U.height / V.scaleResolutionDownBy),
          Math.max(
            15e4,
            Math.floor(
              U.encoding.maxBitrate /
                (Math.pow(V.scaleResolutionDownBy, 2) *
                  (((B = U.encoding.maxFramerate) !== null && B !== void 0
                    ? B
                    : 30) /
                    ((q = V.fps) !== null && q !== void 0 ? q : 30)))
            )
          ),
          V.fps,
          U.encoding.priority
        );
      }),
    videoRids = ["q", "h", "f"];
  function computeVideoEncodings(U, j, V, B) {
    var q, $;
    let H = B?.videoEncoding;
    U && (H = B?.screenShareEncoding);
    const G = B?.simulcast,
      Y = B?.scalabilityMode,
      Q = B?.videoCodec;
    if ((!H && !G && !Y) || !j || !V) return [{}];
    H ||
      ((H = determineAppropriateEncoding(U, j, V, Q)),
      livekitLogger.debug("using video encoding", H));
    const X = H.maxFramerate,
      Z = new VideoPreset(j, V, H.maxBitrate, H.maxFramerate, H.priority);
    if (Y && isSVCCodec(Q)) {
      const ae = new ScalabilityMode(Y),
        se = [];
      if (ae.spatial > 3)
        throw new Error("unsupported scalabilityMode: ".concat(Y));
      const fe = getBrowser();
      if (
        isSafariBased() ||
        isReactNative() ||
        (fe?.name === "Chrome" && compareVersions(fe?.version, "113") < 0)
      ) {
        const ce = ae.suffix == "h" ? 2 : 3,
          ue = isSafariSvcApi(fe);
        for (let he = 0; he < ae.spatial; he += 1)
          se.push({
            rid: videoRids[2 - he],
            maxBitrate: H.maxBitrate / Math.pow(ce, he),
            maxFramerate: Z.encoding.maxFramerate,
            scaleResolutionDownBy: ue ? Math.pow(2, he) : void 0,
          });
        se[0].scalabilityMode = Y;
      } else
        se.push({
          maxBitrate: H.maxBitrate,
          maxFramerate: Z.encoding.maxFramerate,
          scalabilityMode: Y,
        });
      return (
        Z.encoding.priority &&
          ((se[0].priority = Z.encoding.priority),
          (se[0].networkPriority = Z.encoding.priority)),
        livekitLogger.debug("using svc encoding", { encodings: se }),
        se
      );
    }
    if (!G) return [H];
    let te = [];
    U
      ? (te =
          (q = sortPresets(B?.screenShareSimulcastLayers)) !== null &&
          q !== void 0
            ? q
            : defaultSimulcastLayers(U, Z))
      : (te =
          ($ = sortPresets(B?.videoSimulcastLayers)) !== null && $ !== void 0
            ? $
            : defaultSimulcastLayers(U, Z));
    let ne;
    if (te.length > 0) {
      const ae = te[0];
      te.length > 1 && ([, ne] = te);
      const se = Math.max(j, V);
      if (se >= 960 && ne) return encodingsFromPresets(j, V, [ae, ne, Z], X);
      if (se >= 480) return encodingsFromPresets(j, V, [ae, Z], X);
    }
    return encodingsFromPresets(j, V, [Z]);
  }
  function computeTrackBackupEncodings(U, j, V) {
    var B, q, $, H;
    if (
      !V.backupCodec ||
      V.backupCodec === !0 ||
      V.backupCodec.codec === V.videoCodec
    )
      return;
    j !== V.backupCodec.codec &&
      livekitLogger.warn(
        "requested a different codec than specified as backup",
        { serverRequested: j, backup: V.backupCodec.codec }
      ),
      (V.videoCodec = j),
      (V.videoEncoding = V.backupCodec.encoding);
    const G = U.mediaStreamTrack.getSettings(),
      Y =
        (B = G.width) !== null && B !== void 0
          ? B
          : (q = U.dimensions) === null || q === void 0
          ? void 0
          : q.width,
      Q =
        ($ = G.height) !== null && $ !== void 0
          ? $
          : (H = U.dimensions) === null || H === void 0
          ? void 0
          : H.height;
    return (
      U.source === Track.Source.ScreenShare &&
        V.simulcast &&
        (V.simulcast = !1),
      computeVideoEncodings(U.source === Track.Source.ScreenShare, Y, Q, V)
    );
  }
  function determineAppropriateEncoding(U, j, V, B) {
    const q = presetsForResolution(U, j, V);
    let { encoding: $ } = q[0];
    const H = Math.max(j, V);
    for (let G = 0; G < q.length; G += 1) {
      const Y = q[G];
      if ((($ = Y.encoding), Y.width >= H)) break;
    }
    if (B)
      switch (B) {
        case "av1":
        case "h265":
          ($ = Object.assign({}, $)), ($.maxBitrate = $.maxBitrate * 0.7);
          break;
        case "vp9":
          ($ = Object.assign({}, $)), ($.maxBitrate = $.maxBitrate * 0.85);
          break;
      }
    return $;
  }
  function presetsForResolution(U, j, V) {
    if (U) return presetsScreenShare;
    const B = j > V ? j / V : V / j;
    return Math.abs(B - 16 / 9) < Math.abs(B - 4 / 3) ? presets169 : presets43;
  }
  function defaultSimulcastLayers(U, j) {
    if (U) return computeDefaultScreenShareSimulcastPresets(j);
    const { width: V, height: B } = j,
      q = V > B ? V / B : B / V;
    return Math.abs(q - 16 / 9) < Math.abs(q - 4 / 3)
      ? defaultSimulcastPresets169
      : defaultSimulcastPresets43;
  }
  function encodingsFromPresets(U, j, V, B) {
    const q = [];
    if (
      (V.forEach(($, H) => {
        if (H >= videoRids.length) return;
        const G = Math.min(U, j),
          Q = {
            rid: videoRids[H],
            scaleResolutionDownBy: Math.max(1, G / Math.min($.width, $.height)),
            maxBitrate: $.encoding.maxBitrate,
          },
          X =
            B && $.encoding.maxFramerate
              ? Math.min(B, $.encoding.maxFramerate)
              : $.encoding.maxFramerate;
        X && (Q.maxFramerate = X);
        const Z = isFireFox() || H === 0;
        $.encoding.priority &&
          Z &&
          ((Q.priority = $.encoding.priority),
          (Q.networkPriority = $.encoding.priority)),
          q.push(Q);
      }),
      isReactNative() && getReactNativeOs() === "ios")
    ) {
      let $;
      q.forEach((G) => {
        $
          ? G.maxFramerate && G.maxFramerate > $ && ($ = G.maxFramerate)
          : ($ = G.maxFramerate);
      });
      let H = !0;
      q.forEach((G) => {
        var Y;
        G.maxFramerate != $ &&
          (H &&
            ((H = !1),
            livekitLogger.info(
              "Simulcast on iOS React-Native requires all encodings to share the same framerate."
            )),
          livekitLogger.info(
            'Setting framerate of encoding "'
              .concat((Y = G.rid) !== null && Y !== void 0 ? Y : "", '" to ')
              .concat($)
          ),
          (G.maxFramerate = $));
      });
    }
    return q;
  }
  function sortPresets(U) {
    if (U)
      return U.sort((j, V) => {
        const { encoding: B } = j,
          { encoding: q } = V;
        return B.maxBitrate > q.maxBitrate
          ? 1
          : B.maxBitrate < q.maxBitrate
          ? -1
          : B.maxBitrate === q.maxBitrate && B.maxFramerate && q.maxFramerate
          ? B.maxFramerate > q.maxFramerate
            ? 1
            : -1
          : 0;
      });
  }
  class ScalabilityMode {
    constructor(j) {
      const V = j.match(/^L(\d)T(\d)(h|_KEY|_KEY_SHIFT){0,1}$/);
      if (!V) throw new Error("invalid scalability mode");
      if (
        ((this.spatial = parseInt(V[1])),
        (this.temporal = parseInt(V[2])),
        V.length > 3)
      )
        switch (V[3]) {
          case "h":
          case "_KEY":
          case "_KEY_SHIFT":
            this.suffix = V[3];
        }
    }
    toString() {
      var j;
      return "L"
        .concat(this.spatial, "T")
        .concat(this.temporal)
        .concat((j = this.suffix) !== null && j !== void 0 ? j : "");
    }
  }
  function getDefaultDegradationPreference(U) {
    return U.source === Track.Source.ScreenShare ||
      (U.constraints.height && unwrapConstraint(U.constraints.height) >= 1080)
      ? "maintain-resolution"
      : "balanced";
  }
  const refreshSubscribedCodecAfterNewCodec = 5e3;
  class LocalVideoTrack extends LocalTrack {
    get sender() {
      return this._sender;
    }
    set sender(j) {
      (this._sender = j),
        this.degradationPreference &&
          this.setDegradationPreference(this.degradationPreference);
    }
    constructor(j, V) {
      let B =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0,
        q = arguments.length > 3 ? arguments[3] : void 0;
      super(j, Track.Kind.Video, V, B, q),
        (this.simulcastCodecs = new Map()),
        (this.degradationPreference = "balanced"),
        (this.isCpuConstrained = !1),
        (this.optimizeForPerformance = !1),
        (this.monitorSender = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (!this.sender) {
              this._currentBitrate = 0;
              return;
            }
            let $;
            try {
              $ = yield this.getSenderStats();
            } catch (Y) {
              this.log.error(
                "could not get video sender stats",
                Object.assign(Object.assign({}, this.logContext), { error: Y })
              );
              return;
            }
            const H = new Map($.map((Y) => [Y.rid, Y])),
              G = $.some((Y) => Y.qualityLimitationReason === "cpu");
            if (
              (G !== this.isCpuConstrained &&
                ((this.isCpuConstrained = G),
                this.isCpuConstrained && this.emit(TrackEvent.CpuConstrained)),
              this.prevStats)
            ) {
              let Y = 0;
              H.forEach((Q, X) => {
                var Z;
                const te =
                  (Z = this.prevStats) === null || Z === void 0
                    ? void 0
                    : Z.get(X);
                Y += computeBitrate(Q, te);
              }),
                (this._currentBitrate = Y);
            }
            this.prevStats = H;
          })),
        (this.senderLock = new _$1());
    }
    get isSimulcast() {
      return !!(
        this.sender && this.sender.getParameters().encodings.length > 1
      );
    }
    startMonitor(j) {
      var V;
      if (((this.signalClient = j), !isWeb())) return;
      const B =
        (V = this.sender) === null || V === void 0 ? void 0 : V.getParameters();
      B && (this.encodings = B.encodings),
        !this.monitorInterval &&
          (this.monitorInterval = setInterval(() => {
            this.monitorSender();
          }, monitorFrequency));
    }
    stop() {
      this._mediaStreamTrack.getConstraints(),
        this.simulcastCodecs.forEach((j) => {
          j.mediaStreamTrack.stop();
        }),
        super.stop();
    }
    pauseUpstream() {
      const j = Object.create(null, {
        pauseUpstream: { get: () => super.pauseUpstream },
      });
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q, $, H;
        yield j.pauseUpstream.call(this);
        try {
          for (
            var G = !0, Y = __asyncValues(this.simulcastCodecs.values()), Q;
            (Q = yield Y.next()), (V = Q.done), !V;
            G = !0
          )
            ($ = Q.value),
              (G = !1),
              yield (H = $.sender) === null || H === void 0
                ? void 0
                : H.replaceTrack(null);
        } catch (X) {
          B = { error: X };
        } finally {
          try {
            !G && !V && (q = Y.return) && (yield q.call(Y));
          } finally {
            if (B) throw B.error;
          }
        }
      });
    }
    resumeUpstream() {
      const j = Object.create(null, {
        resumeUpstream: { get: () => super.resumeUpstream },
      });
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q, $, H;
        yield j.resumeUpstream.call(this);
        try {
          for (
            var G = !0, Y = __asyncValues(this.simulcastCodecs.values()), Q;
            (Q = yield Y.next()), (V = Q.done), !V;
            G = !0
          ) {
            ($ = Q.value), (G = !1);
            const X = $;
            yield (H = X.sender) === null || H === void 0
              ? void 0
              : H.replaceTrack(X.mediaStreamTrack);
          }
        } catch (X) {
          B = { error: X };
        } finally {
          try {
            !G && !V && (q = Y.return) && (yield q.call(Y));
          } finally {
            if (B) throw B.error;
          }
        }
      });
    }
    mute() {
      const j = Object.create(null, { mute: { get: () => super.mute } });
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = yield this.muteLock.lock();
        try {
          return this.isMuted
            ? (this.log.debug("Track already muted", this.logContext), this)
            : (this.source === Track.Source.Camera &&
                !this.isUserProvided &&
                (this.log.debug("stopping camera track", this.logContext),
                this._mediaStreamTrack.stop()),
              yield j.mute.call(this),
              this);
        } finally {
          V();
        }
      });
    }
    unmute() {
      const j = Object.create(null, { unmute: { get: () => super.unmute } });
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = yield this.muteLock.lock();
        try {
          return this.isMuted
            ? (this.source === Track.Source.Camera &&
                !this.isUserProvided &&
                (this.log.debug("reacquiring camera track", this.logContext),
                yield this.restartTrack()),
              yield j.unmute.call(this),
              this)
            : (this.log.debug("Track already unmuted", this.logContext), this);
        } finally {
          V();
        }
      });
    }
    setTrackMuted(j) {
      super.setTrackMuted(j);
      for (const V of this.simulcastCodecs.values())
        V.mediaStreamTrack.enabled = !j;
    }
    getSenderStats() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        if (!(!((j = this.sender) === null || j === void 0) && j.getStats))
          return [];
        const V = [],
          B = yield this.sender.getStats();
        return (
          B.forEach((q) => {
            var $;
            if (q.type === "outbound-rtp") {
              const H = {
                  type: "video",
                  streamId: q.id,
                  frameHeight: q.frameHeight,
                  frameWidth: q.frameWidth,
                  framesPerSecond: q.framesPerSecond,
                  framesSent: q.framesSent,
                  firCount: q.firCount,
                  pliCount: q.pliCount,
                  nackCount: q.nackCount,
                  packetsSent: q.packetsSent,
                  bytesSent: q.bytesSent,
                  qualityLimitationReason: q.qualityLimitationReason,
                  qualityLimitationDurations: q.qualityLimitationDurations,
                  qualityLimitationResolutionChanges:
                    q.qualityLimitationResolutionChanges,
                  rid: ($ = q.rid) !== null && $ !== void 0 ? $ : q.id,
                  retransmittedPacketsSent: q.retransmittedPacketsSent,
                  targetBitrate: q.targetBitrate,
                  timestamp: q.timestamp,
                },
                G = B.get(q.remoteId);
              G &&
                ((H.jitter = G.jitter),
                (H.packetsLost = G.packetsLost),
                (H.roundTripTime = G.roundTripTime)),
                V.push(H);
            }
          }),
          V.sort((q, $) => {
            var H, G;
            return (
              ((H = $.frameWidth) !== null && H !== void 0 ? H : 0) -
              ((G = q.frameWidth) !== null && G !== void 0 ? G : 0)
            );
          }),
          V
        );
      });
    }
    setPublishingQuality(j) {
      const V = [];
      for (let B = VideoQuality.LOW; B <= VideoQuality.HIGH; B += 1)
        V.push(new SubscribedQuality({ quality: B, enabled: B <= j }));
      this.log.debug(
        "setting publishing quality. max quality ".concat(j),
        this.logContext
      ),
        this.setPublishingLayers(isSVCCodec(this.codec), V);
    }
    restartTrack(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q, $, H;
        let G;
        if (j) {
          const Z = constraintsForOptions({ video: j });
          typeof Z.video != "boolean" && (G = Z.video);
        }
        yield this.restart(G), (this.isCpuConstrained = !1);
        try {
          for (
            var Y = !0, Q = __asyncValues(this.simulcastCodecs.values()), X;
            (X = yield Q.next()), (V = X.done), !V;
            Y = !0
          ) {
            ($ = X.value), (Y = !1);
            const Z = $;
            Z.sender &&
              ((H = Z.sender.transport) === null || H === void 0
                ? void 0
                : H.state) !== "closed" &&
              ((Z.mediaStreamTrack = this.mediaStreamTrack.clone()),
              yield Z.sender.replaceTrack(Z.mediaStreamTrack));
          }
        } catch (Z) {
          B = { error: Z };
        } finally {
          try {
            !Y && !V && (q = Q.return) && (yield q.call(Q));
          } finally {
            if (B) throw B.error;
          }
        }
      });
    }
    setProcessor(j) {
      const V = Object.create(null, {
        setProcessor: { get: () => super.setProcessor },
      });
      return __awaiter$1(this, arguments, void 0, function (B) {
        var q = this;
        let $ =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return (function* () {
          var H, G, Y, Q, X, Z;
          if (
            (yield V.setProcessor.call(q, B, $),
            !((X = q.processor) === null || X === void 0) && X.processedTrack)
          )
            try {
              for (
                var te = !0, ne = __asyncValues(q.simulcastCodecs.values()), ae;
                (ae = yield ne.next()), (H = ae.done), !H;
                te = !0
              )
                (Q = ae.value),
                  (te = !1),
                  yield (Z = Q.sender) === null || Z === void 0
                    ? void 0
                    : Z.replaceTrack(q.processor.processedTrack);
            } catch (se) {
              G = { error: se };
            } finally {
              try {
                !te && !H && (Y = ne.return) && (yield Y.call(ne));
              } finally {
                if (G) throw G.error;
              }
            }
        })();
      });
    }
    setDegradationPreference(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (((this.degradationPreference = j), this.sender))
          try {
            this.log.debug(
              "setting degradationPreference to ".concat(j),
              this.logContext
            );
            const V = this.sender.getParameters();
            (V.degradationPreference = j), this.sender.setParameters(V);
          } catch (V) {
            this.log.warn(
              "failed to set degradationPreference",
              Object.assign({ error: V }, this.logContext)
            );
          }
      });
    }
    addSimulcastTrack(j, V) {
      if (this.simulcastCodecs.has(j)) {
        this.log.error(
          "".concat(j, " already added, skipping adding simulcast codec"),
          this.logContext
        );
        return;
      }
      const B = {
        codec: j,
        mediaStreamTrack: this.mediaStreamTrack.clone(),
        sender: void 0,
        encodings: V,
      };
      return this.simulcastCodecs.set(j, B), B;
    }
    setSimulcastTrackSender(j, V) {
      const B = this.simulcastCodecs.get(j);
      B &&
        ((B.sender = V),
        setTimeout(() => {
          this.subscribedCodecs &&
            this.setPublishingCodecs(this.subscribedCodecs);
        }, refreshSubscribedCodecAfterNewCodec));
    }
    setPublishingCodecs(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q, $, H, G, Y;
        if (
          (this.log.debug(
            "setting publishing codecs",
            Object.assign(Object.assign({}, this.logContext), {
              codecs: j,
              currentCodec: this.codec,
            })
          ),
          !this.codec && j.length > 0)
        )
          return (
            yield this.setPublishingLayers(
              isSVCCodec(j[0].codec),
              j[0].qualities
            ),
            []
          );
        this.subscribedCodecs = j;
        const Q = [];
        try {
          for (
            V = !0, B = __asyncValues(j);
            (q = yield B.next()), ($ = q.done), !$;
            V = !0
          ) {
            (Y = q.value), (V = !1);
            const X = Y;
            if (!this.codec || this.codec === X.codec)
              yield this.setPublishingLayers(isSVCCodec(X.codec), X.qualities);
            else {
              const Z = this.simulcastCodecs.get(X.codec);
              if (
                (this.log.debug(
                  "try setPublishingCodec for ".concat(X.codec),
                  Object.assign(Object.assign({}, this.logContext), {
                    simulcastCodecInfo: Z,
                  })
                ),
                !Z || !Z.sender)
              ) {
                for (const te of X.qualities)
                  if (te.enabled) {
                    Q.push(X.codec);
                    break;
                  }
              } else
                Z.encodings &&
                  (this.log.debug(
                    "try setPublishingLayersForSender ".concat(X.codec),
                    this.logContext
                  ),
                  yield setPublishingLayersForSender(
                    Z.sender,
                    Z.encodings,
                    X.qualities,
                    this.senderLock,
                    isSVCCodec(X.codec),
                    this.log,
                    this.logContext
                  ));
            }
          }
        } catch (X) {
          H = { error: X };
        } finally {
          try {
            !V && !$ && (G = B.return) && (yield G.call(B));
          } finally {
            if (H) throw H.error;
          }
        }
        return Q;
      });
    }
    setPublishingLayers(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.optimizeForPerformance) {
          this.log.info(
            "skipping setPublishingLayers due to optimized publishing performance",
            Object.assign(Object.assign({}, this.logContext), { qualities: V })
          );
          return;
        }
        this.log.debug(
          "setting publishing layers",
          Object.assign(Object.assign({}, this.logContext), { qualities: V })
        ),
          !(!this.sender || !this.encodings) &&
            (yield setPublishingLayersForSender(
              this.sender,
              this.encodings,
              V,
              this.senderLock,
              j,
              this.log,
              this.logContext
            ));
      });
    }
    prioritizePerformance() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.sender) throw new Error("sender not found");
        const j = yield this.senderLock.lock();
        try {
          this.optimizeForPerformance = !0;
          const V = this.sender.getParameters();
          (V.encodings = V.encodings.map((B, q) => {
            var $;
            return Object.assign(Object.assign({}, B), {
              active: q === 0,
              scaleResolutionDownBy: Math.max(
                1,
                Math.ceil(
                  (($ = this.mediaStreamTrack.getSettings().height) !== null &&
                  $ !== void 0
                    ? $
                    : 360) / 360
                )
              ),
              scalabilityMode:
                q === 0 && isSVCCodec(this.codec) ? "L1T3" : void 0,
              maxFramerate: q === 0 ? 15 : 0,
              maxBitrate: q === 0 ? B.maxBitrate : 0,
            });
          })),
            this.log.debug(
              "setting performance optimised encodings",
              Object.assign(Object.assign({}, this.logContext), {
                encodings: V.encodings,
              })
            ),
            (this.encodings = V.encodings),
            yield this.sender.setParameters(V);
        } catch (V) {
          this.log.error(
            "failed to set performance optimised encodings",
            Object.assign(Object.assign({}, this.logContext), { error: V })
          ),
            (this.optimizeForPerformance = !1);
        } finally {
          j();
        }
      });
    }
    handleAppVisibilityChanged() {
      const j = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter$1(this, void 0, void 0, function* () {
        yield j.handleAppVisibilityChanged.call(this),
          isMobile() &&
            this.isInBackground &&
            this.source === Track.Source.Camera &&
            (this._mediaStreamTrack.enabled = !1);
      });
    }
  }
  function setPublishingLayersForSender(U, j, V, B, q, $, H) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const G = yield B.lock();
      $.debug(
        "setPublishingLayersForSender",
        Object.assign(Object.assign({}, H), {
          sender: U,
          qualities: V,
          senderEncodings: j,
        })
      );
      try {
        const Y = U.getParameters(),
          { encodings: Q } = Y;
        if (!Q) return;
        if (Q.length !== j.length) {
          $.warn(
            "cannot set publishing layers, encodings mismatch",
            Object.assign(Object.assign({}, H), {
              encodings: Q,
              senderEncodings: j,
            })
          );
          return;
        }
        let X = !1;
        (!1 && Q[0].scalabilityMode) ||
          (q &&
            V.some((ne) => ne.enabled) &&
            V.forEach((ne) => (ne.enabled = !0)),
          Q.forEach((te, ne) => {
            var ae;
            let se = (ae = te.rid) !== null && ae !== void 0 ? ae : "";
            se === "" && (se = "q");
            const fe = videoQualityForRid(se),
              ce = V.find((ue) => ue.quality === fe);
            ce &&
              te.active !== ce.enabled &&
              ((X = !0),
              (te.active = ce.enabled),
              $.debug(
                "setting layer "
                  .concat(ce.quality, " to ")
                  .concat(te.active ? "enabled" : "disabled"),
                H
              ),
              isFireFox() &&
                (ce.enabled
                  ? ((te.scaleResolutionDownBy = j[ne].scaleResolutionDownBy),
                    (te.maxBitrate = j[ne].maxBitrate),
                    (te.maxFrameRate = j[ne].maxFrameRate))
                  : ((te.scaleResolutionDownBy = 4),
                    (te.maxBitrate = 10),
                    (te.maxFrameRate = 2))));
          })),
          X &&
            ((Y.encodings = Q),
            $.debug(
              "setting encodings",
              Object.assign(Object.assign({}, H), { encodings: Y.encodings })
            ),
            yield U.setParameters(Y));
      } finally {
        G();
      }
    });
  }
  function videoQualityForRid(U) {
    switch (U) {
      case "f":
        return VideoQuality.HIGH;
      case "h":
        return VideoQuality.MEDIUM;
      case "q":
        return VideoQuality.LOW;
      default:
        return VideoQuality.HIGH;
    }
  }
  function videoLayersFromEncodings(U, j, V, B) {
    if (!V)
      return [
        new VideoLayer({
          quality: VideoQuality.HIGH,
          width: U,
          height: j,
          bitrate: 0,
          ssrc: 0,
        }),
      ];
    if (B) {
      const q = V[0].scalabilityMode,
        $ = new ScalabilityMode(q),
        H = [],
        G = $.suffix == "h" ? 1.5 : 2,
        Y = $.suffix == "h" ? 2 : 3;
      for (let Q = 0; Q < $.spatial; Q += 1)
        H.push(
          new VideoLayer({
            quality: Math.min(VideoQuality.HIGH, $.spatial - 1) - Q,
            width: Math.ceil(U / Math.pow(G, Q)),
            height: Math.ceil(j / Math.pow(G, Q)),
            bitrate: V[0].maxBitrate
              ? Math.ceil(V[0].maxBitrate / Math.pow(Y, Q))
              : 0,
            ssrc: 0,
          })
        );
      return H;
    }
    return V.map((q) => {
      var $, H, G;
      const Y = ($ = q.scaleResolutionDownBy) !== null && $ !== void 0 ? $ : 1;
      let Q = videoQualityForRid((H = q.rid) !== null && H !== void 0 ? H : "");
      return new VideoLayer({
        quality: Q,
        width: Math.ceil(U / Y),
        height: Math.ceil(j / Y),
        bitrate: (G = q.maxBitrate) !== null && G !== void 0 ? G : 0,
        ssrc: 0,
      });
    });
  }
  const lossyDataChannel = "_lossy",
    reliableDataChannel = "_reliable",
    minReconnectWait = 2 * 1e3,
    leaveReconnect = "leave-reconnect",
    reliabeReceiveStateTTL = 3e4;
  var PCState;
  (function (U) {
    (U[(U.New = 0)] = "New"),
      (U[(U.Connected = 1)] = "Connected"),
      (U[(U.Disconnected = 2)] = "Disconnected"),
      (U[(U.Reconnecting = 3)] = "Reconnecting"),
      (U[(U.Closed = 4)] = "Closed");
  })(PCState || (PCState = {}));
  class RTCEngine extends eventsExports.EventEmitter {
    get isClosed() {
      return this._isClosed;
    }
    get pendingReconnect() {
      return !!this.reconnectTimeout;
    }
    constructor(j) {
      var V;
      super(),
        (this.options = j),
        (this.rtcConfig = {}),
        (this.peerConnectionTimeout =
          roomConnectOptionDefaults.peerConnectionTimeout),
        (this.fullReconnectOnNext = !1),
        (this.latestRemoteOfferId = 0),
        (this.subscriberPrimary = !1),
        (this.pcState = PCState.New),
        (this._isClosed = !0),
        (this.pendingTrackResolvers = {}),
        (this.reconnectAttempts = 0),
        (this.reconnectStart = 0),
        (this.attemptingReconnect = !1),
        (this.joinAttempts = 0),
        (this.maxJoinAttempts = 1),
        (this.shouldFailNext = !1),
        (this.log = livekitLogger),
        (this.reliableDataSequence = 1),
        (this.reliableMessageBuffer = new DataPacketBuffer()),
        (this.reliableReceivedState = new TTLMap(reliabeReceiveStateTTL)),
        (this.handleDataChannel = (B) =>
          __awaiter$1(this, [B], void 0, function (q) {
            var $ = this;
            let { channel: H } = q;
            return (function* () {
              if (H) {
                if (H.label === reliableDataChannel) $.reliableDCSub = H;
                else if (H.label === lossyDataChannel) $.lossyDCSub = H;
                else return;
                $.log.debug(
                  "on data channel ".concat(H.id, ", ").concat(H.label),
                  $.logContext
                ),
                  (H.onmessage = $.handleDataMessage);
              }
            })();
          })),
        (this.handleDataMessage = (B) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var q, $;
            const H = yield this.dataProcessLock.lock();
            try {
              let G;
              if (B.data instanceof ArrayBuffer) G = B.data;
              else if (B.data instanceof Blob) G = yield B.data.arrayBuffer();
              else {
                this.log.error(
                  "unsupported data type",
                  Object.assign(Object.assign({}, this.logContext), {
                    data: B.data,
                  })
                );
                return;
              }
              const Y = DataPacket.fromBinary(new Uint8Array(G));
              if (Y.sequence > 0 && Y.participantSid !== "") {
                const Q = this.reliableReceivedState.get(Y.participantSid);
                if (Q && Y.sequence <= Q) return;
                this.reliableReceivedState.set(Y.participantSid, Y.sequence);
              }
              ((q = Y.value) === null || q === void 0 ? void 0 : q.case) ===
              "speaker"
                ? this.emit(
                    EngineEvent.ActiveSpeakersUpdate,
                    Y.value.value.speakers
                  )
                : ((($ = Y.value) === null || $ === void 0
                    ? void 0
                    : $.case) === "user" &&
                    applyUserDataCompat(Y, Y.value.value),
                  this.emit(EngineEvent.DataPacketReceived, Y));
            } finally {
              H();
            }
          })),
        (this.handleDataError = (B) => {
          const $ = B.currentTarget.maxRetransmits === 0 ? "lossy" : "reliable";
          if (B instanceof ErrorEvent && B.error) {
            const { error: H } = B.error;
            this.log.error(
              "DataChannel error on ".concat($, ": ").concat(B.message),
              Object.assign(Object.assign({}, this.logContext), { error: H })
            );
          } else
            this.log.error(
              "Unknown DataChannel error on ".concat($),
              Object.assign(Object.assign({}, this.logContext), { event: B })
            );
        }),
        (this.handleBufferedAmountLow = (B) => {
          const $ =
            B.currentTarget.maxRetransmits === 0
              ? DataPacket_Kind.LOSSY
              : DataPacket_Kind.RELIABLE;
          this.updateAndEmitDCBufferStatus($);
        }),
        (this.handleDisconnect = (B, q) => {
          if (this._isClosed) return;
          this.log.warn("".concat(B, " disconnected"), this.logContext),
            this.reconnectAttempts === 0 && (this.reconnectStart = Date.now());
          const $ = (Y) => {
              this.log.warn(
                "could not recover connection after "
                  .concat(this.reconnectAttempts, " attempts, ")
                  .concat(Y, "ms. giving up"),
                this.logContext
              ),
                this.emit(EngineEvent.Disconnected),
                this.close();
            },
            H = Date.now() - this.reconnectStart;
          let G = this.getNextRetryDelay({
            elapsedMs: H,
            retryCount: this.reconnectAttempts,
          });
          if (G === null) {
            $(H);
            return;
          }
          B === leaveReconnect && (G = 0),
            this.log.debug("reconnecting in ".concat(G, "ms"), this.logContext),
            this.clearReconnectTimeout(),
            this.token &&
              this.regionUrlProvider &&
              this.regionUrlProvider.updateToken(this.token),
            (this.reconnectTimeout = CriticalTimers.setTimeout(
              () =>
                this.attemptReconnect(q).finally(
                  () => (this.reconnectTimeout = void 0)
                ),
              G
            ));
        }),
        (this.waitForRestarted = () =>
          new Promise((B, q) => {
            this.pcState === PCState.Connected && B();
            const $ = () => {
                this.off(EngineEvent.Disconnected, H), B();
              },
              H = () => {
                this.off(EngineEvent.Restarted, $), q();
              };
            this.once(EngineEvent.Restarted, $),
              this.once(EngineEvent.Disconnected, H);
          })),
        (this.updateAndEmitDCBufferStatus = (B) => {
          const q = this.isBufferStatusLow(B);
          typeof q < "u" &&
            q !== this.dcBufferStatus.get(B) &&
            (this.dcBufferStatus.set(B, q),
            this.emit(EngineEvent.DCBufferStatusChanged, q, B));
        }),
        (this.isBufferStatusLow = (B) => {
          const q = this.dataChannelForKind(B);
          if (q)
            return (
              B === DataPacket_Kind.RELIABLE &&
                this.reliableMessageBuffer.alignBufferedAmount(
                  q.bufferedAmount
                ),
              q.bufferedAmount <= q.bufferedAmountLowThreshold
            );
        }),
        (this.handleBrowserOnLine = () => {
          this.client.currentState === SignalConnectionState.RECONNECTING &&
            (this.clearReconnectTimeout(),
            this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED));
        }),
        (this.log = getLogger(
          (V = j.loggerName) !== null && V !== void 0 ? V : LoggerNames.Engine
        )),
        (this.loggerOptions = {
          loggerName: j.loggerName,
          loggerContextCb: () => this.logContext,
        }),
        (this.client = new SignalClient(void 0, this.loggerOptions)),
        (this.client.signalLatency = this.options.expSignalLatency),
        (this.reconnectPolicy = this.options.reconnectPolicy),
        this.registerOnLineListener(),
        (this.closingLock = new _$1()),
        (this.dataProcessLock = new _$1()),
        (this.dcBufferStatus = new Map([
          [DataPacket_Kind.LOSSY, !0],
          [DataPacket_Kind.RELIABLE, !0],
        ])),
        (this.client.onParticipantUpdate = (B) =>
          this.emit(EngineEvent.ParticipantUpdate, B)),
        (this.client.onConnectionQuality = (B) =>
          this.emit(EngineEvent.ConnectionQualityUpdate, B)),
        (this.client.onRoomUpdate = (B) =>
          this.emit(EngineEvent.RoomUpdate, B)),
        (this.client.onSubscriptionError = (B) =>
          this.emit(EngineEvent.SubscriptionError, B)),
        (this.client.onSubscriptionPermissionUpdate = (B) =>
          this.emit(EngineEvent.SubscriptionPermissionUpdate, B)),
        (this.client.onSpeakersChanged = (B) =>
          this.emit(EngineEvent.SpeakersChanged, B)),
        (this.client.onStreamStateUpdate = (B) =>
          this.emit(EngineEvent.StreamStateChanged, B)),
        (this.client.onRequestResponse = (B) =>
          this.emit(EngineEvent.SignalRequestResponse, B));
    }
    get logContext() {
      var j, V, B, q, $, H;
      return {
        room:
          (V =
            (j = this.latestJoinResponse) === null || j === void 0
              ? void 0
              : j.room) === null || V === void 0
            ? void 0
            : V.name,
        roomID:
          (q =
            (B = this.latestJoinResponse) === null || B === void 0
              ? void 0
              : B.room) === null || q === void 0
            ? void 0
            : q.sid,
        participant:
          (H =
            ($ = this.latestJoinResponse) === null || $ === void 0
              ? void 0
              : $.participant) === null || H === void 0
            ? void 0
            : H.identity,
        pID: this.participantSid,
      };
    }
    join(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.url = j),
          (this.token = V),
          (this.signalOpts = B),
          (this.maxJoinAttempts = B.maxRetries);
        try {
          (this.joinAttempts += 1), this.setupSignalClientCallbacks();
          const $ = yield this.client.join(j, V, B, q);
          return (
            (this._isClosed = !1),
            (this.latestJoinResponse = $),
            (this.subscriberPrimary = $.subscriberPrimary),
            this.pcManager || (yield this.configure($)),
            (!this.subscriberPrimary || $.fastPublish) && this.negotiate(),
            (this.clientConfiguration = $.clientConfiguration),
            this.emit(EngineEvent.SignalConnected, $),
            $
          );
        } catch ($) {
          if (
            $ instanceof ConnectionError &&
            $.reason === ConnectionErrorReason.ServerUnreachable &&
            (this.log.warn(
              "Couldn't connect to server, attempt "
                .concat(this.joinAttempts, " of ")
                .concat(this.maxJoinAttempts),
              this.logContext
            ),
            this.joinAttempts < this.maxJoinAttempts)
          )
            return this.join(j, V, B, q);
          throw $;
        }
      });
    }
    close() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const j = yield this.closingLock.lock();
        if (this.isClosed) {
          j();
          return;
        }
        try {
          (this._isClosed = !0),
            (this.joinAttempts = 0),
            this.emit(EngineEvent.Closing),
            this.removeAllListeners(),
            this.deregisterOnLineListener(),
            this.clearPendingReconnect(),
            yield this.cleanupPeerConnections(),
            yield this.cleanupClient();
        } finally {
          j();
        }
      });
    }
    cleanupPeerConnections() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        yield (j = this.pcManager) === null || j === void 0
          ? void 0
          : j.close(),
          (this.pcManager = void 0);
        const V = (B) => {
          B &&
            (B.close(),
            (B.onbufferedamountlow = null),
            (B.onclose = null),
            (B.onclosing = null),
            (B.onerror = null),
            (B.onmessage = null),
            (B.onopen = null));
        };
        V(this.lossyDC),
          V(this.lossyDCSub),
          V(this.reliableDC),
          V(this.reliableDCSub),
          (this.lossyDC = void 0),
          (this.lossyDCSub = void 0),
          (this.reliableDC = void 0),
          (this.reliableDCSub = void 0),
          (this.reliableMessageBuffer = new DataPacketBuffer()),
          (this.reliableDataSequence = 1),
          this.reliableReceivedState.clear();
      });
    }
    cleanupClient() {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.client.close(), this.client.resetCallbacks();
      });
    }
    addTrack(j) {
      if (this.pendingTrackResolvers[j.cid])
        throw new TrackInvalidError(
          "a track with the same ID has already been published"
        );
      return new Promise((V, B) => {
        const q = setTimeout(() => {
          delete this.pendingTrackResolvers[j.cid],
            B(
              new ConnectionError(
                "publication of local track timed out, no response from server",
                ConnectionErrorReason.Timeout
              )
            );
        }, 1e4);
        (this.pendingTrackResolvers[j.cid] = {
          resolve: ($) => {
            clearTimeout(q), V($);
          },
          reject: () => {
            clearTimeout(q),
              B(new Error("Cancelled publication by calling unpublish"));
          },
        }),
          this.client.sendAddTrack(j);
      });
    }
    removeTrack(j) {
      if (j.track && this.pendingTrackResolvers[j.track.id]) {
        const { reject: V } = this.pendingTrackResolvers[j.track.id];
        V && V(), delete this.pendingTrackResolvers[j.track.id];
      }
      try {
        return this.pcManager.removeTrack(j), !0;
      } catch (V) {
        this.log.warn(
          "failed to remove track",
          Object.assign(Object.assign({}, this.logContext), { error: V })
        );
      }
      return !1;
    }
    updateMuteStatus(j, V) {
      this.client.sendMuteTrack(j, V);
    }
    get dataSubscriberReadyState() {
      var j;
      return (j = this.reliableDCSub) === null || j === void 0
        ? void 0
        : j.readyState;
    }
    getConnectedServerAddress() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        return (j = this.pcManager) === null || j === void 0
          ? void 0
          : j.getConnectedAddress();
      });
    }
    setRegionUrlProvider(j) {
      this.regionUrlProvider = j;
    }
    configure(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B;
        if (
          this.pcManager &&
          this.pcManager.currentState !== PCTransportState.NEW
        )
          return;
        this.participantSid =
          (V = j.participant) === null || V === void 0 ? void 0 : V.sid;
        const q = this.makeRTCConfiguration(j);
        (this.pcManager = new PCTransportManager(
          q,
          j.subscriberPrimary,
          this.loggerOptions
        )),
          this.emit(
            EngineEvent.TransportsCreated,
            this.pcManager.publisher,
            this.pcManager.subscriber
          ),
          (this.pcManager.onIceCandidate = ($, H) => {
            this.client.sendIceCandidate($, H);
          }),
          (this.pcManager.onPublisherOffer = ($, H) => {
            this.client.sendOffer($, H);
          }),
          (this.pcManager.onDataChannel = this.handleDataChannel),
          (this.pcManager.onStateChange = ($, H, G) =>
            __awaiter$1(this, void 0, void 0, function* () {
              if (
                (this.log.debug(
                  "primary PC state changed ".concat($),
                  this.logContext
                ),
                ["closed", "disconnected", "failed"].includes(H) &&
                  (this.publisherConnectionPromise = void 0),
                $ === PCTransportState.CONNECTED)
              ) {
                const X = this.pcState === PCState.New;
                (this.pcState = PCState.Connected),
                  X && this.emit(EngineEvent.Connected, j);
              } else $ === PCTransportState.FAILED && this.pcState === PCState.Connected && ((this.pcState = PCState.Disconnected), this.handleDisconnect("peerconnection failed", G === "failed" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED));
              const Y =
                  this.client.isDisconnected ||
                  this.client.currentState ===
                    SignalConnectionState.RECONNECTING,
                Q = [
                  PCTransportState.FAILED,
                  PCTransportState.CLOSING,
                  PCTransportState.CLOSED,
                ].includes($);
              Y && Q && !this._isClosed && this.emit(EngineEvent.Offline);
            })),
          (this.pcManager.onTrack = ($) => {
            this.emit(
              EngineEvent.MediaTrackAdded,
              $.track,
              $.streams[0],
              $.receiver
            );
          }),
          supportOptionalDatachannel(
            (B = j.serverInfo) === null || B === void 0 ? void 0 : B.protocol
          ) || this.createDataChannels();
      });
    }
    setupSignalClientCallbacks() {
      (this.client.onAnswer = (j, V) =>
        __awaiter$1(this, void 0, void 0, function* () {
          this.pcManager &&
            (this.log.debug(
              "received server answer",
              Object.assign(Object.assign({}, this.logContext), {
                RTCSdpType: j.type,
              })
            ),
            yield this.pcManager.setPublisherAnswer(j, V));
        })),
        (this.client.onTrickle = (j, V) => {
          this.pcManager &&
            (this.log.debug(
              "got ICE candidate from peer",
              Object.assign(Object.assign({}, this.logContext), {
                candidate: j,
                target: V,
              })
            ),
            this.pcManager.addIceCandidate(j, V));
        }),
        (this.client.onOffer = (j, V) =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (((this.latestRemoteOfferId = V), !this.pcManager)) return;
            const B = yield this.pcManager.createSubscriberAnswerFromOffer(
              j,
              V
            );
            B && this.client.sendAnswer(B, V);
          })),
        (this.client.onLocalTrackPublished = (j) => {
          var V;
          if (
            (this.log.debug(
              "received trackPublishedResponse",
              Object.assign(Object.assign({}, this.logContext), {
                cid: j.cid,
                track: (V = j.track) === null || V === void 0 ? void 0 : V.sid,
              })
            ),
            !this.pendingTrackResolvers[j.cid])
          ) {
            this.log.error(
              "missing track resolver for ".concat(j.cid),
              Object.assign(Object.assign({}, this.logContext), { cid: j.cid })
            );
            return;
          }
          const { resolve: B } = this.pendingTrackResolvers[j.cid];
          delete this.pendingTrackResolvers[j.cid], B(j.track);
        }),
        (this.client.onLocalTrackUnpublished = (j) => {
          this.emit(EngineEvent.LocalTrackUnpublished, j);
        }),
        (this.client.onLocalTrackSubscribed = (j) => {
          this.emit(EngineEvent.LocalTrackSubscribed, j);
        }),
        (this.client.onTokenRefresh = (j) => {
          this.token = j;
        }),
        (this.client.onRemoteMuteChanged = (j, V) => {
          this.emit(EngineEvent.RemoteMute, j, V);
        }),
        (this.client.onSubscribedQualityUpdate = (j) => {
          this.emit(EngineEvent.SubscribedQualityUpdate, j);
        }),
        (this.client.onRoomMoved = (j) => {
          var V;
          (this.participantSid =
            (V = j.participant) === null || V === void 0 ? void 0 : V.sid),
            this.latestJoinResponse && (this.latestJoinResponse.room = j.room),
            this.emit(EngineEvent.RoomMoved, j);
        }),
        (this.client.onClose = () => {
          this.handleDisconnect(
            "signal",
            ReconnectReason.RR_SIGNAL_DISCONNECTED
          );
        }),
        (this.client.onLeave = (j) => {
          switch (
            (this.log.debug(
              "client leave request",
              Object.assign(Object.assign({}, this.logContext), {
                reason: j?.reason,
              })
            ),
            j.regions &&
              this.regionUrlProvider &&
              (this.log.debug("updating regions", this.logContext),
              this.regionUrlProvider.setServerReportedRegions(j.regions)),
            j.action)
          ) {
            case LeaveRequest_Action.DISCONNECT:
              this.emit(EngineEvent.Disconnected, j?.reason), this.close();
              break;
            case LeaveRequest_Action.RECONNECT:
              (this.fullReconnectOnNext = !0),
                this.handleDisconnect(leaveReconnect);
              break;
            case LeaveRequest_Action.RESUME:
              this.handleDisconnect(leaveReconnect);
          }
        });
    }
    makeRTCConfiguration(j) {
      var V;
      const B = Object.assign({}, this.rtcConfig);
      if (
        (!((V = this.signalOpts) === null || V === void 0) &&
          V.e2eeEnabled &&
          (this.log.debug(
            "E2EE - setting up transports with insertable streams",
            this.logContext
          ),
          (B.encodedInsertableStreams = !0)),
        j.iceServers && !B.iceServers)
      ) {
        const q = [];
        j.iceServers.forEach(($) => {
          const H = { urls: $.urls };
          $.username && (H.username = $.username),
            $.credential && (H.credential = $.credential),
            q.push(H);
        }),
          (B.iceServers = q);
      }
      return (
        j.clientConfiguration &&
          j.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED &&
          (B.iceTransportPolicy = "relay"),
        (B.sdpSemantics = "unified-plan"),
        (B.continualGatheringPolicy = "gather_continually"),
        B
      );
    }
    createDataChannels() {
      this.pcManager &&
        (this.lossyDC &&
          ((this.lossyDC.onmessage = null), (this.lossyDC.onerror = null)),
        this.reliableDC &&
          ((this.reliableDC.onmessage = null),
          (this.reliableDC.onerror = null)),
        (this.lossyDC = this.pcManager.createPublisherDataChannel(
          lossyDataChannel,
          { ordered: !1, maxRetransmits: 0 }
        )),
        (this.reliableDC = this.pcManager.createPublisherDataChannel(
          reliableDataChannel,
          { ordered: !0 }
        )),
        (this.lossyDC.onmessage = this.handleDataMessage),
        (this.reliableDC.onmessage = this.handleDataMessage),
        (this.lossyDC.onerror = this.handleDataError),
        (this.reliableDC.onerror = this.handleDataError),
        (this.lossyDC.bufferedAmountLowThreshold = 65535),
        (this.reliableDC.bufferedAmountLowThreshold = 65535),
        (this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow),
        (this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow));
    }
    createSender(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (supportsTransceiver())
          return yield this.createTransceiverRTCRtpSender(j, V, B);
        if (supportsAddTrack())
          return (
            this.log.warn("using add-track fallback", this.logContext),
            yield this.createRTCRtpSender(j.mediaStreamTrack)
          );
        throw new UnexpectedConnectionState(
          "Required webRTC APIs not supported on this device"
        );
      });
    }
    createSimulcastSender(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (supportsTransceiver())
          return this.createSimulcastTransceiverSender(j, V, B, q);
        if (supportsAddTrack())
          return (
            this.log.debug("using add-track fallback", this.logContext),
            this.createRTCRtpSender(j.mediaStreamTrack)
          );
        throw new UnexpectedConnectionState("Cannot stream on this device");
      });
    }
    createTransceiverRTCRtpSender(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.pcManager)
          throw new UnexpectedConnectionState("publisher is closed");
        const q = [];
        j.mediaStream && q.push(j.mediaStream),
          isVideoTrack(j) && (j.codec = V.videoCodec);
        const $ = { direction: "sendonly", streams: q };
        return (
          B && ($.sendEncodings = B),
          (yield this.pcManager.addPublisherTransceiver(j.mediaStreamTrack, $))
            .sender
        );
      });
    }
    createSimulcastTransceiverSender(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.pcManager)
          throw new UnexpectedConnectionState("publisher is closed");
        const $ = { direction: "sendonly" };
        q && ($.sendEncodings = q);
        const H = yield this.pcManager.addPublisherTransceiver(
          V.mediaStreamTrack,
          $
        );
        if (B.videoCodec)
          return j.setSimulcastTrackSender(B.videoCodec, H.sender), H.sender;
      });
    }
    createRTCRtpSender(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.pcManager)
          throw new UnexpectedConnectionState("publisher is closed");
        return this.pcManager.addPublisherTrack(j);
      });
    }
    attemptReconnect(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q;
        if (!this._isClosed) {
          if (this.attemptingReconnect) {
            livekitLogger.warn(
              "already attempting reconnect, returning early",
              this.logContext
            );
            return;
          }
          (((V = this.clientConfiguration) === null || V === void 0
            ? void 0
            : V.resumeConnection) === ClientConfigSetting.DISABLED ||
            ((q =
              (B = this.pcManager) === null || B === void 0
                ? void 0
                : B.currentState) !== null && q !== void 0
              ? q
              : PCTransportState.NEW) === PCTransportState.NEW) &&
            (this.fullReconnectOnNext = !0);
          try {
            (this.attemptingReconnect = !0),
              this.fullReconnectOnNext
                ? yield this.restartConnection()
                : yield this.resumeConnection(j),
              this.clearPendingReconnect(),
              (this.fullReconnectOnNext = !1);
          } catch ($) {
            this.reconnectAttempts += 1;
            let H = !0;
            $ instanceof UnexpectedConnectionState
              ? (this.log.debug(
                  "received unrecoverable error",
                  Object.assign(Object.assign({}, this.logContext), {
                    error: $,
                  })
                ),
                (H = !1))
              : $ instanceof SignalReconnectError ||
                (this.fullReconnectOnNext = !0),
              H
                ? this.handleDisconnect("reconnect", ReconnectReason.RR_UNKNOWN)
                : (this.log.info(
                    "could not recover connection after "
                      .concat(this.reconnectAttempts, " attempts, ")
                      .concat(
                        Date.now() - this.reconnectStart,
                        "ms. giving up"
                      ),
                    this.logContext
                  ),
                  this.emit(EngineEvent.Disconnected),
                  yield this.close());
          } finally {
            this.attemptingReconnect = !1;
          }
        }
      });
    }
    getNextRetryDelay(j) {
      try {
        return this.reconnectPolicy.nextRetryDelayInMs(j);
      } catch (V) {
        this.log.warn(
          "encountered error in reconnect policy",
          Object.assign(Object.assign({}, this.logContext), { error: V })
        );
      }
      return null;
    }
    restartConnection(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q;
        try {
          if (!this.url || !this.token)
            throw new UnexpectedConnectionState(
              "could not reconnect, url or token not saved"
            );
          this.log.info(
            "reconnecting, attempt: ".concat(this.reconnectAttempts),
            this.logContext
          ),
            this.emit(EngineEvent.Restarting),
            this.client.isDisconnected || (yield this.client.sendLeave()),
            yield this.cleanupPeerConnections(),
            yield this.cleanupClient();
          let $;
          try {
            if (!this.signalOpts)
              throw (
                (this.log.warn(
                  "attempted connection restart, without signal options present",
                  this.logContext
                ),
                new SignalReconnectError())
              );
            $ = yield this.join(j ?? this.url, this.token, this.signalOpts);
          } catch (H) {
            throw H instanceof ConnectionError &&
              H.reason === ConnectionErrorReason.NotAllowed
              ? new UnexpectedConnectionState(
                  "could not reconnect, token might be expired"
                )
              : new SignalReconnectError();
          }
          if (this.shouldFailNext)
            throw ((this.shouldFailNext = !1), new Error("simulated failure"));
          if (
            (this.client.setReconnected(),
            this.emit(EngineEvent.SignalRestarted, $),
            yield this.waitForPCReconnected(),
            this.client.currentState !== SignalConnectionState.CONNECTED)
          )
            throw new SignalReconnectError(
              "Signal connection got severed during reconnect"
            );
          (V = this.regionUrlProvider) === null ||
            V === void 0 ||
            V.resetAttempts(),
            this.emit(EngineEvent.Restarted);
        } catch ($) {
          const H = yield (B = this.regionUrlProvider) === null || B === void 0
            ? void 0
            : B.getNextBestRegionUrl();
          if (H) {
            yield this.restartConnection(H);
            return;
          } else throw ((q = this.regionUrlProvider) === null || q === void 0 || q.resetAttempts(), $);
        }
      });
    }
    resumeConnection(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V;
        if (!this.url || !this.token)
          throw new UnexpectedConnectionState(
            "could not reconnect, url or token not saved"
          );
        if (!this.pcManager)
          throw new UnexpectedConnectionState(
            "publisher and subscriber connections unset"
          );
        this.log.info(
          "resuming signal connection, attempt ".concat(this.reconnectAttempts),
          this.logContext
        ),
          this.emit(EngineEvent.Resuming);
        let B;
        try {
          this.setupSignalClientCallbacks(),
            (B = yield this.client.reconnect(
              this.url,
              this.token,
              this.participantSid,
              j
            ));
        } catch (q) {
          let $ = "";
          throw (
            (q instanceof Error &&
              (($ = q.message),
              this.log.error(
                q.message,
                Object.assign(Object.assign({}, this.logContext), { error: q })
              )),
            q instanceof ConnectionError &&
            q.reason === ConnectionErrorReason.NotAllowed
              ? new UnexpectedConnectionState(
                  "could not reconnect, token might be expired"
                )
              : q instanceof ConnectionError &&
                q.reason === ConnectionErrorReason.LeaveRequest
              ? q
              : new SignalReconnectError($))
          );
        }
        if ((this.emit(EngineEvent.SignalResumed), B)) {
          const q = this.makeRTCConfiguration(B);
          this.pcManager.updateConfiguration(q),
            this.latestJoinResponse &&
              (this.latestJoinResponse.serverInfo = B.serverInfo);
        } else this.log.warn("Did not receive reconnect response", this.logContext);
        if (this.shouldFailNext)
          throw ((this.shouldFailNext = !1), new Error("simulated failure"));
        if (
          (yield this.pcManager.triggerIceRestart(),
          yield this.waitForPCReconnected(),
          this.client.currentState !== SignalConnectionState.CONNECTED)
        )
          throw new SignalReconnectError(
            "Signal connection got severed during reconnect"
          );
        this.client.setReconnected(),
          ((V = this.reliableDC) === null || V === void 0
            ? void 0
            : V.readyState) === "open" &&
            this.reliableDC.id === null &&
            this.createDataChannels(),
          B?.lastMessageSeq &&
            this.resendReliableMessagesForResume(B.lastMessageSeq),
          this.emit(EngineEvent.Resumed);
      });
    }
    waitForPCInitialConnection(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.pcManager)
          throw new UnexpectedConnectionState("PC manager is closed");
        yield this.pcManager.ensurePCTransportConnection(V, j);
      });
    }
    waitForPCReconnected() {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.pcState = PCState.Reconnecting),
          this.log.debug(
            "waiting for peer connection to reconnect",
            this.logContext
          );
        try {
          if ((yield sleep$1(minReconnectWait), !this.pcManager))
            throw new UnexpectedConnectionState("PC manager is closed");
          yield this.pcManager.ensurePCTransportConnection(
            void 0,
            this.peerConnectionTimeout
          ),
            (this.pcState = PCState.Connected);
        } catch (j) {
          throw (
            ((this.pcState = PCState.Disconnected),
            new ConnectionError(
              "could not establish PC connection, ".concat(j.message),
              ConnectionErrorReason.InternalError
            ))
          );
        }
      });
    }
    publishRpcResponse(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const $ = new DataPacket({
          destinationIdentities: [j],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcResponse",
            value: new RpcResponse({
              requestId: V,
              value: q
                ? { case: "error", value: q.toProto() }
                : { case: "payload", value: B ?? "" },
            }),
          },
        });
        yield this.sendDataPacket($, DataPacket_Kind.RELIABLE);
      });
    }
    publishRpcAck(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = new DataPacket({
          destinationIdentities: [j],
          kind: DataPacket_Kind.RELIABLE,
          value: { case: "rpcAck", value: new RpcAck({ requestId: V }) },
        });
        yield this.sendDataPacket(B, DataPacket_Kind.RELIABLE);
      });
    }
    sendDataPacket(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.ensurePublisherConnected(V),
          V === DataPacket_Kind.RELIABLE &&
            ((j.sequence = this.reliableDataSequence),
            (this.reliableDataSequence += 1));
        const B = j.toBinary(),
          q = this.dataChannelForKind(V);
        if (q) {
          if (
            (V === DataPacket_Kind.RELIABLE &&
              this.reliableMessageBuffer.push({
                data: B,
                sequence: j.sequence,
              }),
            this.attemptingReconnect)
          )
            return;
          q.send(B);
        }
        this.updateAndEmitDCBufferStatus(V);
      });
    }
    resendReliableMessagesForResume(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.ensurePublisherConnected(DataPacket_Kind.RELIABLE);
        const V = this.dataChannelForKind(DataPacket_Kind.RELIABLE);
        V &&
          (this.reliableMessageBuffer.popToSequence(j),
          this.reliableMessageBuffer.getAll().forEach((B) => {
            V.send(B.data);
          })),
          this.updateAndEmitDCBufferStatus(DataPacket_Kind.RELIABLE);
      });
    }
    waitForBufferStatusLow(j) {
      return new Promise((V, B) =>
        __awaiter$1(this, void 0, void 0, function* () {
          if (this.isBufferStatusLow(j)) V();
          else {
            const q = () => B("Engine closed");
            for (
              this.once(EngineEvent.Closing, q);
              !this.dcBufferStatus.get(j);

            )
              yield sleep$1(10);
            this.off(EngineEvent.Closing, q), V();
          }
        })
      );
    }
    ensureDataTransportConnected(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : this.subscriberPrimary;
        return (function* () {
          var $;
          if (!B.pcManager)
            throw new UnexpectedConnectionState("PC manager is closed");
          const H = q ? B.pcManager.subscriber : B.pcManager.publisher,
            G = q ? "Subscriber" : "Publisher";
          if (!H)
            throw new ConnectionError(
              "".concat(G, " connection not set"),
              ConnectionErrorReason.InternalError
            );
          let Y = !1;
          !q &&
            !B.dataChannelForKind(V, q) &&
            (B.createDataChannels(), (Y = !0)),
            !Y &&
              !q &&
              !B.pcManager.publisher.isICEConnected &&
              B.pcManager.publisher.getICEConnectionState() !== "checking" &&
              (Y = !0),
            Y && B.negotiate();
          const Q = B.dataChannelForKind(V, q);
          if (Q?.readyState === "open") return;
          const X = new Date().getTime() + B.peerConnectionTimeout;
          for (; new Date().getTime() < X; ) {
            if (
              H.isICEConnected &&
              (($ = B.dataChannelForKind(V, q)) === null || $ === void 0
                ? void 0
                : $.readyState) === "open"
            )
              return;
            yield sleep$1(50);
          }
          throw new ConnectionError(
            "could not establish "
              .concat(G, " connection, state: ")
              .concat(H.getICEConnectionState()),
            ConnectionErrorReason.InternalError
          );
        })();
      });
    }
    ensurePublisherConnected(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.publisherConnectionPromise ||
          (this.publisherConnectionPromise = this.ensureDataTransportConnected(
            j,
            !1
          )),
          yield this.publisherConnectionPromise;
      });
    }
    verifyTransport() {
      return !(
        !this.pcManager ||
        this.pcManager.currentState !== PCTransportState.CONNECTED ||
        !this.client.ws ||
        this.client.ws.readyState === WebSocket.CLOSED
      );
    }
    negotiate() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return new Promise((j, V) =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (!this.pcManager) {
              V(new NegotiationError("PC manager is closed"));
              return;
            }
            this.pcManager.requirePublisher(),
              this.pcManager.publisher.getTransceivers().length == 0 &&
                !this.lossyDC &&
                !this.reliableDC &&
                this.createDataChannels();
            const B = new AbortController(),
              q = () => {
                B.abort(),
                  this.log.debug(
                    "engine disconnected while negotiation was ongoing",
                    this.logContext
                  ),
                  j();
              };
            this.isClosed && V("cannot negotiate on closed engine"),
              this.on(EngineEvent.Closing, q),
              this.pcManager.publisher.once(
                PCEvents.RTPVideoPayloadTypes,
                ($) => {
                  const H = new Map();
                  $.forEach((G) => {
                    const Y = G.codec.toLowerCase();
                    isVideoCodec(Y) && H.set(G.payload, Y);
                  }),
                    this.emit(EngineEvent.RTPVideoMapUpdate, H);
                }
              );
            try {
              yield this.pcManager.negotiate(B), j();
            } catch ($) {
              $ instanceof NegotiationError && (this.fullReconnectOnNext = !0),
                this.handleDisconnect(
                  "negotiation",
                  ReconnectReason.RR_UNKNOWN
                ),
                V($);
            } finally {
              this.off(EngineEvent.Closing, q);
            }
          })
        );
      });
    }
    dataChannelForKind(j, V) {
      if (V) {
        if (j === DataPacket_Kind.LOSSY) return this.lossyDCSub;
        if (j === DataPacket_Kind.RELIABLE) return this.reliableDCSub;
      } else {
        if (j === DataPacket_Kind.LOSSY) return this.lossyDC;
        if (j === DataPacket_Kind.RELIABLE) return this.reliableDC;
      }
    }
    sendSyncState(j, V) {
      var B, q;
      if (!this.pcManager) {
        this.log.warn(
          "sync state cannot be sent without peer connection setup",
          this.logContext
        );
        return;
      }
      const $ = this.pcManager.subscriber.getLocalDescription(),
        H = this.pcManager.subscriber.getRemoteDescription(),
        G =
          (q =
            (B = this.signalOpts) === null || B === void 0
              ? void 0
              : B.autoSubscribe) !== null && q !== void 0
            ? q
            : !0,
        Y = new Array(),
        Q = new Array();
      j.forEach((X) => {
        X.isDesired !== G && Y.push(X.trackSid),
          X.isEnabled || Q.push(X.trackSid);
      }),
        this.client.sendSyncState(
          new SyncState({
            answer: $
              ? toProtoSessionDescription({ sdp: $.sdp, type: $.type })
              : void 0,
            offer: H
              ? toProtoSessionDescription({ sdp: H.sdp, type: H.type })
              : void 0,
            subscription: new UpdateSubscription({
              trackSids: Y,
              subscribe: !G,
              participantTracks: [],
            }),
            publishTracks: getTrackPublicationInfo(V),
            dataChannels: this.dataChannelsInfo(),
            trackSidsDisabled: Q,
            datachannelReceiveStates: this.reliableReceivedState.map(
              (X, Z) =>
                new DataChannelReceiveState({ publisherSid: Z, lastSeq: X })
            ),
          })
        );
    }
    failNext() {
      this.shouldFailNext = !0;
    }
    dataChannelsInfo() {
      const j = [],
        V = (B, q) => {
          B?.id !== void 0 &&
            B.id !== null &&
            j.push(
              new DataChannelInfo({ label: B.label, id: B.id, target: q })
            );
        };
      return (
        V(
          this.dataChannelForKind(DataPacket_Kind.LOSSY),
          SignalTarget.PUBLISHER
        ),
        V(
          this.dataChannelForKind(DataPacket_Kind.RELIABLE),
          SignalTarget.PUBLISHER
        ),
        V(
          this.dataChannelForKind(DataPacket_Kind.LOSSY, !0),
          SignalTarget.SUBSCRIBER
        ),
        V(
          this.dataChannelForKind(DataPacket_Kind.RELIABLE, !0),
          SignalTarget.SUBSCRIBER
        ),
        j
      );
    }
    clearReconnectTimeout() {
      this.reconnectTimeout &&
        CriticalTimers.clearTimeout(this.reconnectTimeout);
    }
    clearPendingReconnect() {
      this.clearReconnectTimeout(), (this.reconnectAttempts = 0);
    }
    registerOnLineListener() {
      isWeb() && window.addEventListener("online", this.handleBrowserOnLine);
    }
    deregisterOnLineListener() {
      isWeb() && window.removeEventListener("online", this.handleBrowserOnLine);
    }
  }
  class SignalReconnectError extends Error {}
  function supportOptionalDatachannel(U) {
    return U !== void 0 && U > 13;
  }
  function applyUserDataCompat(U, j) {
    const V = U.participantIdentity
      ? U.participantIdentity
      : j.participantIdentity;
    (U.participantIdentity = V), (j.participantIdentity = V);
    const B =
      U.destinationIdentities.length !== 0
        ? U.destinationIdentities
        : j.destinationIdentities;
    (U.destinationIdentities = B), (j.destinationIdentities = B);
  }
  class RegionUrlProvider {
    constructor(j, V) {
      (this.lastUpdateAt = 0),
        (this.settingsCacheTime = 3e3),
        (this.attemptedRegions = []),
        (this.serverUrl = new URL(j)),
        (this.token = V);
    }
    updateToken(j) {
      this.token = j;
    }
    isCloud() {
      return isCloud(this.serverUrl);
    }
    getServerUrl() {
      return this.serverUrl;
    }
    getNextBestRegionUrl(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.isCloud())
          throw Error(
            "region availability is only supported for LiveKit Cloud domains"
          );
        (!this.regionSettings ||
          Date.now() - this.lastUpdateAt > this.settingsCacheTime) &&
          (this.regionSettings = yield this.fetchRegionSettings(j));
        const V = this.regionSettings.regions.filter(
          (B) => !this.attemptedRegions.find((q) => q.url === B.url)
        );
        if (V.length > 0) {
          const B = V[0];
          return (
            this.attemptedRegions.push(B),
            livekitLogger.debug("next region: ".concat(B.region)),
            B.url
          );
        } else return null;
      });
    }
    resetAttempts() {
      this.attemptedRegions = [];
    }
    fetchRegionSettings(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = yield fetch(
          "".concat(getCloudConfigUrl(this.serverUrl), "/regions"),
          {
            headers: { authorization: "Bearer ".concat(this.token) },
            signal: j,
          }
        );
        if (V.ok) {
          const B = yield V.json();
          return (this.lastUpdateAt = Date.now()), B;
        } else throw new ConnectionError("Could not fetch region settings: ".concat(V.statusText), V.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, V.status);
      });
    }
    setServerReportedRegions(j) {
      (this.regionSettings = j), (this.lastUpdateAt = Date.now());
    }
  }
  function getCloudConfigUrl(U) {
    return ""
      .concat(U.protocol.replace("ws", "http"), "//")
      .concat(U.host, "/settings");
  }
  class BaseStreamReader {
    get info() {
      return this._info;
    }
    constructor(j, V, B) {
      (this.reader = V),
        (this.totalByteSize = B),
        (this._info = j),
        (this.bytesReceived = 0);
    }
  }
  class ByteStreamReader extends BaseStreamReader {
    handleChunkReceived(j) {
      var V;
      this.bytesReceived += j.content.byteLength;
      const B = this.totalByteSize
        ? this.bytesReceived / this.totalByteSize
        : void 0;
      (V = this.onProgress) === null || V === void 0 || V.call(this, B);
    }
    [Symbol.asyncIterator]() {
      const j = this.reader.getReader();
      return {
        next: () =>
          __awaiter$1(this, void 0, void 0, function* () {
            try {
              const { done: V, value: B } = yield j.read();
              return V
                ? { done: !0, value: void 0 }
                : (this.handleChunkReceived(B), { done: !1, value: B.content });
            } catch {
              return { done: !0, value: void 0 };
            }
          }),
        return() {
          return __awaiter$1(this, void 0, void 0, function* () {
            return j.releaseLock(), { done: !0, value: void 0 };
          });
        },
      };
    }
    readAll() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V, B, q;
        let $ = new Set();
        try {
          for (
            var H = !0, G = __asyncValues(this), Y;
            (Y = yield G.next()), (j = Y.done), !j;
            H = !0
          ) {
            (q = Y.value), (H = !1);
            const Q = q;
            $.add(Q);
          }
        } catch (Q) {
          V = { error: Q };
        } finally {
          try {
            !H && !j && (B = G.return) && (yield B.call(G));
          } finally {
            if (V) throw V.error;
          }
        }
        return Array.from($);
      });
    }
  }
  class TextStreamReader extends BaseStreamReader {
    constructor(j, V, B) {
      super(j, V, B), (this.receivedChunks = new Map());
    }
    handleChunkReceived(j) {
      var V;
      const B = bigIntToNumber(j.chunkIndex),
        q = this.receivedChunks.get(B);
      if (q && q.version > j.version) return;
      this.receivedChunks.set(B, j),
        (this.bytesReceived += j.content.byteLength);
      const $ = this.totalByteSize
        ? this.bytesReceived / this.totalByteSize
        : void 0;
      (V = this.onProgress) === null || V === void 0 || V.call(this, $);
    }
    [Symbol.asyncIterator]() {
      const j = this.reader.getReader(),
        V = new TextDecoder();
      return {
        next: () =>
          __awaiter$1(this, void 0, void 0, function* () {
            try {
              const { done: B, value: q } = yield j.read();
              return B
                ? { done: !0, value: void 0 }
                : (this.handleChunkReceived(q),
                  { done: !1, value: V.decode(q.content) });
            } catch {
              return { done: !0, value: void 0 };
            }
          }),
        return() {
          return __awaiter$1(this, void 0, void 0, function* () {
            return j.releaseLock(), { done: !0, value: void 0 };
          });
        },
      };
    }
    readAll() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V, B, q;
        let $ = "";
        try {
          for (
            var H = !0, G = __asyncValues(this), Y;
            (Y = yield G.next()), (j = Y.done), !j;
            H = !0
          )
            (q = Y.value), (H = !1), ($ += q);
        } catch (Q) {
          V = { error: Q };
        } finally {
          try {
            !H && !j && (B = G.return) && (yield B.call(G));
          } finally {
            if (V) throw V.error;
          }
        }
        return $;
      });
    }
  }
  class BaseStreamWriter {
    constructor(j, V, B) {
      (this.writableStream = j),
        (this.defaultWriter = j.getWriter()),
        (this.onClose = B),
        (this.info = V);
    }
    write(j) {
      return this.defaultWriter.write(j);
    }
    close() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        yield this.defaultWriter.close(),
          this.defaultWriter.releaseLock(),
          (j = this.onClose) === null || j === void 0 || j.call(this);
      });
    }
  }
  class TextStreamWriter extends BaseStreamWriter {}
  class ByteStreamWriter extends BaseStreamWriter {}
  class RemoteTrack extends Track {
    constructor(j, V, B, q, $) {
      super(j, B, $), (this.sid = V), (this.receiver = q);
    }
    get isLocal() {
      return !1;
    }
    setMuted(j) {
      this.isMuted !== j &&
        ((this.isMuted = j),
        (this._mediaStreamTrack.enabled = !j),
        this.emit(j ? TrackEvent.Muted : TrackEvent.Unmuted, this));
    }
    setMediaStream(j) {
      this.mediaStream = j;
      const V = (B) => {
        B.track === this._mediaStreamTrack &&
          (j.removeEventListener("removetrack", V),
          this.receiver &&
            "playoutDelayHint" in this.receiver &&
            (this.receiver.playoutDelayHint = void 0),
          (this.receiver = void 0),
          (this._currentBitrate = 0),
          this.emit(TrackEvent.Ended, this));
      };
      j.addEventListener("removetrack", V);
    }
    start() {
      this.startMonitor(), super.enable();
    }
    stop() {
      this.stopMonitor(), super.disable();
    }
    getRTCStatsReport() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        return !((j = this.receiver) === null || j === void 0) && j.getStats
          ? yield this.receiver.getStats()
          : void 0;
      });
    }
    setPlayoutDelay(j) {
      this.receiver
        ? "playoutDelayHint" in this.receiver
          ? (this.receiver.playoutDelayHint = j)
          : this.log.warn("Playout delay not supported in this browser")
        : this.log.warn("Cannot set playout delay, track already ended");
    }
    getPlayoutDelay() {
      if (this.receiver) {
        if ("playoutDelayHint" in this.receiver)
          return this.receiver.playoutDelayHint;
        this.log.warn("Playout delay not supported in this browser");
      } else this.log.warn("Cannot get playout delay, track already ended");
      return 0;
    }
    startMonitor() {
      this.monitorInterval ||
        (this.monitorInterval = setInterval(
          () => this.monitorReceiver(),
          monitorFrequency
        )),
        supportsSynchronizationSources() && this.registerTimeSyncUpdate();
    }
    registerTimeSyncUpdate() {
      const j = () => {
        var V;
        this.timeSyncHandle = requestAnimationFrame(() => j());
        const B =
          (V = this.receiver) === null || V === void 0
            ? void 0
            : V.getSynchronizationSources()[0];
        if (B) {
          const { timestamp: q, rtpTimestamp: $ } = B;
          $ &&
            this.rtpTimestamp !== $ &&
            (this.emit(TrackEvent.TimeSyncUpdate, {
              timestamp: q,
              rtpTimestamp: $,
            }),
            (this.rtpTimestamp = $));
        }
      };
      j();
    }
  }
  class RemoteAudioTrack extends RemoteTrack {
    constructor(j, V, B, q, $, H) {
      super(j, V, Track.Kind.Audio, B, H),
        (this.monitorReceiver = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (!this.receiver) {
              this._currentBitrate = 0;
              return;
            }
            const G = yield this.getReceiverStats();
            G &&
              this.prevStats &&
              this.receiver &&
              (this._currentBitrate = computeBitrate(G, this.prevStats)),
              (this.prevStats = G);
          })),
        (this.audioContext = q),
        (this.webAudioPluginNodes = []),
        $ && (this.sinkId = $.deviceId);
    }
    setVolume(j) {
      var V;
      for (const B of this.attachedElements)
        this.audioContext
          ? (V = this.gainNode) === null ||
            V === void 0 ||
            V.gain.setTargetAtTime(j, 0, 0.1)
          : (B.volume = j);
      isReactNative() && this._mediaStreamTrack._setVolume(j),
        (this.elementVolume = j);
    }
    getVolume() {
      if (this.elementVolume) return this.elementVolume;
      if (isReactNative()) return 1;
      let j = 0;
      return (
        this.attachedElements.forEach((V) => {
          V.volume > j && (j = V.volume);
        }),
        j
      );
    }
    setSinkId(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.sinkId = j),
          yield Promise.all(
            this.attachedElements.map((V) => {
              if (supportsSetSinkId(V)) return V.setSinkId(j);
            })
          );
      });
    }
    attach(j) {
      const V = this.attachedElements.length === 0;
      return (
        j ? super.attach(j) : (j = super.attach()),
        this.sinkId &&
          supportsSetSinkId(j) &&
          j.setSinkId(this.sinkId).catch((B) => {
            this.log.error(
              "Failed to set sink id on remote audio track",
              B,
              this.logContext
            );
          }),
        this.audioContext &&
          V &&
          (this.log.debug("using audio context mapping", this.logContext),
          this.connectWebAudio(this.audioContext, j),
          (j.volume = 0),
          (j.muted = !0)),
        this.elementVolume && this.setVolume(this.elementVolume),
        j
      );
    }
    detach(j) {
      let V;
      return (
        j
          ? ((V = super.detach(j)),
            this.audioContext &&
              (this.attachedElements.length > 0
                ? this.connectWebAudio(
                    this.audioContext,
                    this.attachedElements[0]
                  )
                : this.disconnectWebAudio()))
          : ((V = super.detach()), this.disconnectWebAudio()),
        V
      );
    }
    setAudioContext(j) {
      (this.audioContext = j),
        j && this.attachedElements.length > 0
          ? this.connectWebAudio(j, this.attachedElements[0])
          : j || this.disconnectWebAudio();
    }
    setWebAudioPlugins(j) {
      (this.webAudioPluginNodes = j),
        this.attachedElements.length > 0 &&
          this.audioContext &&
          this.connectWebAudio(this.audioContext, this.attachedElements[0]);
    }
    connectWebAudio(j, V) {
      this.disconnectWebAudio(),
        (this.sourceNode = j.createMediaStreamSource(V.srcObject));
      let B = this.sourceNode;
      this.webAudioPluginNodes.forEach((q) => {
        B.connect(q), (B = q);
      }),
        (this.gainNode = j.createGain()),
        B.connect(this.gainNode),
        this.gainNode.connect(j.destination),
        this.elementVolume &&
          this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1),
        j.state !== "running" &&
          j
            .resume()
            .then(() => {
              j.state !== "running" &&
                this.emit(
                  TrackEvent.AudioPlaybackFailed,
                  new Error("Audio Context couldn't be started automatically")
                );
            })
            .catch((q) => {
              this.emit(TrackEvent.AudioPlaybackFailed, q);
            });
    }
    disconnectWebAudio() {
      var j, V;
      (j = this.gainNode) === null || j === void 0 || j.disconnect(),
        (V = this.sourceNode) === null || V === void 0 || V.disconnect(),
        (this.gainNode = void 0),
        (this.sourceNode = void 0);
    }
    getReceiverStats() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) return;
        const j = yield this.receiver.getStats();
        let V;
        return (
          j.forEach((B) => {
            B.type === "inbound-rtp" &&
              (V = {
                type: "audio",
                streamId: B.id,
                timestamp: B.timestamp,
                jitter: B.jitter,
                bytesReceived: B.bytesReceived,
                concealedSamples: B.concealedSamples,
                concealmentEvents: B.concealmentEvents,
                silentConcealedSamples: B.silentConcealedSamples,
                silentConcealmentEvents: B.silentConcealmentEvents,
                totalAudioEnergy: B.totalAudioEnergy,
                totalSamplesDuration: B.totalSamplesDuration,
              });
          }),
          V
        );
      });
    }
  }
  const REACTION_DELAY = 100;
  class RemoteVideoTrack extends RemoteTrack {
    constructor(j, V, B, q, $) {
      super(j, V, Track.Kind.Video, B, $),
        (this.elementInfos = []),
        (this.monitorReceiver = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (!this.receiver) {
              this._currentBitrate = 0;
              return;
            }
            const H = yield this.getReceiverStats();
            H &&
              this.prevStats &&
              this.receiver &&
              (this._currentBitrate = computeBitrate(H, this.prevStats)),
              (this.prevStats = H);
          })),
        (this.debouncedHandleResize = r$1(() => {
          this.updateDimensions();
        }, REACTION_DELAY)),
        (this.adaptiveStreamSettings = q);
    }
    get isAdaptiveStream() {
      return this.adaptiveStreamSettings !== void 0;
    }
    get mediaStreamTrack() {
      return this._mediaStreamTrack;
    }
    setMuted(j) {
      super.setMuted(j),
        this.attachedElements.forEach((V) => {
          j
            ? detachTrack(this._mediaStreamTrack, V)
            : attachToElement(this._mediaStreamTrack, V);
        });
    }
    attach(j) {
      if (
        (j ? super.attach(j) : (j = super.attach()),
        this.adaptiveStreamSettings &&
          this.elementInfos.find((V) => V.element === j) === void 0)
      ) {
        const V = new HTMLElementInfo(j);
        this.observeElementInfo(V);
      }
      return j;
    }
    observeElementInfo(j) {
      this.adaptiveStreamSettings &&
      this.elementInfos.find((V) => V === j) === void 0
        ? ((j.handleResize = () => {
            this.debouncedHandleResize();
          }),
          (j.handleVisibilityChanged = () => {
            this.updateVisibility();
          }),
          this.elementInfos.push(j),
          j.observe(),
          this.debouncedHandleResize(),
          this.updateVisibility())
        : this.log.warn(
            "visibility resize observer not triggered",
            this.logContext
          );
    }
    stopObservingElementInfo(j) {
      if (!this.isAdaptiveStream) {
        this.log.warn("stopObservingElementInfo ignored", this.logContext);
        return;
      }
      const V = this.elementInfos.filter((B) => B === j);
      for (const B of V) B.stopObserving();
      (this.elementInfos = this.elementInfos.filter((B) => B !== j)),
        this.updateVisibility(),
        this.debouncedHandleResize();
    }
    detach(j) {
      let V = [];
      if (j) return this.stopObservingElement(j), super.detach(j);
      V = super.detach();
      for (const B of V) this.stopObservingElement(B);
      return V;
    }
    getDecoderImplementation() {
      var j;
      return (j = this.prevStats) === null || j === void 0
        ? void 0
        : j.decoderImplementation;
    }
    getReceiverStats() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (!this.receiver || !this.receiver.getStats) return;
        const j = yield this.receiver.getStats();
        let V,
          B = "",
          q = new Map();
        return (
          j.forEach(($) => {
            $.type === "inbound-rtp"
              ? ((B = $.codecId),
                (V = {
                  type: "video",
                  streamId: $.id,
                  framesDecoded: $.framesDecoded,
                  framesDropped: $.framesDropped,
                  framesReceived: $.framesReceived,
                  packetsReceived: $.packetsReceived,
                  packetsLost: $.packetsLost,
                  frameWidth: $.frameWidth,
                  frameHeight: $.frameHeight,
                  pliCount: $.pliCount,
                  firCount: $.firCount,
                  nackCount: $.nackCount,
                  jitter: $.jitter,
                  timestamp: $.timestamp,
                  bytesReceived: $.bytesReceived,
                  decoderImplementation: $.decoderImplementation,
                }))
              : $.type === "codec" && q.set($.id, $);
          }),
          V && B !== "" && q.get(B) && (V.mimeType = q.get(B).mimeType),
          V
        );
      });
    }
    stopObservingElement(j) {
      const V = this.elementInfos.filter((B) => B.element === j);
      for (const B of V) this.stopObservingElementInfo(B);
    }
    handleAppVisibilityChanged() {
      const j = Object.create(null, {
        handleAppVisibilityChanged: {
          get: () => super.handleAppVisibilityChanged,
        },
      });
      return __awaiter$1(this, void 0, void 0, function* () {
        yield j.handleAppVisibilityChanged.call(this),
          this.isAdaptiveStream && this.updateVisibility();
      });
    }
    updateVisibility() {
      var j, V;
      const B = this.elementInfos.reduce(
          (G, Y) => Math.max(G, Y.visibilityChangedAt || 0),
          0
        ),
        q =
          !(
            (V =
              (j = this.adaptiveStreamSettings) === null || j === void 0
                ? void 0
                : j.pauseVideoInBackground) !== null && V !== void 0
          ) || V
            ? this.isInBackground
            : !1,
        $ = this.elementInfos.some((G) => G.pictureInPicture),
        H = (this.elementInfos.some((G) => G.visible) && !q) || $;
      if (this.lastVisible !== H) {
        if (!H && Date.now() - B < REACTION_DELAY) {
          CriticalTimers.setTimeout(() => {
            this.updateVisibility();
          }, REACTION_DELAY);
          return;
        }
        (this.lastVisible = H),
          this.emit(TrackEvent.VisibilityChanged, H, this);
      }
    }
    updateDimensions() {
      var j, V;
      let B = 0,
        q = 0;
      const $ = this.getPixelDensity();
      for (const H of this.elementInfos) {
        const G = H.width() * $,
          Y = H.height() * $;
        G + Y > B + q && ((B = G), (q = Y));
      }
      (((j = this.lastDimensions) === null || j === void 0
        ? void 0
        : j.width) === B &&
        ((V = this.lastDimensions) === null || V === void 0
          ? void 0
          : V.height) === q) ||
        ((this.lastDimensions = { width: B, height: q }),
        this.emit(
          TrackEvent.VideoDimensionsChanged,
          this.lastDimensions,
          this
        ));
    }
    getPixelDensity() {
      var j;
      const V =
        (j = this.adaptiveStreamSettings) === null || j === void 0
          ? void 0
          : j.pixelDensity;
      return V === "screen"
        ? getDevicePixelRatio()
        : V || (getDevicePixelRatio() > 2 ? 2 : 1);
    }
  }
  class HTMLElementInfo {
    get visible() {
      return this.isPiP || this.isIntersecting;
    }
    get pictureInPicture() {
      return this.isPiP;
    }
    constructor(j, V) {
      (this.onVisibilityChanged = (B) => {
        var q;
        const { target: $, isIntersecting: H } = B;
        $ === this.element &&
          ((this.isIntersecting = H),
          (this.isPiP = isElementInPiP(this.element)),
          (this.visibilityChangedAt = Date.now()),
          (q = this.handleVisibilityChanged) === null ||
            q === void 0 ||
            q.call(this));
      }),
        (this.onEnterPiP = () => {
          var B, q, $;
          (q =
            (B = window.documentPictureInPicture) === null || B === void 0
              ? void 0
              : B.window) === null ||
            q === void 0 ||
            q.addEventListener("pagehide", this.onLeavePiP),
            (this.isPiP = isElementInPiP(this.element)),
            ($ = this.handleVisibilityChanged) === null ||
              $ === void 0 ||
              $.call(this);
        }),
        (this.onLeavePiP = () => {
          var B;
          (this.isPiP = isElementInPiP(this.element)),
            (B = this.handleVisibilityChanged) === null ||
              B === void 0 ||
              B.call(this);
        }),
        (this.element = j),
        (this.isIntersecting = V ?? isElementInViewport(j)),
        (this.isPiP = isWeb() && isElementInPiP(j)),
        (this.visibilityChangedAt = 0);
    }
    width() {
      return this.element.clientWidth;
    }
    height() {
      return this.element.clientHeight;
    }
    observe() {
      var j, V, B;
      (this.isIntersecting = isElementInViewport(this.element)),
        (this.isPiP = isElementInPiP(this.element)),
        (this.element.handleResize = () => {
          var q;
          (q = this.handleResize) === null || q === void 0 || q.call(this);
        }),
        (this.element.handleVisibilityChanged = this.onVisibilityChanged),
        getIntersectionObserver().observe(this.element),
        getResizeObserver().observe(this.element),
        this.element.addEventListener("enterpictureinpicture", this.onEnterPiP),
        this.element.addEventListener("leavepictureinpicture", this.onLeavePiP),
        (j = window.documentPictureInPicture) === null ||
          j === void 0 ||
          j.addEventListener("enter", this.onEnterPiP),
        (B =
          (V = window.documentPictureInPicture) === null || V === void 0
            ? void 0
            : V.window) === null ||
          B === void 0 ||
          B.addEventListener("pagehide", this.onLeavePiP);
    }
    stopObserving() {
      var j, V, B, q, $;
      (j = getIntersectionObserver()) === null ||
        j === void 0 ||
        j.unobserve(this.element),
        (V = getResizeObserver()) === null ||
          V === void 0 ||
          V.unobserve(this.element),
        this.element.removeEventListener(
          "enterpictureinpicture",
          this.onEnterPiP
        ),
        this.element.removeEventListener(
          "leavepictureinpicture",
          this.onLeavePiP
        ),
        (B = window.documentPictureInPicture) === null ||
          B === void 0 ||
          B.removeEventListener("enter", this.onEnterPiP),
        ($ =
          (q = window.documentPictureInPicture) === null || q === void 0
            ? void 0
            : q.window) === null ||
          $ === void 0 ||
          $.removeEventListener("pagehide", this.onLeavePiP);
    }
  }
  function isElementInPiP(U) {
    var j, V;
    return document.pictureInPictureElement === U
      ? !0
      : !((j = window.documentPictureInPicture) === null || j === void 0) &&
        j.window
      ? isElementInViewport(
          U,
          (V = window.documentPictureInPicture) === null || V === void 0
            ? void 0
            : V.window
        )
      : !1;
  }
  function isElementInViewport(U, j) {
    const V = j || window;
    let B = U.offsetTop,
      q = U.offsetLeft;
    const $ = U.offsetWidth,
      H = U.offsetHeight,
      { hidden: G } = U,
      { display: Y } = getComputedStyle(U);
    for (; U.offsetParent; )
      (U = U.offsetParent), (B += U.offsetTop), (q += U.offsetLeft);
    return (
      B < V.pageYOffset + V.innerHeight &&
      q < V.pageXOffset + V.innerWidth &&
      B + H > V.pageYOffset &&
      q + $ > V.pageXOffset &&
      !G &&
      Y !== "none"
    );
  }
  class TrackPublication extends eventsExports.EventEmitter {
    constructor(j, V, B, q) {
      var $;
      super(),
        (this.metadataMuted = !1),
        (this.encryption = Encryption_Type.NONE),
        (this.log = livekitLogger),
        (this.handleMuted = () => {
          this.emit(TrackEvent.Muted);
        }),
        (this.handleUnmuted = () => {
          this.emit(TrackEvent.Unmuted);
        }),
        (this.log = getLogger(
          ($ = q?.loggerName) !== null && $ !== void 0
            ? $
            : LoggerNames.Publication
        )),
        (this.loggerContextCb = this.loggerContextCb),
        this.setMaxListeners(100),
        (this.kind = j),
        (this.trackSid = V),
        (this.trackName = B),
        (this.source = Track.Source.Unknown);
    }
    setTrack(j) {
      this.track &&
        (this.track.off(TrackEvent.Muted, this.handleMuted),
        this.track.off(TrackEvent.Unmuted, this.handleUnmuted)),
        (this.track = j),
        j &&
          (j.on(TrackEvent.Muted, this.handleMuted),
          j.on(TrackEvent.Unmuted, this.handleUnmuted));
    }
    get logContext() {
      var j;
      return Object.assign(
        Object.assign(
          {},
          (j = this.loggerContextCb) === null || j === void 0
            ? void 0
            : j.call(this)
        ),
        getLogContextFromTrack(this)
      );
    }
    get isMuted() {
      return this.metadataMuted;
    }
    get isEnabled() {
      return !0;
    }
    get isSubscribed() {
      return this.track !== void 0;
    }
    get isEncrypted() {
      return this.encryption !== Encryption_Type.NONE;
    }
    get audioTrack() {
      if (isAudioTrack(this.track)) return this.track;
    }
    get videoTrack() {
      if (isVideoTrack(this.track)) return this.track;
    }
    updateInfo(j) {
      (this.trackSid = j.sid),
        (this.trackName = j.name),
        (this.source = Track.sourceFromProto(j.source)),
        (this.mimeType = j.mimeType),
        this.kind === Track.Kind.Video &&
          j.width > 0 &&
          ((this.dimensions = { width: j.width, height: j.height }),
          (this.simulcasted = j.simulcast)),
        (this.encryption = j.encryption),
        (this.trackInfo = j),
        this.log.debug(
          "update publication info",
          Object.assign(Object.assign({}, this.logContext), { info: j })
        );
    }
  }
  (function (U) {
    (function (j) {
      (j.Desired = "desired"),
        (j.Subscribed = "subscribed"),
        (j.Unsubscribed = "unsubscribed");
    })(U.SubscriptionStatus || (U.SubscriptionStatus = {})),
      (function (j) {
        (j.Allowed = "allowed"), (j.NotAllowed = "not_allowed");
      })(U.PermissionStatus || (U.PermissionStatus = {}));
  })(TrackPublication || (TrackPublication = {}));
  class LocalTrackPublication extends TrackPublication {
    get isUpstreamPaused() {
      var j;
      return (j = this.track) === null || j === void 0
        ? void 0
        : j.isUpstreamPaused;
    }
    constructor(j, V, B, q) {
      super(j, V.sid, V.name, q),
        (this.track = void 0),
        (this.handleTrackEnded = () => {
          this.emit(TrackEvent.Ended);
        }),
        (this.handleCpuConstrained = () => {
          this.track &&
            isVideoTrack(this.track) &&
            this.emit(TrackEvent.CpuConstrained, this.track);
        }),
        this.updateInfo(V),
        this.setTrack(B);
    }
    setTrack(j) {
      this.track &&
        (this.track.off(TrackEvent.Ended, this.handleTrackEnded),
        this.track.off(TrackEvent.CpuConstrained, this.handleCpuConstrained)),
        super.setTrack(j),
        j &&
          (j.on(TrackEvent.Ended, this.handleTrackEnded),
          j.on(TrackEvent.CpuConstrained, this.handleCpuConstrained));
    }
    get isMuted() {
      return this.track ? this.track.isMuted : super.isMuted;
    }
    get audioTrack() {
      return super.audioTrack;
    }
    get videoTrack() {
      return super.videoTrack;
    }
    get isLocal() {
      return !0;
    }
    mute() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        return (j = this.track) === null || j === void 0 ? void 0 : j.mute();
      });
    }
    unmute() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        return (j = this.track) === null || j === void 0 ? void 0 : j.unmute();
      });
    }
    pauseUpstream() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        yield (j = this.track) === null || j === void 0
          ? void 0
          : j.pauseUpstream();
      });
    }
    resumeUpstream() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        yield (j = this.track) === null || j === void 0
          ? void 0
          : j.resumeUpstream();
      });
    }
    getTrackFeatures() {
      var j;
      if (isAudioTrack(this.track)) {
        const V = this.track.getSourceTrackSettings(),
          B = new Set();
        return (
          V.autoGainControl && B.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL),
          V.echoCancellation && B.add(AudioTrackFeature.TF_ECHO_CANCELLATION),
          V.noiseSuppression && B.add(AudioTrackFeature.TF_NOISE_SUPPRESSION),
          V.channelCount &&
            V.channelCount > 1 &&
            B.add(AudioTrackFeature.TF_STEREO),
          (!((j = this.options) === null || j === void 0) && j.dtx) ||
            B.add(AudioTrackFeature.TF_NO_DTX),
          this.track.enhancedNoiseCancellation &&
            B.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION),
          Array.from(B.values())
        );
      } else return [];
    }
  }
  function createLocalTracks(U, j) {
    return __awaiter$1(this, void 0, void 0, function* () {
      U ?? (U = {});
      let V = !1;
      const {
        audioProcessor: B,
        videoProcessor: q,
        optionsWithoutProcessor: $,
      } = extractProcessorsFromOptions(U);
      let H = $.audio,
        G = $.video;
      if (
        (B && typeof $.audio == "object" && ($.audio.processor = B),
        q && typeof $.video == "object" && ($.video.processor = q),
        U.audio &&
          typeof $.audio == "object" &&
          typeof $.audio.deviceId == "string")
      ) {
        const Z = $.audio.deviceId;
        ($.audio.deviceId = { exact: Z }),
          (V = !0),
          (H = Object.assign(Object.assign({}, $.audio), {
            deviceId: { ideal: Z },
          }));
      }
      if (
        $.video &&
        typeof $.video == "object" &&
        typeof $.video.deviceId == "string"
      ) {
        const Z = $.video.deviceId;
        ($.video.deviceId = { exact: Z }),
          (V = !0),
          (G = Object.assign(Object.assign({}, $.video), {
            deviceId: { ideal: Z },
          }));
      }
      ($.audio === !0 || (typeof $.audio == "object" && !$.audio.deviceId)) &&
        ($.audio = { deviceId: "default" }),
        $.video === !0
          ? ($.video = { deviceId: "default" })
          : typeof $.video == "object" &&
            !$.video.deviceId &&
            ($.video.deviceId = "default");
      const Y = mergeDefaultOptions($, audioDefaults, videoDefaults),
        Q = constraintsForOptions(Y),
        X = navigator.mediaDevices.getUserMedia(Q);
      $.audio &&
        (DeviceManager.userMediaPromiseMap.set("audioinput", X),
        X.catch(() => DeviceManager.userMediaPromiseMap.delete("audioinput"))),
        $.video &&
          (DeviceManager.userMediaPromiseMap.set("videoinput", X),
          X.catch(() =>
            DeviceManager.userMediaPromiseMap.delete("videoinput")
          ));
      try {
        const Z = yield X;
        return yield Promise.all(
          Z.getTracks().map((te) =>
            __awaiter$1(this, void 0, void 0, function* () {
              const ne = te.kind === "audio";
              let ae = ne ? Y.audio : Y.video;
              (typeof ae == "boolean" || !ae) && (ae = {});
              let se;
              const fe = ne ? Q.audio : Q.video;
              typeof fe != "boolean" && (se = fe);
              const ce = te.getSettings().deviceId;
              se?.deviceId && unwrapConstraint(se.deviceId) !== ce
                ? (se.deviceId = ce)
                : se || (se = { deviceId: ce });
              const ue = mediaTrackToLocalTrack(te, se, j);
              return (
                ue.kind === Track.Kind.Video
                  ? (ue.source = Track.Source.Camera)
                  : ue.kind === Track.Kind.Audio &&
                    (ue.source = Track.Source.Microphone),
                (ue.mediaStream = Z),
                isAudioTrack(ue) && B
                  ? yield ue.setProcessor(B)
                  : isVideoTrack(ue) && q && (yield ue.setProcessor(q)),
                ue
              );
            })
          )
        );
      } catch (Z) {
        if (!V) throw Z;
        return createLocalTracks(
          Object.assign(Object.assign({}, U), { audio: H, video: G }),
          j
        );
      }
    });
  }
  function createLocalVideoTrack(U) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return (yield createLocalTracks({ audio: !1, video: !0 }))[0];
    });
  }
  function createLocalAudioTrack(U) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return (yield createLocalTracks({ audio: U ?? !0, video: !1 }))[0];
    });
  }
  var ConnectionQuality$2;
  (function (U) {
    (U.Excellent = "excellent"),
      (U.Good = "good"),
      (U.Poor = "poor"),
      (U.Lost = "lost"),
      (U.Unknown = "unknown");
  })(ConnectionQuality$2 || (ConnectionQuality$2 = {}));
  function qualityFromProto(U) {
    switch (U) {
      case ConnectionQuality$1.EXCELLENT:
        return ConnectionQuality$2.Excellent;
      case ConnectionQuality$1.GOOD:
        return ConnectionQuality$2.Good;
      case ConnectionQuality$1.POOR:
        return ConnectionQuality$2.Poor;
      case ConnectionQuality$1.LOST:
        return ConnectionQuality$2.Lost;
      default:
        return ConnectionQuality$2.Unknown;
    }
  }
  class Participant extends eventsExports.EventEmitter {
    get logContext() {
      var j, V;
      return Object.assign(
        {},
        (V =
          (j = this.loggerOptions) === null || j === void 0
            ? void 0
            : j.loggerContextCb) === null || V === void 0
          ? void 0
          : V.call(j)
      );
    }
    get isEncrypted() {
      return (
        this.trackPublications.size > 0 &&
        Array.from(this.trackPublications.values()).every((j) => j.isEncrypted)
      );
    }
    get isAgent() {
      var j;
      return (
        ((j = this.permissions) === null || j === void 0 ? void 0 : j.agent) ||
        this.kind === ParticipantInfo_Kind.AGENT
      );
    }
    get isActive() {
      var j;
      return (
        ((j = this.participantInfo) === null || j === void 0
          ? void 0
          : j.state) === ParticipantInfo_State.ACTIVE
      );
    }
    get kind() {
      return this._kind;
    }
    get attributes() {
      return Object.freeze(Object.assign({}, this._attributes));
    }
    constructor(j, V, B, q, $, H) {
      let G =
        arguments.length > 6 && arguments[6] !== void 0
          ? arguments[6]
          : ParticipantInfo_Kind.STANDARD;
      var Y;
      super(),
        (this.audioLevel = 0),
        (this.isSpeaking = !1),
        (this._connectionQuality = ConnectionQuality$2.Unknown),
        (this.log = livekitLogger),
        (this.log = getLogger(
          (Y = H?.loggerName) !== null && Y !== void 0
            ? Y
            : LoggerNames.Participant
        )),
        (this.loggerOptions = H),
        this.setMaxListeners(100),
        (this.sid = j),
        (this.identity = V),
        (this.name = B),
        (this.metadata = q),
        (this.audioTrackPublications = new Map()),
        (this.videoTrackPublications = new Map()),
        (this.trackPublications = new Map()),
        (this._kind = G),
        (this._attributes = $ ?? {});
    }
    getTrackPublications() {
      return Array.from(this.trackPublications.values());
    }
    getTrackPublication(j) {
      for (const [, V] of this.trackPublications) if (V.source === j) return V;
    }
    getTrackPublicationByName(j) {
      for (const [, V] of this.trackPublications)
        if (V.trackName === j) return V;
    }
    waitUntilActive() {
      return this.isActive
        ? Promise.resolve()
        : this.activeFuture
        ? this.activeFuture.promise
        : ((this.activeFuture = new Future()),
          this.once(ParticipantEvent.Active, () => {
            var j, V;
            (V =
              (j = this.activeFuture) === null || j === void 0
                ? void 0
                : j.resolve) === null ||
              V === void 0 ||
              V.call(j),
              (this.activeFuture = void 0);
          }),
          this.activeFuture.promise);
    }
    get connectionQuality() {
      return this._connectionQuality;
    }
    get isCameraEnabled() {
      var j;
      const V = this.getTrackPublication(Track.Source.Camera);
      return !(!((j = V?.isMuted) !== null && j !== void 0) || j);
    }
    get isMicrophoneEnabled() {
      var j;
      const V = this.getTrackPublication(Track.Source.Microphone);
      return !(!((j = V?.isMuted) !== null && j !== void 0) || j);
    }
    get isScreenShareEnabled() {
      return !!this.getTrackPublication(Track.Source.ScreenShare);
    }
    get isLocal() {
      return !1;
    }
    get joinedAt() {
      return this.participantInfo
        ? new Date(
            Number.parseInt(this.participantInfo.joinedAt.toString()) * 1e3
          )
        : new Date();
    }
    updateInfo(j) {
      var V;
      return this.participantInfo &&
        this.participantInfo.sid === j.sid &&
        this.participantInfo.version > j.version
        ? !1
        : ((this.identity = j.identity),
          (this.sid = j.sid),
          this._setName(j.name),
          this._setMetadata(j.metadata),
          this._setAttributes(j.attributes),
          j.state === ParticipantInfo_State.ACTIVE &&
            ((V = this.participantInfo) === null || V === void 0
              ? void 0
              : V.state) !== ParticipantInfo_State.ACTIVE &&
            this.emit(ParticipantEvent.Active),
          j.permission && this.setPermissions(j.permission),
          (this.participantInfo = j),
          !0);
    }
    _setMetadata(j) {
      const V = this.metadata !== j,
        B = this.metadata;
      (this.metadata = j),
        V && this.emit(ParticipantEvent.ParticipantMetadataChanged, B);
    }
    _setName(j) {
      const V = this.name !== j;
      (this.name = j),
        V && this.emit(ParticipantEvent.ParticipantNameChanged, j);
    }
    _setAttributes(j) {
      const V = diffAttributes(this.attributes, j);
      (this._attributes = j),
        Object.keys(V).length > 0 &&
          this.emit(ParticipantEvent.AttributesChanged, V);
    }
    setPermissions(j) {
      var V, B, q, $, H, G;
      const Y = this.permissions,
        Q =
          j.canPublish !==
            ((V = this.permissions) === null || V === void 0
              ? void 0
              : V.canPublish) ||
          j.canSubscribe !==
            ((B = this.permissions) === null || B === void 0
              ? void 0
              : B.canSubscribe) ||
          j.canPublishData !==
            ((q = this.permissions) === null || q === void 0
              ? void 0
              : q.canPublishData) ||
          j.hidden !==
            (($ = this.permissions) === null || $ === void 0
              ? void 0
              : $.hidden) ||
          j.recorder !==
            ((H = this.permissions) === null || H === void 0
              ? void 0
              : H.recorder) ||
          j.canPublishSources.length !==
            this.permissions.canPublishSources.length ||
          j.canPublishSources.some((X, Z) => {
            var te;
            return (
              X !==
              ((te = this.permissions) === null || te === void 0
                ? void 0
                : te.canPublishSources[Z])
            );
          }) ||
          j.canSubscribeMetrics !==
            ((G = this.permissions) === null || G === void 0
              ? void 0
              : G.canSubscribeMetrics);
      return (
        (this.permissions = j),
        Q && this.emit(ParticipantEvent.ParticipantPermissionsChanged, Y),
        Q
      );
    }
    setIsSpeaking(j) {
      j !== this.isSpeaking &&
        ((this.isSpeaking = j),
        j && (this.lastSpokeAt = new Date()),
        this.emit(ParticipantEvent.IsSpeakingChanged, j));
    }
    setConnectionQuality(j) {
      const V = this._connectionQuality;
      (this._connectionQuality = qualityFromProto(j)),
        V !== this._connectionQuality &&
          this.emit(
            ParticipantEvent.ConnectionQualityChanged,
            this._connectionQuality
          );
    }
    setDisconnected() {
      var j, V;
      this.activeFuture &&
        ((V = (j = this.activeFuture).reject) === null ||
          V === void 0 ||
          V.call(j, new Error("Participant disconnected")),
        (this.activeFuture = void 0));
    }
    setAudioContext(j) {
      (this.audioContext = j),
        this.audioTrackPublications.forEach(
          (V) => isAudioTrack(V.track) && V.track.setAudioContext(j)
        );
    }
    addTrackPublication(j) {
      j.on(TrackEvent.Muted, () => {
        this.emit(ParticipantEvent.TrackMuted, j);
      }),
        j.on(TrackEvent.Unmuted, () => {
          this.emit(ParticipantEvent.TrackUnmuted, j);
        });
      const V = j;
      switch (
        (V.track && (V.track.sid = j.trackSid),
        this.trackPublications.set(j.trackSid, j),
        j.kind)
      ) {
        case Track.Kind.Audio:
          this.audioTrackPublications.set(j.trackSid, j);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.set(j.trackSid, j);
          break;
      }
    }
  }
  function trackPermissionToProto(U) {
    var j, V, B;
    if (!U.participantSid && !U.participantIdentity)
      throw new Error(
        "Invalid track permission, must provide at least one of participantIdentity and participantSid"
      );
    return new TrackPermission({
      participantIdentity:
        (j = U.participantIdentity) !== null && j !== void 0 ? j : "",
      participantSid: (V = U.participantSid) !== null && V !== void 0 ? V : "",
      allTracks: (B = U.allowAll) !== null && B !== void 0 ? B : !1,
      trackSids: U.allowedTrackSids || [],
    });
  }
  const STREAM_CHUNK_SIZE = 15e3;
  class LocalParticipant extends Participant {
    constructor(j, V, B, q, $) {
      super(j, V, void 0, void 0, void 0, {
        loggerName: q.loggerName,
        loggerContextCb: () => this.engine.logContext,
      }),
        (this.pendingPublishing = new Set()),
        (this.pendingPublishPromises = new Map()),
        (this.participantTrackPermissions = []),
        (this.allParticipantsAllowedToSubscribe = !0),
        (this.encryptionType = Encryption_Type.NONE),
        (this.enabledPublishVideoCodecs = []),
        (this.pendingAcks = new Map()),
        (this.pendingResponses = new Map()),
        (this.handleReconnecting = () => {
          this.reconnectFuture || (this.reconnectFuture = new Future());
        }),
        (this.handleReconnected = () => {
          var H, G;
          (G =
            (H = this.reconnectFuture) === null || H === void 0
              ? void 0
              : H.resolve) === null ||
            G === void 0 ||
            G.call(H),
            (this.reconnectFuture = void 0),
            this.updateTrackSubscriptionPermissions();
        }),
        (this.handleDisconnected = () => {
          var H, G, Y, Q, X, Z;
          this.reconnectFuture &&
            (this.reconnectFuture.promise.catch((te) =>
              this.log.warn(te.message, this.logContext)
            ),
            (G =
              (H = this.reconnectFuture) === null || H === void 0
                ? void 0
                : H.reject) === null ||
              G === void 0 ||
              G.call(H, "Got disconnected during reconnection attempt"),
            (this.reconnectFuture = void 0)),
            this.signalConnectedFuture &&
              ((Q = (Y = this.signalConnectedFuture).reject) === null ||
                Q === void 0 ||
                Q.call(Y, "Got disconnected without signal connected"),
              (this.signalConnectedFuture = void 0)),
            (Z =
              (X = this.activeAgentFuture) === null || X === void 0
                ? void 0
                : X.reject) === null ||
              Z === void 0 ||
              Z.call(X, "Got disconnected without active agent present"),
            (this.activeAgentFuture = void 0),
            (this.firstActiveAgent = void 0);
        }),
        (this.handleSignalConnected = (H) => {
          var G, Y;
          H.participant && this.updateInfo(H.participant),
            this.signalConnectedFuture ||
              (this.signalConnectedFuture = new Future()),
            (Y = (G = this.signalConnectedFuture).resolve) === null ||
              Y === void 0 ||
              Y.call(G);
        }),
        (this.handleSignalRequestResponse = (H) => {
          const { requestId: G, reason: Y, message: Q } = H,
            X = this.pendingSignalRequests.get(G);
          X &&
            (Y !== RequestResponse_Reason.OK &&
              X.reject(new SignalRequestError(Q, Y)),
            this.pendingSignalRequests.delete(G));
        }),
        (this.handleDataPacket = (H) => {
          switch (H.value.case) {
            case "rpcResponse":
              let G = H.value.value,
                Y = null,
                Q = null;
              G.value.case === "payload"
                ? (Y = G.value.value)
                : G.value.case === "error" &&
                  (Q = RpcError.fromProto(G.value.value)),
                this.handleIncomingRpcResponse(G.requestId, Y, Q);
              break;
            case "rpcAck":
              let X = H.value.value;
              this.handleIncomingRpcAck(X.requestId);
              break;
          }
        }),
        (this.updateTrackSubscriptionPermissions = () => {
          this.log.debug(
            "updating track subscription permissions",
            Object.assign(Object.assign({}, this.logContext), {
              allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,
              participantTrackPermissions: this.participantTrackPermissions,
            })
          ),
            this.engine.client.sendUpdateSubscriptionPermissions(
              this.allParticipantsAllowedToSubscribe,
              this.participantTrackPermissions.map((H) =>
                trackPermissionToProto(H)
              )
            );
        }),
        (this.onTrackUnmuted = (H) => {
          this.onTrackMuted(H, H.isUpstreamPaused);
        }),
        (this.onTrackMuted = (H, G) => {
          if ((G === void 0 && (G = !0), !H.sid)) {
            this.log.error(
              "could not update mute status for unpublished track",
              Object.assign(
                Object.assign({}, this.logContext),
                getLogContextFromTrack(H)
              )
            );
            return;
          }
          this.engine.updateMuteStatus(H.sid, G);
        }),
        (this.onTrackUpstreamPaused = (H) => {
          this.log.debug(
            "upstream paused",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(H)
            )
          ),
            this.onTrackMuted(H, !0);
        }),
        (this.onTrackUpstreamResumed = (H) => {
          this.log.debug(
            "upstream resumed",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(H)
            )
          ),
            this.onTrackMuted(H, H.isMuted);
        }),
        (this.onTrackFeatureUpdate = (H) => {
          const G = this.audioTrackPublications.get(H.sid);
          if (!G) {
            this.log.warn(
              "Could not update local audio track settings, missing publication for track ".concat(
                H.sid
              ),
              this.logContext
            );
            return;
          }
          this.engine.client.sendUpdateLocalAudioTrack(
            G.trackSid,
            G.getTrackFeatures()
          );
        }),
        (this.onTrackCpuConstrained = (H, G) => {
          this.log.debug(
            "track cpu constrained",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(G)
            )
          ),
            this.emit(ParticipantEvent.LocalTrackCpuConstrained, H, G);
        }),
        (this.handleSubscribedQualityUpdate = (H) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var G, Y, Q, X, Z;
            if (
              !(
                !((Z = this.roomOptions) === null || Z === void 0) && Z.dynacast
              )
            )
              return;
            const te = this.videoTrackPublications.get(H.trackSid);
            if (!te) {
              this.log.warn(
                "received subscribed quality update for unknown track",
                Object.assign(Object.assign({}, this.logContext), {
                  trackSid: H.trackSid,
                })
              );
              return;
            }
            if (!te.videoTrack) return;
            const ne = yield te.videoTrack.setPublishingCodecs(
              H.subscribedCodecs
            );
            try {
              for (
                var ae = !0, se = __asyncValues(ne), fe;
                (fe = yield se.next()), (G = fe.done), !G;
                ae = !0
              ) {
                (X = fe.value), (ae = !1);
                const ce = X;
                isBackupCodec(ce) &&
                  (this.log.debug(
                    "publish ".concat(ce, " for ").concat(te.videoTrack.sid),
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(te)
                    )
                  ),
                  yield this.publishAdditionalCodecForTrack(
                    te.videoTrack,
                    ce,
                    te.options
                  ));
              }
            } catch (ce) {
              Y = { error: ce };
            } finally {
              try {
                !ae && !G && (Q = se.return) && (yield Q.call(se));
              } finally {
                if (Y) throw Y.error;
              }
            }
          })),
        (this.handleLocalTrackUnpublished = (H) => {
          const G = this.trackPublications.get(H.trackSid);
          if (!G) {
            this.log.warn(
              "received unpublished event for unknown track",
              Object.assign(Object.assign({}, this.logContext), {
                trackSid: H.trackSid,
              })
            );
            return;
          }
          this.unpublishTrack(G.track);
        }),
        (this.handleTrackEnded = (H) =>
          __awaiter$1(this, void 0, void 0, function* () {
            if (
              H.source === Track.Source.ScreenShare ||
              H.source === Track.Source.ScreenShareAudio
            )
              this.log.debug(
                "unpublishing local track due to TrackEnded",
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack(H)
                )
              ),
                this.unpublishTrack(H);
            else if (H.isUserProvided) yield H.mute();
            else if (isLocalAudioTrack(H) || isLocalVideoTrack(H))
              try {
                if (isWeb())
                  try {
                    const G = yield navigator?.permissions.query({
                      name:
                        H.source === Track.Source.Camera
                          ? "camera"
                          : "microphone",
                    });
                    if (G && G.state === "denied")
                      throw (
                        (this.log.warn(
                          "user has revoked access to ".concat(H.source),
                          Object.assign(
                            Object.assign({}, this.logContext),
                            getLogContextFromTrack(H)
                          )
                        ),
                        (G.onchange = () => {
                          G.state !== "denied" &&
                            (H.isMuted || H.restartTrack(),
                            (G.onchange = null));
                        }),
                        new Error("GetUserMedia Permission denied"))
                      );
                  } catch {}
                H.isMuted ||
                  (this.log.debug(
                    "track ended, attempting to use a different device",
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(H)
                    )
                  ),
                  isLocalAudioTrack(H)
                    ? yield H.restartTrack({ deviceId: "default" })
                    : yield H.restartTrack());
              } catch {
                this.log.warn(
                  "could not restart track, muting instead",
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(H)
                  )
                ),
                  yield H.mute();
              }
          })),
        (this.audioTrackPublications = new Map()),
        (this.videoTrackPublications = new Map()),
        (this.trackPublications = new Map()),
        (this.engine = B),
        (this.roomOptions = q),
        this.setupEngine(B),
        (this.activeDeviceMap = new Map([
          ["audioinput", "default"],
          ["videoinput", "default"],
          ["audiooutput", "default"],
        ])),
        (this.pendingSignalRequests = new Map()),
        (this.rpcHandlers = $);
    }
    get lastCameraError() {
      return this.cameraError;
    }
    get lastMicrophoneError() {
      return this.microphoneError;
    }
    get isE2EEEnabled() {
      return this.encryptionType !== Encryption_Type.NONE;
    }
    getTrackPublication(j) {
      const V = super.getTrackPublication(j);
      if (V) return V;
    }
    getTrackPublicationByName(j) {
      const V = super.getTrackPublicationByName(j);
      if (V) return V;
    }
    setupEngine(j) {
      var V;
      (this.engine = j),
        this.engine.on(EngineEvent.RemoteMute, (B, q) => {
          const $ = this.trackPublications.get(B);
          !$ || !$.track || (q ? $.mute() : $.unmute());
        }),
        !((V = this.signalConnectedFuture) === null || V === void 0) &&
          V.isResolved &&
          (this.signalConnectedFuture = void 0),
        this.engine
          .on(EngineEvent.Connected, this.handleReconnected)
          .on(EngineEvent.SignalConnected, this.handleSignalConnected)
          .on(EngineEvent.SignalRestarted, this.handleReconnected)
          .on(EngineEvent.SignalResumed, this.handleReconnected)
          .on(EngineEvent.Restarting, this.handleReconnecting)
          .on(EngineEvent.Resuming, this.handleReconnecting)
          .on(
            EngineEvent.LocalTrackUnpublished,
            this.handleLocalTrackUnpublished
          )
          .on(
            EngineEvent.SubscribedQualityUpdate,
            this.handleSubscribedQualityUpdate
          )
          .on(EngineEvent.Disconnected, this.handleDisconnected)
          .on(
            EngineEvent.SignalRequestResponse,
            this.handleSignalRequestResponse
          )
          .on(EngineEvent.DataPacketReceived, this.handleDataPacket);
    }
    setMetadata(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({ metadata: j });
      });
    }
    setName(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({ name: j });
      });
    }
    setAttributes(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.requestMetadataUpdate({ attributes: j });
      });
    }
    requestMetadataUpdate(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let { metadata: q, name: $, attributes: H } = V;
        return (function* () {
          return new Promise((G, Y) =>
            __awaiter$1(B, void 0, void 0, function* () {
              var Q, X;
              try {
                let Z = !1;
                const te = yield this.engine.client.sendUpdateLocalMetadata(
                    (Q = q ?? this.metadata) !== null && Q !== void 0 ? Q : "",
                    (X = $ ?? this.name) !== null && X !== void 0 ? X : "",
                    H
                  ),
                  ne = performance.now();
                for (
                  this.pendingSignalRequests.set(te, {
                    resolve: G,
                    reject: (ae) => {
                      Y(ae), (Z = !0);
                    },
                    values: { name: $, metadata: q, attributes: H },
                  });
                  performance.now() - ne < 5e3 && !Z;

                ) {
                  if (
                    (!$ || this.name === $) &&
                    (!q || this.metadata === q) &&
                    (!H ||
                      Object.entries(H).every((ae) => {
                        let [se, fe] = ae;
                        return (
                          this.attributes[se] === fe ||
                          (fe === "" && !this.attributes[se])
                        );
                      }))
                  ) {
                    this.pendingSignalRequests.delete(te), G();
                    return;
                  }
                  yield sleep$1(50);
                }
                Y(
                  new SignalRequestError(
                    "Request to update local metadata timed out",
                    "TimeoutError"
                  )
                );
              } catch (Z) {
                Z instanceof Error && Y(Z);
              }
            })
          );
        })();
      });
    }
    setCameraEnabled(j, V, B) {
      return this.setTrackEnabled(Track.Source.Camera, j, V, B);
    }
    setMicrophoneEnabled(j, V, B) {
      return this.setTrackEnabled(Track.Source.Microphone, j, V, B);
    }
    setScreenShareEnabled(j, V, B) {
      return this.setTrackEnabled(Track.Source.ScreenShare, j, V, B);
    }
    setPermissions(j) {
      const V = this.permissions,
        B = super.setPermissions(j);
      return (
        B && V && this.emit(ParticipantEvent.ParticipantPermissionsChanged, V),
        B
      );
    }
    setE2EEEnabled(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        (this.encryptionType = j ? Encryption_Type.GCM : Encryption_Type.NONE),
          yield this.republishAllTracks(void 0, !1);
      });
    }
    setTrackEnabled(j, V, B, q) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var $, H;
        this.log.debug(
          "setTrackEnabled",
          Object.assign(Object.assign({}, this.logContext), {
            source: j,
            enabled: V,
          })
        ),
          this.republishPromise && (yield this.republishPromise);
        let G = this.getTrackPublication(j);
        if (V)
          if (G) yield G.unmute();
          else {
            let Y;
            if (this.pendingPublishing.has(j)) {
              const Q = yield this.waitForPendingPublicationOfSource(j);
              return (
                Q ||
                  this.log.info(
                    "waiting for pending publication promise timed out",
                    Object.assign(Object.assign({}, this.logContext), {
                      source: j,
                    })
                  ),
                yield Q?.unmute(),
                Q
              );
            }
            this.pendingPublishing.add(j);
            try {
              switch (j) {
                case Track.Source.Camera:
                  Y = yield this.createTracks({
                    video: ($ = B) !== null && $ !== void 0 ? $ : !0,
                  });
                  break;
                case Track.Source.Microphone:
                  Y = yield this.createTracks({
                    audio: (H = B) !== null && H !== void 0 ? H : !0,
                  });
                  break;
                case Track.Source.ScreenShare:
                  Y = yield this.createScreenTracks(Object.assign({}, B));
                  break;
                default:
                  throw new TrackInvalidError(j);
              }
            } catch (Q) {
              throw (
                (Y?.forEach((X) => {
                  X.stop();
                }),
                Q instanceof Error &&
                  this.emit(
                    ParticipantEvent.MediaDevicesError,
                    Q,
                    sourceToKind(j)
                  ),
                this.pendingPublishing.delete(j),
                Q)
              );
            }
            for (const Q of Y)
              j === Track.Source.Microphone &&
                isAudioTrack(Q) &&
                q?.preConnectBuffer &&
                (this.log.info(
                  "starting preconnect buffer for microphone",
                  Object.assign({}, this.logContext)
                ),
                Q.startPreConnectBuffer());
            try {
              const Q = [];
              for (const Z of Y)
                this.log.info(
                  "publishing track",
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(Z)
                  )
                ),
                  Q.push(this.publishTrack(Z, q));
              [G] = yield Promise.all(Q);
            } catch (Q) {
              throw (
                (Y?.forEach((X) => {
                  X.stop();
                }),
                Q)
              );
            } finally {
              this.pendingPublishing.delete(j);
            }
          }
        else if (
          (!G?.track &&
            this.pendingPublishing.has(j) &&
            ((G = yield this.waitForPendingPublicationOfSource(j)),
            G ||
              this.log.info(
                "waiting for pending publication promise timed out",
                Object.assign(Object.assign({}, this.logContext), { source: j })
              )),
          G && G.track)
        )
          if (j === Track.Source.ScreenShare) {
            G = yield this.unpublishTrack(G.track);
            const Y = this.getTrackPublication(Track.Source.ScreenShareAudio);
            Y && Y.track && this.unpublishTrack(Y.track);
          } else yield G.mute();
        return G;
      });
    }
    enableCameraAndMicrophone() {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (
          !(
            this.pendingPublishing.has(Track.Source.Camera) ||
            this.pendingPublishing.has(Track.Source.Microphone)
          )
        ) {
          this.pendingPublishing.add(Track.Source.Camera),
            this.pendingPublishing.add(Track.Source.Microphone);
          try {
            const j = yield this.createTracks({ audio: !0, video: !0 });
            yield Promise.all(j.map((V) => this.publishTrack(V)));
          } finally {
            this.pendingPublishing.delete(Track.Source.Camera),
              this.pendingPublishing.delete(Track.Source.Microphone);
          }
        }
      });
    }
    createTracks(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B;
        j ?? (j = {});
        const q = mergeDefaultOptions(
          j,
          (V = this.roomOptions) === null || V === void 0
            ? void 0
            : V.audioCaptureDefaults,
          (B = this.roomOptions) === null || B === void 0
            ? void 0
            : B.videoCaptureDefaults
        );
        try {
          return (yield createLocalTracks(q, {
            loggerName: this.roomOptions.loggerName,
            loggerContextCb: () => this.logContext,
          })).map(
            (G) => (
              isAudioTrack(G) &&
                ((this.microphoneError = void 0),
                G.setAudioContext(this.audioContext),
                (G.source = Track.Source.Microphone),
                this.emit(ParticipantEvent.AudioStreamAcquired)),
              isVideoTrack(G) &&
                ((this.cameraError = void 0), (G.source = Track.Source.Camera)),
              G
            )
          );
        } catch ($) {
          throw (
            ($ instanceof Error &&
              (j.audio && (this.microphoneError = $),
              j.video && (this.cameraError = $)),
            $)
          );
        }
      });
    }
    createScreenTracks(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (
          (j === void 0 && (j = {}),
          navigator.mediaDevices.getDisplayMedia === void 0)
        )
          throw new DeviceUnsupportedError("getDisplayMedia not supported");
        j.resolution === void 0 &&
          !isSafari17Based() &&
          (j.resolution = ScreenSharePresets.h1080fps30.resolution);
        const V = screenCaptureToDisplayMediaStreamOptions(j),
          B = yield navigator.mediaDevices.getDisplayMedia(V),
          q = B.getVideoTracks();
        if (q.length === 0) throw new TrackInvalidError("no video track found");
        const $ = new LocalVideoTrack(q[0], void 0, !1, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext,
        });
        ($.source = Track.Source.ScreenShare),
          j.contentHint && ($.mediaStreamTrack.contentHint = j.contentHint);
        const H = [$];
        if (B.getAudioTracks().length > 0) {
          this.emit(ParticipantEvent.AudioStreamAcquired);
          const G = new LocalAudioTrack(
            B.getAudioTracks()[0],
            void 0,
            !1,
            this.audioContext,
            {
              loggerName: this.roomOptions.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          (G.source = Track.Source.ScreenShareAudio), H.push(G);
        }
        return H;
      });
    }
    publishTrack(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.publishOrRepublishTrack(j, V);
      });
    }
    publishOrRepublishTrack(j, V) {
      return __awaiter$1(this, arguments, void 0, function (B, q) {
        var $ = this;
        let H =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        return (function* () {
          var G, Y, Q, X;
          isLocalAudioTrack(B) && B.setAudioContext($.audioContext),
            yield (G = $.reconnectFuture) === null || G === void 0
              ? void 0
              : G.promise,
            $.republishPromise && !H && (yield $.republishPromise),
            isLocalTrack(B) &&
              $.pendingPublishPromises.has(B) &&
              (yield $.pendingPublishPromises.get(B));
          let Z;
          if (B instanceof MediaStreamTrack) Z = B.getConstraints();
          else {
            Z = B.constraints;
            let ce;
            switch (B.source) {
              case Track.Source.Microphone:
                ce = "audioinput";
                break;
              case Track.Source.Camera:
                ce = "videoinput";
            }
            ce &&
              $.activeDeviceMap.has(ce) &&
              (Z = Object.assign(Object.assign({}, Z), {
                deviceId: $.activeDeviceMap.get(ce),
              }));
          }
          if (B instanceof MediaStreamTrack)
            switch (B.kind) {
              case "audio":
                B = new LocalAudioTrack(B, Z, !0, $.audioContext, {
                  loggerName: $.roomOptions.loggerName,
                  loggerContextCb: () => $.logContext,
                });
                break;
              case "video":
                B = new LocalVideoTrack(B, Z, !0, {
                  loggerName: $.roomOptions.loggerName,
                  loggerContextCb: () => $.logContext,
                });
                break;
              default:
                throw new TrackInvalidError(
                  "unsupported MediaStreamTrack kind ".concat(B.kind)
                );
            }
          else
            B.updateLoggerOptions({
              loggerName: $.roomOptions.loggerName,
              loggerContextCb: () => $.logContext,
            });
          let te;
          if (
            ($.trackPublications.forEach((ce) => {
              ce.track && ce.track === B && (te = ce);
            }),
            te)
          )
            return (
              $.log.warn(
                "track has already been published, skipping",
                Object.assign(
                  Object.assign({}, $.logContext),
                  getLogContextFromTrack(te)
                )
              ),
              te
            );
          const ne =
              ("channelCount" in B.mediaStreamTrack.getSettings() &&
                B.mediaStreamTrack.getSettings().channelCount === 2) ||
              B.mediaStreamTrack.getConstraints().channelCount === 2,
            ae = (Y = q?.forceStereo) !== null && Y !== void 0 ? Y : ne;
          ae &&
            (q || (q = {}),
            q.dtx === void 0 &&
              $.log.info(
                "Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.",
                Object.assign(
                  Object.assign({}, $.logContext),
                  getLogContextFromTrack(B)
                )
              ),
            q.red === void 0 &&
              $.log.info(
                "Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work."
              ),
            ((Q = q.dtx) !== null && Q !== void 0) || (q.dtx = !1),
            ((X = q.red) !== null && X !== void 0) || (q.red = !1));
          const se = Object.assign(
            Object.assign({}, $.roomOptions.publishDefaults),
            q
          );
          !isE2EESimulcastSupported() &&
            $.roomOptions.e2ee &&
            ($.log.info(
              "End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2",
              Object.assign({}, $.logContext)
            ),
            (se.simulcast = !1)),
            se.source && (B.source = se.source);
          const fe = new Promise((ce, ue) =>
            __awaiter$1($, void 0, void 0, function* () {
              try {
                if (
                  this.engine.client.currentState !==
                  SignalConnectionState.CONNECTED
                ) {
                  this.log.debug(
                    "deferring track publication until signal is connected",
                    Object.assign(Object.assign({}, this.logContext), {
                      track: getLogContextFromTrack(B),
                    })
                  );
                  const he = setTimeout(() => {
                    ue(
                      new PublishTrackError(
                        "publishing rejected as engine not connected within timeout",
                        408
                      )
                    );
                  }, 15e3);
                  yield this.waitUntilEngineConnected(), clearTimeout(he);
                  const me = yield this.publish(B, se, ae);
                  ce(me);
                } else
                  try {
                    const he = yield this.publish(B, se, ae);
                    ce(he);
                  } catch (he) {
                    ue(he);
                  }
              } catch (he) {
                ue(he);
              }
            })
          );
          $.pendingPublishPromises.set(B, fe);
          try {
            return yield fe;
          } catch (ce) {
            throw ce;
          } finally {
            $.pendingPublishPromises.delete(B);
          }
        })();
      });
    }
    waitUntilEngineConnected() {
      return (
        this.signalConnectedFuture ||
          (this.signalConnectedFuture = new Future()),
        this.signalConnectedFuture.promise
      );
    }
    hasPermissionsToPublish(j) {
      if (!this.permissions)
        return (
          this.log.warn(
            "no permissions present for publishing track",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(j)
            )
          ),
          !1
        );
      const { canPublish: V, canPublishSources: B } = this.permissions;
      return V &&
        (B.length === 0 ||
          B.map((q) => getTrackSourceFromProto(q)).includes(j.source))
        ? !0
        : (this.log.warn(
            "insufficient permissions to publish",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(j)
            )
          ),
          !1);
    }
    publish(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var q, $, H, G, Y, Q, X, Z, te, ne;
        if (!this.hasPermissionsToPublish(j))
          throw new PublishTrackError(
            "failed to publish track, insufficient permissions",
            403
          );
        Array.from(this.trackPublications.values()).find(
          (Re) => isLocalTrack(j) && Re.source === j.source
        ) &&
          j.source !== Track.Source.Unknown &&
          this.log.info(
            "publishing a second track with the same source: ".concat(j.source),
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(j)
            )
          ),
          V.stopMicTrackOnMute && isAudioTrack(j) && (j.stopOnMute = !0),
          j.source === Track.Source.ScreenShare &&
            isFireFox() &&
            (V.simulcast = !1),
          V.videoCodec === "av1" && !supportsAV1() && (V.videoCodec = void 0),
          V.videoCodec === "vp9" && !supportsVP9() && (V.videoCodec = void 0),
          V.videoCodec === void 0 && (V.videoCodec = defaultVideoCodec),
          this.enabledPublishVideoCodecs.length > 0 &&
            (this.enabledPublishVideoCodecs.some(
              (Re) => V.videoCodec === mimeTypeToVideoCodecString(Re.mime)
            ) ||
              (V.videoCodec = mimeTypeToVideoCodecString(
                this.enabledPublishVideoCodecs[0].mime
              )));
        const se = V.videoCodec;
        j.on(TrackEvent.Muted, this.onTrackMuted),
          j.on(TrackEvent.Unmuted, this.onTrackUnmuted),
          j.on(TrackEvent.Ended, this.handleTrackEnded),
          j.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused),
          j.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed),
          j.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);
        const fe = [],
          ce = !(!((q = V.dtx) !== null && q !== void 0) || q),
          ue = j.getSourceTrackSettings();
        ue.autoGainControl && fe.push(AudioTrackFeature.TF_AUTO_GAIN_CONTROL),
          ue.echoCancellation &&
            fe.push(AudioTrackFeature.TF_ECHO_CANCELLATION),
          ue.noiseSuppression &&
            fe.push(AudioTrackFeature.TF_NOISE_SUPPRESSION),
          ue.channelCount &&
            ue.channelCount > 1 &&
            fe.push(AudioTrackFeature.TF_STEREO),
          ce && fe.push(AudioTrackFeature.TF_NO_DTX),
          isLocalAudioTrack(j) &&
            j.hasPreConnectBuffer &&
            fe.push(AudioTrackFeature.TF_PRECONNECT_BUFFER);
        const he = new AddTrackRequest({
          cid: j.mediaStreamTrack.id,
          name: V.name,
          type: Track.kindToProto(j.kind),
          muted: j.isMuted,
          source: Track.sourceToProto(j.source),
          disableDtx: ce,
          encryption: this.encryptionType,
          stereo: B,
          disableRed:
            this.isE2EEEnabled ||
            !(!(($ = V.red) !== null && $ !== void 0) || $),
          stream: V?.stream,
          backupCodecPolicy: V?.backupCodecPolicy,
          audioFeatures: fe,
        });
        let me;
        if (j.kind === Track.Kind.Video) {
          let Re = { width: 0, height: 0 };
          try {
            Re = yield j.waitForDimensions();
          } catch {
            const be =
              (G =
                (H = this.roomOptions.videoCaptureDefaults) === null ||
                H === void 0
                  ? void 0
                  : H.resolution) !== null && G !== void 0
                ? G
                : VideoPresets.h720.resolution;
            (Re = { width: be.width, height: be.height }),
              this.log.error(
                "could not determine track dimensions, using defaults",
                Object.assign(
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(j)
                  ),
                  { dims: Re }
                )
              );
          }
          (he.width = Re.width),
            (he.height = Re.height),
            isLocalVideoTrack(j) &&
              (isSVCCodec(se) &&
                (j.source === Track.Source.ScreenShare &&
                  ((V.scalabilityMode = "L1T3"),
                  "contentHint" in j.mediaStreamTrack &&
                    ((j.mediaStreamTrack.contentHint = "motion"),
                    this.log.info(
                      "forcing contentHint to motion for screenshare with SVC codecs",
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(j)
                      )
                    ))),
                (V.scalabilityMode =
                  (Y = V.scalabilityMode) !== null && Y !== void 0
                    ? Y
                    : "L3T3_KEY")),
              (he.simulcastCodecs = [
                new SimulcastCodec({ codec: se, cid: j.mediaStreamTrack.id }),
              ]),
              V.backupCodec === !0 &&
                (V.backupCodec = { codec: defaultVideoCodec }),
              V.backupCodec &&
                se !== V.backupCodec.codec &&
                he.encryption === Encryption_Type.NONE &&
                (this.roomOptions.dynacast || (this.roomOptions.dynacast = !0),
                he.simulcastCodecs.push(
                  new SimulcastCodec({ codec: V.backupCodec.codec, cid: "" })
                ))),
            (me = computeVideoEncodings(
              j.source === Track.Source.ScreenShare,
              he.width,
              he.height,
              V
            )),
            (he.layers = videoLayersFromEncodings(
              he.width,
              he.height,
              me,
              isSVCCodec(V.videoCodec)
            ));
        } else j.kind === Track.Kind.Audio && (me = [{ maxBitrate: (Q = V.audioPreset) === null || Q === void 0 ? void 0 : Q.maxBitrate, priority: (Z = (X = V.audioPreset) === null || X === void 0 ? void 0 : X.priority) !== null && Z !== void 0 ? Z : "high", networkPriority: (ne = (te = V.audioPreset) === null || te === void 0 ? void 0 : te.priority) !== null && ne !== void 0 ? ne : "high" }]);
        if (!this.engine || this.engine.isClosed)
          throw new UnexpectedConnectionState(
            "cannot publish track when not connected"
          );
        const ve = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            var Re, Ae, be;
            if (!this.engine.pcManager)
              throw new UnexpectedConnectionState("pcManager is not ready");
            if (
              ((j.sender = yield this.engine.createSender(j, V, me)),
              this.emit(ParticipantEvent.LocalSenderCreated, j.sender, j),
              isLocalVideoTrack(j) &&
                (((Re = V.degradationPreference) !== null && Re !== void 0) ||
                  (V.degradationPreference =
                    getDefaultDegradationPreference(j)),
                j.setDegradationPreference(V.degradationPreference)),
              me)
            )
              if (isFireFox() && j.kind === Track.Kind.Audio) {
                let Le;
                for (const Fe of this.engine.pcManager.publisher.getTransceivers())
                  if (Fe.sender === j.sender) {
                    Le = Fe;
                    break;
                  }
                Le &&
                  this.engine.pcManager.publisher.setTrackCodecBitrate({
                    transceiver: Le,
                    codec: "opus",
                    maxbr:
                      !((Ae = me[0]) === null || Ae === void 0) && Ae.maxBitrate
                        ? me[0].maxBitrate / 1e3
                        : 0,
                  });
              } else
                j.codec &&
                  isSVCCodec(j.codec) &&
                  !((be = me[0]) === null || be === void 0) &&
                  be.maxBitrate &&
                  this.engine.pcManager.publisher.setTrackCodecBitrate({
                    cid: he.cid,
                    codec: j.codec,
                    maxbr: me[0].maxBitrate / 1e3,
                  });
            yield this.engine.negotiate();
          });
        let ge;
        const Ee = new Promise((Re, Ae) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var be;
            try {
              (ge = yield this.engine.addTrack(he)), Re(ge);
            } catch (Le) {
              j.sender &&
                !((be = this.engine.pcManager) === null || be === void 0) &&
                be.publisher &&
                (this.engine.pcManager.publisher.removeTrack(j.sender),
                yield this.engine.negotiate().catch((Fe) => {
                  this.log.error(
                    "failed to negotiate after removing track due to failed add track request",
                    Object.assign(
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(j)
                      ),
                      { error: Fe }
                    )
                  );
                })),
                Ae(Le);
            }
          })
        );
        if (this.enabledPublishVideoCodecs.length > 0)
          ge = (yield Promise.all([Ee, ve()]))[0];
        else {
          ge = yield Ee;
          let Re;
          if (
            (ge.codecs.forEach((Ae) => {
              Re === void 0 && (Re = Ae.mimeType);
            }),
            Re && j.kind === Track.Kind.Video)
          ) {
            const Ae = mimeTypeToVideoCodecString(Re);
            Ae !== se &&
              (this.log.debug(
                "falling back to server selected codec",
                Object.assign(
                  Object.assign(
                    Object.assign({}, this.logContext),
                    getLogContextFromTrack(j)
                  ),
                  { codec: Ae }
                )
              ),
              (V.videoCodec = Ae),
              (me = computeVideoEncodings(
                j.source === Track.Source.ScreenShare,
                he.width,
                he.height,
                V
              )));
          }
          yield ve();
        }
        const Ce = new LocalTrackPublication(j.kind, ge, j, {
          loggerName: this.roomOptions.loggerName,
          loggerContextCb: () => this.logContext,
        });
        if (
          (Ce.on(TrackEvent.CpuConstrained, (Re) =>
            this.onTrackCpuConstrained(Re, Ce)
          ),
          (Ce.options = V),
          (j.sid = ge.sid),
          this.log.debug(
            "publishing ".concat(j.kind, " with encodings"),
            Object.assign(Object.assign({}, this.logContext), {
              encodings: me,
              trackInfo: ge,
            })
          ),
          isLocalVideoTrack(j)
            ? j.startMonitor(this.engine.client)
            : isLocalAudioTrack(j) && j.startMonitor(),
          this.addTrackPublication(Ce),
          this.emit(ParticipantEvent.LocalTrackPublished, Ce),
          isLocalAudioTrack(j) &&
            ge.audioFeatures.includes(AudioTrackFeature.TF_PRECONNECT_BUFFER))
        ) {
          const Re = j.getPreConnectBuffer();
          this.on(ParticipantEvent.LocalTrackSubscribed, (Ae) => {
            if (Ae.trackSid === ge.sid) {
              if (!j.hasPreConnectBuffer) {
                this.log.warn(
                  "subscribe event came to late, buffer already closed",
                  this.logContext
                );
                return;
              }
              this.log.debug(
                "finished recording preconnect buffer",
                Object.assign(
                  Object.assign({}, this.logContext),
                  getLogContextFromTrack(j)
                )
              ),
                j.stopPreConnectBuffer();
            }
          }),
            Re &&
              new Promise((be, Le) =>
                __awaiter$1(this, void 0, void 0, function* () {
                  var Fe, Me, je, Te, xe, He;
                  try {
                    this.log.debug(
                      "waiting for agent",
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(j)
                      )
                    );
                    const Ge = setTimeout(() => {
                        Le(new Error("agent not active within 10 seconds"));
                      }, 1e4),
                      pe = yield this.waitUntilActiveAgentPresent();
                    clearTimeout(Ge),
                      this.log.debug(
                        "sending preconnect buffer",
                        Object.assign(
                          Object.assign({}, this.logContext),
                          getLogContextFromTrack(j)
                        )
                      );
                    const Ye = yield this.streamBytes({
                      name: "preconnect-buffer",
                      mimeType: "audio/opus",
                      topic: "lk.agent.pre-connect-audio-buffer",
                      destinationIdentities: [pe.identity],
                      attributes: {
                        trackId: Ce.trackSid,
                        sampleRate: String(
                          (xe = ue.sampleRate) !== null && xe !== void 0
                            ? xe
                            : "48000"
                        ),
                        channels: String(
                          (He = ue.channelCount) !== null && He !== void 0
                            ? He
                            : "1"
                        ),
                      },
                    });
                    try {
                      for (
                        var Je = !0, oe = __asyncValues(Re), De;
                        (De = yield oe.next()), (Fe = De.done), !Fe;
                        Je = !0
                      ) {
                        (Te = De.value), (Je = !1);
                        const Qe = Te;
                        yield Ye.write(Qe);
                      }
                    } catch (Qe) {
                      Me = { error: Qe };
                    } finally {
                      try {
                        !Je && !Fe && (je = oe.return) && (yield je.call(oe));
                      } finally {
                        if (Me) throw Me.error;
                      }
                    }
                    yield Ye.close(), be();
                  } catch (Ge) {
                    Le(Ge);
                  }
                })
              )
                .then(() => {
                  this.log.debug(
                    "preconnect buffer sent successfully",
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack(j)
                    )
                  );
                })
                .catch((be) => {
                  this.log.error(
                    "error sending preconnect buffer",
                    Object.assign(
                      Object.assign(
                        Object.assign({}, this.logContext),
                        getLogContextFromTrack(j)
                      ),
                      { error: be }
                    )
                  );
                });
        }
        return Ce;
      });
    }
    get isLocal() {
      return !0;
    }
    publishAdditionalCodecForTrack(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var q;
        if (this.encryptionType !== Encryption_Type.NONE) return;
        let $;
        if (
          (this.trackPublications.forEach((ne) => {
            ne.track && ne.track === j && ($ = ne);
          }),
          !$)
        )
          throw new TrackInvalidError("track is not published");
        if (!isLocalVideoTrack(j))
          throw new TrackInvalidError("track is not a video track");
        const H = Object.assign(
            Object.assign(
              {},
              (q = this.roomOptions) === null || q === void 0
                ? void 0
                : q.publishDefaults
            ),
            B
          ),
          G = computeTrackBackupEncodings(j, V, H);
        if (!G) {
          this.log.info(
            "backup codec has been disabled, ignoring request to add additional codec for track",
            Object.assign(
              Object.assign({}, this.logContext),
              getLogContextFromTrack(j)
            )
          );
          return;
        }
        const Y = j.addSimulcastTrack(V, G);
        if (!Y) return;
        const Q = new AddTrackRequest({
          cid: Y.mediaStreamTrack.id,
          type: Track.kindToProto(j.kind),
          muted: j.isMuted,
          source: Track.sourceToProto(j.source),
          sid: j.sid,
          simulcastCodecs: [
            { codec: H.videoCodec, cid: Y.mediaStreamTrack.id },
          ],
        });
        if (
          ((Q.layers = videoLayersFromEncodings(Q.width, Q.height, G)),
          !this.engine || this.engine.isClosed)
        )
          throw new UnexpectedConnectionState(
            "cannot publish track when not connected"
          );
        const X = () =>
            __awaiter$1(this, void 0, void 0, function* () {
              yield this.engine.createSimulcastSender(j, Y, H, G),
                yield this.engine.negotiate();
            }),
          te = (yield Promise.all([this.engine.addTrack(Q), X()]))[0];
        this.log.debug(
          "published ".concat(V, " for track ").concat(j.sid),
          Object.assign(Object.assign({}, this.logContext), {
            encodings: G,
            trackInfo: te,
          })
        );
      });
    }
    unpublishTrack(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B, q;
        if (isLocalTrack(j)) {
          const Q = this.pendingPublishPromises.get(j);
          Q &&
            (this.log.info(
              "awaiting publish promise before attempting to unpublish",
              Object.assign(
                Object.assign({}, this.logContext),
                getLogContextFromTrack(j)
              )
            ),
            yield Q);
        }
        const $ = this.getPublicationForTrack(j),
          H = $ ? getLogContextFromTrack($) : void 0;
        if (
          (this.log.debug(
            "unpublishing track",
            Object.assign(Object.assign({}, this.logContext), H)
          ),
          !$ || !$.track)
        ) {
          this.log.warn(
            "track was not unpublished because no publication was found",
            Object.assign(Object.assign({}, this.logContext), H)
          );
          return;
        }
        (j = $.track),
          j.off(TrackEvent.Muted, this.onTrackMuted),
          j.off(TrackEvent.Unmuted, this.onTrackUnmuted),
          j.off(TrackEvent.Ended, this.handleTrackEnded),
          j.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused),
          j.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed),
          j.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate),
          V === void 0 &&
            (V =
              (q =
                (B = this.roomOptions) === null || B === void 0
                  ? void 0
                  : B.stopLocalTrackOnUnpublish) !== null && q !== void 0
                ? q
                : !0),
          V ? j.stop() : j.stopMonitor();
        let G = !1;
        const Y = j.sender;
        if (
          ((j.sender = void 0),
          this.engine.pcManager &&
            this.engine.pcManager.currentState < PCTransportState.FAILED &&
            Y)
        )
          try {
            for (const Q of this.engine.pcManager.publisher.getTransceivers())
              Q.sender === Y && ((Q.direction = "inactive"), (G = !0));
            if (
              (this.engine.removeTrack(Y) && (G = !0), isLocalVideoTrack(j))
            ) {
              for (const [, Q] of j.simulcastCodecs)
                Q.sender &&
                  (this.engine.removeTrack(Q.sender) && (G = !0),
                  (Q.sender = void 0));
              j.simulcastCodecs.clear();
            }
          } catch (Q) {
            this.log.warn(
              "failed to unpublish track",
              Object.assign(
                Object.assign(Object.assign({}, this.logContext), H),
                { error: Q }
              )
            );
          }
        switch ((this.trackPublications.delete($.trackSid), $.kind)) {
          case Track.Kind.Audio:
            this.audioTrackPublications.delete($.trackSid);
            break;
          case Track.Kind.Video:
            this.videoTrackPublications.delete($.trackSid);
            break;
        }
        return (
          this.emit(ParticipantEvent.LocalTrackUnpublished, $),
          $.setTrack(void 0),
          G && (yield this.engine.negotiate()),
          $
        );
      });
    }
    unpublishTracks(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return (yield Promise.all(j.map((B) => this.unpublishTrack(B)))).filter(
          (B) => !!B
        );
      });
    }
    republishAllTracks(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
        return (function* () {
          B.republishPromise && (yield B.republishPromise),
            (B.republishPromise = new Promise(($, H) =>
              __awaiter$1(B, void 0, void 0, function* () {
                try {
                  const G = [];
                  this.trackPublications.forEach((Y) => {
                    Y.track &&
                      (V &&
                        (Y.options = Object.assign(
                          Object.assign({}, Y.options),
                          V
                        )),
                      G.push(Y));
                  }),
                    yield Promise.all(
                      G.map((Y) =>
                        __awaiter$1(this, void 0, void 0, function* () {
                          const Q = Y.track;
                          yield this.unpublishTrack(Q, !1),
                            q &&
                              !Q.isMuted &&
                              Q.source !== Track.Source.ScreenShare &&
                              Q.source !== Track.Source.ScreenShareAudio &&
                              (isLocalAudioTrack(Q) || isLocalVideoTrack(Q)) &&
                              !Q.isUserProvided &&
                              (this.log.debug(
                                "restarting existing track",
                                Object.assign(
                                  Object.assign({}, this.logContext),
                                  { track: Y.trackSid }
                                )
                              ),
                              yield Q.restartTrack()),
                            yield this.publishOrRepublishTrack(
                              Q,
                              Y.options,
                              !0
                            );
                        })
                      )
                    ),
                    $();
                } catch (G) {
                  H(G);
                } finally {
                  this.republishPromise = void 0;
                }
              })
            )),
            yield B.republishPromise;
        })();
      });
    }
    publishData(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let q =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return (function* () {
          const $ = q.reliable
              ? DataPacket_Kind.RELIABLE
              : DataPacket_Kind.LOSSY,
            H = q.destinationIdentities,
            G = q.topic,
            Y = new DataPacket({
              kind: $,
              value: {
                case: "user",
                value: new UserPacket({
                  participantIdentity: B.identity,
                  payload: V,
                  destinationIdentities: H,
                  topic: G,
                }),
              },
            });
          yield B.engine.sendDataPacket(Y, $);
        })();
      });
    }
    publishDtmf(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = new DataPacket({
          kind: DataPacket_Kind.RELIABLE,
          value: { case: "sipDtmf", value: new SipDTMF({ code: j, digit: V }) },
        });
        yield this.engine.sendDataPacket(B, DataPacket_Kind.RELIABLE);
      });
    }
    sendChatMessage(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = {
            id: crypto.randomUUID(),
            message: j,
            timestamp: Date.now(),
            attachedFiles: V?.attachments,
          },
          q = new DataPacket({
            value: {
              case: "chatMessage",
              value: new ChatMessage(
                Object.assign(Object.assign({}, B), {
                  timestamp: protoInt64.parse(B.timestamp),
                })
              ),
            },
          });
        return (
          yield this.engine.sendDataPacket(q, DataPacket_Kind.RELIABLE),
          this.emit(ParticipantEvent.ChatMessage, B),
          B
        );
      });
    }
    editChatMessage(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = Object.assign(Object.assign({}, V), {
            message: j,
            editTimestamp: Date.now(),
          }),
          q = new DataPacket({
            value: {
              case: "chatMessage",
              value: new ChatMessage(
                Object.assign(Object.assign({}, B), {
                  timestamp: protoInt64.parse(B.timestamp),
                  editTimestamp: protoInt64.parse(B.editTimestamp),
                })
              ),
            },
          });
        return (
          yield this.engine.sendDataPacket(q, DataPacket_Kind.RELIABLE),
          this.emit(ParticipantEvent.ChatMessage, B),
          B
        );
      });
    }
    sendText(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B;
        const q = crypto.randomUUID(),
          H = new TextEncoder().encode(j).byteLength,
          G =
            (B = V?.attachments) === null || B === void 0
              ? void 0
              : B.map(() => crypto.randomUUID()),
          Y = new Array(G ? G.length + 1 : 1).fill(0),
          Q = (Z, te) => {
            var ne;
            Y[te] = Z;
            const ae = Y.reduce((se, fe) => se + fe, 0);
            (ne = V?.onProgress) === null || ne === void 0 || ne.call(V, ae);
          },
          X = yield this.streamText({
            streamId: q,
            totalSize: H,
            destinationIdentities: V?.destinationIdentities,
            topic: V?.topic,
            attachedStreamIds: G,
            attributes: V?.attributes,
          });
        return (
          yield X.write(j),
          Q(1, 0),
          yield X.close(),
          V?.attachments &&
            G &&
            (yield Promise.all(
              V.attachments.map((Z, te) =>
                __awaiter$1(this, void 0, void 0, function* () {
                  return this._sendFile(G[te], Z, {
                    topic: V.topic,
                    mimeType: Z.type,
                    onProgress: (ne) => {
                      Q(ne, te + 1);
                    },
                  });
                })
              )
            )),
          X.info
        );
      });
    }
    streamText(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B;
        const q =
            (V = j?.streamId) !== null && V !== void 0
              ? V
              : crypto.randomUUID(),
          $ = {
            id: q,
            mimeType: "text/plain",
            timestamp: Date.now(),
            topic: (B = j?.topic) !== null && B !== void 0 ? B : "",
            size: j?.totalSize,
            attributes: j?.attributes,
          },
          H = new DataStream_Header({
            streamId: q,
            mimeType: $.mimeType,
            topic: $.topic,
            timestamp: numberToBigInt($.timestamp),
            totalLength: numberToBigInt(j?.totalSize),
            attributes: $.attributes,
            contentHeader: {
              case: "textHeader",
              value: new DataStream_TextHeader({
                version: j?.version,
                attachedStreamIds: j?.attachedStreamIds,
                replyToStreamId: j?.replyToStreamId,
                operationType:
                  j?.type === "update"
                    ? DataStream_OperationType.UPDATE
                    : DataStream_OperationType.CREATE,
              }),
            },
          }),
          G = j?.destinationIdentities,
          Y = new DataPacket({
            destinationIdentities: G,
            value: { case: "streamHeader", value: H },
          });
        yield this.engine.sendDataPacket(Y, DataPacket_Kind.RELIABLE);
        let Q = 0;
        const X = this,
          Z = new WritableStream({
            write(ae) {
              return __awaiter$1(this, void 0, void 0, function* () {
                for (const se of splitUtf8(ae, STREAM_CHUNK_SIZE)) {
                  yield X.engine.waitForBufferStatusLow(
                    DataPacket_Kind.RELIABLE
                  );
                  const fe = new DataStream_Chunk({
                      content: se,
                      streamId: q,
                      chunkIndex: numberToBigInt(Q),
                    }),
                    ce = new DataPacket({
                      destinationIdentities: G,
                      value: { case: "streamChunk", value: fe },
                    });
                  yield X.engine.sendDataPacket(ce, DataPacket_Kind.RELIABLE),
                    (Q += 1);
                }
              });
            },
            close() {
              return __awaiter$1(this, void 0, void 0, function* () {
                const ae = new DataStream_Trailer({ streamId: q }),
                  se = new DataPacket({
                    destinationIdentities: G,
                    value: { case: "streamTrailer", value: ae },
                  });
                yield X.engine.sendDataPacket(se, DataPacket_Kind.RELIABLE);
              });
            },
            abort(ae) {
              console.log("Sink error:", ae);
            },
          });
        let te = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            yield ne.close();
          });
        X.engine.once(EngineEvent.Closing, te);
        const ne = new TextStreamWriter(Z, $, () =>
          this.engine.off(EngineEvent.Closing, te)
        );
        return ne;
      });
    }
    sendFile(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = crypto.randomUUID();
        return yield this._sendFile(B, j, V), { id: B };
      });
    }
    _sendFile(j, V, B) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var q;
        const $ = yield this.streamBytes({
            streamId: j,
            totalSize: V.size,
            name: V.name,
            mimeType: (q = B?.mimeType) !== null && q !== void 0 ? q : V.type,
            topic: B?.topic,
            destinationIdentities: B?.destinationIdentities,
          }),
          H = V.stream().getReader();
        for (;;) {
          const { done: G, value: Y } = yield H.read();
          if (G) break;
          yield $.write(Y);
        }
        return yield $.close(), $.info;
      });
    }
    streamBytes(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B, q, $, H;
        const G =
            (V = j?.streamId) !== null && V !== void 0
              ? V
              : crypto.randomUUID(),
          Y = j?.destinationIdentities,
          Q = {
            id: G,
            mimeType:
              (B = j?.mimeType) !== null && B !== void 0
                ? B
                : "application/octet-stream",
            topic: (q = j?.topic) !== null && q !== void 0 ? q : "",
            timestamp: Date.now(),
            attributes: j?.attributes,
            size: j?.totalSize,
            name: ($ = j?.name) !== null && $ !== void 0 ? $ : "unknown",
          },
          X = new DataStream_Header({
            totalLength: numberToBigInt(
              (H = Q.size) !== null && H !== void 0 ? H : 0
            ),
            mimeType: Q.mimeType,
            streamId: G,
            topic: Q.topic,
            timestamp: numberToBigInt(Date.now()),
            attributes: Q.attributes,
            contentHeader: {
              case: "byteHeader",
              value: new DataStream_ByteHeader({ name: Q.name }),
            },
          }),
          Z = new DataPacket({
            destinationIdentities: Y,
            value: { case: "streamHeader", value: X },
          });
        yield this.engine.sendDataPacket(Z, DataPacket_Kind.RELIABLE);
        let te = 0;
        const ne = new _$1(),
          ae = this.engine,
          se = this.log,
          fe = new WritableStream({
            write(ue) {
              return __awaiter$1(this, void 0, void 0, function* () {
                const he = yield ne.lock();
                let me = 0;
                try {
                  for (; me < ue.byteLength; ) {
                    const ve = ue.slice(me, me + STREAM_CHUNK_SIZE);
                    yield ae.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);
                    const ge = new DataPacket({
                      destinationIdentities: Y,
                      value: {
                        case: "streamChunk",
                        value: new DataStream_Chunk({
                          content: ve,
                          streamId: G,
                          chunkIndex: numberToBigInt(te),
                        }),
                      },
                    });
                    yield ae.sendDataPacket(ge, DataPacket_Kind.RELIABLE),
                      (te += 1),
                      (me += ve.byteLength);
                  }
                } finally {
                  he();
                }
              });
            },
            close() {
              return __awaiter$1(this, void 0, void 0, function* () {
                const ue = new DataStream_Trailer({ streamId: G }),
                  he = new DataPacket({
                    destinationIdentities: Y,
                    value: { case: "streamTrailer", value: ue },
                  });
                yield ae.sendDataPacket(he, DataPacket_Kind.RELIABLE);
              });
            },
            abort(ue) {
              se.error("Sink error:", ue);
            },
          });
        return new ByteStreamWriter(fe, Q);
      });
    }
    performRpc(j) {
      return __awaiter$1(this, arguments, void 0, function (V) {
        var B = this;
        let {
          destinationIdentity: q,
          method: $,
          payload: H,
          responseTimeout: G = 1e4,
        } = V;
        return (function* () {
          return new Promise((Q, X) =>
            __awaiter$1(B, void 0, void 0, function* () {
              var Z, te, ne, ae;
              if (byteLength(H) > MAX_PAYLOAD_BYTES) {
                X(RpcError.builtIn("REQUEST_PAYLOAD_TOO_LARGE"));
                return;
              }
              if (
                !(
                  (te =
                    (Z = this.engine.latestJoinResponse) === null ||
                    Z === void 0
                      ? void 0
                      : Z.serverInfo) === null || te === void 0
                ) &&
                te.version &&
                compareVersions(
                  (ae =
                    (ne = this.engine.latestJoinResponse) === null ||
                    ne === void 0
                      ? void 0
                      : ne.serverInfo) === null || ae === void 0
                    ? void 0
                    : ae.version,
                  "1.8.0"
                ) < 0
              ) {
                X(RpcError.builtIn("UNSUPPORTED_SERVER"));
                return;
              }
              const se = crypto.randomUUID();
              yield this.publishRpcRequest(q, se, $, H, G - 2e3);
              const fe = setTimeout(() => {
                this.pendingAcks.delete(se),
                  X(RpcError.builtIn("CONNECTION_TIMEOUT")),
                  this.pendingResponses.delete(se),
                  clearTimeout(ce);
              }, 2e3);
              this.pendingAcks.set(se, {
                resolve: () => {
                  clearTimeout(fe);
                },
                participantIdentity: q,
              });
              const ce = setTimeout(() => {
                this.pendingResponses.delete(se),
                  X(RpcError.builtIn("RESPONSE_TIMEOUT"));
              }, G);
              this.pendingResponses.set(se, {
                resolve: (ue, he) => {
                  clearTimeout(ce),
                    this.pendingAcks.has(se) &&
                      (console.warn("RPC response received before ack", se),
                      this.pendingAcks.delete(se),
                      clearTimeout(fe)),
                    he ? X(he) : Q(ue ?? "");
                },
                participantIdentity: q,
              });
            })
          );
        })();
      });
    }
    registerRpcMethod(j, V) {
      this.rpcHandlers.has(j) &&
        this.log.warn(
          "you're overriding the RPC handler for method ".concat(
            j,
            ", in the future this will throw an error"
          )
        ),
        this.rpcHandlers.set(j, V);
    }
    unregisterRpcMethod(j) {
      this.rpcHandlers.delete(j);
    }
    setTrackSubscriptionPermissions(j) {
      let V =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      (this.participantTrackPermissions = V),
        (this.allParticipantsAllowedToSubscribe = j),
        this.engine.client.isDisconnected ||
          this.updateTrackSubscriptionPermissions();
    }
    handleIncomingRpcAck(j) {
      const V = this.pendingAcks.get(j);
      V
        ? (V.resolve(), this.pendingAcks.delete(j))
        : console.error("Ack received for unexpected RPC request", j);
    }
    handleIncomingRpcResponse(j, V, B) {
      const q = this.pendingResponses.get(j);
      q
        ? (q.resolve(V, B), this.pendingResponses.delete(j))
        : console.error("Response received for unexpected RPC request", j);
    }
    publishRpcRequest(j, V, B, q, $) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const H = new DataPacket({
          destinationIdentities: [j],
          kind: DataPacket_Kind.RELIABLE,
          value: {
            case: "rpcRequest",
            value: new RpcRequest({
              id: V,
              method: B,
              payload: q,
              responseTimeoutMs: $,
              version: 1,
            }),
          },
        });
        yield this.engine.sendDataPacket(H, DataPacket_Kind.RELIABLE);
      });
    }
    handleParticipantDisconnected(j) {
      for (const [V, { participantIdentity: B }] of this.pendingAcks)
        B === j && this.pendingAcks.delete(V);
      for (const [V, { participantIdentity: B, resolve: q }] of this
        .pendingResponses)
        B === j &&
          (q(null, RpcError.builtIn("RECIPIENT_DISCONNECTED")),
          this.pendingResponses.delete(V));
    }
    setEnabledPublishCodecs(j) {
      this.enabledPublishVideoCodecs = j.filter(
        (V) => V.mime.split("/")[0].toLowerCase() === "video"
      );
    }
    updateInfo(j) {
      return super.updateInfo(j)
        ? (j.tracks.forEach((V) => {
            var B, q;
            const $ = this.trackPublications.get(V.sid);
            if ($) {
              const H =
                $.isMuted ||
                ((q =
                  (B = $.track) === null || B === void 0
                    ? void 0
                    : B.isUpstreamPaused) !== null && q !== void 0
                  ? q
                  : !1);
              H !== V.muted &&
                (this.log.debug(
                  "updating server mute state after reconcile",
                  Object.assign(
                    Object.assign(
                      Object.assign({}, this.logContext),
                      getLogContextFromTrack($)
                    ),
                    { mutedOnServer: H }
                  )
                ),
                this.engine.client.sendMuteTrack(V.sid, H));
            }
          }),
          !0)
        : !1;
    }
    setActiveAgent(j) {
      var V, B, q, $;
      (this.firstActiveAgent = j),
        j && !this.firstActiveAgent && (this.firstActiveAgent = j),
        j
          ? (B =
              (V = this.activeAgentFuture) === null || V === void 0
                ? void 0
                : V.resolve) === null ||
            B === void 0 ||
            B.call(V, j)
          : ($ =
              (q = this.activeAgentFuture) === null || q === void 0
                ? void 0
                : q.reject) === null ||
            $ === void 0 ||
            $.call(q, "Agent disconnected"),
        (this.activeAgentFuture = void 0);
    }
    waitUntilActiveAgentPresent() {
      return this.firstActiveAgent
        ? Promise.resolve(this.firstActiveAgent)
        : (this.activeAgentFuture || (this.activeAgentFuture = new Future()),
          this.activeAgentFuture.promise);
    }
    getPublicationForTrack(j) {
      let V;
      return (
        this.trackPublications.forEach((B) => {
          const q = B.track;
          q &&
            (j instanceof MediaStreamTrack
              ? (isLocalAudioTrack(q) || isLocalVideoTrack(q)) &&
                q.mediaStreamTrack === j &&
                (V = B)
              : j === q && (V = B));
        }),
        V
      );
    }
    waitForPendingPublicationOfSource(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const B = Date.now();
        for (; Date.now() < B + 1e4; ) {
          const q = Array.from(this.pendingPublishPromises.entries()).find(
            ($) => {
              let [H] = $;
              return H.source === j;
            }
          );
          if (q) return q[1];
          yield sleep$1(20);
        }
      });
    }
  }
  class RemoteTrackPublication extends TrackPublication {
    constructor(j, V, B, q) {
      super(j, V.sid, V.name, q),
        (this.track = void 0),
        (this.allowed = !0),
        (this.requestedDisabled = void 0),
        (this.visible = !0),
        (this.handleEnded = ($) => {
          this.setTrack(void 0), this.emit(TrackEvent.Ended, $);
        }),
        (this.handleVisibilityChange = ($) => {
          this.log.debug(
            "adaptivestream video visibility "
              .concat(this.trackSid, ", visible=")
              .concat($),
            this.logContext
          ),
            (this.visible = $),
            this.emitTrackUpdate();
        }),
        (this.handleVideoDimensionsChange = ($) => {
          this.log.debug(
            "adaptivestream video dimensions "
              .concat($.width, "x")
              .concat($.height),
            this.logContext
          ),
            (this.videoDimensionsAdaptiveStream = $),
            this.emitTrackUpdate();
        }),
        (this.subscribed = B),
        this.updateInfo(V);
    }
    setSubscribed(j) {
      const V = this.subscriptionStatus,
        B = this.permissionStatus;
      (this.subscribed = j), j && (this.allowed = !0);
      const q = new UpdateSubscription({
        trackSids: [this.trackSid],
        subscribe: this.subscribed,
        participantTracks: [
          new ParticipantTracks({
            participantSid: "",
            trackSids: [this.trackSid],
          }),
        ],
      });
      this.emit(TrackEvent.UpdateSubscription, q),
        this.emitSubscriptionUpdateIfChanged(V),
        this.emitPermissionUpdateIfChanged(B);
    }
    get subscriptionStatus() {
      return this.subscribed === !1
        ? TrackPublication.SubscriptionStatus.Unsubscribed
        : super.isSubscribed
        ? TrackPublication.SubscriptionStatus.Subscribed
        : TrackPublication.SubscriptionStatus.Desired;
    }
    get permissionStatus() {
      return this.allowed
        ? TrackPublication.PermissionStatus.Allowed
        : TrackPublication.PermissionStatus.NotAllowed;
    }
    get isSubscribed() {
      return this.subscribed === !1 ? !1 : super.isSubscribed;
    }
    get isDesired() {
      return this.subscribed !== !1;
    }
    get isEnabled() {
      return this.requestedDisabled !== void 0
        ? !this.requestedDisabled
        : this.isAdaptiveStream
        ? this.visible
        : !0;
    }
    get isLocal() {
      return !1;
    }
    setEnabled(j) {
      !this.isManualOperationAllowed() ||
        this.requestedDisabled === !j ||
        ((this.requestedDisabled = !j), this.emitTrackUpdate());
    }
    setVideoQuality(j) {
      !this.isManualOperationAllowed() ||
        this.requestedMaxQuality === j ||
        ((this.requestedMaxQuality = j),
        (this.requestedVideoDimensions = void 0),
        this.emitTrackUpdate());
    }
    setVideoDimensions(j) {
      var V, B;
      this.isManualOperationAllowed() &&
        ((((V = this.requestedVideoDimensions) === null || V === void 0
          ? void 0
          : V.width) === j.width &&
          ((B = this.requestedVideoDimensions) === null || B === void 0
            ? void 0
            : B.height) === j.height) ||
          (isRemoteVideoTrack(this.track) &&
            (this.requestedVideoDimensions = j),
          (this.requestedMaxQuality = void 0),
          this.emitTrackUpdate()));
    }
    setVideoFPS(j) {
      this.isManualOperationAllowed() &&
        isRemoteVideoTrack(this.track) &&
        this.fps !== j &&
        ((this.fps = j), this.emitTrackUpdate());
    }
    get videoQuality() {
      var j;
      return (j = this.requestedMaxQuality) !== null && j !== void 0
        ? j
        : VideoQuality.HIGH;
    }
    setTrack(j) {
      const V = this.subscriptionStatus,
        B = this.permissionStatus,
        q = this.track;
      q !== j &&
        (q &&
          (q.off(
            TrackEvent.VideoDimensionsChanged,
            this.handleVideoDimensionsChange
          ),
          q.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange),
          q.off(TrackEvent.Ended, this.handleEnded),
          q.detach(),
          q.stopMonitor(),
          this.emit(TrackEvent.Unsubscribed, q)),
        super.setTrack(j),
        j &&
          ((j.sid = this.trackSid),
          j.on(
            TrackEvent.VideoDimensionsChanged,
            this.handleVideoDimensionsChange
          ),
          j.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange),
          j.on(TrackEvent.Ended, this.handleEnded),
          this.emit(TrackEvent.Subscribed, j)),
        this.emitPermissionUpdateIfChanged(B),
        this.emitSubscriptionUpdateIfChanged(V));
    }
    setAllowed(j) {
      const V = this.subscriptionStatus,
        B = this.permissionStatus;
      (this.allowed = j),
        this.emitPermissionUpdateIfChanged(B),
        this.emitSubscriptionUpdateIfChanged(V);
    }
    setSubscriptionError(j) {
      this.emit(TrackEvent.SubscriptionFailed, j);
    }
    updateInfo(j) {
      super.updateInfo(j);
      const V = this.metadataMuted;
      (this.metadataMuted = j.muted),
        this.track
          ? this.track.setMuted(j.muted)
          : V !== j.muted &&
            this.emit(j.muted ? TrackEvent.Muted : TrackEvent.Unmuted);
    }
    emitSubscriptionUpdateIfChanged(j) {
      const V = this.subscriptionStatus;
      j !== V && this.emit(TrackEvent.SubscriptionStatusChanged, V, j);
    }
    emitPermissionUpdateIfChanged(j) {
      this.permissionStatus !== j &&
        this.emit(
          TrackEvent.SubscriptionPermissionChanged,
          this.permissionStatus,
          j
        );
    }
    isManualOperationAllowed() {
      return this.isDesired
        ? !0
        : (this.log.warn(
            "cannot update track settings when not subscribed",
            this.logContext
          ),
          !1);
    }
    get isAdaptiveStream() {
      return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;
    }
    emitTrackUpdate() {
      const j = new UpdateTrackSettings({
        trackSids: [this.trackSid],
        disabled: !this.isEnabled,
        fps: this.fps,
      });
      if (this.kind === Track.Kind.Video) {
        let V = this.requestedVideoDimensions;
        if (this.videoDimensionsAdaptiveStream !== void 0)
          if (V)
            areDimensionsSmaller(this.videoDimensionsAdaptiveStream, V) &&
              (this.log.debug(
                "using adaptive stream dimensions instead of requested",
                Object.assign(
                  Object.assign({}, this.logContext),
                  this.videoDimensionsAdaptiveStream
                )
              ),
              (V = this.videoDimensionsAdaptiveStream));
          else if (this.requestedMaxQuality !== void 0 && this.trackInfo) {
            const B = layerDimensionsFor(
              this.trackInfo,
              this.requestedMaxQuality
            );
            B &&
              areDimensionsSmaller(this.videoDimensionsAdaptiveStream, B) &&
              (this.log.debug(
                "using adaptive stream dimensions instead of max quality layer",
                Object.assign(
                  Object.assign({}, this.logContext),
                  this.videoDimensionsAdaptiveStream
                )
              ),
              (V = this.videoDimensionsAdaptiveStream));
          } else
            this.log.debug(
              "using adaptive stream dimensions",
              Object.assign(
                Object.assign({}, this.logContext),
                this.videoDimensionsAdaptiveStream
              )
            ),
              (V = this.videoDimensionsAdaptiveStream);
        V
          ? ((j.width = Math.ceil(V.width)), (j.height = Math.ceil(V.height)))
          : this.requestedMaxQuality !== void 0
          ? (this.log.debug(
              "using requested max quality",
              Object.assign(Object.assign({}, this.logContext), {
                quality: this.requestedMaxQuality,
              })
            ),
            (j.quality = this.requestedMaxQuality))
          : (this.log.debug(
              "using default quality",
              Object.assign(Object.assign({}, this.logContext), {
                quality: VideoQuality.HIGH,
              })
            ),
            (j.quality = VideoQuality.HIGH));
      }
      this.emit(TrackEvent.UpdateSettings, j);
    }
  }
  class RemoteParticipant extends Participant {
    static fromParticipantInfo(j, V, B) {
      return new RemoteParticipant(
        j,
        V.sid,
        V.identity,
        V.name,
        V.metadata,
        V.attributes,
        B,
        V.kind
      );
    }
    get logContext() {
      return Object.assign(Object.assign({}, super.logContext), {
        rpID: this.sid,
        remoteParticipant: this.identity,
      });
    }
    constructor(j, V, B, q, $, H, G) {
      let Y =
        arguments.length > 7 && arguments[7] !== void 0
          ? arguments[7]
          : ParticipantInfo_Kind.STANDARD;
      super(V, B || "", q, $, H, G, Y),
        (this.signalClient = j),
        (this.trackPublications = new Map()),
        (this.audioTrackPublications = new Map()),
        (this.videoTrackPublications = new Map()),
        (this.volumeMap = new Map());
    }
    addTrackPublication(j) {
      super.addTrackPublication(j),
        j.on(TrackEvent.UpdateSettings, (V) => {
          this.log.debug(
            "send update settings",
            Object.assign(
              Object.assign(
                Object.assign({}, this.logContext),
                getLogContextFromTrack(j)
              ),
              { settings: V }
            )
          ),
            this.signalClient.sendUpdateTrackSettings(V);
        }),
        j.on(TrackEvent.UpdateSubscription, (V) => {
          V.participantTracks.forEach((B) => {
            B.participantSid = this.sid;
          }),
            this.signalClient.sendUpdateSubscription(V);
        }),
        j.on(TrackEvent.SubscriptionPermissionChanged, (V) => {
          this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, j, V);
        }),
        j.on(TrackEvent.SubscriptionStatusChanged, (V) => {
          this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, j, V);
        }),
        j.on(TrackEvent.Subscribed, (V) => {
          this.emit(ParticipantEvent.TrackSubscribed, V, j);
        }),
        j.on(TrackEvent.Unsubscribed, (V) => {
          this.emit(ParticipantEvent.TrackUnsubscribed, V, j);
        }),
        j.on(TrackEvent.SubscriptionFailed, (V) => {
          this.emit(ParticipantEvent.TrackSubscriptionFailed, j.trackSid, V);
        });
    }
    getTrackPublication(j) {
      const V = super.getTrackPublication(j);
      if (V) return V;
    }
    getTrackPublicationByName(j) {
      const V = super.getTrackPublicationByName(j);
      if (V) return V;
    }
    setVolume(j) {
      let V =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : Track.Source.Microphone;
      this.volumeMap.set(V, j);
      const B = this.getTrackPublication(V);
      B && B.track && B.track.setVolume(j);
    }
    getVolume() {
      let j =
        arguments.length > 0 && arguments[0] !== void 0
          ? arguments[0]
          : Track.Source.Microphone;
      const V = this.getTrackPublication(j);
      return V && V.track ? V.track.getVolume() : this.volumeMap.get(j);
    }
    addSubscribedMediaTrack(j, V, B, q, $, H) {
      let G = this.getTrackPublicationBySid(V);
      if (
        (G ||
          V.startsWith("TR") ||
          this.trackPublications.forEach((X) => {
            !G && j.kind === X.kind.toString() && (G = X);
          }),
        !G)
      ) {
        if (H === 0) {
          this.log.error(
            "could not find published track",
            Object.assign(Object.assign({}, this.logContext), { trackSid: V })
          ),
            this.emit(ParticipantEvent.TrackSubscriptionFailed, V);
          return;
        }
        H === void 0 && (H = 20),
          setTimeout(() => {
            this.addSubscribedMediaTrack(j, V, B, q, $, H - 1);
          }, 150);
        return;
      }
      if (j.readyState === "ended") {
        this.log.error(
          "unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()",
          Object.assign(
            Object.assign({}, this.logContext),
            getLogContextFromTrack(G)
          )
        ),
          this.emit(ParticipantEvent.TrackSubscriptionFailed, V);
        return;
      }
      const Y = j.kind === "video";
      let Q;
      return (
        Y
          ? (Q = new RemoteVideoTrack(j, V, q, $))
          : (Q = new RemoteAudioTrack(
              j,
              V,
              q,
              this.audioContext,
              this.audioOutput
            )),
        (Q.source = G.source),
        (Q.isMuted = G.isMuted),
        Q.setMediaStream(B),
        Q.start(),
        G.setTrack(Q),
        this.volumeMap.has(G.source) &&
          isRemoteTrack(Q) &&
          isAudioTrack(Q) &&
          Q.setVolume(this.volumeMap.get(G.source)),
        G
      );
    }
    get hasMetadata() {
      return !!this.participantInfo;
    }
    getTrackPublicationBySid(j) {
      return this.trackPublications.get(j);
    }
    updateInfo(j) {
      if (!super.updateInfo(j)) return !1;
      const V = new Map(),
        B = new Map();
      return (
        j.tracks.forEach((q) => {
          var $, H;
          let G = this.getTrackPublicationBySid(q.sid);
          if (G) G.updateInfo(q);
          else {
            const Y = Track.kindFromProto(q.type);
            if (!Y) return;
            (G = new RemoteTrackPublication(
              Y,
              q,
              ($ = this.signalClient.connectOptions) === null || $ === void 0
                ? void 0
                : $.autoSubscribe,
              {
                loggerContextCb: () => this.logContext,
                loggerName:
                  (H = this.loggerOptions) === null || H === void 0
                    ? void 0
                    : H.loggerName,
              }
            )),
              G.updateInfo(q),
              B.set(q.sid, G);
            const Q = Array.from(this.trackPublications.values()).find(
              (X) => X.source === G?.source
            );
            Q &&
              G.source !== Track.Source.Unknown &&
              this.log.debug(
                "received a second track publication for "
                  .concat(this.identity, " with the same source: ")
                  .concat(G.source),
                Object.assign(Object.assign({}, this.logContext), {
                  oldTrack: getLogContextFromTrack(Q),
                  newTrack: getLogContextFromTrack(G),
                })
              ),
              this.addTrackPublication(G);
          }
          V.set(q.sid, G);
        }),
        this.trackPublications.forEach((q) => {
          V.has(q.trackSid) ||
            (this.log.trace(
              "detected removed track on remote participant, unpublishing",
              Object.assign(
                Object.assign({}, this.logContext),
                getLogContextFromTrack(q)
              )
            ),
            this.unpublishTrack(q.trackSid, !0));
        }),
        B.forEach((q) => {
          this.emit(ParticipantEvent.TrackPublished, q);
        }),
        !0
      );
    }
    unpublishTrack(j, V) {
      const B = this.trackPublications.get(j);
      if (!B) return;
      const { track: q } = B;
      switch (
        (q && (q.stop(), B.setTrack(void 0)),
        this.trackPublications.delete(j),
        B.kind)
      ) {
        case Track.Kind.Audio:
          this.audioTrackPublications.delete(j);
          break;
        case Track.Kind.Video:
          this.videoTrackPublications.delete(j);
          break;
      }
      V && this.emit(ParticipantEvent.TrackUnpublished, B);
    }
    setAudioOutput(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.audioOutput = j;
        const V = [];
        this.audioTrackPublications.forEach((B) => {
          var q;
          isAudioTrack(B.track) &&
            isRemoteTrack(B.track) &&
            V.push(
              B.track.setSinkId(
                (q = j.deviceId) !== null && q !== void 0 ? q : "default"
              )
            );
        }),
          yield Promise.all(V);
      });
    }
    emit(j) {
      for (
        var V = arguments.length, B = new Array(V > 1 ? V - 1 : 0), q = 1;
        q < V;
        q++
      )
        B[q - 1] = arguments[q];
      return (
        this.log.trace(
          "participant event",
          Object.assign(Object.assign({}, this.logContext), {
            event: j,
            args: B,
          })
        ),
        super.emit(j, ...B)
      );
    }
  }
  var ConnectionState;
  (function (U) {
    (U.Disconnected = "disconnected"),
      (U.Connecting = "connecting"),
      (U.Connected = "connected"),
      (U.Reconnecting = "reconnecting"),
      (U.SignalReconnecting = "signalReconnecting");
  })(ConnectionState || (ConnectionState = {}));
  const connectionReconcileFrequency = 4 * 1e3;
  class Room extends eventsExports.EventEmitter {
    constructor(j) {
      var V, B, q, $;
      if (
        (super(),
        (V = this),
        (this.state = ConnectionState.Disconnected),
        (this.activeSpeakers = []),
        (this.isE2EEEnabled = !1),
        (this.audioEnabled = !0),
        (this.isVideoPlaybackBlocked = !1),
        (this.log = livekitLogger),
        (this.bufferedEvents = []),
        (this.isResuming = !1),
        (this.byteStreamControllers = new Map()),
        (this.textStreamControllers = new Map()),
        (this.byteStreamHandlers = new Map()),
        (this.textStreamHandlers = new Map()),
        (this.rpcHandlers = new Map()),
        (this.connect = (H, G, Y) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var Q;
            if (!isBrowserSupported())
              throw isReactNative()
                ? Error(
                    "WebRTC isn't detected, have you called registerGlobals?"
                  )
                : Error(
                    "LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC."
                  );
            const X = yield this.disconnectLock.lock();
            if (this.state === ConnectionState.Connected)
              return (
                this.log.info(
                  "already connected to room ".concat(this.name),
                  this.logContext
                ),
                X(),
                Promise.resolve()
              );
            if (this.connectFuture) return X(), this.connectFuture.promise;
            this.setAndEmitConnectionState(ConnectionState.Connecting),
              ((Q = this.regionUrlProvider) === null || Q === void 0
                ? void 0
                : Q.getServerUrl().toString()) !== H &&
                ((this.regionUrl = void 0), (this.regionUrlProvider = void 0)),
              isCloud(new URL(H)) &&
                (this.regionUrlProvider === void 0
                  ? (this.regionUrlProvider = new RegionUrlProvider(H, G))
                  : this.regionUrlProvider.updateToken(G),
                this.regionUrlProvider
                  .fetchRegionSettings()
                  .then((ne) => {
                    var ae;
                    (ae = this.regionUrlProvider) === null ||
                      ae === void 0 ||
                      ae.setServerReportedRegions(ne);
                  })
                  .catch((ne) => {
                    this.log.warn(
                      "could not fetch region settings",
                      Object.assign(Object.assign({}, this.logContext), {
                        error: ne,
                      })
                    );
                  }));
            const Z = (ne, ae, se) =>
                __awaiter$1(this, void 0, void 0, function* () {
                  var fe, ce;
                  this.abortController && this.abortController.abort();
                  const ue = new AbortController();
                  (this.abortController = ue), X?.();
                  try {
                    yield this.attemptConnection(se ?? H, G, Y, ue),
                      (this.abortController = void 0),
                      ne();
                  } catch (he) {
                    if (
                      this.regionUrlProvider &&
                      he instanceof ConnectionError &&
                      he.reason !== ConnectionErrorReason.Cancelled &&
                      he.reason !== ConnectionErrorReason.NotAllowed
                    ) {
                      let me = null;
                      try {
                        me = yield this.regionUrlProvider.getNextBestRegionUrl(
                          (fe = this.abortController) === null || fe === void 0
                            ? void 0
                            : fe.signal
                        );
                      } catch (ve) {
                        if (
                          ve instanceof ConnectionError &&
                          (ve.status === 401 ||
                            ve.reason === ConnectionErrorReason.Cancelled)
                        ) {
                          this.handleDisconnect(
                            this.options.stopLocalTrackOnUnpublish
                          ),
                            ae(ve);
                          return;
                        }
                      }
                      me &&
                      !(
                        !(
                          (ce = this.abortController) === null || ce === void 0
                        ) && ce.signal.aborted
                      )
                        ? (this.log.info(
                            "Initial connection failed with ConnectionError: "
                              .concat(
                                he.message,
                                ". Retrying with another region: "
                              )
                              .concat(me),
                            this.logContext
                          ),
                          this.recreateEngine(),
                          yield Z(ne, ae, me))
                        : (this.handleDisconnect(
                            this.options.stopLocalTrackOnUnpublish,
                            getDisconnectReasonFromConnectionError(he)
                          ),
                          ae(he));
                    } else {
                      let me = DisconnectReason.UNKNOWN_REASON;
                      he instanceof ConnectionError &&
                        (me = getDisconnectReasonFromConnectionError(he)),
                        this.handleDisconnect(
                          this.options.stopLocalTrackOnUnpublish,
                          me
                        ),
                        ae(he);
                    }
                  }
                }),
              te = this.regionUrl;
            return (
              (this.regionUrl = void 0),
              (this.connectFuture = new Future(
                (ne, ae) => {
                  Z(ne, ae, te);
                },
                () => {
                  this.clearConnectionFutures();
                }
              )),
              this.connectFuture.promise
            );
          })),
        (this.connectSignal = (H, G, Y, Q, X, Z) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var te, ne, ae;
            const se = yield Y.join(
              H,
              G,
              {
                autoSubscribe: Q.autoSubscribe,
                adaptiveStream:
                  typeof X.adaptiveStream == "object" ? !0 : X.adaptiveStream,
                maxRetries: Q.maxRetries,
                e2eeEnabled: !!this.e2eeManager,
                websocketTimeout: Q.websocketTimeout,
              },
              Z.signal
            );
            let fe = se.serverInfo;
            if (
              (fe ||
                (fe = { version: se.serverVersion, region: se.serverRegion }),
              (this.serverInfo = fe),
              this.log.debug(
                "connected to Livekit Server ".concat(
                  Object.entries(fe)
                    .map((ce) => {
                      let [ue, he] = ce;
                      return "".concat(ue, ": ").concat(he);
                    })
                    .join(", ")
                ),
                {
                  room:
                    (te = se.room) === null || te === void 0 ? void 0 : te.name,
                  roomSid:
                    (ne = se.room) === null || ne === void 0 ? void 0 : ne.sid,
                  identity:
                    (ae = se.participant) === null || ae === void 0
                      ? void 0
                      : ae.identity,
                }
              ),
              !fe.version)
            )
              throw new UnsupportedServer("unknown server version");
            return (
              fe.version === "0.15.1" &&
                this.options.dynacast &&
                (this.log.debug(
                  "disabling dynacast due to server version",
                  this.logContext
                ),
                (X.dynacast = !1)),
              se
            );
          })),
        (this.applyJoinResponse = (H) => {
          const G = H.participant;
          if (
            ((this.localParticipant.sid = G.sid),
            (this.localParticipant.identity = G.identity),
            this.localParticipant.setEnabledPublishCodecs(
              H.enabledPublishCodecs
            ),
            this.options.e2ee && this.e2eeManager)
          )
            try {
              this.e2eeManager.setSifTrailer(H.sifTrailer);
            } catch (Y) {
              this.log.error(
                Y instanceof Error ? Y.message : "Could not set SifTrailer",
                Object.assign(Object.assign({}, this.logContext), { error: Y })
              );
            }
          this.handleParticipantUpdates([G, ...H.otherParticipants]),
            H.room && this.handleRoomUpdate(H.room);
        }),
        (this.attemptConnection = (H, G, Y, Q) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var X, Z;
            this.state === ConnectionState.Reconnecting ||
            this.isResuming ||
            (!((X = this.engine) === null || X === void 0) &&
              X.pendingReconnect)
              ? (this.log.info(
                  "Reconnection attempt replaced by new connection attempt",
                  this.logContext
                ),
                this.recreateEngine())
              : this.maybeCreateEngine(),
              !((Z = this.regionUrlProvider) === null || Z === void 0) &&
                Z.isCloud() &&
                this.engine.setRegionUrlProvider(this.regionUrlProvider),
              this.acquireAudioContext(),
              (this.connOptions = Object.assign(
                Object.assign({}, roomConnectOptionDefaults),
                Y
              )),
              this.connOptions.rtcConfig &&
                (this.engine.rtcConfig = this.connOptions.rtcConfig),
              this.connOptions.peerConnectionTimeout &&
                (this.engine.peerConnectionTimeout =
                  this.connOptions.peerConnectionTimeout);
            try {
              const te = yield this.connectSignal(
                H,
                G,
                this.engine,
                this.connOptions,
                this.options,
                Q
              );
              this.applyJoinResponse(te),
                this.setupLocalParticipantEvents(),
                this.emit(RoomEvent.SignalConnected);
            } catch (te) {
              yield this.engine.close(), this.recreateEngine();
              const ne = new ConnectionError(
                "could not establish signal connection",
                ConnectionErrorReason.ServerUnreachable
              );
              throw (
                (te instanceof Error &&
                  (ne.message = "".concat(ne.message, ": ").concat(te.message)),
                te instanceof ConnectionError &&
                  ((ne.reason = te.reason), (ne.status = te.status)),
                this.log.debug(
                  "error trying to establish signal connection",
                  Object.assign(Object.assign({}, this.logContext), {
                    error: te,
                  })
                ),
                ne)
              );
            }
            if (Q.signal.aborted)
              throw (
                (yield this.engine.close(),
                this.recreateEngine(),
                new ConnectionError(
                  "Connection attempt aborted",
                  ConnectionErrorReason.Cancelled
                ))
              );
            try {
              yield this.engine.waitForPCInitialConnection(
                this.connOptions.peerConnectionTimeout,
                Q
              );
            } catch (te) {
              throw (yield this.engine.close(), this.recreateEngine(), te);
            }
            isWeb() &&
              this.options.disconnectOnPageLeave &&
              (window.addEventListener("pagehide", this.onPageLeave),
              window.addEventListener("beforeunload", this.onPageLeave)),
              isWeb() && document.addEventListener("freeze", this.onPageLeave),
              this.setAndEmitConnectionState(ConnectionState.Connected),
              this.emit(RoomEvent.Connected),
              this.registerConnectionReconcile();
          })),
        (this.disconnect = function () {
          for (var H = arguments.length, G = new Array(H), Y = 0; Y < H; Y++)
            G[Y] = arguments[Y];
          return __awaiter$1(V, [...G], void 0, function () {
            var Q = this;
            let X =
              arguments.length > 0 && arguments[0] !== void 0
                ? arguments[0]
                : !0;
            return (function* () {
              var Z, te, ne, ae;
              const se = yield Q.disconnectLock.lock();
              try {
                if (Q.state === ConnectionState.Disconnected) {
                  Q.log.debug("already disconnected", Q.logContext);
                  return;
                }
                Q.log.info(
                  "disconnect from room",
                  Object.assign({}, Q.logContext)
                ),
                  (Q.state === ConnectionState.Connecting ||
                    Q.state === ConnectionState.Reconnecting ||
                    Q.isResuming) &&
                    (Q.log.warn("abort connection attempt", Q.logContext),
                    (Z = Q.abortController) === null ||
                      Z === void 0 ||
                      Z.abort(),
                    (ne =
                      (te = Q.connectFuture) === null || te === void 0
                        ? void 0
                        : te.reject) === null ||
                      ne === void 0 ||
                      ne.call(
                        te,
                        new ConnectionError(
                          "Client initiated disconnect",
                          ConnectionErrorReason.Cancelled
                        )
                      ),
                    (Q.connectFuture = void 0)),
                  (!((ae = Q.engine) === null || ae === void 0) &&
                    ae.client.isDisconnected) ||
                    (yield Q.engine.client.sendLeave()),
                  Q.engine && (yield Q.engine.close()),
                  Q.handleDisconnect(X, DisconnectReason.CLIENT_INITIATED),
                  (Q.engine = void 0);
              } finally {
                se();
              }
            })();
          });
        }),
        (this.onPageLeave = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            this.log.info(
              "Page leave detected, disconnecting",
              this.logContext
            ),
              yield this.disconnect();
          })),
        (this.startAudio = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            const H = [],
              G = getBrowser();
            if (G && G.os === "iOS") {
              const Y = "livekit-dummy-audio-el";
              let Q = document.getElementById(Y);
              if (!Q) {
                (Q = document.createElement("audio")),
                  (Q.id = Y),
                  (Q.autoplay = !0),
                  (Q.hidden = !0);
                const X = getEmptyAudioStreamTrack();
                X.enabled = !0;
                const Z = new MediaStream([X]);
                (Q.srcObject = Z),
                  document.addEventListener("visibilitychange", () => {
                    Q &&
                      ((Q.srcObject = document.hidden ? null : Z),
                      document.hidden ||
                        (this.log.debug(
                          "page visible again, triggering startAudio to resume playback and update playback status",
                          this.logContext
                        ),
                        this.startAudio()));
                  }),
                  document.body.append(Q),
                  this.once(RoomEvent.Disconnected, () => {
                    Q?.remove(), (Q = null);
                  });
              }
              H.push(Q);
            }
            this.remoteParticipants.forEach((Y) => {
              Y.audioTrackPublications.forEach((Q) => {
                Q.track &&
                  Q.track.attachedElements.forEach((X) => {
                    H.push(X);
                  });
              });
            });
            try {
              yield Promise.all([
                this.acquireAudioContext(),
                ...H.map((Y) => ((Y.muted = !1), Y.play())),
              ]),
                this.handleAudioPlaybackStarted();
            } catch (Y) {
              throw (this.handleAudioPlaybackFailed(Y), Y);
            }
          })),
        (this.startVideo = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            const H = [];
            for (const G of this.remoteParticipants.values())
              G.videoTrackPublications.forEach((Y) => {
                var Q;
                (Q = Y.track) === null ||
                  Q === void 0 ||
                  Q.attachedElements.forEach((X) => {
                    H.includes(X) || H.push(X);
                  });
              });
            yield Promise.all(H.map((G) => G.play()))
              .then(() => {
                this.handleVideoPlaybackStarted();
              })
              .catch((G) => {
                G.name === "NotAllowedError"
                  ? this.handleVideoPlaybackFailed()
                  : this.log.warn(
                      "Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler",
                      this.logContext
                    );
              });
          })),
        (this.handleRestarting = () => {
          this.clearConnectionReconcile(), (this.isResuming = !1);
          for (const H of this.remoteParticipants.values())
            this.handleParticipantDisconnected(H.identity, H);
          this.setAndEmitConnectionState(ConnectionState.Reconnecting) &&
            this.emit(RoomEvent.Reconnecting);
        }),
        (this.handleSignalRestarted = (H) =>
          __awaiter$1(this, void 0, void 0, function* () {
            this.log.debug(
              "signal reconnected to server, region ".concat(H.serverRegion),
              Object.assign(Object.assign({}, this.logContext), {
                region: H.serverRegion,
              })
            ),
              (this.bufferedEvents = []),
              this.applyJoinResponse(H);
            try {
              yield this.localParticipant.republishAllTracks(void 0, !0);
            } catch (G) {
              this.log.error(
                "error trying to re-publish tracks after reconnection",
                Object.assign(Object.assign({}, this.logContext), { error: G })
              );
            }
            try {
              yield this.engine.waitForRestarted(),
                this.log.debug(
                  "fully reconnected to server",
                  Object.assign(Object.assign({}, this.logContext), {
                    region: H.serverRegion,
                  })
                );
            } catch {
              return;
            }
            this.setAndEmitConnectionState(ConnectionState.Connected),
              this.emit(RoomEvent.Reconnected),
              this.registerConnectionReconcile(),
              this.emitBufferedEvents();
          })),
        (this.handleParticipantUpdates = (H) => {
          H.forEach((G) => {
            var Y;
            if (G.identity === this.localParticipant.identity) {
              this.localParticipant.updateInfo(G);
              return;
            }
            G.identity === "" &&
              (G.identity =
                (Y = this.sidToIdentity.get(G.sid)) !== null && Y !== void 0
                  ? Y
                  : "");
            let Q = this.remoteParticipants.get(G.identity);
            G.state === ParticipantInfo_State.DISCONNECTED
              ? this.handleParticipantDisconnected(G.identity, Q)
              : (Q = this.getOrCreateParticipant(G.identity, G));
          });
        }),
        (this.handleActiveSpeakersUpdate = (H) => {
          const G = [],
            Y = {};
          H.forEach((Q) => {
            if (((Y[Q.sid] = !0), Q.sid === this.localParticipant.sid))
              (this.localParticipant.audioLevel = Q.level),
                this.localParticipant.setIsSpeaking(!0),
                G.push(this.localParticipant);
            else {
              const X = this.getRemoteParticipantBySid(Q.sid);
              X && ((X.audioLevel = Q.level), X.setIsSpeaking(!0), G.push(X));
            }
          }),
            Y[this.localParticipant.sid] ||
              ((this.localParticipant.audioLevel = 0),
              this.localParticipant.setIsSpeaking(!1)),
            this.remoteParticipants.forEach((Q) => {
              Y[Q.sid] || ((Q.audioLevel = 0), Q.setIsSpeaking(!1));
            }),
            (this.activeSpeakers = G),
            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, G);
        }),
        (this.handleSpeakersChanged = (H) => {
          const G = new Map();
          this.activeSpeakers.forEach((Q) => {
            const X = this.remoteParticipants.get(Q.identity);
            (X && X.sid !== Q.sid) || G.set(Q.sid, Q);
          }),
            H.forEach((Q) => {
              let X = this.getRemoteParticipantBySid(Q.sid);
              Q.sid === this.localParticipant.sid &&
                (X = this.localParticipant),
                X &&
                  ((X.audioLevel = Q.level),
                  X.setIsSpeaking(Q.active),
                  Q.active ? G.set(Q.sid, X) : G.delete(Q.sid));
            });
          const Y = Array.from(G.values());
          Y.sort((Q, X) => X.audioLevel - Q.audioLevel),
            (this.activeSpeakers = Y),
            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, Y);
        }),
        (this.handleStreamStateUpdate = (H) => {
          H.streamStates.forEach((G) => {
            const Y = this.getRemoteParticipantBySid(G.participantSid);
            if (!Y) return;
            const Q = Y.getTrackPublicationBySid(G.trackSid);
            if (!Q || !Q.track) return;
            const X = Track.streamStateFromProto(G.state);
            X !== Q.track.streamState &&
              ((Q.track.streamState = X),
              Y.emit(
                ParticipantEvent.TrackStreamStateChanged,
                Q,
                Q.track.streamState
              ),
              this.emitWhenConnected(
                RoomEvent.TrackStreamStateChanged,
                Q,
                Q.track.streamState,
                Y
              ));
          });
        }),
        (this.handleSubscriptionPermissionUpdate = (H) => {
          const G = this.getRemoteParticipantBySid(H.participantSid);
          if (!G) return;
          const Y = G.getTrackPublicationBySid(H.trackSid);
          Y && Y.setAllowed(H.allowed);
        }),
        (this.handleSubscriptionError = (H) => {
          const G = Array.from(this.remoteParticipants.values()).find((Q) =>
            Q.trackPublications.has(H.trackSid)
          );
          if (!G) return;
          const Y = G.getTrackPublicationBySid(H.trackSid);
          Y && Y.setSubscriptionError(H.err);
        }),
        (this.handleDataPacket = (H) => {
          const G = this.remoteParticipants.get(H.participantIdentity);
          if (H.value.case === "user")
            this.handleUserPacket(G, H.value.value, H.kind);
          else if (H.value.case === "transcription")
            this.handleTranscription(G, H.value.value);
          else if (H.value.case === "sipDtmf")
            this.handleSipDtmf(G, H.value.value);
          else if (H.value.case === "chatMessage")
            this.handleChatMessage(G, H.value.value);
          else if (H.value.case === "metrics")
            this.handleMetrics(H.value.value, G);
          else if (H.value.case === "streamHeader")
            this.handleStreamHeader(H.value.value, H.participantIdentity);
          else if (H.value.case === "streamChunk")
            this.handleStreamChunk(H.value.value);
          else if (H.value.case === "streamTrailer")
            this.handleStreamTrailer(H.value.value);
          else if (H.value.case === "rpcRequest") {
            const Y = H.value.value;
            this.handleIncomingRpcRequest(
              H.participantIdentity,
              Y.id,
              Y.method,
              Y.payload,
              Y.responseTimeoutMs,
              Y.version
            );
          }
        }),
        (this.handleUserPacket = (H, G, Y) => {
          this.emit(RoomEvent.DataReceived, G.payload, H, Y, G.topic),
            H?.emit(ParticipantEvent.DataReceived, G.payload, Y);
        }),
        (this.handleSipDtmf = (H, G) => {
          this.emit(RoomEvent.SipDTMFReceived, G, H),
            H?.emit(ParticipantEvent.SipDTMFReceived, G);
        }),
        (this.bufferedSegments = new Map()),
        (this.handleTranscription = (H, G) => {
          const Y =
              G.transcribedParticipantIdentity ===
              this.localParticipant.identity
                ? this.localParticipant
                : this.getParticipantByIdentity(
                    G.transcribedParticipantIdentity
                  ),
            Q = Y?.trackPublications.get(G.trackId),
            X = extractTranscriptionSegments(
              G,
              this.transcriptionReceivedTimes
            );
          Q?.emit(TrackEvent.TranscriptionReceived, X),
            Y?.emit(ParticipantEvent.TranscriptionReceived, X, Q),
            this.emit(RoomEvent.TranscriptionReceived, X, Y, Q);
        }),
        (this.handleChatMessage = (H, G) => {
          const Y = extractChatMessage(G);
          this.emit(RoomEvent.ChatMessage, Y, H);
        }),
        (this.handleMetrics = (H, G) => {
          this.emit(RoomEvent.MetricsReceived, H, G);
        }),
        (this.handleAudioPlaybackStarted = () => {
          this.canPlaybackAudio ||
            ((this.audioEnabled = !0),
            this.emit(RoomEvent.AudioPlaybackStatusChanged, !0));
        }),
        (this.handleAudioPlaybackFailed = (H) => {
          this.log.warn(
            "could not playback audio",
            Object.assign(Object.assign({}, this.logContext), { error: H })
          ),
            this.canPlaybackAudio &&
              ((this.audioEnabled = !1),
              this.emit(RoomEvent.AudioPlaybackStatusChanged, !1));
        }),
        (this.handleVideoPlaybackStarted = () => {
          this.isVideoPlaybackBlocked &&
            ((this.isVideoPlaybackBlocked = !1),
            this.emit(RoomEvent.VideoPlaybackStatusChanged, !0));
        }),
        (this.handleVideoPlaybackFailed = () => {
          this.isVideoPlaybackBlocked ||
            ((this.isVideoPlaybackBlocked = !0),
            this.emit(RoomEvent.VideoPlaybackStatusChanged, !1));
        }),
        (this.handleDeviceChange = () =>
          __awaiter$1(this, void 0, void 0, function* () {
            var H;
            ((H = getBrowser()) === null || H === void 0 ? void 0 : H.os) !==
              "iOS" && (yield this.selectDefaultDevices()),
              this.emit(RoomEvent.MediaDevicesChanged);
          })),
        (this.handleRoomUpdate = (H) => {
          const G = this.roomInfo;
          (this.roomInfo = H),
            G &&
              G.metadata !== H.metadata &&
              this.emitWhenConnected(RoomEvent.RoomMetadataChanged, H.metadata),
            G?.activeRecording !== H.activeRecording &&
              this.emitWhenConnected(
                RoomEvent.RecordingStatusChanged,
                H.activeRecording
              );
        }),
        (this.handleConnectionQualityUpdate = (H) => {
          H.updates.forEach((G) => {
            if (G.participantSid === this.localParticipant.sid) {
              this.localParticipant.setConnectionQuality(G.quality);
              return;
            }
            const Y = this.getRemoteParticipantBySid(G.participantSid);
            Y && Y.setConnectionQuality(G.quality);
          });
        }),
        (this.onLocalParticipantMetadataChanged = (H) => {
          this.emit(
            RoomEvent.ParticipantMetadataChanged,
            H,
            this.localParticipant
          );
        }),
        (this.onLocalParticipantNameChanged = (H) => {
          this.emit(RoomEvent.ParticipantNameChanged, H, this.localParticipant);
        }),
        (this.onLocalAttributesChanged = (H) => {
          this.emit(
            RoomEvent.ParticipantAttributesChanged,
            H,
            this.localParticipant
          );
        }),
        (this.onLocalTrackMuted = (H) => {
          this.emit(RoomEvent.TrackMuted, H, this.localParticipant);
        }),
        (this.onLocalTrackUnmuted = (H) => {
          this.emit(RoomEvent.TrackUnmuted, H, this.localParticipant);
        }),
        (this.onTrackProcessorUpdate = (H) => {
          var G;
          (G = H?.onPublish) === null || G === void 0 || G.call(H, this);
        }),
        (this.onLocalTrackPublished = (H) =>
          __awaiter$1(this, void 0, void 0, function* () {
            var G, Y, Q, X, Z, te;
            (G = H.track) === null ||
              G === void 0 ||
              G.on(
                TrackEvent.TrackProcessorUpdate,
                this.onTrackProcessorUpdate
              ),
              (Y = H.track) === null ||
                Y === void 0 ||
                Y.on(TrackEvent.Restarted, this.onLocalTrackRestarted),
              (Z =
                (X =
                  (Q = H.track) === null || Q === void 0
                    ? void 0
                    : Q.getProcessor()) === null || X === void 0
                  ? void 0
                  : X.onPublish) === null ||
                Z === void 0 ||
                Z.call(X, this),
              this.emit(
                RoomEvent.LocalTrackPublished,
                H,
                this.localParticipant
              ),
              isLocalAudioTrack(H.track) &&
                (yield H.track.checkForSilence()) &&
                this.emit(RoomEvent.LocalAudioSilenceDetected, H);
            const ne = yield (te = H.track) === null || te === void 0
                ? void 0
                : te.getDeviceId(!1),
              ae = sourceToKind(H.source);
            ae &&
              ne &&
              ne !== this.localParticipant.activeDeviceMap.get(ae) &&
              (this.localParticipant.activeDeviceMap.set(ae, ne),
              this.emit(RoomEvent.ActiveDeviceChanged, ae, ne));
          })),
        (this.onLocalTrackUnpublished = (H) => {
          var G, Y;
          (G = H.track) === null ||
            G === void 0 ||
            G.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate),
            (Y = H.track) === null ||
              Y === void 0 ||
              Y.off(TrackEvent.Restarted, this.onLocalTrackRestarted),
            this.emit(
              RoomEvent.LocalTrackUnpublished,
              H,
              this.localParticipant
            );
        }),
        (this.onLocalTrackRestarted = (H) =>
          __awaiter$1(this, void 0, void 0, function* () {
            const G = yield H.getDeviceId(!1),
              Y = sourceToKind(H.source);
            Y &&
              G &&
              G !== this.localParticipant.activeDeviceMap.get(Y) &&
              (this.log.debug(
                "local track restarted, setting "
                  .concat(Y, " ")
                  .concat(G, " active"),
                this.logContext
              ),
              this.localParticipant.activeDeviceMap.set(Y, G),
              this.emit(RoomEvent.ActiveDeviceChanged, Y, G));
          })),
        (this.onLocalConnectionQualityChanged = (H) => {
          this.emit(
            RoomEvent.ConnectionQualityChanged,
            H,
            this.localParticipant
          );
        }),
        (this.onMediaDevicesError = (H, G) => {
          this.emit(RoomEvent.MediaDevicesError, H, G);
        }),
        (this.onLocalParticipantPermissionsChanged = (H) => {
          this.emit(
            RoomEvent.ParticipantPermissionsChanged,
            H,
            this.localParticipant
          );
        }),
        (this.onLocalChatMessageSent = (H) => {
          this.emit(RoomEvent.ChatMessage, H, this.localParticipant);
        }),
        this.setMaxListeners(100),
        (this.remoteParticipants = new Map()),
        (this.sidToIdentity = new Map()),
        (this.options = Object.assign(
          Object.assign({}, roomOptionDefaults),
          j
        )),
        (this.log = getLogger(
          (B = this.options.loggerName) !== null && B !== void 0
            ? B
            : LoggerNames.Room
        )),
        (this.transcriptionReceivedTimes = new Map()),
        (this.options.audioCaptureDefaults = Object.assign(
          Object.assign({}, audioDefaults),
          j?.audioCaptureDefaults
        )),
        (this.options.videoCaptureDefaults = Object.assign(
          Object.assign({}, videoDefaults),
          j?.videoCaptureDefaults
        )),
        (this.options.publishDefaults = Object.assign(
          Object.assign({}, publishDefaults),
          j?.publishDefaults
        )),
        this.maybeCreateEngine(),
        (this.disconnectLock = new _$1()),
        (this.localParticipant = new LocalParticipant(
          "",
          "",
          this.engine,
          this.options,
          this.rpcHandlers
        )),
        this.options.videoCaptureDefaults.deviceId &&
          this.localParticipant.activeDeviceMap.set(
            "videoinput",
            unwrapConstraint(this.options.videoCaptureDefaults.deviceId)
          ),
        this.options.audioCaptureDefaults.deviceId &&
          this.localParticipant.activeDeviceMap.set(
            "audioinput",
            unwrapConstraint(this.options.audioCaptureDefaults.deviceId)
          ),
        !((q = this.options.audioOutput) === null || q === void 0) &&
          q.deviceId &&
          this.switchActiveDevice(
            "audiooutput",
            unwrapConstraint(this.options.audioOutput.deviceId)
          ).catch((H) =>
            this.log.warn(
              "Could not set audio output: ".concat(H.message),
              this.logContext
            )
          ),
        this.options.e2ee && this.setupE2EE(),
        isWeb())
      ) {
        const H = new AbortController();
        ($ = navigator.mediaDevices) === null ||
          $ === void 0 ||
          $.addEventListener("devicechange", this.handleDeviceChange, {
            signal: H.signal,
          }),
          Room.cleanupRegistry &&
            Room.cleanupRegistry.register(this, () => {
              H.abort();
            });
      }
    }
    registerTextStreamHandler(j, V) {
      if (this.textStreamHandlers.has(j))
        throw new TypeError(
          'A text stream handler for topic "'.concat(
            j,
            '" has already been set.'
          )
        );
      this.textStreamHandlers.set(j, V);
    }
    unregisterTextStreamHandler(j) {
      this.textStreamHandlers.delete(j);
    }
    registerByteStreamHandler(j, V) {
      if (this.byteStreamHandlers.has(j))
        throw new TypeError(
          'A byte stream handler for topic "'.concat(
            j,
            '" has already been set.'
          )
        );
      this.byteStreamHandlers.set(j, V);
    }
    unregisterByteStreamHandler(j) {
      this.byteStreamHandlers.delete(j);
    }
    registerRpcMethod(j, V) {
      if (this.rpcHandlers.has(j))
        throw Error(
          "RPC handler already registered for method ".concat(
            j,
            ", unregisterRpcMethod before trying to register again"
          )
        );
      this.rpcHandlers.set(j, V);
    }
    unregisterRpcMethod(j) {
      this.rpcHandlers.delete(j);
    }
    handleIncomingRpcRequest(j, V, B, q, $, H) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if ((yield this.engine.publishRpcAck(j, V), H !== 1)) {
          yield this.engine.publishRpcResponse(
            j,
            V,
            null,
            RpcError.builtIn("UNSUPPORTED_VERSION")
          );
          return;
        }
        const G = this.rpcHandlers.get(B);
        if (!G) {
          yield this.engine.publishRpcResponse(
            j,
            V,
            null,
            RpcError.builtIn("UNSUPPORTED_METHOD")
          );
          return;
        }
        let Y = null,
          Q = null;
        try {
          const X = yield G({
            requestId: V,
            callerIdentity: j,
            payload: q,
            responseTimeout: $,
          });
          byteLength(X) > MAX_PAYLOAD_BYTES
            ? ((Y = RpcError.builtIn("RESPONSE_PAYLOAD_TOO_LARGE")),
              console.warn("RPC Response payload too large for ".concat(B)))
            : (Q = X);
        } catch (X) {
          X instanceof RpcError
            ? (Y = X)
            : (console.warn(
                "Uncaught error returned by RPC handler for ".concat(
                  B,
                  ". Returning APPLICATION_ERROR instead."
                ),
                X
              ),
              (Y = RpcError.builtIn("APPLICATION_ERROR")));
        }
        yield this.engine.publishRpcResponse(j, V, Q, Y);
      });
    }
    setE2EEEnabled(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.e2eeManager)
          yield Promise.all([this.localParticipant.setE2EEEnabled(j)]),
            this.localParticipant.identity !== "" &&
              this.e2eeManager.setParticipantCryptorEnabled(
                j,
                this.localParticipant.identity
              );
        else
          throw Error(
            "e2ee not configured, please set e2ee settings within the room options"
          );
      });
    }
    setupE2EE() {
      var j;
      this.options.e2ee &&
        ("e2eeManager" in this.options.e2ee
          ? (this.e2eeManager = this.options.e2ee.e2eeManager)
          : (this.e2eeManager = new E2EEManager(this.options.e2ee)),
        this.e2eeManager.on(
          EncryptionEvent.ParticipantEncryptionStatusChanged,
          (V, B) => {
            isLocalParticipant(B) && (this.isE2EEEnabled = V),
              this.emit(RoomEvent.ParticipantEncryptionStatusChanged, V, B);
          }
        ),
        this.e2eeManager.on(EncryptionEvent.EncryptionError, (V) =>
          this.emit(RoomEvent.EncryptionError, V)
        ),
        (j = this.e2eeManager) === null || j === void 0 || j.setup(this));
    }
    get logContext() {
      var j;
      return {
        room: this.name,
        roomID: (j = this.roomInfo) === null || j === void 0 ? void 0 : j.sid,
        participant: this.localParticipant.identity,
        pID: this.localParticipant.sid,
      };
    }
    get isRecording() {
      var j, V;
      return (V =
        (j = this.roomInfo) === null || j === void 0
          ? void 0
          : j.activeRecording) !== null && V !== void 0
        ? V
        : !1;
    }
    getSid() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.state === ConnectionState.Disconnected
          ? ""
          : this.roomInfo && this.roomInfo.sid !== ""
          ? this.roomInfo.sid
          : new Promise((j, V) => {
              const B = (q) => {
                q.sid !== "" &&
                  (this.engine.off(EngineEvent.RoomUpdate, B), j(q.sid));
              };
              this.engine.on(EngineEvent.RoomUpdate, B),
                this.once(RoomEvent.Disconnected, () => {
                  this.engine.off(EngineEvent.RoomUpdate, B),
                    V("Room disconnected before room server id was available");
                });
            });
      });
    }
    get name() {
      var j, V;
      return (V =
        (j = this.roomInfo) === null || j === void 0 ? void 0 : j.name) !==
        null && V !== void 0
        ? V
        : "";
    }
    get metadata() {
      var j;
      return (j = this.roomInfo) === null || j === void 0 ? void 0 : j.metadata;
    }
    get numParticipants() {
      var j, V;
      return (V =
        (j = this.roomInfo) === null || j === void 0
          ? void 0
          : j.numParticipants) !== null && V !== void 0
        ? V
        : 0;
    }
    get numPublishers() {
      var j, V;
      return (V =
        (j = this.roomInfo) === null || j === void 0
          ? void 0
          : j.numPublishers) !== null && V !== void 0
        ? V
        : 0;
    }
    maybeCreateEngine() {
      (this.engine && !this.engine.isClosed) ||
        ((this.engine = new RTCEngine(this.options)),
        this.engine
          .on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates)
          .on(EngineEvent.RoomUpdate, this.handleRoomUpdate)
          .on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged)
          .on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate)
          .on(
            EngineEvent.ConnectionQualityUpdate,
            this.handleConnectionQualityUpdate
          )
          .on(EngineEvent.SubscriptionError, this.handleSubscriptionError)
          .on(
            EngineEvent.SubscriptionPermissionUpdate,
            this.handleSubscriptionPermissionUpdate
          )
          .on(EngineEvent.MediaTrackAdded, (j, V, B) => {
            this.onTrackAdded(j, V, B);
          })
          .on(EngineEvent.Disconnected, (j) => {
            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, j);
          })
          .on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate)
          .on(EngineEvent.DataPacketReceived, this.handleDataPacket)
          .on(EngineEvent.Resuming, () => {
            this.clearConnectionReconcile(),
              (this.isResuming = !0),
              this.log.info("Resuming signal connection", this.logContext),
              this.setAndEmitConnectionState(
                ConnectionState.SignalReconnecting
              ) && this.emit(RoomEvent.SignalReconnecting);
          })
          .on(EngineEvent.Resumed, () => {
            this.registerConnectionReconcile(),
              (this.isResuming = !1),
              this.log.info("Resumed signal connection", this.logContext),
              this.updateSubscriptions(),
              this.emitBufferedEvents(),
              this.setAndEmitConnectionState(ConnectionState.Connected) &&
                this.emit(RoomEvent.Reconnected);
          })
          .on(EngineEvent.SignalResumed, () => {
            (this.bufferedEvents = []),
              (this.state === ConnectionState.Reconnecting ||
                this.isResuming) &&
                this.sendSyncState();
          })
          .on(EngineEvent.Restarting, this.handleRestarting)
          .on(EngineEvent.SignalRestarted, this.handleSignalRestarted)
          .on(EngineEvent.Offline, () => {
            this.setAndEmitConnectionState(ConnectionState.Reconnecting) &&
              this.emit(RoomEvent.Reconnecting);
          })
          .on(EngineEvent.DCBufferStatusChanged, (j, V) => {
            this.emit(RoomEvent.DCBufferStatusChanged, j, V);
          })
          .on(EngineEvent.LocalTrackSubscribed, (j) => {
            const V = this.localParticipant.getTrackPublications().find((B) => {
              let { trackSid: q } = B;
              return q === j;
            });
            if (!V) {
              this.log.warn(
                "could not find local track subscription for subscribed event",
                this.logContext
              );
              return;
            }
            this.localParticipant.emit(
              ParticipantEvent.LocalTrackSubscribed,
              V
            ),
              this.emitWhenConnected(
                RoomEvent.LocalTrackSubscribed,
                V,
                this.localParticipant
              );
          })
          .on(EngineEvent.RoomMoved, (j) => {
            this.log.debug("room moved", j),
              j.room && this.handleRoomUpdate(j.room),
              this.remoteParticipants.forEach((V, B) => {
                this.handleParticipantDisconnected(B, V);
              }),
              this.emit(RoomEvent.Moved, j.room.name),
              j.participant
                ? this.handleParticipantUpdates([
                    j.participant,
                    ...j.otherParticipants,
                  ])
                : this.handleParticipantUpdates(j.otherParticipants);
          }),
        this.localParticipant && this.localParticipant.setupEngine(this.engine),
        this.e2eeManager && this.e2eeManager.setupEngine(this.engine));
    }
    static getLocalDevices(j) {
      let V =
        arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
      return DeviceManager.getInstance().getDevices(j, V);
    }
    prepareConnection(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.state === ConnectionState.Disconnected) {
          this.log.debug("prepareConnection to ".concat(j), this.logContext);
          try {
            if (isCloud(new URL(j)) && V) {
              this.regionUrlProvider = new RegionUrlProvider(j, V);
              const B = yield this.regionUrlProvider.getNextBestRegionUrl();
              B &&
                this.state === ConnectionState.Disconnected &&
                ((this.regionUrl = B),
                yield fetch(toHttpUrl(B), { method: "HEAD" }),
                this.log.debug(
                  "prepared connection to ".concat(B),
                  this.logContext
                ));
            } else yield fetch(toHttpUrl(j), { method: "HEAD" });
          } catch (B) {
            this.log.warn(
              "could not prepare connection",
              Object.assign(Object.assign({}, this.logContext), { error: B })
            );
          }
        }
      });
    }
    getParticipantByIdentity(j) {
      return this.localParticipant.identity === j
        ? this.localParticipant
        : this.remoteParticipants.get(j);
    }
    clearConnectionFutures() {
      this.connectFuture = void 0;
    }
    simulateScenario(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        let B = () => {},
          q;
        switch (j) {
          case "signal-reconnect":
            yield this.engine.client.handleOnClose("simulate disconnect");
            break;
          case "speaker":
            q = new SimulateScenario({
              scenario: { case: "speakerUpdate", value: 3 },
            });
            break;
          case "node-failure":
            q = new SimulateScenario({
              scenario: { case: "nodeFailure", value: !0 },
            });
            break;
          case "server-leave":
            q = new SimulateScenario({
              scenario: { case: "serverLeave", value: !0 },
            });
            break;
          case "migration":
            q = new SimulateScenario({
              scenario: { case: "migration", value: !0 },
            });
            break;
          case "resume-reconnect":
            this.engine.failNext(),
              yield this.engine.client.handleOnClose(
                "simulate resume-disconnect"
              );
            break;
          case "disconnect-signal-on-resume":
            (B = () =>
              __awaiter$1(this, void 0, void 0, function* () {
                yield this.engine.client.handleOnClose(
                  "simulate resume-disconnect"
                );
              })),
              (q = new SimulateScenario({
                scenario: { case: "disconnectSignalOnResume", value: !0 },
              }));
            break;
          case "disconnect-signal-on-resume-no-messages":
            (B = () =>
              __awaiter$1(this, void 0, void 0, function* () {
                yield this.engine.client.handleOnClose(
                  "simulate resume-disconnect"
                );
              })),
              (q = new SimulateScenario({
                scenario: {
                  case: "disconnectSignalOnResumeNoMessages",
                  value: !0,
                },
              }));
            break;
          case "full-reconnect":
            (this.engine.fullReconnectOnNext = !0),
              yield this.engine.client.handleOnClose("simulate full-reconnect");
            break;
          case "force-tcp":
          case "force-tls":
            (q = new SimulateScenario({
              scenario: {
                case: "switchCandidateProtocol",
                value: j === "force-tls" ? 2 : 1,
              },
            })),
              (B = () =>
                __awaiter$1(this, void 0, void 0, function* () {
                  const $ = this.engine.client.onLeave;
                  $ &&
                    $(
                      new LeaveRequest({
                        reason: DisconnectReason.CLIENT_INITIATED,
                        action: LeaveRequest_Action.RECONNECT,
                      })
                    );
                }));
            break;
          case "subscriber-bandwidth":
            if (V === void 0 || typeof V != "number")
              throw new Error(
                "subscriber-bandwidth requires a number as argument"
              );
            q = new SimulateScenario({
              scenario: {
                case: "subscriberBandwidth",
                value: numberToBigInt(V),
              },
            });
            break;
          case "leave-full-reconnect":
            q = new SimulateScenario({
              scenario: { case: "leaveRequestFullReconnect", value: !0 },
            });
        }
        q && (yield this.engine.client.sendSimulateScenario(q), yield B());
      });
    }
    get canPlaybackAudio() {
      return this.audioEnabled;
    }
    get canPlaybackVideo() {
      return !this.isVideoPlaybackBlocked;
    }
    getActiveDevice(j) {
      return this.localParticipant.activeDeviceMap.get(j);
    }
    switchActiveDevice(j, V) {
      return __awaiter$1(this, arguments, void 0, function (B, q) {
        var $ = this;
        let H =
          arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
        return (function* () {
          var G, Y, Q, X, Z, te, ne;
          let ae = !0,
            se = !1;
          const fe = H ? { exact: q } : q;
          if (B === "audioinput") {
            se = $.localParticipant.audioTrackPublications.size === 0;
            const ce =
              (G = $.getActiveDevice(B)) !== null && G !== void 0
                ? G
                : $.options.audioCaptureDefaults.deviceId;
            $.options.audioCaptureDefaults.deviceId = fe;
            const ue = Array.from(
              $.localParticipant.audioTrackPublications.values()
            ).filter((me) => me.source === Track.Source.Microphone);
            try {
              ae = (yield Promise.all(
                ue.map((me) => {
                  var ve;
                  return (ve = me.audioTrack) === null || ve === void 0
                    ? void 0
                    : ve.setDeviceId(fe);
                })
              )).every((me) => me === !0);
            } catch (me) {
              throw (($.options.audioCaptureDefaults.deviceId = ce), me);
            }
            const he = ue.some((me) => {
              var ve, ge;
              return (ge =
                (ve = me.track) === null || ve === void 0
                  ? void 0
                  : ve.isMuted) !== null && ge !== void 0
                ? ge
                : !1;
            });
            ae && he && (se = !0);
          } else if (B === "videoinput") {
            se = $.localParticipant.videoTrackPublications.size === 0;
            const ce =
              (Y = $.getActiveDevice(B)) !== null && Y !== void 0
                ? Y
                : $.options.videoCaptureDefaults.deviceId;
            $.options.videoCaptureDefaults.deviceId = fe;
            const ue = Array.from(
              $.localParticipant.videoTrackPublications.values()
            ).filter((me) => me.source === Track.Source.Camera);
            try {
              ae = (yield Promise.all(
                ue.map((me) => {
                  var ve;
                  return (ve = me.videoTrack) === null || ve === void 0
                    ? void 0
                    : ve.setDeviceId(fe);
                })
              )).every((me) => me === !0);
            } catch (me) {
              throw (($.options.videoCaptureDefaults.deviceId = ce), me);
            }
            const he = ue.some((me) => {
              var ve, ge;
              return (ge =
                (ve = me.track) === null || ve === void 0
                  ? void 0
                  : ve.isMuted) !== null && ge !== void 0
                ? ge
                : !1;
            });
            ae && he && (se = !0);
          } else if (B === "audiooutput") {
            if (
              ((se = !0),
              (!supportsSetSinkId() && !$.options.webAudioMix) ||
                ($.options.webAudioMix &&
                  $.audioContext &&
                  !("setSinkId" in $.audioContext)))
            )
              throw new Error(
                "cannot switch audio output, setSinkId not supported"
              );
            $.options.webAudioMix &&
              (q =
                (Q = yield DeviceManager.getInstance().normalizeDeviceId(
                  "audiooutput",
                  q
                )) !== null && Q !== void 0
                  ? Q
                  : ""),
              ((X = (ne = $.options).audioOutput) !== null && X !== void 0) ||
                (ne.audioOutput = {});
            const ce =
              (Z = $.getActiveDevice(B)) !== null && Z !== void 0
                ? Z
                : $.options.audioOutput.deviceId;
            $.options.audioOutput.deviceId = q;
            try {
              $.options.webAudioMix &&
                ((te = $.audioContext) === null ||
                  te === void 0 ||
                  te.setSinkId(q)),
                yield Promise.all(
                  Array.from($.remoteParticipants.values()).map((ue) =>
                    ue.setAudioOutput({ deviceId: q })
                  )
                );
            } catch (ue) {
              throw (($.options.audioOutput.deviceId = ce), ue);
            }
          }
          return (
            se &&
              ($.localParticipant.activeDeviceMap.set(B, q),
              $.emit(RoomEvent.ActiveDeviceChanged, B, q)),
            ae
          );
        })();
      });
    }
    setupLocalParticipantEvents() {
      this.localParticipant
        .on(
          ParticipantEvent.ParticipantMetadataChanged,
          this.onLocalParticipantMetadataChanged
        )
        .on(
          ParticipantEvent.ParticipantNameChanged,
          this.onLocalParticipantNameChanged
        )
        .on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged)
        .on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
        .on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
        .on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished)
        .on(
          ParticipantEvent.LocalTrackUnpublished,
          this.onLocalTrackUnpublished
        )
        .on(
          ParticipantEvent.ConnectionQualityChanged,
          this.onLocalConnectionQualityChanged
        )
        .on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
        .on(ParticipantEvent.AudioStreamAcquired, this.startAudio)
        .on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
        .on(
          ParticipantEvent.ParticipantPermissionsChanged,
          this.onLocalParticipantPermissionsChanged
        );
    }
    recreateEngine() {
      var j;
      (j = this.engine) === null || j === void 0 || j.close(),
        (this.engine = void 0),
        (this.isResuming = !1),
        this.remoteParticipants.clear(),
        this.sidToIdentity.clear(),
        (this.bufferedEvents = []),
        this.maybeCreateEngine();
    }
    onTrackAdded(j, V, B) {
      if (
        this.state === ConnectionState.Connecting ||
        this.state === ConnectionState.Reconnecting
      ) {
        const X = () => {
            this.onTrackAdded(j, V, B), Z();
          },
          Z = () => {
            this.off(RoomEvent.Reconnected, X),
              this.off(RoomEvent.Connected, X),
              this.off(RoomEvent.Disconnected, Z);
          };
        this.once(RoomEvent.Reconnected, X),
          this.once(RoomEvent.Connected, X),
          this.once(RoomEvent.Disconnected, Z);
        return;
      }
      if (this.state === ConnectionState.Disconnected) {
        this.log.warn(
          "skipping incoming track after Room disconnected",
          this.logContext
        );
        return;
      }
      if (j.readyState === "ended") {
        this.log.info(
          "skipping incoming track as it already ended",
          this.logContext
        );
        return;
      }
      const q = unpackStreamId(V.id),
        $ = q[0];
      let H = q[1],
        G = j.id;
      if (
        (H && H.startsWith("TR") && (G = H), $ === this.localParticipant.sid)
      ) {
        this.log.warn(
          "tried to create RemoteParticipant for local participant",
          this.logContext
        );
        return;
      }
      const Y = Array.from(this.remoteParticipants.values()).find(
        (X) => X.sid === $
      );
      if (!Y) {
        this.log.error(
          "Tried to add a track for a participant, that's not present. Sid: ".concat(
            $
          ),
          this.logContext
        );
        return;
      }
      let Q;
      this.options.adaptiveStream &&
        (typeof this.options.adaptiveStream == "object"
          ? (Q = this.options.adaptiveStream)
          : (Q = {})),
        Y.addSubscribedMediaTrack(j, G, V, B, Q);
    }
    handleDisconnect() {
      let j =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0,
        V = arguments.length > 1 ? arguments[1] : void 0;
      var B;
      if (
        (this.clearConnectionReconcile(),
        (this.isResuming = !1),
        (this.bufferedEvents = []),
        this.transcriptionReceivedTimes.clear(),
        this.state !== ConnectionState.Disconnected)
      ) {
        this.regionUrl = void 0;
        try {
          this.remoteParticipants.forEach((q) => {
            q.trackPublications.forEach(($) => {
              q.unpublishTrack($.trackSid);
            });
          }),
            this.localParticipant.trackPublications.forEach((q) => {
              var $, H, G;
              q.track && this.localParticipant.unpublishTrack(q.track, j),
                j
                  ? (($ = q.track) === null || $ === void 0 || $.detach(),
                    (H = q.track) === null || H === void 0 || H.stop())
                  : (G = q.track) === null || G === void 0 || G.stopMonitor();
            }),
            this.localParticipant
              .off(
                ParticipantEvent.ParticipantMetadataChanged,
                this.onLocalParticipantMetadataChanged
              )
              .off(
                ParticipantEvent.ParticipantNameChanged,
                this.onLocalParticipantNameChanged
              )
              .off(
                ParticipantEvent.AttributesChanged,
                this.onLocalAttributesChanged
              )
              .off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted)
              .off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted)
              .off(
                ParticipantEvent.LocalTrackPublished,
                this.onLocalTrackPublished
              )
              .off(
                ParticipantEvent.LocalTrackUnpublished,
                this.onLocalTrackUnpublished
              )
              .off(
                ParticipantEvent.ConnectionQualityChanged,
                this.onLocalConnectionQualityChanged
              )
              .off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError)
              .off(ParticipantEvent.AudioStreamAcquired, this.startAudio)
              .off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent)
              .off(
                ParticipantEvent.ParticipantPermissionsChanged,
                this.onLocalParticipantPermissionsChanged
              ),
            this.localParticipant.trackPublications.clear(),
            this.localParticipant.videoTrackPublications.clear(),
            this.localParticipant.audioTrackPublications.clear(),
            this.remoteParticipants.clear(),
            this.sidToIdentity.clear(),
            (this.activeSpeakers = []),
            this.audioContext &&
              typeof this.options.webAudioMix == "boolean" &&
              (this.audioContext.close(), (this.audioContext = void 0)),
            isWeb() &&
              (window.removeEventListener("beforeunload", this.onPageLeave),
              window.removeEventListener("pagehide", this.onPageLeave),
              window.removeEventListener("freeze", this.onPageLeave),
              (B = navigator.mediaDevices) === null ||
                B === void 0 ||
                B.removeEventListener("devicechange", this.handleDeviceChange));
        } finally {
          this.setAndEmitConnectionState(ConnectionState.Disconnected),
            this.emit(RoomEvent.Disconnected, V);
        }
      }
    }
    handleParticipantDisconnected(j, V) {
      var B;
      this.remoteParticipants.delete(j),
        V &&
          (V.trackPublications.forEach((q) => {
            V.unpublishTrack(q.trackSid, !0);
          }),
          this.emit(RoomEvent.ParticipantDisconnected, V),
          V.setDisconnected(),
          (B = this.localParticipant) === null ||
            B === void 0 ||
            B.handleParticipantDisconnected(V.identity));
    }
    handleStreamHeader(j, V) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var B;
        if (j.contentHeader.case === "byteHeader") {
          const q = this.byteStreamHandlers.get(j.topic);
          if (!q) {
            this.log.debug(
              "ignoring incoming byte stream due to no handler for topic",
              j.topic
            );
            return;
          }
          let $;
          const H = {
              id: j.streamId,
              name:
                (B = j.contentHeader.value.name) !== null && B !== void 0
                  ? B
                  : "unknown",
              mimeType: j.mimeType,
              size: j.totalLength ? Number(j.totalLength) : void 0,
              topic: j.topic,
              timestamp: bigIntToNumber(j.timestamp),
              attributes: j.attributes,
            },
            G = new ReadableStream({
              start: (Y) => {
                ($ = Y),
                  this.byteStreamControllers.set(j.streamId, {
                    info: H,
                    controller: $,
                    startTime: Date.now(),
                  });
              },
            });
          q(new ByteStreamReader(H, G, bigIntToNumber(j.totalLength)), {
            identity: V,
          });
        } else if (j.contentHeader.case === "textHeader") {
          const q = this.textStreamHandlers.get(j.topic);
          if (!q) {
            this.log.debug(
              "ignoring incoming text stream due to no handler for topic",
              j.topic
            );
            return;
          }
          let $;
          const H = {
              id: j.streamId,
              mimeType: j.mimeType,
              size: j.totalLength ? Number(j.totalLength) : void 0,
              topic: j.topic,
              timestamp: Number(j.timestamp),
              attributes: j.attributes,
            },
            G = new ReadableStream({
              start: (Y) => {
                ($ = Y),
                  this.textStreamControllers.set(j.streamId, {
                    info: H,
                    controller: $,
                    startTime: Date.now(),
                  });
              },
            });
          q(new TextStreamReader(H, G, bigIntToNumber(j.totalLength)), {
            identity: V,
          });
        }
      });
    }
    handleStreamChunk(j) {
      const V = this.byteStreamControllers.get(j.streamId);
      V && j.content.length > 0 && V.controller.enqueue(j);
      const B = this.textStreamControllers.get(j.streamId);
      B && j.content.length > 0 && B.controller.enqueue(j);
    }
    handleStreamTrailer(j) {
      const V = this.textStreamControllers.get(j.streamId);
      V &&
        ((V.info.attributes = Object.assign(
          Object.assign({}, V.info.attributes),
          j.attributes
        )),
        V.controller.close(),
        this.textStreamControllers.delete(j.streamId));
      const B = this.byteStreamControllers.get(j.streamId);
      B &&
        ((B.info.attributes = Object.assign(
          Object.assign({}, B.info.attributes),
          j.attributes
        )),
        B.controller.close(),
        this.byteStreamControllers.delete(j.streamId));
    }
    selectDefaultDevices() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V, B;
        const q = DeviceManager.getInstance().previousDevices,
          $ = yield DeviceManager.getInstance().getDevices(void 0, !1),
          H = getBrowser();
        if (H?.name === "Chrome" && H.os !== "iOS")
          for (let Y of $) {
            const Q = q.find((X) => X.deviceId === Y.deviceId);
            Q &&
              Q.label !== "" &&
              Q.kind === Y.kind &&
              Q.label !== Y.label &&
              this.getActiveDevice(Y.kind) === "default" &&
              this.emit(RoomEvent.ActiveDeviceChanged, Y.kind, Y.deviceId);
          }
        const G = ["audiooutput", "audioinput", "videoinput"];
        for (let Y of G) {
          const Q = kindToSource(Y),
            X = this.localParticipant.getTrackPublication(Q);
          if (
            X &&
            !((j = X.track) === null || j === void 0) &&
            j.isUserProvided
          )
            continue;
          const Z = $.filter((ne) => ne.kind === Y),
            te = this.getActiveDevice(Y);
          if (
            te ===
              ((V = q.filter((ne) => ne.kind === Y)[0]) === null || V === void 0
                ? void 0
                : V.deviceId) &&
            Z.length > 0 &&
            ((B = Z[0]) === null || B === void 0 ? void 0 : B.deviceId) !== te
          ) {
            yield this.switchActiveDevice(Y, Z[0].deviceId);
            continue;
          }
          (Y === "audioinput" && !isSafariBased()) ||
            Y === "videoinput" ||
            (Z.length > 0 &&
              !Z.find((ne) => ne.deviceId === this.getActiveDevice(Y)) &&
              (Y !== "audiooutput" || !isSafariBased()) &&
              (yield this.switchActiveDevice(Y, Z[0].deviceId)));
        }
      });
    }
    acquireAudioContext() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V;
        if (
          (typeof this.options.webAudioMix != "boolean" &&
          this.options.webAudioMix.audioContext
            ? (this.audioContext = this.options.webAudioMix.audioContext)
            : (!this.audioContext || this.audioContext.state === "closed") &&
              (this.audioContext =
                (j = getNewAudioContext()) !== null && j !== void 0
                  ? j
                  : void 0),
          this.options.webAudioMix &&
            this.remoteParticipants.forEach((q) =>
              q.setAudioContext(this.audioContext)
            ),
          this.localParticipant.setAudioContext(this.audioContext),
          this.audioContext && this.audioContext.state === "suspended")
        )
          try {
            yield Promise.race([this.audioContext.resume(), sleep$1(200)]);
          } catch (q) {
            this.log.warn(
              "Could not resume audio context",
              Object.assign(Object.assign({}, this.logContext), { error: q })
            );
          }
        const B =
          ((V = this.audioContext) === null || V === void 0
            ? void 0
            : V.state) === "running";
        B !== this.canPlaybackAudio &&
          ((this.audioEnabled = B),
          this.emit(RoomEvent.AudioPlaybackStatusChanged, B));
      });
    }
    createParticipant(j, V) {
      var B;
      let q;
      return (
        V
          ? (q = RemoteParticipant.fromParticipantInfo(this.engine.client, V, {
              loggerContextCb: () => this.logContext,
              loggerName: this.options.loggerName,
            }))
          : (q = new RemoteParticipant(
              this.engine.client,
              "",
              j,
              void 0,
              void 0,
              void 0,
              {
                loggerContextCb: () => this.logContext,
                loggerName: this.options.loggerName,
              }
            )),
        this.options.webAudioMix && q.setAudioContext(this.audioContext),
        !((B = this.options.audioOutput) === null || B === void 0) &&
          B.deviceId &&
          q
            .setAudioOutput(this.options.audioOutput)
            .catch(($) =>
              this.log.warn(
                "Could not set audio output: ".concat($.message),
                this.logContext
              )
            ),
        q
      );
    }
    getOrCreateParticipant(j, V) {
      if (this.remoteParticipants.has(j)) {
        const q = this.remoteParticipants.get(j);
        return (
          V && q.updateInfo(V) && this.sidToIdentity.set(V.sid, V.identity), q
        );
      }
      const B = this.createParticipant(j, V);
      return (
        this.remoteParticipants.set(j, B),
        this.sidToIdentity.set(V.sid, V.identity),
        this.emitWhenConnected(RoomEvent.ParticipantConnected, B),
        B.on(ParticipantEvent.TrackPublished, (q) => {
          this.emitWhenConnected(RoomEvent.TrackPublished, q, B);
        })
          .on(ParticipantEvent.TrackSubscribed, (q, $) => {
            q.kind === Track.Kind.Audio
              ? (q.on(
                  TrackEvent.AudioPlaybackStarted,
                  this.handleAudioPlaybackStarted
                ),
                q.on(
                  TrackEvent.AudioPlaybackFailed,
                  this.handleAudioPlaybackFailed
                ))
              : q.kind === Track.Kind.Video &&
                (q.on(
                  TrackEvent.VideoPlaybackFailed,
                  this.handleVideoPlaybackFailed
                ),
                q.on(
                  TrackEvent.VideoPlaybackStarted,
                  this.handleVideoPlaybackStarted
                )),
              this.emit(RoomEvent.TrackSubscribed, q, $, B);
          })
          .on(ParticipantEvent.TrackUnpublished, (q) => {
            this.emit(RoomEvent.TrackUnpublished, q, B);
          })
          .on(ParticipantEvent.TrackUnsubscribed, (q, $) => {
            this.emit(RoomEvent.TrackUnsubscribed, q, $, B);
          })
          .on(ParticipantEvent.TrackMuted, (q) => {
            this.emitWhenConnected(RoomEvent.TrackMuted, q, B);
          })
          .on(ParticipantEvent.TrackUnmuted, (q) => {
            this.emitWhenConnected(RoomEvent.TrackUnmuted, q, B);
          })
          .on(ParticipantEvent.ParticipantMetadataChanged, (q) => {
            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, q, B);
          })
          .on(ParticipantEvent.ParticipantNameChanged, (q) => {
            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, q, B);
          })
          .on(ParticipantEvent.AttributesChanged, (q) => {
            this.emitWhenConnected(
              RoomEvent.ParticipantAttributesChanged,
              q,
              B
            );
          })
          .on(ParticipantEvent.ConnectionQualityChanged, (q) => {
            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, q, B);
          })
          .on(ParticipantEvent.ParticipantPermissionsChanged, (q) => {
            this.emitWhenConnected(
              RoomEvent.ParticipantPermissionsChanged,
              q,
              B
            );
          })
          .on(ParticipantEvent.TrackSubscriptionStatusChanged, (q, $) => {
            this.emitWhenConnected(
              RoomEvent.TrackSubscriptionStatusChanged,
              q,
              $,
              B
            );
          })
          .on(ParticipantEvent.TrackSubscriptionFailed, (q, $) => {
            this.emit(RoomEvent.TrackSubscriptionFailed, q, B, $);
          })
          .on(ParticipantEvent.TrackSubscriptionPermissionChanged, (q, $) => {
            this.emitWhenConnected(
              RoomEvent.TrackSubscriptionPermissionChanged,
              q,
              $,
              B
            );
          })
          .on(ParticipantEvent.Active, () => {
            this.emitWhenConnected(RoomEvent.ParticipantActive, B),
              B.kind === ParticipantInfo_Kind.AGENT &&
                this.localParticipant.setActiveAgent(B);
          }),
        V && B.updateInfo(V),
        B
      );
    }
    sendSyncState() {
      const j = Array.from(this.remoteParticipants.values()).reduce(
          (B, q) => (B.push(...q.getTrackPublications()), B),
          []
        ),
        V = this.localParticipant.getTrackPublications();
      this.engine.sendSyncState(j, V);
    }
    updateSubscriptions() {
      for (const j of this.remoteParticipants.values())
        for (const V of j.videoTrackPublications.values())
          V.isSubscribed && isRemotePub(V) && V.emitTrackUpdate();
    }
    getRemoteParticipantBySid(j) {
      const V = this.sidToIdentity.get(j);
      if (V) return this.remoteParticipants.get(V);
    }
    registerConnectionReconcile() {
      this.clearConnectionReconcile();
      let j = 0;
      this.connectionReconcileInterval = CriticalTimers.setInterval(() => {
        !this.engine || this.engine.isClosed || !this.engine.verifyTransport()
          ? (j++,
            this.log.warn(
              "detected connection state mismatch",
              Object.assign(Object.assign({}, this.logContext), {
                numFailures: j,
                engine: this.engine
                  ? {
                      closed: this.engine.isClosed,
                      transportsConnected: this.engine.verifyTransport(),
                    }
                  : void 0,
              })
            ),
            j >= 3 &&
              (this.recreateEngine(),
              this.handleDisconnect(
                this.options.stopLocalTrackOnUnpublish,
                DisconnectReason.STATE_MISMATCH
              )))
          : (j = 0);
      }, connectionReconcileFrequency);
    }
    clearConnectionReconcile() {
      this.connectionReconcileInterval &&
        CriticalTimers.clearInterval(this.connectionReconcileInterval);
    }
    setAndEmitConnectionState(j) {
      return j === this.state
        ? !1
        : ((this.state = j),
          this.emit(RoomEvent.ConnectionStateChanged, this.state),
          !0);
    }
    emitBufferedEvents() {
      this.bufferedEvents.forEach((j) => {
        let [V, B] = j;
        this.emit(V, ...B);
      }),
        (this.bufferedEvents = []);
    }
    emitWhenConnected(j) {
      for (
        var V = arguments.length, B = new Array(V > 1 ? V - 1 : 0), q = 1;
        q < V;
        q++
      )
        B[q - 1] = arguments[q];
      if (
        this.state === ConnectionState.Reconnecting ||
        this.isResuming ||
        !this.engine ||
        this.engine.pendingReconnect
      )
        this.bufferedEvents.push([j, B]);
      else if (this.state === ConnectionState.Connected)
        return this.emit(j, ...B);
      return !1;
    }
    simulateParticipants(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B;
        const q = Object.assign(
            { audio: !0, video: !0, useRealTracks: !1 },
            j.publish
          ),
          $ = Object.assign(
            { count: 9, audio: !1, video: !0, aspectRatios: [1.66, 1.7, 1.3] },
            j.participants
          );
        if (
          (this.handleDisconnect(),
          (this.roomInfo = new Room$1({
            sid: "RM_SIMULATED",
            name: "simulated-room",
            emptyTimeout: 0,
            maxParticipants: 0,
            creationTime: protoInt64.parse(new Date().getTime()),
            metadata: "",
            numParticipants: 1,
            numPublishers: 1,
            turnPassword: "",
            enabledCodecs: [],
            activeRecording: !1,
          })),
          this.localParticipant.updateInfo(
            new ParticipantInfo({
              identity: "simulated-local",
              name: "local-name",
            })
          ),
          this.setupLocalParticipantEvents(),
          this.emit(RoomEvent.SignalConnected),
          this.emit(RoomEvent.Connected),
          this.setAndEmitConnectionState(ConnectionState.Connected),
          q.video)
        ) {
          const H = new LocalTrackPublication(
            Track.Kind.Video,
            new TrackInfo({
              source: TrackSource.CAMERA,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO,
              name: "video-dummy",
            }),
            new LocalVideoTrack(
              q.useRealTracks
                ? (yield window.navigator.mediaDevices.getUserMedia({
                    video: !0,
                  })).getVideoTracks()[0]
                : createDummyVideoStreamTrack(
                    160 *
                      ((V = $.aspectRatios[0]) !== null && V !== void 0
                        ? V
                        : 1),
                    160,
                    !0,
                    !0
                  ),
              void 0,
              !1,
              {
                loggerName: this.options.loggerName,
                loggerContextCb: () => this.logContext,
              }
            ),
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          this.localParticipant.addTrackPublication(H),
            this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, H);
        }
        if (q.audio) {
          const H = new LocalTrackPublication(
            Track.Kind.Audio,
            new TrackInfo({
              source: TrackSource.MICROPHONE,
              sid: Math.floor(Math.random() * 1e4).toString(),
              type: TrackType.AUDIO,
            }),
            new LocalAudioTrack(
              q.useRealTracks
                ? (yield navigator.mediaDevices.getUserMedia({
                    audio: !0,
                  })).getAudioTracks()[0]
                : getEmptyAudioStreamTrack(),
              void 0,
              !1,
              this.audioContext,
              {
                loggerName: this.options.loggerName,
                loggerContextCb: () => this.logContext,
              }
            ),
            {
              loggerName: this.options.loggerName,
              loggerContextCb: () => this.logContext,
            }
          );
          this.localParticipant.addTrackPublication(H),
            this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, H);
        }
        for (let H = 0; H < $.count - 1; H += 1) {
          let G = new ParticipantInfo({
            sid: Math.floor(Math.random() * 1e4).toString(),
            identity: "simulated-".concat(H),
            state: ParticipantInfo_State.ACTIVE,
            tracks: [],
            joinedAt: protoInt64.parse(Date.now()),
          });
          const Y = this.getOrCreateParticipant(G.identity, G);
          if ($.video) {
            const Q = createDummyVideoStreamTrack(
                160 *
                  ((B = $.aspectRatios[H % $.aspectRatios.length]) !== null &&
                  B !== void 0
                    ? B
                    : 1),
                160,
                !1,
                !0
              ),
              X = new TrackInfo({
                source: TrackSource.CAMERA,
                sid: Math.floor(Math.random() * 1e4).toString(),
                type: TrackType.AUDIO,
              });
            Y.addSubscribedMediaTrack(
              Q,
              X.sid,
              new MediaStream([Q]),
              new RTCRtpReceiver()
            ),
              (G.tracks = [...G.tracks, X]);
          }
          if ($.audio) {
            const Q = getEmptyAudioStreamTrack(),
              X = new TrackInfo({
                source: TrackSource.MICROPHONE,
                sid: Math.floor(Math.random() * 1e4).toString(),
                type: TrackType.AUDIO,
              });
            Y.addSubscribedMediaTrack(
              Q,
              X.sid,
              new MediaStream([Q]),
              new RTCRtpReceiver()
            ),
              (G.tracks = [...G.tracks, X]);
          }
          Y.updateInfo(G);
        }
      });
    }
    emit(j) {
      for (
        var V = arguments.length, B = new Array(V > 1 ? V - 1 : 0), q = 1;
        q < V;
        q++
      )
        B[q - 1] = arguments[q];
      if (
        j !== RoomEvent.ActiveSpeakersChanged &&
        j !== RoomEvent.TranscriptionReceived
      ) {
        const $ = mapArgs(B).filter((H) => H !== void 0);
        this.log.debug(
          "room event ".concat(j),
          Object.assign(Object.assign({}, this.logContext), {
            event: j,
            args: $,
          })
        );
      }
      return super.emit(j, ...B);
    }
  }
  Room.cleanupRegistry =
    typeof FinalizationRegistry < "u" &&
    new FinalizationRegistry((U) => {
      U();
    });
  function mapArgs(U) {
    return U.map((j) => {
      if (j)
        return Array.isArray(j)
          ? mapArgs(j)
          : typeof j == "object"
          ? "logContext" in j
            ? j.logContext
            : void 0
          : j;
    });
  }
  var CheckStatus;
  (function (U) {
    (U[(U.IDLE = 0)] = "IDLE"),
      (U[(U.RUNNING = 1)] = "RUNNING"),
      (U[(U.SKIPPED = 2)] = "SKIPPED"),
      (U[(U.SUCCESS = 3)] = "SUCCESS"),
      (U[(U.FAILED = 4)] = "FAILED");
  })(CheckStatus || (CheckStatus = {}));
  class Checker extends eventsExports.EventEmitter {
    constructor(j, V) {
      let B =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super(),
        (this.status = CheckStatus.IDLE),
        (this.logs = []),
        (this.options = {}),
        (this.url = j),
        (this.token = V),
        (this.name = this.constructor.name),
        (this.room = new Room(B.roomOptions)),
        (this.connectOptions = B.connectOptions),
        (this.options = B);
    }
    run(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        if (this.status !== CheckStatus.IDLE)
          throw Error("check is running already");
        this.setStatus(CheckStatus.RUNNING);
        try {
          yield this.perform();
        } catch (V) {
          V instanceof Error &&
            (this.options.errorsAsWarnings
              ? this.appendWarning(V.message)
              : this.appendError(V.message));
        }
        return (
          yield this.disconnect(),
          yield new Promise((V) => setTimeout(V, 500)),
          this.status !== CheckStatus.SKIPPED &&
            this.setStatus(
              this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED
            ),
          j && j(),
          this.getInfo()
        );
      });
    }
    isSuccess() {
      return !this.logs.some((j) => j.level === "error");
    }
    connect(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.room.state === ConnectionState.Connected
          ? this.room
          : (j || (j = this.url),
            yield this.room.connect(j, this.token, this.connectOptions),
            this.room);
      });
    }
    disconnect() {
      return __awaiter$1(this, void 0, void 0, function* () {
        this.room &&
          this.room.state !== ConnectionState.Disconnected &&
          (yield this.room.disconnect(),
          yield new Promise((j) => setTimeout(j, 500)));
      });
    }
    skip() {
      this.setStatus(CheckStatus.SKIPPED);
    }
    switchProtocol(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        let V = !1,
          B = !1;
        if (
          (this.room.on(RoomEvent.Reconnecting, () => {
            V = !0;
          }),
          this.room.once(RoomEvent.Reconnected, () => {
            B = !0;
          }),
          this.room.simulateScenario("force-".concat(j)),
          yield new Promise(($) => setTimeout($, 1e3)),
          !V)
        )
          return;
        const q = Date.now() + 1e4;
        for (; Date.now() < q; ) {
          if (B) return;
          yield sleep$1(100);
        }
        throw new Error(
          "Could not reconnect using ".concat(j, " protocol after 10 seconds")
        );
      });
    }
    appendMessage(j) {
      this.logs.push({ level: "info", message: j }),
        this.emit("update", this.getInfo());
    }
    appendWarning(j) {
      this.logs.push({ level: "warning", message: j }),
        this.emit("update", this.getInfo());
    }
    appendError(j) {
      this.logs.push({ level: "error", message: j }),
        this.emit("update", this.getInfo());
    }
    setStatus(j) {
      (this.status = j), this.emit("update", this.getInfo());
    }
    get engine() {
      var j;
      return (j = this.room) === null || j === void 0 ? void 0 : j.engine;
    }
    getInfo() {
      return {
        logs: this.logs,
        name: this.name,
        status: this.status,
        description: this.description,
      };
    }
  }
  class CloudRegionCheck extends Checker {
    get description() {
      return "Cloud regions";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const j = new RegionUrlProvider(this.url, this.token);
        if (!j.isCloud()) {
          this.skip();
          return;
        }
        const V = [],
          B = new Set();
        for (let $ = 0; $ < 3; $++) {
          const H = yield j.getNextBestRegionUrl();
          if (!H) break;
          if (B.has(H)) continue;
          B.add(H);
          const G = yield this.checkCloudRegion(H);
          this.appendMessage(
            ""
              .concat(G.region, " RTT: ")
              .concat(G.rtt, "ms, duration: ")
              .concat(G.duration, "ms")
          ),
            V.push(G);
        }
        V.sort(
          ($, H) => ($.duration - H.duration) * 0.5 + ($.rtt - H.rtt) * 0.5
        );
        const q = V[0];
        (this.bestStats = q),
          this.appendMessage("best Cloud region: ".concat(q.region));
      });
    }
    getInfo() {
      const j = super.getInfo();
      return (j.data = this.bestStats), j;
    }
    checkCloudRegion(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        var V, B;
        yield this.connect(j),
          this.options.protocol === "tcp" && (yield this.switchProtocol("tcp"));
        const q =
          (V = this.room.serverInfo) === null || V === void 0
            ? void 0
            : V.region;
        if (!q) throw new Error("Region not found");
        const $ = yield this.room.localParticipant.streamText({
            topic: "test",
          }),
          H = 1e3,
          Y = 1e6 / H,
          Q = "A".repeat(H),
          X = Date.now();
        for (let ae = 0; ae < Y; ae++) yield $.write(Q);
        yield $.close();
        const Z = Date.now(),
          te = yield (B = this.room.engine.pcManager) === null || B === void 0
            ? void 0
            : B.publisher.getStats(),
          ne = { region: q, rtt: 1e4, duration: Z - X };
        return (
          te?.forEach((ae) => {
            ae.type === "candidate-pair" &&
              ae.nominated &&
              (ne.rtt = ae.currentRoundTripTime * 1e3);
          }),
          yield this.disconnect(),
          ne
        );
      });
    }
  }
  const TEST_DURATION = 1e4;
  class ConnectionProtocolCheck extends Checker {
    get description() {
      return "Connection via UDP vs TCP";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const j = yield this.checkConnectionProtocol("udp"),
          V = yield this.checkConnectionProtocol("tcp");
        (this.bestStats = j),
          j.qualityLimitationDurations.bandwidth -
            V.qualityLimitationDurations.bandwidth >
            0.5 || (j.packetsLost - V.packetsLost) / j.packetsSent > 0.01
            ? (this.appendMessage("best connection quality via tcp"),
              (this.bestStats = V))
            : this.appendMessage("best connection quality via udp");
        const B = this.bestStats;
        this.appendMessage(
          "upstream bitrate: ".concat(
            (B.bitrateTotal / B.count / 1e3 / 1e3).toFixed(2),
            " mbps"
          )
        ),
          this.appendMessage(
            "RTT: ".concat(((B.rttTotal / B.count) * 1e3).toFixed(2), " ms")
          ),
          this.appendMessage(
            "jitter: ".concat(
              ((B.jitterTotal / B.count) * 1e3).toFixed(2),
              " ms"
            )
          ),
          B.packetsLost > 0 &&
            this.appendWarning(
              "packets lost: ".concat(
                ((B.packetsLost / B.packetsSent) * 100).toFixed(2),
                "%"
              )
            ),
          B.qualityLimitationDurations.bandwidth > 1 &&
            this.appendWarning(
              "bandwidth limited ".concat(
                (
                  (B.qualityLimitationDurations.bandwidth /
                    (TEST_DURATION / 1e3)) *
                  100
                ).toFixed(2),
                "%"
              )
            ),
          B.qualityLimitationDurations.cpu > 0 &&
            this.appendWarning(
              "cpu limited ".concat(
                (
                  (B.qualityLimitationDurations.cpu / (TEST_DURATION / 1e3)) *
                  100
                ).toFixed(2),
                "%"
              )
            );
      });
    }
    getInfo() {
      const j = super.getInfo();
      return (j.data = this.bestStats), j;
    }
    checkConnectionProtocol(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        yield this.connect(),
          j === "tcp"
            ? yield this.switchProtocol("tcp")
            : yield this.switchProtocol("udp");
        const V = document.createElement("canvas");
        (V.width = 1280), (V.height = 720);
        const B = V.getContext("2d");
        if (!B) throw new Error("Could not get canvas context");
        let q = 0;
        const $ = () => {
          (q = (q + 1) % 360),
            (B.fillStyle = "hsl(".concat(q, ", 100%, 50%)")),
            B.fillRect(0, 0, V.width, V.height),
            requestAnimationFrame($);
        };
        $();
        const G = V.captureStream(30).getVideoTracks()[0],
          Q = (yield this.room.localParticipant.publishTrack(G, {
            simulcast: !1,
            degradationPreference: "maintain-resolution",
            videoEncoding: { maxBitrate: 2e6 },
          })).track,
          X = {
            protocol: j,
            packetsLost: 0,
            packetsSent: 0,
            qualityLimitationDurations: {},
            rttTotal: 0,
            jitterTotal: 0,
            bitrateTotal: 0,
            count: 0,
          },
          Z = setInterval(
            () =>
              __awaiter$1(this, void 0, void 0, function* () {
                const te = yield Q.getRTCStatsReport();
                te?.forEach((ne) => {
                  ne.type === "outbound-rtp"
                    ? ((X.packetsSent = ne.packetsSent),
                      (X.qualityLimitationDurations =
                        ne.qualityLimitationDurations),
                      (X.bitrateTotal += ne.targetBitrate),
                      X.count++)
                    : ne.type === "remote-inbound-rtp" &&
                      ((X.packetsLost = ne.packetsLost),
                      (X.rttTotal += ne.roundTripTime),
                      (X.jitterTotal += ne.jitter));
                });
              }),
            1e3
          );
        return (
          yield new Promise((te) => setTimeout(te, TEST_DURATION)),
          clearInterval(Z),
          G.stop(),
          V.remove(),
          yield this.disconnect(),
          X
        );
      });
    }
  }
  class PublishAudioCheck extends Checker {
    get description() {
      return "Can publish audio";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.connect(),
          B = yield createLocalAudioTrack();
        if (yield detectSilence(B, 1e3))
          throw new Error("unable to detect audio from microphone");
        this.appendMessage("detected audio from microphone"),
          V.localParticipant.publishTrack(B),
          yield new Promise((G) => setTimeout(G, 3e3));
        const $ = yield (j = B.sender) === null || j === void 0
          ? void 0
          : j.getStats();
        if (!$) throw new Error("Could not get RTCStats");
        let H = 0;
        if (
          ($.forEach((G) => {
            G.type === "outbound-rtp" &&
              (G.kind === "audio" || (!G.kind && G.mediaType === "audio")) &&
              (H = G.packetsSent);
          }),
          H === 0)
        )
          throw new Error("Could not determine packets are sent");
        this.appendMessage("published ".concat(H, " audio packets"));
      });
    }
  }
  class PublishVideoCheck extends Checker {
    get description() {
      return "Can publish video";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.connect(),
          B = yield createLocalVideoTrack();
        yield this.checkForVideo(B.mediaStreamTrack),
          V.localParticipant.publishTrack(B),
          yield new Promise((H) => setTimeout(H, 5e3));
        const q = yield (j = B.sender) === null || j === void 0
          ? void 0
          : j.getStats();
        if (!q) throw new Error("Could not get RTCStats");
        let $ = 0;
        if (
          (q.forEach((H) => {
            H.type === "outbound-rtp" &&
              (H.kind === "video" || (!H.kind && H.mediaType === "video")) &&
              ($ += H.packetsSent);
          }),
          $ === 0)
        )
          throw new Error("Could not determine packets are sent");
        this.appendMessage("published ".concat($, " video packets"));
      });
    }
    checkForVideo(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = new MediaStream();
        V.addTrack(j.clone());
        const B = document.createElement("video");
        (B.srcObject = V),
          (B.muted = !0),
          yield new Promise((q) => {
            (B.onplay = () => {
              setTimeout(() => {
                var $, H, G, Y;
                const Q = document.createElement("canvas"),
                  X = j.getSettings(),
                  Z =
                    (H =
                      ($ = X.width) !== null && $ !== void 0
                        ? $
                        : B.videoWidth) !== null && H !== void 0
                      ? H
                      : 1280,
                  te =
                    (Y =
                      (G = X.height) !== null && G !== void 0
                        ? G
                        : B.videoHeight) !== null && Y !== void 0
                      ? Y
                      : 720;
                (Q.width = Z), (Q.height = te);
                const ne = Q.getContext("2d");
                ne.drawImage(B, 0, 0);
                const se = ne.getImageData(0, 0, Q.width, Q.height).data;
                let fe = !0;
                for (let ce = 0; ce < se.length; ce += 4)
                  if (se[ce] !== 0 || se[ce + 1] !== 0 || se[ce + 2] !== 0) {
                    fe = !1;
                    break;
                  }
                fe
                  ? this.appendError(
                      "camera appears to be producing only black frames"
                    )
                  : this.appendMessage("received video frames"),
                  q();
              }, 1e3);
            }),
              B.play();
          }),
          V.getTracks().forEach((q) => q.stop()),
          B.remove();
      });
    }
  }
  class ReconnectCheck extends Checker {
    get description() {
      return "Resuming connection after interruption";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j;
        const V = yield this.connect();
        let B = !1,
          q = !1,
          $;
        const H = new Promise((Q) => {
            setTimeout(Q, 5e3), ($ = Q);
          }),
          G = () => {
            B = !0;
          };
        V.on(RoomEvent.SignalReconnecting, G)
          .on(RoomEvent.Reconnecting, G)
          .on(RoomEvent.Reconnected, () => {
            (q = !0), $(!0);
          }),
          (j = V.engine.client.ws) === null || j === void 0 || j.close();
        const Y = V.engine.client.onClose;
        if ((Y && Y(""), yield H, B)) {
          if (!q || V.state !== ConnectionState.Connected)
            throw (
              (this.appendWarning(
                "reconnection is only possible in Redis-based configurations"
              ),
              new Error("Not able to reconnect"))
            );
        } else throw new Error("Did not attempt to reconnect");
      });
    }
  }
  class TURNCheck extends Checker {
    get description() {
      return "Can connect via TURN";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V;
        const B = new SignalClient(),
          q = yield B.join(this.url, this.token, {
            autoSubscribe: !0,
            maxRetries: 0,
            e2eeEnabled: !1,
            websocketTimeout: 15e3,
          });
        let $ = !1,
          H = !1,
          G = !1;
        for (let Y of q.iceServers)
          for (let Q of Y.urls)
            Q.startsWith("turn:")
              ? ((H = !0), (G = !0))
              : Q.startsWith("turns:") && ((H = !0), (G = !0), ($ = !0)),
              Q.startsWith("stun:") && (G = !0);
        G
          ? H &&
            !$ &&
            this.appendWarning(
              "TURN is configured server side, but TURN/TLS is unavailable."
            )
          : this.appendWarning("No STUN servers configured on server side."),
          yield B.close(),
          (!(
            (V =
              (j = this.connectOptions) === null || j === void 0
                ? void 0
                : j.rtcConfig) === null || V === void 0
          ) &&
            V.iceServers) ||
          H
            ? yield this.room.connect(this.url, this.token, {
                rtcConfig: { iceTransportPolicy: "relay" },
              })
            : (this.appendWarning("No TURN servers configured."),
              this.skip(),
              yield new Promise((Y) => setTimeout(Y, 0)));
      });
    }
  }
  class WebRTCCheck extends Checker {
    get description() {
      return "Establishing WebRTC connection";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        let j = !1,
          V = !1;
        this.room.on(RoomEvent.SignalConnected, () => {
          const B = this.room.engine.client.onTrickle;
          (this.room.engine.client.onTrickle = (q, $) => {
            if (q.candidate) {
              const H = new RTCIceCandidate(q);
              let G = ""
                .concat(H.protocol, " ")
                .concat(H.address, ":")
                .concat(H.port, " ")
                .concat(H.type);
              H.address &&
                (isIPPrivate(H.address)
                  ? (G += " (private)")
                  : H.protocol === "tcp" && H.tcpType === "passive"
                  ? ((j = !0), (G += " (passive)"))
                  : H.protocol === "udp" && (V = !0)),
                this.appendMessage(G);
            }
            B && B(q, $);
          }),
            this.room.engine.pcManager &&
              (this.room.engine.pcManager.subscriber.onIceCandidateError = (
                q
              ) => {
                q instanceof RTCPeerConnectionIceErrorEvent &&
                  this.appendWarning(
                    "error with ICE candidate: "
                      .concat(q.errorCode, " ")
                      .concat(q.errorText, " ")
                      .concat(q.url)
                  );
              });
        });
        try {
          yield this.connect(), livekitLogger.info("now the room is connected");
        } catch (B) {
          throw (
            (this.appendWarning(
              "ports need to be open on firewall in order to connect."
            ),
            B)
          );
        }
        j || this.appendWarning("Server is not configured for ICE/TCP"),
          V ||
            this.appendWarning(
              "No public IPv4 UDP candidates were found. Your server is likely not configured correctly"
            );
      });
    }
  }
  function isIPPrivate(U) {
    const j = U.split(".");
    if (j.length === 4) {
      if (j[0] === "10") return !0;
      if (j[0] === "192" && j[1] === "168") return !0;
      if (j[0] === "172") {
        const V = parseInt(j[1], 10);
        if (V >= 16 && V <= 31) return !0;
      }
    }
    return !1;
  }
  class WebSocketCheck extends Checker {
    get description() {
      return "Connecting to signal connection via WebSocket";
    }
    perform() {
      return __awaiter$1(this, void 0, void 0, function* () {
        var j, V, B;
        (this.url.startsWith("ws:") || this.url.startsWith("http:")) &&
          this.appendWarning(
            "Server is insecure, clients may block connections to it"
          );
        let q = new SignalClient();
        const $ = yield q.join(this.url, this.token, {
          autoSubscribe: !0,
          maxRetries: 0,
          e2eeEnabled: !1,
          websocketTimeout: 15e3,
        });
        this.appendMessage(
          "Connected to server, version ".concat($.serverVersion, ".")
        ),
          ((j = $.serverInfo) === null || j === void 0 ? void 0 : j.edition) ===
            ServerInfo_Edition.Cloud &&
            !((V = $.serverInfo) === null || V === void 0) &&
            V.region &&
            this.appendMessage(
              "LiveKit Cloud: ".concat(
                (B = $.serverInfo) === null || B === void 0 ? void 0 : B.region
              )
            ),
          yield q.close();
      });
    }
  }
  class ConnectionCheck extends eventsExports.EventEmitter {
    constructor(j, V) {
      let B =
        arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      super(),
        (this.options = {}),
        (this.checkResults = new Map()),
        (this.url = j),
        (this.token = V),
        (this.options = B);
    }
    getNextCheckId() {
      const j = this.checkResults.size;
      return (
        this.checkResults.set(j, {
          logs: [],
          status: CheckStatus.IDLE,
          name: "",
          description: "",
        }),
        j
      );
    }
    updateCheck(j, V) {
      this.checkResults.set(j, V), this.emit("checkUpdate", j, V);
    }
    isSuccess() {
      return Array.from(this.checkResults.values()).every(
        (j) => j.status !== CheckStatus.FAILED
      );
    }
    getResults() {
      return Array.from(this.checkResults.values());
    }
    createAndRunCheck(j) {
      return __awaiter$1(this, void 0, void 0, function* () {
        const V = this.getNextCheckId(),
          B = new j(this.url, this.token, this.options),
          q = (H) => {
            this.updateCheck(V, H);
          };
        B.on("update", q);
        const $ = yield B.run();
        return B.off("update", q), $;
      });
    }
    checkWebsocket() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebSocketCheck);
      });
    }
    checkWebRTC() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(WebRTCCheck);
      });
    }
    checkTURN() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(TURNCheck);
      });
    }
    checkReconnect() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(ReconnectCheck);
      });
    }
    checkPublishAudio() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishAudioCheck);
      });
    }
    checkPublishVideo() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(PublishVideoCheck);
      });
    }
    checkConnectionProtocol() {
      return __awaiter$1(this, void 0, void 0, function* () {
        const j = yield this.createAndRunCheck(ConnectionProtocolCheck);
        if (j.data && "protocol" in j.data) {
          const V = j.data;
          this.options.protocol = V.protocol;
        }
        return j;
      });
    }
    checkCloudRegion() {
      return __awaiter$1(this, void 0, void 0, function* () {
        return this.createAndRunCheck(CloudRegionCheck);
      });
    }
  }
  var src = { exports: {} },
    indexLight = { exports: {} },
    indexMinimal = {},
    minimal = {},
    aspromise,
    hasRequiredAspromise;
  function requireAspromise() {
    if (hasRequiredAspromise) return aspromise;
    (hasRequiredAspromise = 1), (aspromise = U);
    function U(j, V) {
      for (
        var B = new Array(arguments.length - 1), q = 0, $ = 2, H = !0;
        $ < arguments.length;

      )
        B[q++] = arguments[$++];
      return new Promise(function (Y, Q) {
        B[q] = function (Z) {
          if (H)
            if (((H = !1), Z)) Q(Z);
            else {
              for (
                var te = new Array(arguments.length - 1), ne = 0;
                ne < te.length;

              )
                te[ne++] = arguments[ne];
              Y.apply(null, te);
            }
        };
        try {
          j.apply(V || null, B);
        } catch (X) {
          H && ((H = !1), Q(X));
        }
      });
    }
    return aspromise;
  }
  var base64 = {},
    hasRequiredBase64;
  function requireBase64() {
    return (
      hasRequiredBase64 ||
        ((hasRequiredBase64 = 1),
        (function (U) {
          var j = U;
          j.length = function (G) {
            var Y = G.length;
            if (!Y) return 0;
            for (var Q = 0; --Y % 4 > 1 && G.charAt(Y) === "="; ) ++Q;
            return Math.ceil(G.length * 3) / 4 - Q;
          };
          for (var V = new Array(64), B = new Array(123), q = 0; q < 64; )
            B[
              (V[q] =
                q < 26
                  ? q + 65
                  : q < 52
                  ? q + 71
                  : q < 62
                  ? q - 4
                  : (q - 59) | 43)
            ] = q++;
          j.encode = function (G, Y, Q) {
            for (var X = null, Z = [], te = 0, ne = 0, ae; Y < Q; ) {
              var se = G[Y++];
              switch (ne) {
                case 0:
                  (Z[te++] = V[se >> 2]), (ae = (se & 3) << 4), (ne = 1);
                  break;
                case 1:
                  (Z[te++] = V[ae | (se >> 4)]),
                    (ae = (se & 15) << 2),
                    (ne = 2);
                  break;
                case 2:
                  (Z[te++] = V[ae | (se >> 6)]),
                    (Z[te++] = V[se & 63]),
                    (ne = 0);
                  break;
              }
              te > 8191 &&
                ((X || (X = [])).push(String.fromCharCode.apply(String, Z)),
                (te = 0));
            }
            return (
              ne &&
                ((Z[te++] = V[ae]), (Z[te++] = 61), ne === 1 && (Z[te++] = 61)),
              X
                ? (te &&
                    X.push(String.fromCharCode.apply(String, Z.slice(0, te))),
                  X.join(""))
                : String.fromCharCode.apply(String, Z.slice(0, te))
            );
          };
          var $ = "invalid encoding";
          (j.decode = function (G, Y, Q) {
            for (var X = Q, Z = 0, te, ne = 0; ne < G.length; ) {
              var ae = G.charCodeAt(ne++);
              if (ae === 61 && Z > 1) break;
              if ((ae = B[ae]) === void 0) throw Error($);
              switch (Z) {
                case 0:
                  (te = ae), (Z = 1);
                  break;
                case 1:
                  (Y[Q++] = (te << 2) | ((ae & 48) >> 4)), (te = ae), (Z = 2);
                  break;
                case 2:
                  (Y[Q++] = ((te & 15) << 4) | ((ae & 60) >> 2)),
                    (te = ae),
                    (Z = 3);
                  break;
                case 3:
                  (Y[Q++] = ((te & 3) << 6) | ae), (Z = 0);
                  break;
              }
            }
            if (Z === 1) throw Error($);
            return Q - X;
          }),
            (j.test = function (G) {
              return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(
                G
              );
            });
        })(base64)),
      base64
    );
  }
  var eventemitter, hasRequiredEventemitter;
  function requireEventemitter() {
    if (hasRequiredEventemitter) return eventemitter;
    (hasRequiredEventemitter = 1), (eventemitter = U);
    function U() {
      this._listeners = {};
    }
    return (
      (U.prototype.on = function (V, B, q) {
        return (
          (this._listeners[V] || (this._listeners[V] = [])).push({
            fn: B,
            ctx: q || this,
          }),
          this
        );
      }),
      (U.prototype.off = function (V, B) {
        if (V === void 0) this._listeners = {};
        else if (B === void 0) this._listeners[V] = [];
        else
          for (var q = this._listeners[V], $ = 0; $ < q.length; )
            q[$].fn === B ? q.splice($, 1) : ++$;
        return this;
      }),
      (U.prototype.emit = function (V) {
        var B = this._listeners[V];
        if (B) {
          for (var q = [], $ = 1; $ < arguments.length; )
            q.push(arguments[$++]);
          for ($ = 0; $ < B.length; ) B[$].fn.apply(B[$++].ctx, q);
        }
        return this;
      }),
      eventemitter
    );
  }
  var float, hasRequiredFloat;
  function requireFloat() {
    if (hasRequiredFloat) return float;
    (hasRequiredFloat = 1), (float = U(U));
    function U($) {
      return (
        typeof Float32Array < "u"
          ? (function () {
              var H = new Float32Array([-0]),
                G = new Uint8Array(H.buffer),
                Y = G[3] === 128;
              function Q(ne, ae, se) {
                (H[0] = ne),
                  (ae[se] = G[0]),
                  (ae[se + 1] = G[1]),
                  (ae[se + 2] = G[2]),
                  (ae[se + 3] = G[3]);
              }
              function X(ne, ae, se) {
                (H[0] = ne),
                  (ae[se] = G[3]),
                  (ae[se + 1] = G[2]),
                  (ae[se + 2] = G[1]),
                  (ae[se + 3] = G[0]);
              }
              ($.writeFloatLE = Y ? Q : X), ($.writeFloatBE = Y ? X : Q);
              function Z(ne, ae) {
                return (
                  (G[0] = ne[ae]),
                  (G[1] = ne[ae + 1]),
                  (G[2] = ne[ae + 2]),
                  (G[3] = ne[ae + 3]),
                  H[0]
                );
              }
              function te(ne, ae) {
                return (
                  (G[3] = ne[ae]),
                  (G[2] = ne[ae + 1]),
                  (G[1] = ne[ae + 2]),
                  (G[0] = ne[ae + 3]),
                  H[0]
                );
              }
              ($.readFloatLE = Y ? Z : te), ($.readFloatBE = Y ? te : Z);
            })()
          : (function () {
              function H(Y, Q, X, Z) {
                var te = Q < 0 ? 1 : 0;
                if ((te && (Q = -Q), Q === 0))
                  Y(1 / Q > 0 ? 0 : 2147483648, X, Z);
                else if (isNaN(Q)) Y(2143289344, X, Z);
                else if (Q > 34028234663852886e22)
                  Y(((te << 31) | 2139095040) >>> 0, X, Z);
                else if (Q < 11754943508222875e-54)
                  Y(
                    ((te << 31) | Math.round(Q / 1401298464324817e-60)) >>> 0,
                    X,
                    Z
                  );
                else {
                  var ne = Math.floor(Math.log(Q) / Math.LN2),
                    ae = Math.round(Q * Math.pow(2, -ne) * 8388608) & 8388607;
                  Y(((te << 31) | ((ne + 127) << 23) | ae) >>> 0, X, Z);
                }
              }
              ($.writeFloatLE = H.bind(null, j)),
                ($.writeFloatBE = H.bind(null, V));
              function G(Y, Q, X) {
                var Z = Y(Q, X),
                  te = (Z >> 31) * 2 + 1,
                  ne = (Z >>> 23) & 255,
                  ae = Z & 8388607;
                return ne === 255
                  ? ae
                    ? NaN
                    : te * (1 / 0)
                  : ne === 0
                  ? te * 1401298464324817e-60 * ae
                  : te * Math.pow(2, ne - 150) * (ae + 8388608);
              }
              ($.readFloatLE = G.bind(null, B)),
                ($.readFloatBE = G.bind(null, q));
            })(),
        typeof Float64Array < "u"
          ? (function () {
              var H = new Float64Array([-0]),
                G = new Uint8Array(H.buffer),
                Y = G[7] === 128;
              function Q(ne, ae, se) {
                (H[0] = ne),
                  (ae[se] = G[0]),
                  (ae[se + 1] = G[1]),
                  (ae[se + 2] = G[2]),
                  (ae[se + 3] = G[3]),
                  (ae[se + 4] = G[4]),
                  (ae[se + 5] = G[5]),
                  (ae[se + 6] = G[6]),
                  (ae[se + 7] = G[7]);
              }
              function X(ne, ae, se) {
                (H[0] = ne),
                  (ae[se] = G[7]),
                  (ae[se + 1] = G[6]),
                  (ae[se + 2] = G[5]),
                  (ae[se + 3] = G[4]),
                  (ae[se + 4] = G[3]),
                  (ae[se + 5] = G[2]),
                  (ae[se + 6] = G[1]),
                  (ae[se + 7] = G[0]);
              }
              ($.writeDoubleLE = Y ? Q : X), ($.writeDoubleBE = Y ? X : Q);
              function Z(ne, ae) {
                return (
                  (G[0] = ne[ae]),
                  (G[1] = ne[ae + 1]),
                  (G[2] = ne[ae + 2]),
                  (G[3] = ne[ae + 3]),
                  (G[4] = ne[ae + 4]),
                  (G[5] = ne[ae + 5]),
                  (G[6] = ne[ae + 6]),
                  (G[7] = ne[ae + 7]),
                  H[0]
                );
              }
              function te(ne, ae) {
                return (
                  (G[7] = ne[ae]),
                  (G[6] = ne[ae + 1]),
                  (G[5] = ne[ae + 2]),
                  (G[4] = ne[ae + 3]),
                  (G[3] = ne[ae + 4]),
                  (G[2] = ne[ae + 5]),
                  (G[1] = ne[ae + 6]),
                  (G[0] = ne[ae + 7]),
                  H[0]
                );
              }
              ($.readDoubleLE = Y ? Z : te), ($.readDoubleBE = Y ? te : Z);
            })()
          : (function () {
              function H(Y, Q, X, Z, te, ne) {
                var ae = Z < 0 ? 1 : 0;
                if ((ae && (Z = -Z), Z === 0))
                  Y(0, te, ne + Q), Y(1 / Z > 0 ? 0 : 2147483648, te, ne + X);
                else if (isNaN(Z)) Y(0, te, ne + Q), Y(2146959360, te, ne + X);
                else if (Z > 17976931348623157e292)
                  Y(0, te, ne + Q),
                    Y(((ae << 31) | 2146435072) >>> 0, te, ne + X);
                else {
                  var se;
                  if (Z < 22250738585072014e-324)
                    (se = Z / 5e-324),
                      Y(se >>> 0, te, ne + Q),
                      Y(((ae << 31) | (se / 4294967296)) >>> 0, te, ne + X);
                  else {
                    var fe = Math.floor(Math.log(Z) / Math.LN2);
                    fe === 1024 && (fe = 1023),
                      (se = Z * Math.pow(2, -fe)),
                      Y((se * 4503599627370496) >>> 0, te, ne + Q),
                      Y(
                        ((ae << 31) |
                          ((fe + 1023) << 20) |
                          ((se * 1048576) & 1048575)) >>>
                          0,
                        te,
                        ne + X
                      );
                  }
                }
              }
              ($.writeDoubleLE = H.bind(null, j, 0, 4)),
                ($.writeDoubleBE = H.bind(null, V, 4, 0));
              function G(Y, Q, X, Z, te) {
                var ne = Y(Z, te + Q),
                  ae = Y(Z, te + X),
                  se = (ae >> 31) * 2 + 1,
                  fe = (ae >>> 20) & 2047,
                  ce = 4294967296 * (ae & 1048575) + ne;
                return fe === 2047
                  ? ce
                    ? NaN
                    : se * (1 / 0)
                  : fe === 0
                  ? se * 5e-324 * ce
                  : se * Math.pow(2, fe - 1075) * (ce + 4503599627370496);
              }
              ($.readDoubleLE = G.bind(null, B, 0, 4)),
                ($.readDoubleBE = G.bind(null, q, 4, 0));
            })(),
        $
      );
    }
    function j($, H, G) {
      (H[G] = $ & 255),
        (H[G + 1] = ($ >>> 8) & 255),
        (H[G + 2] = ($ >>> 16) & 255),
        (H[G + 3] = $ >>> 24);
    }
    function V($, H, G) {
      (H[G] = $ >>> 24),
        (H[G + 1] = ($ >>> 16) & 255),
        (H[G + 2] = ($ >>> 8) & 255),
        (H[G + 3] = $ & 255);
    }
    function B($, H) {
      return (
        ($[H] | ($[H + 1] << 8) | ($[H + 2] << 16) | ($[H + 3] << 24)) >>> 0
      );
    }
    function q($, H) {
      return (
        (($[H] << 24) | ($[H + 1] << 16) | ($[H + 2] << 8) | $[H + 3]) >>> 0
      );
    }
    return float;
  }
  var inquire_1, hasRequiredInquire;
  function requireInquire() {
    if (hasRequiredInquire) return inquire_1;
    (hasRequiredInquire = 1), (inquire_1 = inquire);
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
      } catch (U) {}
      return null;
    }
    return inquire_1;
  }
  var utf8 = {},
    hasRequiredUtf8;
  function requireUtf8() {
    return (
      hasRequiredUtf8 ||
        ((hasRequiredUtf8 = 1),
        (function (U) {
          var j = U;
          (j.length = function (B) {
            for (var q = 0, $ = 0, H = 0; H < B.length; ++H)
              ($ = B.charCodeAt(H)),
                $ < 128
                  ? (q += 1)
                  : $ < 2048
                  ? (q += 2)
                  : ($ & 64512) === 55296 &&
                    (B.charCodeAt(H + 1) & 64512) === 56320
                  ? (++H, (q += 4))
                  : (q += 3);
            return q;
          }),
            (j.read = function (B, q, $) {
              var H = $ - q;
              if (H < 1) return "";
              for (var G = null, Y = [], Q = 0, X; q < $; )
                (X = B[q++]),
                  X < 128
                    ? (Y[Q++] = X)
                    : X > 191 && X < 224
                    ? (Y[Q++] = ((X & 31) << 6) | (B[q++] & 63))
                    : X > 239 && X < 365
                    ? ((X =
                        (((X & 7) << 18) |
                          ((B[q++] & 63) << 12) |
                          ((B[q++] & 63) << 6) |
                          (B[q++] & 63)) -
                        65536),
                      (Y[Q++] = 55296 + (X >> 10)),
                      (Y[Q++] = 56320 + (X & 1023)))
                    : (Y[Q++] =
                        ((X & 15) << 12) |
                        ((B[q++] & 63) << 6) |
                        (B[q++] & 63)),
                  Q > 8191 &&
                    ((G || (G = [])).push(String.fromCharCode.apply(String, Y)),
                    (Q = 0));
              return G
                ? (Q &&
                    G.push(String.fromCharCode.apply(String, Y.slice(0, Q))),
                  G.join(""))
                : String.fromCharCode.apply(String, Y.slice(0, Q));
            }),
            (j.write = function (B, q, $) {
              for (var H = $, G, Y, Q = 0; Q < B.length; ++Q)
                (G = B.charCodeAt(Q)),
                  G < 128
                    ? (q[$++] = G)
                    : G < 2048
                    ? ((q[$++] = (G >> 6) | 192), (q[$++] = (G & 63) | 128))
                    : (G & 64512) === 55296 &&
                      ((Y = B.charCodeAt(Q + 1)) & 64512) === 56320
                    ? ((G = 65536 + ((G & 1023) << 10) + (Y & 1023)),
                      ++Q,
                      (q[$++] = (G >> 18) | 240),
                      (q[$++] = ((G >> 12) & 63) | 128),
                      (q[$++] = ((G >> 6) & 63) | 128),
                      (q[$++] = (G & 63) | 128))
                    : ((q[$++] = (G >> 12) | 224),
                      (q[$++] = ((G >> 6) & 63) | 128),
                      (q[$++] = (G & 63) | 128));
              return $ - H;
            });
        })(utf8)),
      utf8
    );
  }
  var pool_1, hasRequiredPool;
  function requirePool() {
    if (hasRequiredPool) return pool_1;
    (hasRequiredPool = 1), (pool_1 = U);
    function U(j, V, B) {
      var q = B || 8192,
        $ = q >>> 1,
        H = null,
        G = q;
      return function (Q) {
        if (Q < 1 || Q > $) return j(Q);
        G + Q > q && ((H = j(q)), (G = 0));
        var X = V.call(H, G, (G += Q));
        return G & 7 && (G = (G | 7) + 1), X;
      };
    }
    return pool_1;
  }
  var longbits, hasRequiredLongbits;
  function requireLongbits() {
    if (hasRequiredLongbits) return longbits;
    (hasRequiredLongbits = 1), (longbits = j);
    var U = requireMinimal();
    function j($, H) {
      (this.lo = $ >>> 0), (this.hi = H >>> 0);
    }
    var V = (j.zero = new j(0, 0));
    (V.toNumber = function () {
      return 0;
    }),
      (V.zzEncode = V.zzDecode =
        function () {
          return this;
        }),
      (V.length = function () {
        return 1;
      });
    var B = (j.zeroHash = "\0\0\0\0\0\0\0\0");
    (j.fromNumber = function (H) {
      if (H === 0) return V;
      var G = H < 0;
      G && (H = -H);
      var Y = H >>> 0,
        Q = ((H - Y) / 4294967296) >>> 0;
      return (
        G &&
          ((Q = ~Q >>> 0),
          (Y = ~Y >>> 0),
          ++Y > 4294967295 && ((Y = 0), ++Q > 4294967295 && (Q = 0))),
        new j(Y, Q)
      );
    }),
      (j.from = function (H) {
        if (typeof H == "number") return j.fromNumber(H);
        if (U.isString(H))
          if (U.Long) H = U.Long.fromString(H);
          else return j.fromNumber(parseInt(H, 10));
        return H.low || H.high ? new j(H.low >>> 0, H.high >>> 0) : V;
      }),
      (j.prototype.toNumber = function (H) {
        if (!H && this.hi >>> 31) {
          var G = (~this.lo + 1) >>> 0,
            Y = ~this.hi >>> 0;
          return G || (Y = (Y + 1) >>> 0), -(G + Y * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      }),
      (j.prototype.toLong = function (H) {
        return U.Long
          ? new U.Long(this.lo | 0, this.hi | 0, !!H)
          : { low: this.lo | 0, high: this.hi | 0, unsigned: !!H };
      });
    var q = String.prototype.charCodeAt;
    return (
      (j.fromHash = function (H) {
        return H === B
          ? V
          : new j(
              (q.call(H, 0) |
                (q.call(H, 1) << 8) |
                (q.call(H, 2) << 16) |
                (q.call(H, 3) << 24)) >>>
                0,
              (q.call(H, 4) |
                (q.call(H, 5) << 8) |
                (q.call(H, 6) << 16) |
                (q.call(H, 7) << 24)) >>>
                0
            );
      }),
      (j.prototype.toHash = function () {
        return String.fromCharCode(
          this.lo & 255,
          (this.lo >>> 8) & 255,
          (this.lo >>> 16) & 255,
          this.lo >>> 24,
          this.hi & 255,
          (this.hi >>> 8) & 255,
          (this.hi >>> 16) & 255,
          this.hi >>> 24
        );
      }),
      (j.prototype.zzEncode = function () {
        var H = this.hi >> 31;
        return (
          (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ H) >>> 0),
          (this.lo = ((this.lo << 1) ^ H) >>> 0),
          this
        );
      }),
      (j.prototype.zzDecode = function () {
        var H = -(this.lo & 1);
        return (
          (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ H) >>> 0),
          (this.hi = ((this.hi >>> 1) ^ H) >>> 0),
          this
        );
      }),
      (j.prototype.length = function () {
        var H = this.lo,
          G = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
          Y = this.hi >>> 24;
        return Y === 0
          ? G === 0
            ? H < 16384
              ? H < 128
                ? 1
                : 2
              : H < 2097152
              ? 3
              : 4
            : G < 16384
            ? G < 128
              ? 5
              : 6
            : G < 2097152
            ? 7
            : 8
          : Y < 128
          ? 9
          : 10;
      }),
      longbits
    );
  }
  var hasRequiredMinimal;
  function requireMinimal() {
    return (
      hasRequiredMinimal ||
        ((hasRequiredMinimal = 1),
        (function (U) {
          var j = U;
          (j.asPromise = requireAspromise()),
            (j.base64 = requireBase64()),
            (j.EventEmitter = requireEventemitter()),
            (j.float = requireFloat()),
            (j.inquire = requireInquire()),
            (j.utf8 = requireUtf8()),
            (j.pool = requirePool()),
            (j.LongBits = requireLongbits()),
            (j.isNode = !!(
              typeof commonjsGlobal < "u" &&
              commonjsGlobal &&
              commonjsGlobal.process &&
              commonjsGlobal.process.versions &&
              commonjsGlobal.process.versions.node
            )),
            (j.global =
              (j.isNode && commonjsGlobal) ||
              (typeof window < "u" && window) ||
              (typeof self < "u" && self) ||
              minimal),
            (j.emptyArray = Object.freeze ? Object.freeze([]) : []),
            (j.emptyObject = Object.freeze ? Object.freeze({}) : {}),
            (j.isInteger =
              Number.isInteger ||
              function ($) {
                return (
                  typeof $ == "number" && isFinite($) && Math.floor($) === $
                );
              }),
            (j.isString = function ($) {
              return typeof $ == "string" || $ instanceof String;
            }),
            (j.isObject = function ($) {
              return $ && typeof $ == "object";
            }),
            (j.isset = j.isSet =
              function ($, H) {
                var G = $[H];
                return G != null && $.hasOwnProperty(H)
                  ? typeof G != "object" ||
                      (Array.isArray(G) ? G.length : Object.keys(G).length) > 0
                  : !1;
              }),
            (j.Buffer = (function () {
              try {
                var q = j.inquire("buffer").Buffer;
                return q.prototype.utf8Write ? q : null;
              } catch {
                return null;
              }
            })()),
            (j._Buffer_from = null),
            (j._Buffer_allocUnsafe = null),
            (j.newBuffer = function ($) {
              return typeof $ == "number"
                ? j.Buffer
                  ? j._Buffer_allocUnsafe($)
                  : new j.Array($)
                : j.Buffer
                ? j._Buffer_from($)
                : typeof Uint8Array > "u"
                ? $
                : new Uint8Array($);
            }),
            (j.Array = typeof Uint8Array < "u" ? Uint8Array : Array),
            (j.Long =
              (j.global.dcodeIO && j.global.dcodeIO.Long) ||
              j.global.Long ||
              j.inquire("long")),
            (j.key2Re = /^true|false|0|1$/),
            (j.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
            (j.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
            (j.longToHash = function ($) {
              return $ ? j.LongBits.from($).toHash() : j.LongBits.zeroHash;
            }),
            (j.longFromHash = function ($, H) {
              var G = j.LongBits.fromHash($);
              return j.Long ? j.Long.fromBits(G.lo, G.hi, H) : G.toNumber(!!H);
            });
          function V(q, $, H) {
            for (var G = Object.keys($), Y = 0; Y < G.length; ++Y)
              (q[G[Y]] === void 0 || !H) && (q[G[Y]] = $[G[Y]]);
            return q;
          }
          (j.merge = V),
            (j.lcFirst = function ($) {
              return $.charAt(0).toLowerCase() + $.substring(1);
            });
          function B(q) {
            function $(H, G) {
              if (!(this instanceof $)) return new $(H, G);
              Object.defineProperty(this, "message", {
                get: function () {
                  return H;
                },
              }),
                Error.captureStackTrace
                  ? Error.captureStackTrace(this, $)
                  : Object.defineProperty(this, "stack", {
                      value: new Error().stack || "",
                    }),
                G && V(this, G);
            }
            return (
              ($.prototype = Object.create(Error.prototype, {
                constructor: {
                  value: $,
                  writable: !0,
                  enumerable: !1,
                  configurable: !0,
                },
                name: {
                  get: function () {
                    return q;
                  },
                  set: void 0,
                  enumerable: !1,
                  configurable: !0,
                },
                toString: {
                  value: function () {
                    return this.name + ": " + this.message;
                  },
                  writable: !0,
                  enumerable: !1,
                  configurable: !0,
                },
              })),
              $
            );
          }
          (j.newError = B),
            (j.ProtocolError = B("ProtocolError")),
            (j.oneOfGetter = function ($) {
              for (var H = {}, G = 0; G < $.length; ++G) H[$[G]] = 1;
              return function () {
                for (var Y = Object.keys(this), Q = Y.length - 1; Q > -1; --Q)
                  if (
                    H[Y[Q]] === 1 &&
                    this[Y[Q]] !== void 0 &&
                    this[Y[Q]] !== null
                  )
                    return Y[Q];
              };
            }),
            (j.oneOfSetter = function ($) {
              return function (H) {
                for (var G = 0; G < $.length; ++G)
                  $[G] !== H && delete this[$[G]];
              };
            }),
            (j.toJSONOptions = {
              longs: String,
              enums: String,
              bytes: String,
              json: !0,
            }),
            (j._configure = function () {
              var q = j.Buffer;
              if (!q) {
                j._Buffer_from = j._Buffer_allocUnsafe = null;
                return;
              }
              (j._Buffer_from =
                (q.from !== Uint8Array.from && q.from) ||
                function (H, G) {
                  return new q(H, G);
                }),
                (j._Buffer_allocUnsafe =
                  q.allocUnsafe ||
                  function (H) {
                    return new q(H);
                  });
            });
        })(minimal)),
      minimal
    );
  }
  var writer, hasRequiredWriter;
  function requireWriter() {
    if (hasRequiredWriter) return writer;
    (hasRequiredWriter = 1), (writer = Y);
    var U = requireMinimal(),
      j,
      V = U.LongBits,
      B = U.base64,
      q = U.utf8;
    function $(fe, ce, ue) {
      (this.fn = fe), (this.len = ce), (this.next = void 0), (this.val = ue);
    }
    function H() {}
    function G(fe) {
      (this.head = fe.head),
        (this.tail = fe.tail),
        (this.len = fe.len),
        (this.next = fe.states);
    }
    function Y() {
      (this.len = 0),
        (this.head = new $(H, 0, 0)),
        (this.tail = this.head),
        (this.states = null);
    }
    var Q = function () {
      return U.Buffer
        ? function () {
            return (Y.create = function () {
              return new j();
            })();
          }
        : function () {
            return new Y();
          };
    };
    (Y.create = Q()),
      (Y.alloc = function (ce) {
        return new U.Array(ce);
      }),
      U.Array !== Array &&
        (Y.alloc = U.pool(Y.alloc, U.Array.prototype.subarray)),
      (Y.prototype._push = function (ce, ue, he) {
        return (
          (this.tail = this.tail.next = new $(ce, ue, he)),
          (this.len += ue),
          this
        );
      });
    function X(fe, ce, ue) {
      ce[ue] = fe & 255;
    }
    function Z(fe, ce, ue) {
      for (; fe > 127; ) (ce[ue++] = (fe & 127) | 128), (fe >>>= 7);
      ce[ue] = fe;
    }
    function te(fe, ce) {
      (this.len = fe), (this.next = void 0), (this.val = ce);
    }
    (te.prototype = Object.create($.prototype)),
      (te.prototype.fn = Z),
      (Y.prototype.uint32 = function (ce) {
        return (
          (this.len += (this.tail = this.tail.next =
            new te(
              (ce = ce >>> 0) < 128
                ? 1
                : ce < 16384
                ? 2
                : ce < 2097152
                ? 3
                : ce < 268435456
                ? 4
                : 5,
              ce
            )).len),
          this
        );
      }),
      (Y.prototype.int32 = function (ce) {
        return ce < 0 ? this._push(ne, 10, V.fromNumber(ce)) : this.uint32(ce);
      }),
      (Y.prototype.sint32 = function (ce) {
        return this.uint32(((ce << 1) ^ (ce >> 31)) >>> 0);
      });
    function ne(fe, ce, ue) {
      for (; fe.hi; )
        (ce[ue++] = (fe.lo & 127) | 128),
          (fe.lo = ((fe.lo >>> 7) | (fe.hi << 25)) >>> 0),
          (fe.hi >>>= 7);
      for (; fe.lo > 127; )
        (ce[ue++] = (fe.lo & 127) | 128), (fe.lo = fe.lo >>> 7);
      ce[ue++] = fe.lo;
    }
    (Y.prototype.uint64 = function (ce) {
      var ue = V.from(ce);
      return this._push(ne, ue.length(), ue);
    }),
      (Y.prototype.int64 = Y.prototype.uint64),
      (Y.prototype.sint64 = function (ce) {
        var ue = V.from(ce).zzEncode();
        return this._push(ne, ue.length(), ue);
      }),
      (Y.prototype.bool = function (ce) {
        return this._push(X, 1, ce ? 1 : 0);
      });
    function ae(fe, ce, ue) {
      (ce[ue] = fe & 255),
        (ce[ue + 1] = (fe >>> 8) & 255),
        (ce[ue + 2] = (fe >>> 16) & 255),
        (ce[ue + 3] = fe >>> 24);
    }
    (Y.prototype.fixed32 = function (ce) {
      return this._push(ae, 4, ce >>> 0);
    }),
      (Y.prototype.sfixed32 = Y.prototype.fixed32),
      (Y.prototype.fixed64 = function (ce) {
        var ue = V.from(ce);
        return this._push(ae, 4, ue.lo)._push(ae, 4, ue.hi);
      }),
      (Y.prototype.sfixed64 = Y.prototype.fixed64),
      (Y.prototype.float = function (ce) {
        return this._push(U.float.writeFloatLE, 4, ce);
      }),
      (Y.prototype.double = function (ce) {
        return this._push(U.float.writeDoubleLE, 8, ce);
      });
    var se = U.Array.prototype.set
      ? function (ce, ue, he) {
          ue.set(ce, he);
        }
      : function (ce, ue, he) {
          for (var me = 0; me < ce.length; ++me) ue[he + me] = ce[me];
        };
    return (
      (Y.prototype.bytes = function (ce) {
        var ue = ce.length >>> 0;
        if (!ue) return this._push(X, 1, 0);
        if (U.isString(ce)) {
          var he = Y.alloc((ue = B.length(ce)));
          B.decode(ce, he, 0), (ce = he);
        }
        return this.uint32(ue)._push(se, ue, ce);
      }),
      (Y.prototype.string = function (ce) {
        var ue = q.length(ce);
        return ue
          ? this.uint32(ue)._push(q.write, ue, ce)
          : this._push(X, 1, 0);
      }),
      (Y.prototype.fork = function () {
        return (
          (this.states = new G(this)),
          (this.head = this.tail = new $(H, 0, 0)),
          (this.len = 0),
          this
        );
      }),
      (Y.prototype.reset = function () {
        return (
          this.states
            ? ((this.head = this.states.head),
              (this.tail = this.states.tail),
              (this.len = this.states.len),
              (this.states = this.states.next))
            : ((this.head = this.tail = new $(H, 0, 0)), (this.len = 0)),
          this
        );
      }),
      (Y.prototype.ldelim = function () {
        var ce = this.head,
          ue = this.tail,
          he = this.len;
        return (
          this.reset().uint32(he),
          he &&
            ((this.tail.next = ce.next), (this.tail = ue), (this.len += he)),
          this
        );
      }),
      (Y.prototype.finish = function () {
        for (
          var ce = this.head.next,
            ue = this.constructor.alloc(this.len),
            he = 0;
          ce;

        )
          ce.fn(ce.val, ue, he), (he += ce.len), (ce = ce.next);
        return ue;
      }),
      (Y._configure = function (fe) {
        (j = fe), (Y.create = Q()), j._configure();
      }),
      writer
    );
  }
  var writer_buffer, hasRequiredWriter_buffer;
  function requireWriter_buffer() {
    if (hasRequiredWriter_buffer) return writer_buffer;
    (hasRequiredWriter_buffer = 1), (writer_buffer = V);
    var U = requireWriter();
    (V.prototype = Object.create(U.prototype)).constructor = V;
    var j = requireMinimal();
    function V() {
      U.call(this);
    }
    (V._configure = function () {
      (V.alloc = j._Buffer_allocUnsafe),
        (V.writeBytesBuffer =
          j.Buffer &&
          j.Buffer.prototype instanceof Uint8Array &&
          j.Buffer.prototype.set.name === "set"
            ? function ($, H, G) {
                H.set($, G);
              }
            : function ($, H, G) {
                if ($.copy) $.copy(H, G, 0, $.length);
                else for (var Y = 0; Y < $.length; ) H[G++] = $[Y++];
              });
    }),
      (V.prototype.bytes = function ($) {
        j.isString($) && ($ = j._Buffer_from($, "base64"));
        var H = $.length >>> 0;
        return this.uint32(H), H && this._push(V.writeBytesBuffer, H, $), this;
      });
    function B(q, $, H) {
      q.length < 40
        ? j.utf8.write(q, $, H)
        : $.utf8Write
        ? $.utf8Write(q, H)
        : $.write(q, H);
    }
    return (
      (V.prototype.string = function ($) {
        var H = j.Buffer.byteLength($);
        return this.uint32(H), H && this._push(B, H, $), this;
      }),
      V._configure(),
      writer_buffer
    );
  }
  var reader, hasRequiredReader;
  function requireReader() {
    if (hasRequiredReader) return reader;
    (hasRequiredReader = 1), (reader = $);
    var U = requireMinimal(),
      j,
      V = U.LongBits,
      B = U.utf8;
    function q(Z, te) {
      return RangeError(
        "index out of range: " + Z.pos + " + " + (te || 1) + " > " + Z.len
      );
    }
    function $(Z) {
      (this.buf = Z), (this.pos = 0), (this.len = Z.length);
    }
    var H =
        typeof Uint8Array < "u"
          ? function (te) {
              if (te instanceof Uint8Array || Array.isArray(te))
                return new $(te);
              throw Error("illegal buffer");
            }
          : function (te) {
              if (Array.isArray(te)) return new $(te);
              throw Error("illegal buffer");
            },
      G = function () {
        return U.Buffer
          ? function (ne) {
              return ($.create = function (se) {
                return U.Buffer.isBuffer(se) ? new j(se) : H(se);
              })(ne);
            }
          : H;
      };
    ($.create = G()),
      ($.prototype._slice =
        U.Array.prototype.subarray || U.Array.prototype.slice),
      ($.prototype.uint32 = (function () {
        var te = 4294967295;
        return function () {
          if (
            ((te = (this.buf[this.pos] & 127) >>> 0),
            this.buf[this.pos++] < 128 ||
              ((te = (te | ((this.buf[this.pos] & 127) << 7)) >>> 0),
              this.buf[this.pos++] < 128) ||
              ((te = (te | ((this.buf[this.pos] & 127) << 14)) >>> 0),
              this.buf[this.pos++] < 128) ||
              ((te = (te | ((this.buf[this.pos] & 127) << 21)) >>> 0),
              this.buf[this.pos++] < 128) ||
              ((te = (te | ((this.buf[this.pos] & 15) << 28)) >>> 0),
              this.buf[this.pos++] < 128))
          )
            return te;
          if ((this.pos += 5) > this.len)
            throw ((this.pos = this.len), q(this, 10));
          return te;
        };
      })()),
      ($.prototype.int32 = function () {
        return this.uint32() | 0;
      }),
      ($.prototype.sint32 = function () {
        var te = this.uint32();
        return ((te >>> 1) ^ -(te & 1)) | 0;
      });
    function Y() {
      var Z = new V(0, 0),
        te = 0;
      if (this.len - this.pos > 4) {
        for (; te < 4; ++te)
          if (
            ((Z.lo = (Z.lo | ((this.buf[this.pos] & 127) << (te * 7))) >>> 0),
            this.buf[this.pos++] < 128)
          )
            return Z;
        if (
          ((Z.lo = (Z.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0),
          (Z.hi = (Z.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0),
          this.buf[this.pos++] < 128)
        )
          return Z;
        te = 0;
      } else {
        for (; te < 3; ++te) {
          if (this.pos >= this.len) throw q(this);
          if (
            ((Z.lo = (Z.lo | ((this.buf[this.pos] & 127) << (te * 7))) >>> 0),
            this.buf[this.pos++] < 128)
          )
            return Z;
        }
        return (
          (Z.lo = (Z.lo | ((this.buf[this.pos++] & 127) << (te * 7))) >>> 0), Z
        );
      }
      if (this.len - this.pos > 4) {
        for (; te < 5; ++te)
          if (
            ((Z.hi =
              (Z.hi | ((this.buf[this.pos] & 127) << (te * 7 + 3))) >>> 0),
            this.buf[this.pos++] < 128)
          )
            return Z;
      } else
        for (; te < 5; ++te) {
          if (this.pos >= this.len) throw q(this);
          if (
            ((Z.hi =
              (Z.hi | ((this.buf[this.pos] & 127) << (te * 7 + 3))) >>> 0),
            this.buf[this.pos++] < 128)
          )
            return Z;
        }
      throw Error("invalid varint encoding");
    }
    $.prototype.bool = function () {
      return this.uint32() !== 0;
    };
    function Q(Z, te) {
      return (
        (Z[te - 4] |
          (Z[te - 3] << 8) |
          (Z[te - 2] << 16) |
          (Z[te - 1] << 24)) >>>
        0
      );
    }
    ($.prototype.fixed32 = function () {
      if (this.pos + 4 > this.len) throw q(this, 4);
      return Q(this.buf, (this.pos += 4));
    }),
      ($.prototype.sfixed32 = function () {
        if (this.pos + 4 > this.len) throw q(this, 4);
        return Q(this.buf, (this.pos += 4)) | 0;
      });
    function X() {
      if (this.pos + 8 > this.len) throw q(this, 8);
      return new V(Q(this.buf, (this.pos += 4)), Q(this.buf, (this.pos += 4)));
    }
    return (
      ($.prototype.float = function () {
        if (this.pos + 4 > this.len) throw q(this, 4);
        var te = U.float.readFloatLE(this.buf, this.pos);
        return (this.pos += 4), te;
      }),
      ($.prototype.double = function () {
        if (this.pos + 8 > this.len) throw q(this, 4);
        var te = U.float.readDoubleLE(this.buf, this.pos);
        return (this.pos += 8), te;
      }),
      ($.prototype.bytes = function () {
        var te = this.uint32(),
          ne = this.pos,
          ae = this.pos + te;
        if (ae > this.len) throw q(this, te);
        if (((this.pos += te), Array.isArray(this.buf)))
          return this.buf.slice(ne, ae);
        if (ne === ae) {
          var se = U.Buffer;
          return se ? se.alloc(0) : new this.buf.constructor(0);
        }
        return this._slice.call(this.buf, ne, ae);
      }),
      ($.prototype.string = function () {
        var te = this.bytes();
        return B.read(te, 0, te.length);
      }),
      ($.prototype.skip = function (te) {
        if (typeof te == "number") {
          if (this.pos + te > this.len) throw q(this, te);
          this.pos += te;
        } else
          do if (this.pos >= this.len) throw q(this);
          while (this.buf[this.pos++] & 128);
        return this;
      }),
      ($.prototype.skipType = function (Z) {
        switch (Z) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            for (; (Z = this.uint32() & 7) !== 4; ) this.skipType(Z);
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + Z + " at offset " + this.pos);
        }
        return this;
      }),
      ($._configure = function (Z) {
        (j = Z), ($.create = G()), j._configure();
        var te = U.Long ? "toLong" : "toNumber";
        U.merge($.prototype, {
          int64: function () {
            return Y.call(this)[te](!1);
          },
          uint64: function () {
            return Y.call(this)[te](!0);
          },
          sint64: function () {
            return Y.call(this).zzDecode()[te](!1);
          },
          fixed64: function () {
            return X.call(this)[te](!0);
          },
          sfixed64: function () {
            return X.call(this)[te](!1);
          },
        });
      }),
      reader
    );
  }
  var reader_buffer, hasRequiredReader_buffer;
  function requireReader_buffer() {
    if (hasRequiredReader_buffer) return reader_buffer;
    (hasRequiredReader_buffer = 1), (reader_buffer = V);
    var U = requireReader();
    (V.prototype = Object.create(U.prototype)).constructor = V;
    var j = requireMinimal();
    function V(B) {
      U.call(this, B);
    }
    return (
      (V._configure = function () {
        j.Buffer && (V.prototype._slice = j.Buffer.prototype.slice);
      }),
      (V.prototype.string = function () {
        var q = this.uint32();
        return this.buf.utf8Slice
          ? this.buf.utf8Slice(
              this.pos,
              (this.pos = Math.min(this.pos + q, this.len))
            )
          : this.buf.toString(
              "utf-8",
              this.pos,
              (this.pos = Math.min(this.pos + q, this.len))
            );
      }),
      V._configure(),
      reader_buffer
    );
  }
  var rpc = {},
    service$1,
    hasRequiredService$1;
  function requireService$1() {
    if (hasRequiredService$1) return service$1;
    (hasRequiredService$1 = 1), (service$1 = j);
    var U = requireMinimal();
    (j.prototype = Object.create(U.EventEmitter.prototype)).constructor = j;
    function j(V, B, q) {
      if (typeof V != "function") throw TypeError("rpcImpl must be a function");
      U.EventEmitter.call(this),
        (this.rpcImpl = V),
        (this.requestDelimited = !!B),
        (this.responseDelimited = !!q);
    }
    return (
      (j.prototype.rpcCall = function V(B, q, $, H, G) {
        if (!H) throw TypeError("request must be specified");
        var Y = this;
        if (!G) return U.asPromise(V, Y, B, q, $, H);
        if (!Y.rpcImpl) {
          setTimeout(function () {
            G(Error("already ended"));
          }, 0);
          return;
        }
        try {
          return Y.rpcImpl(
            B,
            q[Y.requestDelimited ? "encodeDelimited" : "encode"](H).finish(),
            function (X, Z) {
              if (X) return Y.emit("error", X, B), G(X);
              if (Z === null) {
                Y.end(!0);
                return;
              }
              if (!(Z instanceof $))
                try {
                  Z = $[Y.responseDelimited ? "decodeDelimited" : "decode"](Z);
                } catch (te) {
                  return Y.emit("error", te, B), G(te);
                }
              return Y.emit("data", Z, B), G(null, Z);
            }
          );
        } catch (Q) {
          Y.emit("error", Q, B),
            setTimeout(function () {
              G(Q);
            }, 0);
          return;
        }
      }),
      (j.prototype.end = function (B) {
        return (
          this.rpcImpl &&
            (B || this.rpcImpl(null, null, null),
            (this.rpcImpl = null),
            this.emit("end").off()),
          this
        );
      }),
      service$1
    );
  }
  var hasRequiredRpc;
  function requireRpc() {
    return (
      hasRequiredRpc ||
        ((hasRequiredRpc = 1),
        (function (U) {
          var j = U;
          j.Service = requireService$1();
        })(rpc)),
      rpc
    );
  }
  var roots, hasRequiredRoots;
  function requireRoots() {
    return hasRequiredRoots || ((hasRequiredRoots = 1), (roots = {})), roots;
  }
  var hasRequiredIndexMinimal;
  function requireIndexMinimal() {
    return (
      hasRequiredIndexMinimal ||
        ((hasRequiredIndexMinimal = 1),
        (function (U) {
          var j = U;
          (j.build = "minimal"),
            (j.Writer = requireWriter()),
            (j.BufferWriter = requireWriter_buffer()),
            (j.Reader = requireReader()),
            (j.BufferReader = requireReader_buffer()),
            (j.util = requireMinimal()),
            (j.rpc = requireRpc()),
            (j.roots = requireRoots()),
            (j.configure = V);
          function V() {
            j.util._configure(),
              j.Writer._configure(j.BufferWriter),
              j.Reader._configure(j.BufferReader);
          }
          V();
        })(indexMinimal)),
      indexMinimal
    );
  }
  var types$1 = {},
    util = { exports: {} },
    codegen_1,
    hasRequiredCodegen;
  function requireCodegen() {
    if (hasRequiredCodegen) return codegen_1;
    (hasRequiredCodegen = 1), (codegen_1 = U);
    function U(j, V) {
      typeof j == "string" && ((V = j), (j = void 0));
      var B = [];
      function q(H) {
        if (typeof H != "string") {
          var G = $();
          if (
            (U.verbose && console.log("codegen: " + G), (G = "return " + G), H)
          ) {
            for (
              var Y = Object.keys(H),
                Q = new Array(Y.length + 1),
                X = new Array(Y.length),
                Z = 0;
              Z < Y.length;

            )
              (Q[Z] = Y[Z]), (X[Z] = H[Y[Z++]]);
            return (Q[Z] = G), Function.apply(null, Q).apply(null, X);
          }
          return Function(G)();
        }
        for (var te = new Array(arguments.length - 1), ne = 0; ne < te.length; )
          te[ne] = arguments[++ne];
        if (
          ((ne = 0),
          (H = H.replace(/%([%dfijs])/g, function (se, fe) {
            var ce = te[ne++];
            switch (fe) {
              case "d":
              case "f":
                return String(Number(ce));
              case "i":
                return String(Math.floor(ce));
              case "j":
                return JSON.stringify(ce);
              case "s":
                return String(ce);
            }
            return "%";
          })),
          ne !== te.length)
        )
          throw Error("parameter count mismatch");
        return B.push(H), q;
      }
      function $(H) {
        return (
          "function " +
          (H || V || "") +
          "(" +
          ((j && j.join(",")) || "") +
          `){
  ` +
          B.join(`
  `) +
          `
}`
        );
      }
      return (q.toString = $), q;
    }
    return (U.verbose = !1), codegen_1;
  }
  var fetch_1, hasRequiredFetch;
  function requireFetch() {
    if (hasRequiredFetch) return fetch_1;
    (hasRequiredFetch = 1), (fetch_1 = B);
    var U = requireAspromise(),
      j = requireInquire(),
      V = j("fs");
    function B(q, $, H) {
      return (
        typeof $ == "function" ? ((H = $), ($ = {})) : $ || ($ = {}),
        H
          ? !$.xhr && V && V.readFile
            ? V.readFile(q, function (Y, Q) {
                return Y && typeof XMLHttpRequest < "u"
                  ? B.xhr(q, $, H)
                  : Y
                  ? H(Y)
                  : H(null, $.binary ? Q : Q.toString("utf8"));
              })
            : B.xhr(q, $, H)
          : U(B, this, q, $)
      );
    }
    return (
      (B.xhr = function ($, H, G) {
        var Y = new XMLHttpRequest();
        (Y.onreadystatechange = function () {
          if (Y.readyState === 4) {
            if (Y.status !== 0 && Y.status !== 200)
              return G(Error("status " + Y.status));
            if (H.binary) {
              var X = Y.response;
              if (!X) {
                X = [];
                for (var Z = 0; Z < Y.responseText.length; ++Z)
                  X.push(Y.responseText.charCodeAt(Z) & 255);
              }
              return G(null, typeof Uint8Array < "u" ? new Uint8Array(X) : X);
            }
            return G(null, Y.responseText);
          }
        }),
          H.binary &&
            ("overrideMimeType" in Y &&
              Y.overrideMimeType("text/plain; charset=x-user-defined"),
            (Y.responseType = "arraybuffer")),
          Y.open("GET", $),
          Y.send();
      }),
      fetch_1
    );
  }
  var path = {},
    hasRequiredPath;
  function requirePath() {
    return (
      hasRequiredPath ||
        ((hasRequiredPath = 1),
        (function (U) {
          var j = U,
            V = (j.isAbsolute = function ($) {
              return /^(?:\/|\w+:)/.test($);
            }),
            B = (j.normalize = function ($) {
              $ = $.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
              var H = $.split("/"),
                G = V($),
                Y = "";
              G && (Y = H.shift() + "/");
              for (var Q = 0; Q < H.length; )
                H[Q] === ".."
                  ? Q > 0 && H[Q - 1] !== ".."
                    ? H.splice(--Q, 2)
                    : G
                    ? H.splice(Q, 1)
                    : ++Q
                  : H[Q] === "."
                  ? H.splice(Q, 1)
                  : ++Q;
              return Y + H.join("/");
            });
          j.resolve = function ($, H, G) {
            return (
              G || (H = B(H)),
              V(H)
                ? H
                : (G || ($ = B($)),
                  ($ = $.replace(/(?:\/|^)[^/]+$/, "")).length
                    ? B($ + "/" + H)
                    : H)
            );
          };
        })(path)),
      path
    );
  }
  var namespace, hasRequiredNamespace;
  function requireNamespace() {
    if (hasRequiredNamespace) return namespace;
    (hasRequiredNamespace = 1), (namespace = Y);
    var U = requireObject();
    ((Y.prototype = Object.create(U.prototype)).constructor = Y).className =
      "Namespace";
    var j = requireField(),
      V = requireUtil(),
      B = requireOneof(),
      q,
      $,
      H;
    Y.fromJSON = function (Z, te) {
      return new Y(Z, te.options).addJSON(te.nested);
    };
    function G(X, Z) {
      if (X && X.length) {
        for (var te = {}, ne = 0; ne < X.length; ++ne)
          te[X[ne].name] = X[ne].toJSON(Z);
        return te;
      }
    }
    (Y.arrayToJSON = G),
      (Y.isReservedId = function (Z, te) {
        if (Z) {
          for (var ne = 0; ne < Z.length; ++ne)
            if (typeof Z[ne] != "string" && Z[ne][0] <= te && Z[ne][1] > te)
              return !0;
        }
        return !1;
      }),
      (Y.isReservedName = function (Z, te) {
        if (Z) {
          for (var ne = 0; ne < Z.length; ++ne) if (Z[ne] === te) return !0;
        }
        return !1;
      });
    function Y(X, Z) {
      U.call(this, X, Z),
        (this.nested = void 0),
        (this._nestedArray = null),
        (this._lookupCache = {}),
        (this._needsRecursiveFeatureResolution = !0),
        (this._needsRecursiveResolve = !0);
    }
    function Q(X) {
      (X._nestedArray = null), (X._lookupCache = {});
      for (var Z = X; (Z = Z.parent); ) Z._lookupCache = {};
      return X;
    }
    return (
      Object.defineProperty(Y.prototype, "nestedArray", {
        get: function () {
          return (
            this._nestedArray || (this._nestedArray = V.toArray(this.nested))
          );
        },
      }),
      (Y.prototype.toJSON = function (Z) {
        return V.toObject([
          "options",
          this.options,
          "nested",
          G(this.nestedArray, Z),
        ]);
      }),
      (Y.prototype.addJSON = function (Z) {
        var te = this;
        if (Z)
          for (var ne = Object.keys(Z), ae = 0, se; ae < ne.length; ++ae)
            (se = Z[ne[ae]]),
              te.add(
                (se.fields !== void 0
                  ? q.fromJSON
                  : se.values !== void 0
                  ? H.fromJSON
                  : se.methods !== void 0
                  ? $.fromJSON
                  : se.id !== void 0
                  ? j.fromJSON
                  : Y.fromJSON)(ne[ae], se)
              );
        return this;
      }),
      (Y.prototype.get = function (Z) {
        return (this.nested && this.nested[Z]) || null;
      }),
      (Y.prototype.getEnum = function (Z) {
        if (this.nested && this.nested[Z] instanceof H)
          return this.nested[Z].values;
        throw Error("no such enum: " + Z);
      }),
      (Y.prototype.add = function (Z) {
        if (
          !(
            (Z instanceof j && Z.extend !== void 0) ||
            Z instanceof q ||
            Z instanceof B ||
            Z instanceof H ||
            Z instanceof $ ||
            Z instanceof Y
          )
        )
          throw TypeError("object must be a valid nested object");
        if (!this.nested) this.nested = {};
        else {
          var te = this.get(Z.name);
          if (te)
            if (
              te instanceof Y &&
              Z instanceof Y &&
              !(te instanceof q || te instanceof $)
            ) {
              for (var ne = te.nestedArray, ae = 0; ae < ne.length; ++ae)
                Z.add(ne[ae]);
              this.remove(te),
                this.nested || (this.nested = {}),
                Z.setOptions(te.options, !0);
            } else throw Error("duplicate name '" + Z.name + "' in " + this);
        }
        (this.nested[Z.name] = Z),
          this instanceof q ||
            this instanceof $ ||
            this instanceof H ||
            this instanceof j ||
            Z._edition ||
            (Z._edition = Z._defaultEdition),
          (this._needsRecursiveFeatureResolution = !0),
          (this._needsRecursiveResolve = !0);
        for (var se = this; (se = se.parent); )
          (se._needsRecursiveFeatureResolution = !0),
            (se._needsRecursiveResolve = !0);
        return Z.onAdd(this), Q(this);
      }),
      (Y.prototype.remove = function (Z) {
        if (!(Z instanceof U))
          throw TypeError("object must be a ReflectionObject");
        if (Z.parent !== this) throw Error(Z + " is not a member of " + this);
        return (
          delete this.nested[Z.name],
          Object.keys(this.nested).length || (this.nested = void 0),
          Z.onRemove(this),
          Q(this)
        );
      }),
      (Y.prototype.define = function (Z, te) {
        if (V.isString(Z)) Z = Z.split(".");
        else if (!Array.isArray(Z)) throw TypeError("illegal path");
        if (Z && Z.length && Z[0] === "") throw Error("path must be relative");
        for (var ne = this; Z.length > 0; ) {
          var ae = Z.shift();
          if (ne.nested && ne.nested[ae]) {
            if (((ne = ne.nested[ae]), !(ne instanceof Y)))
              throw Error("path conflicts with non-namespace objects");
          } else ne.add((ne = new Y(ae)));
        }
        return te && ne.addJSON(te), ne;
      }),
      (Y.prototype.resolveAll = function () {
        if (!this._needsRecursiveResolve) return this;
        this._resolveFeaturesRecursive(this._edition);
        var Z = this.nestedArray,
          te = 0;
        for (this.resolve(); te < Z.length; )
          Z[te] instanceof Y ? Z[te++].resolveAll() : Z[te++].resolve();
        return (this._needsRecursiveResolve = !1), this;
      }),
      (Y.prototype._resolveFeaturesRecursive = function (Z) {
        return this._needsRecursiveFeatureResolution
          ? ((this._needsRecursiveFeatureResolution = !1),
            (Z = this._edition || Z),
            U.prototype._resolveFeaturesRecursive.call(this, Z),
            this.nestedArray.forEach((te) => {
              te._resolveFeaturesRecursive(Z);
            }),
            this)
          : this;
      }),
      (Y.prototype.lookup = function (Z, te, ne) {
        if (
          (typeof te == "boolean"
            ? ((ne = te), (te = void 0))
            : te && !Array.isArray(te) && (te = [te]),
          V.isString(Z) && Z.length)
        ) {
          if (Z === ".") return this.root;
          Z = Z.split(".");
        } else if (!Z.length) return this;
        var ae = Z.join(".");
        if (Z[0] === "") return this.root.lookup(Z.slice(1), te);
        var se =
          this.root._fullyQualifiedObjects &&
          this.root._fullyQualifiedObjects["." + ae];
        if (
          (se && (!te || te.indexOf(se.constructor) > -1)) ||
          ((se = this._lookupImpl(Z, ae)),
          se && (!te || te.indexOf(se.constructor) > -1))
        )
          return se;
        if (ne) return null;
        for (var fe = this; fe.parent; ) {
          if (
            ((se = fe.parent._lookupImpl(Z, ae)),
            se && (!te || te.indexOf(se.constructor) > -1))
          )
            return se;
          fe = fe.parent;
        }
        return null;
      }),
      (Y.prototype._lookupImpl = function (Z, te) {
        if (Object.prototype.hasOwnProperty.call(this._lookupCache, te))
          return this._lookupCache[te];
        var ne = this.get(Z[0]),
          ae = null;
        if (ne)
          Z.length === 1
            ? (ae = ne)
            : ne instanceof Y &&
              ((Z = Z.slice(1)), (ae = ne._lookupImpl(Z, Z.join("."))));
        else
          for (var se = 0; se < this.nestedArray.length; ++se)
            this._nestedArray[se] instanceof Y &&
              (ne = this._nestedArray[se]._lookupImpl(Z, te)) &&
              (ae = ne);
        return (this._lookupCache[te] = ae), ae;
      }),
      (Y.prototype.lookupType = function (Z) {
        var te = this.lookup(Z, [q]);
        if (!te) throw Error("no such type: " + Z);
        return te;
      }),
      (Y.prototype.lookupEnum = function (Z) {
        var te = this.lookup(Z, [H]);
        if (!te) throw Error("no such Enum '" + Z + "' in " + this);
        return te;
      }),
      (Y.prototype.lookupTypeOrEnum = function (Z) {
        var te = this.lookup(Z, [q, H]);
        if (!te) throw Error("no such Type or Enum '" + Z + "' in " + this);
        return te;
      }),
      (Y.prototype.lookupService = function (Z) {
        var te = this.lookup(Z, [$]);
        if (!te) throw Error("no such Service '" + Z + "' in " + this);
        return te;
      }),
      (Y._configure = function (X, Z, te) {
        (q = X), ($ = Z), (H = te);
      }),
      namespace
    );
  }
  var mapfield, hasRequiredMapfield;
  function requireMapfield() {
    if (hasRequiredMapfield) return mapfield;
    (hasRequiredMapfield = 1), (mapfield = B);
    var U = requireField();
    ((B.prototype = Object.create(U.prototype)).constructor = B).className =
      "MapField";
    var j = requireTypes(),
      V = requireUtil();
    function B(q, $, H, G, Y, Q) {
      if ((U.call(this, q, $, G, void 0, void 0, Y, Q), !V.isString(H)))
        throw TypeError("keyType must be a string");
      (this.keyType = H), (this.resolvedKeyType = null), (this.map = !0);
    }
    return (
      (B.fromJSON = function ($, H) {
        return new B($, H.id, H.keyType, H.type, H.options, H.comment);
      }),
      (B.prototype.toJSON = function ($) {
        var H = $ ? !!$.keepComments : !1;
        return V.toObject([
          "keyType",
          this.keyType,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          H ? this.comment : void 0,
        ]);
      }),
      (B.prototype.resolve = function () {
        if (this.resolved) return this;
        if (j.mapKey[this.keyType] === void 0)
          throw Error("invalid key type: " + this.keyType);
        return U.prototype.resolve.call(this);
      }),
      (B.d = function ($, H, G) {
        return (
          typeof G == "function"
            ? (G = V.decorateType(G).name)
            : G && typeof G == "object" && (G = V.decorateEnum(G).name),
          function (Q, X) {
            V.decorateType(Q.constructor).add(new B(X, $, H, G));
          }
        );
      }),
      mapfield
    );
  }
  var method, hasRequiredMethod;
  function requireMethod() {
    if (hasRequiredMethod) return method;
    (hasRequiredMethod = 1), (method = V);
    var U = requireObject();
    ((V.prototype = Object.create(U.prototype)).constructor = V).className =
      "Method";
    var j = requireUtil();
    function V(B, q, $, H, G, Y, Q, X, Z) {
      if (
        (j.isObject(G)
          ? ((Q = G), (G = Y = void 0))
          : j.isObject(Y) && ((Q = Y), (Y = void 0)),
        !(q === void 0 || j.isString(q)))
      )
        throw TypeError("type must be a string");
      if (!j.isString($)) throw TypeError("requestType must be a string");
      if (!j.isString(H)) throw TypeError("responseType must be a string");
      U.call(this, B, Q),
        (this.type = q || "rpc"),
        (this.requestType = $),
        (this.requestStream = G ? !0 : void 0),
        (this.responseType = H),
        (this.responseStream = Y ? !0 : void 0),
        (this.resolvedRequestType = null),
        (this.resolvedResponseType = null),
        (this.comment = X),
        (this.parsedOptions = Z);
    }
    return (
      (V.fromJSON = function (q, $) {
        return new V(
          q,
          $.type,
          $.requestType,
          $.responseType,
          $.requestStream,
          $.responseStream,
          $.options,
          $.comment,
          $.parsedOptions
        );
      }),
      (V.prototype.toJSON = function (q) {
        var $ = q ? !!q.keepComments : !1;
        return j.toObject([
          "type",
          (this.type !== "rpc" && this.type) || void 0,
          "requestType",
          this.requestType,
          "requestStream",
          this.requestStream,
          "responseType",
          this.responseType,
          "responseStream",
          this.responseStream,
          "options",
          this.options,
          "comment",
          $ ? this.comment : void 0,
          "parsedOptions",
          this.parsedOptions,
        ]);
      }),
      (V.prototype.resolve = function () {
        return this.resolved
          ? this
          : ((this.resolvedRequestType = this.parent.lookupType(
              this.requestType
            )),
            (this.resolvedResponseType = this.parent.lookupType(
              this.responseType
            )),
            U.prototype.resolve.call(this));
      }),
      method
    );
  }
  var service, hasRequiredService;
  function requireService() {
    if (hasRequiredService) return service;
    (hasRequiredService = 1), (service = q);
    var U = requireNamespace();
    ((q.prototype = Object.create(U.prototype)).constructor = q).className =
      "Service";
    var j = requireMethod(),
      V = requireUtil(),
      B = requireRpc();
    function q(H, G) {
      U.call(this, H, G), (this.methods = {}), (this._methodsArray = null);
    }
    (q.fromJSON = function (G, Y) {
      var Q = new q(G, Y.options);
      if (Y.methods)
        for (var X = Object.keys(Y.methods), Z = 0; Z < X.length; ++Z)
          Q.add(j.fromJSON(X[Z], Y.methods[X[Z]]));
      return (
        Y.nested && Q.addJSON(Y.nested),
        Y.edition && (Q._edition = Y.edition),
        (Q.comment = Y.comment),
        (Q._defaultEdition = "proto3"),
        Q
      );
    }),
      (q.prototype.toJSON = function (G) {
        var Y = U.prototype.toJSON.call(this, G),
          Q = G ? !!G.keepComments : !1;
        return V.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          (Y && Y.options) || void 0,
          "methods",
          U.arrayToJSON(this.methodsArray, G) || {},
          "nested",
          (Y && Y.nested) || void 0,
          "comment",
          Q ? this.comment : void 0,
        ]);
      }),
      Object.defineProperty(q.prototype, "methodsArray", {
        get: function () {
          return (
            this._methodsArray || (this._methodsArray = V.toArray(this.methods))
          );
        },
      });
    function $(H) {
      return (H._methodsArray = null), H;
    }
    return (
      (q.prototype.get = function (G) {
        return this.methods[G] || U.prototype.get.call(this, G);
      }),
      (q.prototype.resolveAll = function () {
        if (!this._needsRecursiveResolve) return this;
        U.prototype.resolve.call(this);
        for (var G = this.methodsArray, Y = 0; Y < G.length; ++Y)
          G[Y].resolve();
        return this;
      }),
      (q.prototype._resolveFeaturesRecursive = function (G) {
        return this._needsRecursiveFeatureResolution
          ? ((G = this._edition || G),
            U.prototype._resolveFeaturesRecursive.call(this, G),
            this.methodsArray.forEach((Y) => {
              Y._resolveFeaturesRecursive(G);
            }),
            this)
          : this;
      }),
      (q.prototype.add = function (G) {
        if (this.get(G.name))
          throw Error("duplicate name '" + G.name + "' in " + this);
        return G instanceof j
          ? ((this.methods[G.name] = G), (G.parent = this), $(this))
          : U.prototype.add.call(this, G);
      }),
      (q.prototype.remove = function (G) {
        if (G instanceof j) {
          if (this.methods[G.name] !== G)
            throw Error(G + " is not a member of " + this);
          return delete this.methods[G.name], (G.parent = null), $(this);
        }
        return U.prototype.remove.call(this, G);
      }),
      (q.prototype.create = function (G, Y, Q) {
        for (
          var X = new B.Service(G, Y, Q), Z = 0, te;
          Z < this.methodsArray.length;
          ++Z
        ) {
          var ne = V.lcFirst(
            (te = this._methodsArray[Z]).resolve().name
          ).replace(/[^$\w_]/g, "");
          X[ne] = V.codegen(
            ["r", "c"],
            V.isReserved(ne) ? ne + "_" : ne
          )("return this.rpcCall(m,q,s,r,c)")({
            m: te,
            q: te.resolvedRequestType.ctor,
            s: te.resolvedResponseType.ctor,
          });
        }
        return X;
      }),
      service
    );
  }
  var message, hasRequiredMessage;
  function requireMessage() {
    if (hasRequiredMessage) return message;
    (hasRequiredMessage = 1), (message = j);
    var U = requireMinimal();
    function j(V) {
      if (V)
        for (var B = Object.keys(V), q = 0; q < B.length; ++q)
          this[B[q]] = V[B[q]];
    }
    return (
      (j.create = function (B) {
        return this.$type.create(B);
      }),
      (j.encode = function (B, q) {
        return this.$type.encode(B, q);
      }),
      (j.encodeDelimited = function (B, q) {
        return this.$type.encodeDelimited(B, q);
      }),
      (j.decode = function (B) {
        return this.$type.decode(B);
      }),
      (j.decodeDelimited = function (B) {
        return this.$type.decodeDelimited(B);
      }),
      (j.verify = function (B) {
        return this.$type.verify(B);
      }),
      (j.fromObject = function (B) {
        return this.$type.fromObject(B);
      }),
      (j.toObject = function (B, q) {
        return this.$type.toObject(B, q);
      }),
      (j.prototype.toJSON = function () {
        return this.$type.toObject(this, U.toJSONOptions);
      }),
      message
    );
  }
  var decoder_1, hasRequiredDecoder;
  function requireDecoder() {
    if (hasRequiredDecoder) return decoder_1;
    (hasRequiredDecoder = 1), (decoder_1 = q);
    var U = require_enum(),
      j = requireTypes(),
      V = requireUtil();
    function B($) {
      return "missing required '" + $.name + "'";
    }
    function q($) {
      for (
        var H = V.codegen(
            ["r", "l", "e"],
            $.name + "$decode"
          )("if(!(r instanceof Reader))")("r=Reader.create(r)")(
            "var c=l===undefined?r.len:r.pos+l,m=new this.ctor" +
              ($.fieldsArray.filter(function (te) {
                return te.map;
              }).length
                ? ",k,value"
                : "")
          )("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")(
            "switch(t>>>3){"
          ),
          G = 0;
        G < $.fieldsArray.length;
        ++G
      ) {
        var Y = $._fieldsArray[G].resolve(),
          Q = Y.resolvedType instanceof U ? "int32" : Y.type,
          X = "m" + V.safeProp(Y.name);
        H("case %i: {", Y.id),
          Y.map
            ? (H("if(%s===util.emptyObject)", X)("%s={}", X)(
                "var c2 = r.uint32()+r.pos"
              ),
              j.defaults[Y.keyType] !== void 0
                ? H("k=%j", j.defaults[Y.keyType])
                : H("k=null"),
              j.defaults[Q] !== void 0
                ? H("value=%j", j.defaults[Q])
                : H("value=null"),
              H("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")(
                "case 1: k=r.%s(); break",
                Y.keyType
              )("case 2:"),
              j.basic[Q] === void 0
                ? H("value=types[%i].decode(r,r.uint32())", G)
                : H("value=r.%s()", Q),
              H("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"),
              j.long[Y.keyType] !== void 0
                ? H('%s[typeof k==="object"?util.longToHash(k):k]=value', X)
                : H("%s[k]=value", X))
            : Y.repeated
            ? (H("if(!(%s&&%s.length))", X, X)("%s=[]", X),
              j.packed[Q] !== void 0 &&
                H("if((t&7)===2){")("var c2=r.uint32()+r.pos")(
                  "while(r.pos<c2)"
                )(
                  "%s.push(r.%s())",
                  X,
                  Q
                )("}else"),
              j.basic[Q] === void 0
                ? H(
                    Y.delimited
                      ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))"
                      : "%s.push(types[%i].decode(r,r.uint32()))",
                    X,
                    G
                  )
                : H("%s.push(r.%s())", X, Q))
            : j.basic[Q] === void 0
            ? H(
                Y.delimited
                  ? "%s=types[%i].decode(r,undefined,((t&~7)|4))"
                  : "%s=types[%i].decode(r,r.uint32())",
                X,
                G
              )
            : H("%s=r.%s()", X, Q),
          H("break")("}");
      }
      for (
        H("default:")("r.skipType(t&7)")("break")("}")("}"), G = 0;
        G < $._fieldsArray.length;
        ++G
      ) {
        var Z = $._fieldsArray[G];
        Z.required &&
          H("if(!m.hasOwnProperty(%j))", Z.name)(
            "throw util.ProtocolError(%j,{instance:m})",
            B(Z)
          );
      }
      return H("return m");
    }
    return decoder_1;
  }
  var verifier_1, hasRequiredVerifier;
  function requireVerifier() {
    if (hasRequiredVerifier) return verifier_1;
    (hasRequiredVerifier = 1), (verifier_1 = $);
    var U = require_enum(),
      j = requireUtil();
    function V(H, G) {
      return (
        H.name +
        ": " +
        G +
        (H.repeated && G !== "array"
          ? "[]"
          : H.map && G !== "object"
          ? "{k:" + H.keyType + "}"
          : "") +
        " expected"
      );
    }
    function B(H, G, Y, Q) {
      if (G.resolvedType)
        if (G.resolvedType instanceof U) {
          H("switch(%s){", Q)("default:")("return%j", V(G, "enum value"));
          for (
            var X = Object.keys(G.resolvedType.values), Z = 0;
            Z < X.length;
            ++Z
          )
            H("case %i:", G.resolvedType.values[X[Z]]);
          H("break")("}");
        } else
          H("{")("var e=types[%i].verify(%s);", Y, Q)("if(e)")(
            "return%j+e",
            G.name + "."
          )("}");
      else
        switch (G.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            H("if(!util.isInteger(%s))", Q)("return%j", V(G, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            H(
              "if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",
              Q,
              Q,
              Q,
              Q
            )("return%j", V(G, "integer|Long"));
            break;
          case "float":
          case "double":
            H('if(typeof %s!=="number")', Q)("return%j", V(G, "number"));
            break;
          case "bool":
            H('if(typeof %s!=="boolean")', Q)("return%j", V(G, "boolean"));
            break;
          case "string":
            H("if(!util.isString(%s))", Q)("return%j", V(G, "string"));
            break;
          case "bytes":
            H(
              'if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',
              Q,
              Q,
              Q
            )("return%j", V(G, "buffer"));
            break;
        }
      return H;
    }
    function q(H, G, Y) {
      switch (G.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          H("if(!util.key32Re.test(%s))", Y)("return%j", V(G, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          H("if(!util.key64Re.test(%s))", Y)(
            "return%j",
            V(G, "integer|Long key")
          );
          break;
        case "bool":
          H("if(!util.key2Re.test(%s))", Y)("return%j", V(G, "boolean key"));
          break;
      }
      return H;
    }
    function $(H) {
      var G = j.codegen(
          ["m"],
          H.name + "$verify"
        )('if(typeof m!=="object"||m===null)')("return%j", "object expected"),
        Y = H.oneofsArray,
        Q = {};
      Y.length && G("var p={}");
      for (var X = 0; X < H.fieldsArray.length; ++X) {
        var Z = H._fieldsArray[X].resolve(),
          te = "m" + j.safeProp(Z.name);
        if (
          (Z.optional && G("if(%s!=null&&m.hasOwnProperty(%j)){", te, Z.name),
          Z.map)
        )
          G("if(!util.isObject(%s))", te)("return%j", V(Z, "object"))(
            "var k=Object.keys(%s)",
            te
          )("for(var i=0;i<k.length;++i){"),
            q(G, Z, "k[i]"),
            B(G, Z, X, te + "[k[i]]")("}");
        else if (Z.repeated)
          G("if(!Array.isArray(%s))", te)("return%j", V(Z, "array"))(
            "for(var i=0;i<%s.length;++i){",
            te
          ),
            B(G, Z, X, te + "[i]")("}");
        else {
          if (Z.partOf) {
            var ne = j.safeProp(Z.partOf.name);
            Q[Z.partOf.name] === 1 &&
              G("if(p%s===1)", ne)(
                "return%j",
                Z.partOf.name + ": multiple values"
              ),
              (Q[Z.partOf.name] = 1),
              G("p%s=1", ne);
          }
          B(G, Z, X, te);
        }
        Z.optional && G("}");
      }
      return G("return null");
    }
    return verifier_1;
  }
  var converter = {},
    hasRequiredConverter;
  function requireConverter() {
    return (
      hasRequiredConverter ||
        ((hasRequiredConverter = 1),
        (function (U) {
          var j = U,
            V = require_enum(),
            B = requireUtil();
          function q(H, G, Y, Q) {
            var X = !1;
            if (G.resolvedType)
              if (G.resolvedType instanceof V) {
                H("switch(d%s){", Q);
                for (
                  var Z = G.resolvedType.values, te = Object.keys(Z), ne = 0;
                  ne < te.length;
                  ++ne
                )
                  Z[te[ne]] === G.typeDefault &&
                    !X &&
                    (H("default:")(
                      'if(typeof(d%s)==="number"){m%s=d%s;break}',
                      Q,
                      Q,
                      Q
                    ),
                    G.repeated || H("break"),
                    (X = !0)),
                    H("case%j:", te[ne])("case %i:", Z[te[ne]])(
                      "m%s=%j",
                      Q,
                      Z[te[ne]]
                    )("break");
                H("}");
              } else
                H('if(typeof d%s!=="object")', Q)(
                  "throw TypeError(%j)",
                  G.fullName + ": object expected"
                )("m%s=types[%i].fromObject(d%s)", Q, Y, Q);
            else {
              var ae = !1;
              switch (G.type) {
                case "double":
                case "float":
                  H("m%s=Number(d%s)", Q, Q);
                  break;
                case "uint32":
                case "fixed32":
                  H("m%s=d%s>>>0", Q, Q);
                  break;
                case "int32":
                case "sint32":
                case "sfixed32":
                  H("m%s=d%s|0", Q, Q);
                  break;
                case "uint64":
                  ae = !0;
                case "int64":
                case "sint64":
                case "fixed64":
                case "sfixed64":
                  H("if(util.Long)")(
                    "(m%s=util.Long.fromValue(d%s)).unsigned=%j",
                    Q,
                    Q,
                    ae
                  )('else if(typeof d%s==="string")', Q)(
                    "m%s=parseInt(d%s,10)",
                    Q,
                    Q
                  )('else if(typeof d%s==="number")', Q)(
                    "m%s=d%s",
                    Q,
                    Q
                  )('else if(typeof d%s==="object")', Q)(
                    "m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",
                    Q,
                    Q,
                    Q,
                    ae ? "true" : ""
                  );
                  break;
                case "bytes":
                  H('if(typeof d%s==="string")', Q)(
                    "util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",
                    Q,
                    Q,
                    Q
                  )("else if(d%s.length >= 0)", Q)("m%s=d%s", Q, Q);
                  break;
                case "string":
                  H("m%s=String(d%s)", Q, Q);
                  break;
                case "bool":
                  H("m%s=Boolean(d%s)", Q, Q);
                  break;
              }
            }
            return H;
          }
          j.fromObject = function (G) {
            var Y = G.fieldsArray,
              Q = B.codegen(
                ["d"],
                G.name + "$fromObject"
              )("if(d instanceof this.ctor)")("return d");
            if (!Y.length) return Q("return new this.ctor");
            Q("var m=new this.ctor");
            for (var X = 0; X < Y.length; ++X) {
              var Z = Y[X].resolve(),
                te = B.safeProp(Z.name);
              Z.map
                ? (Q("if(d%s){", te)('if(typeof d%s!=="object")', te)(
                    "throw TypeError(%j)",
                    Z.fullName + ": object expected"
                  )("m%s={}", te)(
                    "for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",
                    te
                  ),
                  q(Q, Z, X, te + "[ks[i]]")("}")("}"))
                : Z.repeated
                ? (Q("if(d%s){", te)("if(!Array.isArray(d%s))", te)(
                    "throw TypeError(%j)",
                    Z.fullName + ": array expected"
                  )("m%s=[]", te)("for(var i=0;i<d%s.length;++i){", te),
                  q(Q, Z, X, te + "[i]")("}")("}"))
                : (Z.resolvedType instanceof V || Q("if(d%s!=null){", te),
                  q(Q, Z, X, te),
                  Z.resolvedType instanceof V || Q("}"));
            }
            return Q("return m");
          };
          function $(H, G, Y, Q) {
            if (G.resolvedType)
              G.resolvedType instanceof V
                ? H(
                    "d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",
                    Q,
                    Y,
                    Q,
                    Q,
                    Y,
                    Q,
                    Q
                  )
                : H("d%s=types[%i].toObject(m%s,o)", Q, Y, Q);
            else {
              var X = !1;
              switch (G.type) {
                case "double":
                case "float":
                  H("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", Q, Q, Q, Q);
                  break;
                case "uint64":
                  X = !0;
                case "int64":
                case "sint64":
                case "fixed64":
                case "sfixed64":
                  H('if(typeof m%s==="number")', Q)(
                    "d%s=o.longs===String?String(m%s):m%s",
                    Q,
                    Q,
                    Q
                  )("else")(
                    "d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",
                    Q,
                    Q,
                    Q,
                    Q,
                    X ? "true" : "",
                    Q
                  );
                  break;
                case "bytes":
                  H(
                    "d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",
                    Q,
                    Q,
                    Q,
                    Q,
                    Q
                  );
                  break;
                default:
                  H("d%s=m%s", Q, Q);
                  break;
              }
            }
            return H;
          }
          j.toObject = function (G) {
            var Y = G.fieldsArray.slice().sort(B.compareFieldsById);
            if (!Y.length) return B.codegen()("return {}");
            for (
              var Q = B.codegen(["m", "o"], G.name + "$toObject")("if(!o)")(
                  "o={}"
                )("var d={}"),
                X = [],
                Z = [],
                te = [],
                ne = 0;
              ne < Y.length;
              ++ne
            )
              Y[ne].partOf ||
                (Y[ne].resolve().repeated ? X : Y[ne].map ? Z : te).push(Y[ne]);
            if (X.length) {
              for (Q("if(o.arrays||o.defaults){"), ne = 0; ne < X.length; ++ne)
                Q("d%s=[]", B.safeProp(X[ne].name));
              Q("}");
            }
            if (Z.length) {
              for (Q("if(o.objects||o.defaults){"), ne = 0; ne < Z.length; ++ne)
                Q("d%s={}", B.safeProp(Z[ne].name));
              Q("}");
            }
            if (te.length) {
              for (Q("if(o.defaults){"), ne = 0; ne < te.length; ++ne) {
                var ae = te[ne],
                  se = B.safeProp(ae.name);
                if (ae.resolvedType instanceof V)
                  Q(
                    "d%s=o.enums===String?%j:%j",
                    se,
                    ae.resolvedType.valuesById[ae.typeDefault],
                    ae.typeDefault
                  );
                else if (ae.long)
                  Q("if(util.Long){")(
                    "var n=new util.Long(%i,%i,%j)",
                    ae.typeDefault.low,
                    ae.typeDefault.high,
                    ae.typeDefault.unsigned
                  )(
                    "d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",
                    se
                  )("}else")(
                    "d%s=o.longs===String?%j:%i",
                    se,
                    ae.typeDefault.toString(),
                    ae.typeDefault.toNumber()
                  );
                else if (ae.bytes) {
                  var fe =
                    "[" +
                    Array.prototype.slice.call(ae.typeDefault).join(",") +
                    "]";
                  Q(
                    "if(o.bytes===String)d%s=%j",
                    se,
                    String.fromCharCode.apply(String, ae.typeDefault)
                  )("else{")("d%s=%s", se, fe)(
                    "if(o.bytes!==Array)d%s=util.newBuffer(d%s)",
                    se,
                    se
                  )("}");
                } else Q("d%s=%j", se, ae.typeDefault);
              }
              Q("}");
            }
            var ce = !1;
            for (ne = 0; ne < Y.length; ++ne) {
              var ae = Y[ne],
                ue = G._fieldsArray.indexOf(ae),
                se = B.safeProp(ae.name);
              ae.map
                ? (ce || ((ce = !0), Q("var ks2")),
                  Q(
                    "if(m%s&&(ks2=Object.keys(m%s)).length){",
                    se,
                    se
                  )(
                    "d%s={}",
                    se
                  )("for(var j=0;j<ks2.length;++j){"),
                  $(Q, ae, ue, se + "[ks2[j]]")("}"))
                : ae.repeated
                ? (Q("if(m%s&&m%s.length){", se, se)("d%s=[]", se)(
                    "for(var j=0;j<m%s.length;++j){",
                    se
                  ),
                  $(Q, ae, ue, se + "[j]")("}"))
                : (Q("if(m%s!=null&&m.hasOwnProperty(%j)){", se, ae.name),
                  $(Q, ae, ue, se),
                  ae.partOf &&
                    Q("if(o.oneofs)")(
                      "d%s=%j",
                      B.safeProp(ae.partOf.name),
                      ae.name
                    )),
                Q("}");
            }
            return Q("return d");
          };
        })(converter)),
      converter
    );
  }
  var wrappers = {},
    hasRequiredWrappers;
  function requireWrappers() {
    return (
      hasRequiredWrappers ||
        ((hasRequiredWrappers = 1),
        (function (U) {
          var j = U,
            V = requireMessage();
          j[".google.protobuf.Any"] = {
            fromObject: function (B) {
              if (B && B["@type"]) {
                var q = B["@type"].substring(B["@type"].lastIndexOf("/") + 1),
                  $ = this.lookup(q);
                if ($) {
                  var H =
                    B["@type"].charAt(0) === "."
                      ? B["@type"].slice(1)
                      : B["@type"];
                  return (
                    H.indexOf("/") === -1 && (H = "/" + H),
                    this.create({
                      type_url: H,
                      value: $.encode($.fromObject(B)).finish(),
                    })
                  );
                }
              }
              return this.fromObject(B);
            },
            toObject: function (B, q) {
              var $ = "type.googleapis.com/",
                H = "",
                G = "";
              if (q && q.json && B.type_url && B.value) {
                (G = B.type_url.substring(B.type_url.lastIndexOf("/") + 1)),
                  (H = B.type_url.substring(
                    0,
                    B.type_url.lastIndexOf("/") + 1
                  ));
                var Y = this.lookup(G);
                Y && (B = Y.decode(B.value));
              }
              if (!(B instanceof this.ctor) && B instanceof V) {
                var Q = B.$type.toObject(B, q),
                  X =
                    B.$type.fullName[0] === "."
                      ? B.$type.fullName.slice(1)
                      : B.$type.fullName;
                return H === "" && (H = $), (G = H + X), (Q["@type"] = G), Q;
              }
              return this.toObject(B, q);
            },
          };
        })(wrappers)),
      wrappers
    );
  }
  var type, hasRequiredType;
  function requireType() {
    if (hasRequiredType) return type;
    (hasRequiredType = 1), (type = se);
    var U = requireNamespace();
    ((se.prototype = Object.create(U.prototype)).constructor = se).className =
      "Type";
    var j = require_enum(),
      V = requireOneof(),
      B = requireField(),
      q = requireMapfield(),
      $ = requireService(),
      H = requireMessage(),
      G = requireReader(),
      Y = requireWriter(),
      Q = requireUtil(),
      X = requireEncoder(),
      Z = requireDecoder(),
      te = requireVerifier(),
      ne = requireConverter(),
      ae = requireWrappers();
    function se(ce, ue) {
      U.call(this, ce, ue),
        (this.fields = {}),
        (this.oneofs = void 0),
        (this.extensions = void 0),
        (this.reserved = void 0),
        (this.group = void 0),
        (this._fieldsById = null),
        (this._fieldsArray = null),
        (this._oneofsArray = null),
        (this._ctor = null);
    }
    Object.defineProperties(se.prototype, {
      fieldsById: {
        get: function () {
          if (this._fieldsById) return this._fieldsById;
          this._fieldsById = {};
          for (
            var ce = Object.keys(this.fields), ue = 0;
            ue < ce.length;
            ++ue
          ) {
            var he = this.fields[ce[ue]],
              me = he.id;
            if (this._fieldsById[me])
              throw Error("duplicate id " + me + " in " + this);
            this._fieldsById[me] = he;
          }
          return this._fieldsById;
        },
      },
      fieldsArray: {
        get: function () {
          return (
            this._fieldsArray || (this._fieldsArray = Q.toArray(this.fields))
          );
        },
      },
      oneofsArray: {
        get: function () {
          return (
            this._oneofsArray || (this._oneofsArray = Q.toArray(this.oneofs))
          );
        },
      },
      ctor: {
        get: function () {
          return this._ctor || (this.ctor = se.generateConstructor(this)());
        },
        set: function (ce) {
          var ue = ce.prototype;
          ue instanceof H ||
            (((ce.prototype = new H()).constructor = ce),
            Q.merge(ce.prototype, ue)),
            (ce.$type = ce.prototype.$type = this),
            Q.merge(ce, H, !0),
            (this._ctor = ce);
          for (var he = 0; he < this.fieldsArray.length; ++he)
            this._fieldsArray[he].resolve();
          var me = {};
          for (he = 0; he < this.oneofsArray.length; ++he)
            me[this._oneofsArray[he].resolve().name] = {
              get: Q.oneOfGetter(this._oneofsArray[he].oneof),
              set: Q.oneOfSetter(this._oneofsArray[he].oneof),
            };
          he && Object.defineProperties(ce.prototype, me);
        },
      },
    }),
      (se.generateConstructor = function (ue) {
        for (
          var he = Q.codegen(["p"], ue.name), me = 0, ve;
          me < ue.fieldsArray.length;
          ++me
        )
          (ve = ue._fieldsArray[me]).map
            ? he("this%s={}", Q.safeProp(ve.name))
            : ve.repeated && he("this%s=[]", Q.safeProp(ve.name));
        return he(
          "if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)"
        )("this[ks[i]]=p[ks[i]]");
      });
    function fe(ce) {
      return (
        (ce._fieldsById = ce._fieldsArray = ce._oneofsArray = null),
        delete ce.encode,
        delete ce.decode,
        delete ce.verify,
        ce
      );
    }
    return (
      (se.fromJSON = function (ue, he) {
        var me = new se(ue, he.options);
        (me.extensions = he.extensions), (me.reserved = he.reserved);
        for (var ve = Object.keys(he.fields), ge = 0; ge < ve.length; ++ge)
          me.add(
            (typeof he.fields[ve[ge]].keyType < "u" ? q.fromJSON : B.fromJSON)(
              ve[ge],
              he.fields[ve[ge]]
            )
          );
        if (he.oneofs)
          for (ve = Object.keys(he.oneofs), ge = 0; ge < ve.length; ++ge)
            me.add(V.fromJSON(ve[ge], he.oneofs[ve[ge]]));
        if (he.nested)
          for (ve = Object.keys(he.nested), ge = 0; ge < ve.length; ++ge) {
            var Ee = he.nested[ve[ge]];
            me.add(
              (Ee.id !== void 0
                ? B.fromJSON
                : Ee.fields !== void 0
                ? se.fromJSON
                : Ee.values !== void 0
                ? j.fromJSON
                : Ee.methods !== void 0
                ? $.fromJSON
                : U.fromJSON)(ve[ge], Ee)
            );
          }
        return (
          he.extensions &&
            he.extensions.length &&
            (me.extensions = he.extensions),
          he.reserved && he.reserved.length && (me.reserved = he.reserved),
          he.group && (me.group = !0),
          he.comment && (me.comment = he.comment),
          he.edition && (me._edition = he.edition),
          (me._defaultEdition = "proto3"),
          me
        );
      }),
      (se.prototype.toJSON = function (ue) {
        var he = U.prototype.toJSON.call(this, ue),
          me = ue ? !!ue.keepComments : !1;
        return Q.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          (he && he.options) || void 0,
          "oneofs",
          U.arrayToJSON(this.oneofsArray, ue),
          "fields",
          U.arrayToJSON(
            this.fieldsArray.filter(function (ve) {
              return !ve.declaringField;
            }),
            ue
          ) || {},
          "extensions",
          this.extensions && this.extensions.length ? this.extensions : void 0,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : void 0,
          "group",
          this.group || void 0,
          "nested",
          (he && he.nested) || void 0,
          "comment",
          me ? this.comment : void 0,
        ]);
      }),
      (se.prototype.resolveAll = function () {
        if (!this._needsRecursiveResolve) return this;
        U.prototype.resolveAll.call(this);
        var ue = this.oneofsArray;
        for (me = 0; me < ue.length; ) ue[me++].resolve();
        for (var he = this.fieldsArray, me = 0; me < he.length; )
          he[me++].resolve();
        return this;
      }),
      (se.prototype._resolveFeaturesRecursive = function (ue) {
        return this._needsRecursiveFeatureResolution
          ? ((ue = this._edition || ue),
            U.prototype._resolveFeaturesRecursive.call(this, ue),
            this.oneofsArray.forEach((he) => {
              he._resolveFeatures(ue);
            }),
            this.fieldsArray.forEach((he) => {
              he._resolveFeatures(ue);
            }),
            this)
          : this;
      }),
      (se.prototype.get = function (ue) {
        return (
          this.fields[ue] ||
          (this.oneofs && this.oneofs[ue]) ||
          (this.nested && this.nested[ue]) ||
          null
        );
      }),
      (se.prototype.add = function (ue) {
        if (this.get(ue.name))
          throw Error("duplicate name '" + ue.name + "' in " + this);
        if (ue instanceof B && ue.extend === void 0) {
          if (
            this._fieldsById ? this._fieldsById[ue.id] : this.fieldsById[ue.id]
          )
            throw Error("duplicate id " + ue.id + " in " + this);
          if (this.isReservedId(ue.id))
            throw Error("id " + ue.id + " is reserved in " + this);
          if (this.isReservedName(ue.name))
            throw Error("name '" + ue.name + "' is reserved in " + this);
          return (
            ue.parent && ue.parent.remove(ue),
            (this.fields[ue.name] = ue),
            (ue.message = this),
            ue.onAdd(this),
            fe(this)
          );
        }
        return ue instanceof V
          ? (this.oneofs || (this.oneofs = {}),
            (this.oneofs[ue.name] = ue),
            ue.onAdd(this),
            fe(this))
          : U.prototype.add.call(this, ue);
      }),
      (se.prototype.remove = function (ue) {
        if (ue instanceof B && ue.extend === void 0) {
          if (!this.fields || this.fields[ue.name] !== ue)
            throw Error(ue + " is not a member of " + this);
          return (
            delete this.fields[ue.name],
            (ue.parent = null),
            ue.onRemove(this),
            fe(this)
          );
        }
        if (ue instanceof V) {
          if (!this.oneofs || this.oneofs[ue.name] !== ue)
            throw Error(ue + " is not a member of " + this);
          return (
            delete this.oneofs[ue.name],
            (ue.parent = null),
            ue.onRemove(this),
            fe(this)
          );
        }
        return U.prototype.remove.call(this, ue);
      }),
      (se.prototype.isReservedId = function (ue) {
        return U.isReservedId(this.reserved, ue);
      }),
      (se.prototype.isReservedName = function (ue) {
        return U.isReservedName(this.reserved, ue);
      }),
      (se.prototype.create = function (ue) {
        return new this.ctor(ue);
      }),
      (se.prototype.setup = function () {
        for (
          var ue = this.fullName, he = [], me = 0;
          me < this.fieldsArray.length;
          ++me
        )
          he.push(this._fieldsArray[me].resolve().resolvedType);
        (this.encode = X(this)({ Writer: Y, types: he, util: Q })),
          (this.decode = Z(this)({ Reader: G, types: he, util: Q })),
          (this.verify = te(this)({ types: he, util: Q })),
          (this.fromObject = ne.fromObject(this)({ types: he, util: Q })),
          (this.toObject = ne.toObject(this)({ types: he, util: Q }));
        var ve = ae[ue];
        if (ve) {
          var ge = Object.create(this);
          (ge.fromObject = this.fromObject),
            (this.fromObject = ve.fromObject.bind(ge)),
            (ge.toObject = this.toObject),
            (this.toObject = ve.toObject.bind(ge));
        }
        return this;
      }),
      (se.prototype.encode = function (ue, he) {
        return this.setup().encode(ue, he);
      }),
      (se.prototype.encodeDelimited = function (ue, he) {
        return this.encode(ue, he && he.len ? he.fork() : he).ldelim();
      }),
      (se.prototype.decode = function (ue, he) {
        return this.setup().decode(ue, he);
      }),
      (se.prototype.decodeDelimited = function (ue) {
        return (
          ue instanceof G || (ue = G.create(ue)), this.decode(ue, ue.uint32())
        );
      }),
      (se.prototype.verify = function (ue) {
        return this.setup().verify(ue);
      }),
      (se.prototype.fromObject = function (ue) {
        return this.setup().fromObject(ue);
      }),
      (se.prototype.toObject = function (ue, he) {
        return this.setup().toObject(ue, he);
      }),
      (se.d = function (ue) {
        return function (me) {
          Q.decorateType(me, ue);
        };
      }),
      type
    );
  }
  var root$2, hasRequiredRoot;
  function requireRoot() {
    if (hasRequiredRoot) return root$2;
    (hasRequiredRoot = 1), (root$2 = Y);
    var U = requireNamespace();
    ((Y.prototype = Object.create(U.prototype)).constructor = Y).className =
      "Root";
    var j = requireField(),
      V = require_enum(),
      B = requireOneof(),
      q = requireUtil(),
      $,
      H,
      G;
    function Y(te) {
      U.call(this, "", te),
        (this.deferred = []),
        (this.files = []),
        (this._edition = "proto2"),
        (this._fullyQualifiedObjects = {});
    }
    (Y.fromJSON = function (ne, ae) {
      return (
        ae || (ae = new Y()),
        ne.options && ae.setOptions(ne.options),
        ae.addJSON(ne.nested).resolveAll()
      );
    }),
      (Y.prototype.resolvePath = q.path.resolve),
      (Y.prototype.fetch = q.fetch);
    function Q() {}
    (Y.prototype.load = function te(ne, ae, se) {
      typeof ae == "function" && ((se = ae), (ae = void 0));
      var fe = this;
      if (!se) return q.asPromise(te, fe, ne, ae);
      var ce = se === Q;
      function ue(Re, Ae) {
        if (se) {
          if (ce) throw Re;
          Ae && Ae.resolveAll();
          var be = se;
          (se = null), be(Re, Ae);
        }
      }
      function he(Re) {
        var Ae = Re.lastIndexOf("google/protobuf/");
        if (Ae > -1) {
          var be = Re.substring(Ae);
          if (be in G) return be;
        }
        return null;
      }
      function me(Re, Ae) {
        try {
          if (
            (q.isString(Ae) && Ae.charAt(0) === "{" && (Ae = JSON.parse(Ae)),
            !q.isString(Ae))
          )
            fe.setOptions(Ae.options).addJSON(Ae.nested);
          else {
            H.filename = Re;
            var be = H(Ae, fe, ae),
              Le,
              Fe = 0;
            if (be.imports)
              for (; Fe < be.imports.length; ++Fe)
                (Le =
                  he(be.imports[Fe]) || fe.resolvePath(Re, be.imports[Fe])) &&
                  ve(Le);
            if (be.weakImports)
              for (Fe = 0; Fe < be.weakImports.length; ++Fe)
                (Le =
                  he(be.weakImports[Fe]) ||
                  fe.resolvePath(Re, be.weakImports[Fe])) && ve(Le, !0);
          }
        } catch (Me) {
          ue(Me);
        }
        !ce && !ge && ue(null, fe);
      }
      function ve(Re, Ae) {
        if (((Re = he(Re) || Re), !(fe.files.indexOf(Re) > -1))) {
          if ((fe.files.push(Re), Re in G)) {
            ce
              ? me(Re, G[Re])
              : (++ge,
                setTimeout(function () {
                  --ge, me(Re, G[Re]);
                }));
            return;
          }
          if (ce) {
            var be;
            try {
              be = q.fs.readFileSync(Re).toString("utf8");
            } catch (Le) {
              Ae || ue(Le);
              return;
            }
            me(Re, be);
          } else
            ++ge,
              fe.fetch(Re, function (Le, Fe) {
                if ((--ge, !!se)) {
                  if (Le) {
                    Ae ? ge || ue(null, fe) : ue(Le);
                    return;
                  }
                  me(Re, Fe);
                }
              });
        }
      }
      var ge = 0;
      q.isString(ne) && (ne = [ne]);
      for (var Ee = 0, Ce; Ee < ne.length; ++Ee)
        (Ce = fe.resolvePath("", ne[Ee])) && ve(Ce);
      return ce ? (fe.resolveAll(), fe) : (ge || ue(null, fe), fe);
    }),
      (Y.prototype.loadSync = function (ne, ae) {
        if (!q.isNode) throw Error("not supported");
        return this.load(ne, ae, Q);
      }),
      (Y.prototype.resolveAll = function () {
        if (!this._needsRecursiveResolve) return this;
        if (this.deferred.length)
          throw Error(
            "unresolvable extensions: " +
              this.deferred
                .map(function (ne) {
                  return "'extend " + ne.extend + "' in " + ne.parent.fullName;
                })
                .join(", ")
          );
        return U.prototype.resolveAll.call(this);
      });
    var X = /^[A-Z]/;
    function Z(te, ne) {
      var ae = ne.parent.lookup(ne.extend);
      if (ae) {
        var se = new j(
          ne.fullName,
          ne.id,
          ne.type,
          ne.rule,
          void 0,
          ne.options
        );
        return (
          ae.get(se.name) ||
            ((se.declaringField = ne), (ne.extensionField = se), ae.add(se)),
          !0
        );
      }
      return !1;
    }
    return (
      (Y.prototype._handleAdd = function (ne) {
        if (ne instanceof j)
          ne.extend !== void 0 &&
            !ne.extensionField &&
            (Z(this, ne) || this.deferred.push(ne));
        else if (ne instanceof V)
          X.test(ne.name) && (ne.parent[ne.name] = ne.values);
        else if (!(ne instanceof B)) {
          if (ne instanceof $)
            for (var ae = 0; ae < this.deferred.length; )
              Z(this, this.deferred[ae]) ? this.deferred.splice(ae, 1) : ++ae;
          for (var se = 0; se < ne.nestedArray.length; ++se)
            this._handleAdd(ne._nestedArray[se]);
          X.test(ne.name) && (ne.parent[ne.name] = ne);
        }
        (ne instanceof $ || ne instanceof V || ne instanceof j) &&
          (this._fullyQualifiedObjects[ne.fullName] = ne);
      }),
      (Y.prototype._handleRemove = function (ne) {
        if (ne instanceof j) {
          if (ne.extend !== void 0)
            if (ne.extensionField)
              ne.extensionField.parent.remove(ne.extensionField),
                (ne.extensionField = null);
            else {
              var ae = this.deferred.indexOf(ne);
              ae > -1 && this.deferred.splice(ae, 1);
            }
        } else if (ne instanceof V)
          X.test(ne.name) && delete ne.parent[ne.name];
        else if (ne instanceof U) {
          for (var se = 0; se < ne.nestedArray.length; ++se)
            this._handleRemove(ne._nestedArray[se]);
          X.test(ne.name) && delete ne.parent[ne.name];
        }
        delete this._fullyQualifiedObjects[ne.fullName];
      }),
      (Y._configure = function (te, ne, ae) {
        ($ = te), (H = ne), (G = ae);
      }),
      root$2
    );
  }
  var hasRequiredUtil;
  function requireUtil() {
    if (hasRequiredUtil) return util.exports;
    hasRequiredUtil = 1;
    var U = (util.exports = requireMinimal()),
      j = requireRoots(),
      V,
      B;
    (U.codegen = requireCodegen()),
      (U.fetch = requireFetch()),
      (U.path = requirePath()),
      (U.fs = U.inquire("fs")),
      (U.toArray = function (Q) {
        if (Q) {
          for (
            var X = Object.keys(Q), Z = new Array(X.length), te = 0;
            te < X.length;

          )
            Z[te] = Q[X[te++]];
          return Z;
        }
        return [];
      }),
      (U.toObject = function (Q) {
        for (var X = {}, Z = 0; Z < Q.length; ) {
          var te = Q[Z++],
            ne = Q[Z++];
          ne !== void 0 && (X[te] = ne);
        }
        return X;
      });
    var q = /\\/g,
      $ = /"/g;
    (U.isReserved = function (Q) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(
        Q
      );
    }),
      (U.safeProp = function (Q) {
        return !/^[$\w_]+$/.test(Q) || U.isReserved(Q)
          ? '["' + Q.replace(q, "\\\\").replace($, '\\"') + '"]'
          : "." + Q;
      }),
      (U.ucFirst = function (Q) {
        return Q.charAt(0).toUpperCase() + Q.substring(1);
      });
    var H = /_([a-z])/g;
    (U.camelCase = function (Q) {
      return (
        Q.substring(0, 1) +
        Q.substring(1).replace(H, function (X, Z) {
          return Z.toUpperCase();
        })
      );
    }),
      (U.compareFieldsById = function (Q, X) {
        return Q.id - X.id;
      }),
      (U.decorateType = function (Q, X) {
        if (Q.$type)
          return (
            X &&
              Q.$type.name !== X &&
              (U.decorateRoot.remove(Q.$type),
              (Q.$type.name = X),
              U.decorateRoot.add(Q.$type)),
            Q.$type
          );
        V || (V = requireType());
        var Z = new V(X || Q.name);
        return (
          U.decorateRoot.add(Z),
          (Z.ctor = Q),
          Object.defineProperty(Q, "$type", { value: Z, enumerable: !1 }),
          Object.defineProperty(Q.prototype, "$type", {
            value: Z,
            enumerable: !1,
          }),
          Z
        );
      });
    var G = 0;
    return (
      (U.decorateEnum = function (Q) {
        if (Q.$type) return Q.$type;
        B || (B = require_enum());
        var X = new B("Enum" + G++, Q);
        return (
          U.decorateRoot.add(X),
          Object.defineProperty(Q, "$type", { value: X, enumerable: !1 }),
          X
        );
      }),
      (U.setProperty = function (Q, X, Z, te) {
        function ne(ae, se, fe) {
          var ce = se.shift();
          if (ce === "__proto__" || ce === "prototype") return ae;
          if (se.length > 0) ae[ce] = ne(ae[ce] || {}, se, fe);
          else {
            var ue = ae[ce];
            if (ue && te) return ae;
            ue && (fe = [].concat(ue).concat(fe)), (ae[ce] = fe);
          }
          return ae;
        }
        if (typeof Q != "object") throw TypeError("dst must be an object");
        if (!X) throw TypeError("path must be specified");
        return (X = X.split(".")), ne(Q, X, Z);
      }),
      Object.defineProperty(U, "decorateRoot", {
        get: function () {
          return j.decorated || (j.decorated = new (requireRoot())());
        },
      }),
      util.exports
    );
  }
  var hasRequiredTypes;
  function requireTypes() {
    return (
      hasRequiredTypes ||
        ((hasRequiredTypes = 1),
        (function (U) {
          var j = U,
            V = requireUtil(),
            B = [
              "double",
              "float",
              "int32",
              "uint32",
              "sint32",
              "fixed32",
              "sfixed32",
              "int64",
              "uint64",
              "sint64",
              "fixed64",
              "sfixed64",
              "bool",
              "string",
              "bytes",
            ];
          function q($, H) {
            var G = 0,
              Y = {};
            for (H |= 0; G < $.length; ) Y[B[G + H]] = $[G++];
            return Y;
          }
          (j.basic = q([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2])),
            (j.defaults = q([
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              !1,
              "",
              V.emptyArray,
              null,
            ])),
            (j.long = q([0, 0, 0, 1, 1], 7)),
            (j.mapKey = q([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2)),
            (j.packed = q([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]));
        })(types$1)),
      types$1
    );
  }
  var field, hasRequiredField;
  function requireField() {
    if (hasRequiredField) return field;
    (hasRequiredField = 1), (field = H);
    var U = requireObject();
    ((H.prototype = Object.create(U.prototype)).constructor = H).className =
      "Field";
    var j = require_enum(),
      V = requireTypes(),
      B = requireUtil(),
      q,
      $ = /^required|optional|repeated$/;
    H.fromJSON = function (Y, Q) {
      var X = new H(Y, Q.id, Q.type, Q.rule, Q.extend, Q.options, Q.comment);
      return (
        Q.edition && (X._edition = Q.edition), (X._defaultEdition = "proto3"), X
      );
    };
    function H(G, Y, Q, X, Z, te, ne) {
      if (
        (B.isObject(X)
          ? ((ne = Z), (te = X), (X = Z = void 0))
          : B.isObject(Z) && ((ne = te), (te = Z), (Z = void 0)),
        U.call(this, G, te),
        !B.isInteger(Y) || Y < 0)
      )
        throw TypeError("id must be a non-negative integer");
      if (!B.isString(Q)) throw TypeError("type must be a string");
      if (X !== void 0 && !$.test((X = X.toString().toLowerCase())))
        throw TypeError("rule must be a string rule");
      if (Z !== void 0 && !B.isString(Z))
        throw TypeError("extend must be a string");
      X === "proto3_optional" && (X = "optional"),
        (this.rule = X && X !== "optional" ? X : void 0),
        (this.type = Q),
        (this.id = Y),
        (this.extend = Z || void 0),
        (this.repeated = X === "repeated"),
        (this.map = !1),
        (this.message = null),
        (this.partOf = null),
        (this.typeDefault = null),
        (this.defaultValue = null),
        (this.long = B.Long ? V.long[Q] !== void 0 : !1),
        (this.bytes = Q === "bytes"),
        (this.resolvedType = null),
        (this.extensionField = null),
        (this.declaringField = null),
        (this.comment = ne);
    }
    return (
      Object.defineProperty(H.prototype, "required", {
        get: function () {
          return this._features.field_presence === "LEGACY_REQUIRED";
        },
      }),
      Object.defineProperty(H.prototype, "optional", {
        get: function () {
          return !this.required;
        },
      }),
      Object.defineProperty(H.prototype, "delimited", {
        get: function () {
          return (
            this.resolvedType instanceof q &&
            this._features.message_encoding === "DELIMITED"
          );
        },
      }),
      Object.defineProperty(H.prototype, "packed", {
        get: function () {
          return this._features.repeated_field_encoding === "PACKED";
        },
      }),
      Object.defineProperty(H.prototype, "hasPresence", {
        get: function () {
          return this.repeated || this.map
            ? !1
            : this.partOf ||
                this.declaringField ||
                this.extensionField ||
                this._features.field_presence !== "IMPLICIT";
        },
      }),
      (H.prototype.setOption = function (Y, Q, X) {
        return U.prototype.setOption.call(this, Y, Q, X);
      }),
      (H.prototype.toJSON = function (Y) {
        var Q = Y ? !!Y.keepComments : !1;
        return B.toObject([
          "edition",
          this._editionToJSON(),
          "rule",
          (this.rule !== "optional" && this.rule) || void 0,
          "type",
          this.type,
          "id",
          this.id,
          "extend",
          this.extend,
          "options",
          this.options,
          "comment",
          Q ? this.comment : void 0,
        ]);
      }),
      (H.prototype.resolve = function () {
        if (this.resolved) return this;
        if (
          ((this.typeDefault = V.defaults[this.type]) === void 0
            ? ((this.resolvedType = (
                this.declaringField ? this.declaringField.parent : this.parent
              ).lookupTypeOrEnum(this.type)),
              this.resolvedType instanceof q
                ? (this.typeDefault = null)
                : (this.typeDefault =
                    this.resolvedType.values[
                      Object.keys(this.resolvedType.values)[0]
                    ]))
            : this.options &&
              this.options.proto3_optional &&
              (this.typeDefault = null),
          this.options &&
            this.options.default != null &&
            ((this.typeDefault = this.options.default),
            this.resolvedType instanceof j &&
              typeof this.typeDefault == "string" &&
              (this.typeDefault = this.resolvedType.values[this.typeDefault])),
          this.options &&
            (this.options.packed !== void 0 &&
              this.resolvedType &&
              !(this.resolvedType instanceof j) &&
              delete this.options.packed,
            Object.keys(this.options).length || (this.options = void 0)),
          this.long)
        )
          (this.typeDefault = B.Long.fromNumber(
            this.typeDefault,
            this.type.charAt(0) === "u"
          )),
            Object.freeze && Object.freeze(this.typeDefault);
        else if (this.bytes && typeof this.typeDefault == "string") {
          var Y;
          B.base64.test(this.typeDefault)
            ? B.base64.decode(
                this.typeDefault,
                (Y = B.newBuffer(B.base64.length(this.typeDefault))),
                0
              )
            : B.utf8.write(
                this.typeDefault,
                (Y = B.newBuffer(B.utf8.length(this.typeDefault))),
                0
              ),
            (this.typeDefault = Y);
        }
        return (
          this.map
            ? (this.defaultValue = B.emptyObject)
            : this.repeated
            ? (this.defaultValue = B.emptyArray)
            : (this.defaultValue = this.typeDefault),
          this.parent instanceof q &&
            (this.parent.ctor.prototype[this.name] = this.defaultValue),
          U.prototype.resolve.call(this)
        );
      }),
      (H.prototype._inferLegacyProtoFeatures = function (Y) {
        if (Y !== "proto2" && Y !== "proto3") return {};
        var Q = {};
        if (
          (this.rule === "required" && (Q.field_presence = "LEGACY_REQUIRED"),
          this.parent && V.defaults[this.type] === void 0)
        ) {
          var X = this.parent.get(this.type.split(".").pop());
          X && X instanceof q && X.group && (Q.message_encoding = "DELIMITED");
        }
        return (
          this.getOption("packed") === !0
            ? (Q.repeated_field_encoding = "PACKED")
            : this.getOption("packed") === !1 &&
              (Q.repeated_field_encoding = "EXPANDED"),
          Q
        );
      }),
      (H.prototype._resolveFeatures = function (Y) {
        return U.prototype._resolveFeatures.call(this, this._edition || Y);
      }),
      (H.d = function (Y, Q, X, Z) {
        return (
          typeof Q == "function"
            ? (Q = B.decorateType(Q).name)
            : Q && typeof Q == "object" && (Q = B.decorateEnum(Q).name),
          function (ne, ae) {
            B.decorateType(ne.constructor).add(
              new H(ae, Y, Q, X, { default: Z })
            );
          }
        );
      }),
      (H._configure = function (Y) {
        q = Y;
      }),
      field
    );
  }
  var oneof, hasRequiredOneof;
  function requireOneof() {
    if (hasRequiredOneof) return oneof;
    (hasRequiredOneof = 1), (oneof = B);
    var U = requireObject();
    ((B.prototype = Object.create(U.prototype)).constructor = B).className =
      "OneOf";
    var j = requireField(),
      V = requireUtil();
    function B($, H, G, Y) {
      if (
        (Array.isArray(H) || ((G = H), (H = void 0)),
        U.call(this, $, G),
        !(H === void 0 || Array.isArray(H)))
      )
        throw TypeError("fieldNames must be an Array");
      (this.oneof = H || []), (this.fieldsArray = []), (this.comment = Y);
    }
    (B.fromJSON = function (H, G) {
      return new B(H, G.oneof, G.options, G.comment);
    }),
      (B.prototype.toJSON = function (H) {
        var G = H ? !!H.keepComments : !1;
        return V.toObject([
          "options",
          this.options,
          "oneof",
          this.oneof,
          "comment",
          G ? this.comment : void 0,
        ]);
      });
    function q($) {
      if ($.parent)
        for (var H = 0; H < $.fieldsArray.length; ++H)
          $.fieldsArray[H].parent || $.parent.add($.fieldsArray[H]);
    }
    return (
      (B.prototype.add = function (H) {
        if (!(H instanceof j)) throw TypeError("field must be a Field");
        return (
          H.parent && H.parent !== this.parent && H.parent.remove(H),
          this.oneof.push(H.name),
          this.fieldsArray.push(H),
          (H.partOf = this),
          q(this),
          this
        );
      }),
      (B.prototype.remove = function (H) {
        if (!(H instanceof j)) throw TypeError("field must be a Field");
        var G = this.fieldsArray.indexOf(H);
        if (G < 0) throw Error(H + " is not a member of " + this);
        return (
          this.fieldsArray.splice(G, 1),
          (G = this.oneof.indexOf(H.name)),
          G > -1 && this.oneof.splice(G, 1),
          (H.partOf = null),
          this
        );
      }),
      (B.prototype.onAdd = function (H) {
        U.prototype.onAdd.call(this, H);
        for (var G = this, Y = 0; Y < this.oneof.length; ++Y) {
          var Q = H.get(this.oneof[Y]);
          Q && !Q.partOf && ((Q.partOf = G), G.fieldsArray.push(Q));
        }
        q(this);
      }),
      (B.prototype.onRemove = function (H) {
        for (var G = 0, Y; G < this.fieldsArray.length; ++G)
          (Y = this.fieldsArray[G]).parent && Y.parent.remove(Y);
        U.prototype.onRemove.call(this, H);
      }),
      Object.defineProperty(B.prototype, "isProto3Optional", {
        get: function () {
          if (this.fieldsArray == null || this.fieldsArray.length !== 1)
            return !1;
          var $ = this.fieldsArray[0];
          return $.options != null && $.options.proto3_optional === !0;
        },
      }),
      (B.d = function () {
        for (var H = new Array(arguments.length), G = 0; G < arguments.length; )
          H[G] = arguments[G++];
        return function (Q, X) {
          V.decorateType(Q.constructor).add(new B(X, H)),
            Object.defineProperty(Q, X, {
              get: V.oneOfGetter(H),
              set: V.oneOfSetter(H),
            });
        };
      }),
      oneof
    );
  }
  var object, hasRequiredObject;
  function requireObject() {
    if (hasRequiredObject) return object;
    (hasRequiredObject = 1), (object = H), (H.className = "ReflectionObject");
    const U = requireOneof();
    var j = requireUtil(),
      V,
      B = {
        enum_type: "OPEN",
        field_presence: "EXPLICIT",
        json_format: "ALLOW",
        message_encoding: "LENGTH_PREFIXED",
        repeated_field_encoding: "PACKED",
        utf8_validation: "VERIFY",
      },
      q = {
        enum_type: "CLOSED",
        field_presence: "EXPLICIT",
        json_format: "LEGACY_BEST_EFFORT",
        message_encoding: "LENGTH_PREFIXED",
        repeated_field_encoding: "EXPANDED",
        utf8_validation: "NONE",
      },
      $ = {
        enum_type: "OPEN",
        field_presence: "IMPLICIT",
        json_format: "ALLOW",
        message_encoding: "LENGTH_PREFIXED",
        repeated_field_encoding: "PACKED",
        utf8_validation: "VERIFY",
      };
    function H(G, Y) {
      if (!j.isString(G)) throw TypeError("name must be a string");
      if (Y && !j.isObject(Y)) throw TypeError("options must be an object");
      (this.options = Y),
        (this.parsedOptions = null),
        (this.name = G),
        (this._edition = null),
        (this._defaultEdition = "proto2"),
        (this._features = {}),
        (this._featuresResolved = !1),
        (this.parent = null),
        (this.resolved = !1),
        (this.comment = null),
        (this.filename = null);
    }
    return (
      Object.defineProperties(H.prototype, {
        root: {
          get: function () {
            for (var G = this; G.parent !== null; ) G = G.parent;
            return G;
          },
        },
        fullName: {
          get: function () {
            for (var G = [this.name], Y = this.parent; Y; )
              G.unshift(Y.name), (Y = Y.parent);
            return G.join(".");
          },
        },
      }),
      (H.prototype.toJSON = function () {
        throw Error();
      }),
      (H.prototype.onAdd = function (Y) {
        this.parent && this.parent !== Y && this.parent.remove(this),
          (this.parent = Y),
          (this.resolved = !1);
        var Q = Y.root;
        Q instanceof V && Q._handleAdd(this);
      }),
      (H.prototype.onRemove = function (Y) {
        var Q = Y.root;
        Q instanceof V && Q._handleRemove(this),
          (this.parent = null),
          (this.resolved = !1);
      }),
      (H.prototype.resolve = function () {
        return this.resolved
          ? this
          : (this.root instanceof V && (this.resolved = !0), this);
      }),
      (H.prototype._resolveFeaturesRecursive = function (Y) {
        return this._resolveFeatures(this._edition || Y);
      }),
      (H.prototype._resolveFeatures = function (Y) {
        if (!this._featuresResolved) {
          var Q = {};
          if (!Y) throw new Error("Unknown edition for " + this.fullName);
          var X = Object.assign(
            this.options ? Object.assign({}, this.options.features) : {},
            this._inferLegacyProtoFeatures(Y)
          );
          if (this._edition) {
            if (Y === "proto2") Q = Object.assign({}, q);
            else if (Y === "proto3") Q = Object.assign({}, $);
            else if (Y === "2023") Q = Object.assign({}, B);
            else throw new Error("Unknown edition: " + Y);
            (this._features = Object.assign(Q, X || {})),
              (this._featuresResolved = !0);
            return;
          }
          if (this.partOf instanceof U) {
            var Z = Object.assign({}, this.partOf._features);
            this._features = Object.assign(Z, X || {});
          } else if (!this.declaringField)
            if (this.parent) {
              var te = Object.assign({}, this.parent._features);
              this._features = Object.assign(te, X || {});
            } else
              throw new Error("Unable to find a parent for " + this.fullName);
          this.extensionField &&
            (this.extensionField._features = this._features),
            (this._featuresResolved = !0);
        }
      }),
      (H.prototype._inferLegacyProtoFeatures = function () {
        return {};
      }),
      (H.prototype.getOption = function (Y) {
        if (this.options) return this.options[Y];
      }),
      (H.prototype.setOption = function (Y, Q, X) {
        return (
          this.options || (this.options = {}),
          /^features\./.test(Y)
            ? j.setProperty(this.options, Y, Q, X)
            : (!X || this.options[Y] === void 0) &&
              (this.getOption(Y) !== Q && (this.resolved = !1),
              (this.options[Y] = Q)),
          this
        );
      }),
      (H.prototype.setParsedOption = function (Y, Q, X) {
        this.parsedOptions || (this.parsedOptions = []);
        var Z = this.parsedOptions;
        if (X) {
          var te = Z.find(function (se) {
            return Object.prototype.hasOwnProperty.call(se, Y);
          });
          if (te) {
            var ne = te[Y];
            j.setProperty(ne, X, Q);
          } else (te = {}), (te[Y] = j.setProperty({}, X, Q)), Z.push(te);
        } else {
          var ae = {};
          (ae[Y] = Q), Z.push(ae);
        }
        return this;
      }),
      (H.prototype.setOptions = function (Y, Q) {
        if (Y)
          for (var X = Object.keys(Y), Z = 0; Z < X.length; ++Z)
            this.setOption(X[Z], Y[X[Z]], Q);
        return this;
      }),
      (H.prototype.toString = function () {
        var Y = this.constructor.className,
          Q = this.fullName;
        return Q.length ? Y + " " + Q : Y;
      }),
      (H.prototype._editionToJSON = function () {
        if (!(!this._edition || this._edition === "proto3"))
          return this._edition;
      }),
      (H._configure = function (G) {
        V = G;
      }),
      object
    );
  }
  var _enum, hasRequired_enum;
  function require_enum() {
    if (hasRequired_enum) return _enum;
    (hasRequired_enum = 1), (_enum = B);
    var U = requireObject();
    ((B.prototype = Object.create(U.prototype)).constructor = B).className =
      "Enum";
    var j = requireNamespace(),
      V = requireUtil();
    function B(q, $, H, G, Y, Q) {
      if ((U.call(this, q, H), $ && typeof $ != "object"))
        throw TypeError("values must be an object");
      if (
        ((this.valuesById = {}),
        (this.values = Object.create(this.valuesById)),
        (this.comment = G),
        (this.comments = Y || {}),
        (this.valuesOptions = Q),
        (this._valuesFeatures = {}),
        (this.reserved = void 0),
        $)
      )
        for (var X = Object.keys($), Z = 0; Z < X.length; ++Z)
          typeof $[X[Z]] == "number" &&
            (this.valuesById[(this.values[X[Z]] = $[X[Z]])] = X[Z]);
    }
    return (
      (B.prototype._resolveFeatures = function ($) {
        return (
          ($ = this._edition || $),
          U.prototype._resolveFeatures.call(this, $),
          Object.keys(this.values).forEach((H) => {
            var G = Object.assign({}, this._features);
            this._valuesFeatures[H] = Object.assign(
              G,
              this.valuesOptions &&
                this.valuesOptions[H] &&
                this.valuesOptions[H].features
            );
          }),
          this
        );
      }),
      (B.fromJSON = function ($, H) {
        var G = new B($, H.values, H.options, H.comment, H.comments);
        return (
          (G.reserved = H.reserved),
          H.edition && (G._edition = H.edition),
          (G._defaultEdition = "proto3"),
          G
        );
      }),
      (B.prototype.toJSON = function ($) {
        var H = $ ? !!$.keepComments : !1;
        return V.toObject([
          "edition",
          this._editionToJSON(),
          "options",
          this.options,
          "valuesOptions",
          this.valuesOptions,
          "values",
          this.values,
          "reserved",
          this.reserved && this.reserved.length ? this.reserved : void 0,
          "comment",
          H ? this.comment : void 0,
          "comments",
          H ? this.comments : void 0,
        ]);
      }),
      (B.prototype.add = function ($, H, G, Y) {
        if (!V.isString($)) throw TypeError("name must be a string");
        if (!V.isInteger(H)) throw TypeError("id must be an integer");
        if (this.values[$] !== void 0)
          throw Error("duplicate name '" + $ + "' in " + this);
        if (this.isReservedId(H))
          throw Error("id " + H + " is reserved in " + this);
        if (this.isReservedName($))
          throw Error("name '" + $ + "' is reserved in " + this);
        if (this.valuesById[H] !== void 0) {
          if (!(this.options && this.options.allow_alias))
            throw Error("duplicate id " + H + " in " + this);
          this.values[$] = H;
        } else this.valuesById[(this.values[$] = H)] = $;
        return (
          Y &&
            (this.valuesOptions === void 0 && (this.valuesOptions = {}),
            (this.valuesOptions[$] = Y || null)),
          (this.comments[$] = G || null),
          this
        );
      }),
      (B.prototype.remove = function ($) {
        if (!V.isString($)) throw TypeError("name must be a string");
        var H = this.values[$];
        if (H == null)
          throw Error("name '" + $ + "' does not exist in " + this);
        return (
          delete this.valuesById[H],
          delete this.values[$],
          delete this.comments[$],
          this.valuesOptions && delete this.valuesOptions[$],
          this
        );
      }),
      (B.prototype.isReservedId = function ($) {
        return j.isReservedId(this.reserved, $);
      }),
      (B.prototype.isReservedName = function ($) {
        return j.isReservedName(this.reserved, $);
      }),
      _enum
    );
  }
  var encoder_1, hasRequiredEncoder;
  function requireEncoder() {
    if (hasRequiredEncoder) return encoder_1;
    (hasRequiredEncoder = 1), (encoder_1 = q);
    var U = require_enum(),
      j = requireTypes(),
      V = requireUtil();
    function B($, H, G, Y) {
      return H.delimited
        ? $(
            "types[%i].encode(%s,w.uint32(%i)).uint32(%i)",
            G,
            Y,
            ((H.id << 3) | 3) >>> 0,
            ((H.id << 3) | 4) >>> 0
          )
        : $(
            "types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",
            G,
            Y,
            ((H.id << 3) | 2) >>> 0
          );
    }
    function q($) {
      for (
        var H = V.codegen(["m", "w"], $.name + "$encode")("if(!w)")(
            "w=Writer.create()"
          ),
          G,
          Y,
          Q = $.fieldsArray.slice().sort(V.compareFieldsById),
          G = 0;
        G < Q.length;
        ++G
      ) {
        var X = Q[G].resolve(),
          Z = $._fieldsArray.indexOf(X),
          te = X.resolvedType instanceof U ? "int32" : X.type,
          ne = j.basic[te];
        (Y = "m" + V.safeProp(X.name)),
          X.map
            ? (H(
                "if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",
                Y,
                X.name
              )("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", Y)(
                "w.uint32(%i).fork().uint32(%i).%s(ks[i])",
                ((X.id << 3) | 2) >>> 0,
                8 | j.mapKey[X.keyType],
                X.keyType
              ),
              ne === void 0
                ? H(
                    "types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",
                    Z,
                    Y
                  )
                : H(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | ne, te, Y),
              H("}")("}"))
            : X.repeated
            ? (H("if(%s!=null&&%s.length){", Y, Y),
              X.packed && j.packed[te] !== void 0
                ? H("w.uint32(%i).fork()", ((X.id << 3) | 2) >>> 0)(
                    "for(var i=0;i<%s.length;++i)",
                    Y
                  )(
                    "w.%s(%s[i])",
                    te,
                    Y
                  )("w.ldelim()")
                : (H("for(var i=0;i<%s.length;++i)", Y),
                  ne === void 0
                    ? B(H, X, Z, Y + "[i]")
                    : H(
                        "w.uint32(%i).%s(%s[i])",
                        ((X.id << 3) | ne) >>> 0,
                        te,
                        Y
                      )),
              H("}"))
            : (X.optional &&
                H("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", Y, X.name),
              ne === void 0
                ? B(H, X, Z, Y)
                : H("w.uint32(%i).%s(%s)", ((X.id << 3) | ne) >>> 0, te, Y));
      }
      return H("return w");
    }
    return encoder_1;
  }
  var hasRequiredIndexLight;
  function requireIndexLight() {
    if (hasRequiredIndexLight) return indexLight.exports;
    hasRequiredIndexLight = 1;
    var U = (indexLight.exports = requireIndexMinimal());
    U.build = "light";
    function j(B, q, $) {
      return (
        typeof q == "function"
          ? (($ = q), (q = new U.Root()))
          : q || (q = new U.Root()),
        q.load(B, $)
      );
    }
    U.load = j;
    function V(B, q) {
      return q || (q = new U.Root()), q.loadSync(B);
    }
    return (
      (U.loadSync = V),
      (U.encoder = requireEncoder()),
      (U.decoder = requireDecoder()),
      (U.verifier = requireVerifier()),
      (U.converter = requireConverter()),
      (U.ReflectionObject = requireObject()),
      (U.Namespace = requireNamespace()),
      (U.Root = requireRoot()),
      (U.Enum = require_enum()),
      (U.Type = requireType()),
      (U.Field = requireField()),
      (U.OneOf = requireOneof()),
      (U.MapField = requireMapfield()),
      (U.Service = requireService()),
      (U.Method = requireMethod()),
      (U.Message = requireMessage()),
      (U.wrappers = requireWrappers()),
      (U.types = requireTypes()),
      (U.util = requireUtil()),
      U.ReflectionObject._configure(U.Root),
      U.Namespace._configure(U.Type, U.Service, U.Enum),
      U.Root._configure(U.Type),
      U.Field._configure(U.Type),
      indexLight.exports
    );
  }
  var tokenize_1, hasRequiredTokenize;
  function requireTokenize() {
    if (hasRequiredTokenize) return tokenize_1;
    (hasRequiredTokenize = 1), (tokenize_1 = X);
    var U = /[\s{}=;:[\],'"()<>]/g,
      j = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
      V = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
      B = /^ *[*/]+ */,
      q = /^\s*\*?\/*/,
      $ = /\n/g,
      H = /\s/,
      G = /\\(.?)/g,
      Y = {
        0: "\0",
        r: "\r",
        n: `
`,
        t: "	",
      };
    function Q(Z) {
      return Z.replace(G, function (te, ne) {
        switch (ne) {
          case "\\":
          case "":
            return ne;
          default:
            return Y[ne] || "";
        }
      });
    }
    X.unescape = Q;
    function X(Z, te) {
      Z = Z.toString();
      var ne = 0,
        ae = Z.length,
        se = 1,
        fe = 0,
        ce = {},
        ue = [],
        he = null;
      function me(je) {
        return Error("illegal " + je + " (line " + se + ")");
      }
      function ve() {
        var je = he === "'" ? V : j;
        je.lastIndex = ne - 1;
        var Te = je.exec(Z);
        if (!Te) throw me("string");
        return (ne = je.lastIndex), be(he), (he = null), Q(Te[1]);
      }
      function ge(je) {
        return Z.charAt(je);
      }
      function Ee(je, Te, xe) {
        var He = { type: Z.charAt(je++), lineEmpty: !1, leading: xe },
          Je;
        te ? (Je = 2) : (Je = 3);
        var oe = je - Je,
          De;
        do
          if (
            --oe < 0 ||
            (De = Z.charAt(oe)) ===
              `
`
          ) {
            He.lineEmpty = !0;
            break;
          }
        while (De === " " || De === "	");
        for (
          var Ge = Z.substring(je, Te).split($), pe = 0;
          pe < Ge.length;
          ++pe
        )
          Ge[pe] = Ge[pe].replace(te ? q : B, "").trim();
        (He.text = Ge.join(
          `
`
        ).trim()),
          (ce[se] = He),
          (fe = se);
      }
      function Ce(je) {
        var Te = Re(je),
          xe = Z.substring(je, Te),
          He = /^\s*\/\//.test(xe);
        return He;
      }
      function Re(je) {
        for (
          var Te = je;
          Te < ae &&
          ge(Te) !==
            `
`;

        )
          Te++;
        return Te;
      }
      function Ae() {
        if (ue.length > 0) return ue.shift();
        if (he) return ve();
        var je,
          Te,
          xe,
          He,
          Je,
          oe = ne === 0;
        do {
          if (ne === ae) return null;
          for (je = !1; H.test((xe = ge(ne))); )
            if (
              (xe ===
                `
` && ((oe = !0), ++se),
              ++ne === ae)
            )
              return null;
          if (ge(ne) === "/") {
            if (++ne === ae) throw me("comment");
            if (ge(ne) === "/")
              if (te) {
                if (((He = ne), (Je = !1), Ce(ne - 1))) {
                  Je = !0;
                  do if (((ne = Re(ne)), ne === ae || (ne++, !oe))) break;
                  while (Ce(ne));
                } else ne = Math.min(ae, Re(ne) + 1);
                Je && (Ee(He, ne, oe), (oe = !0)), se++, (je = !0);
              } else {
                for (
                  Je = ge((He = ne + 1)) === "/";
                  ge(++ne) !==
                  `
`;

                )
                  if (ne === ae) return null;
                ++ne, Je && (Ee(He, ne - 1, oe), (oe = !0)), ++se, (je = !0);
              }
            else if ((xe = ge(ne)) === "*") {
              (He = ne + 1), (Je = te || ge(He) === "*");
              do {
                if (
                  (xe ===
                    `
` && ++se,
                  ++ne === ae)
                )
                  throw me("comment");
                (Te = xe), (xe = ge(ne));
              } while (Te !== "*" || xe !== "/");
              ++ne, Je && (Ee(He, ne - 2, oe), (oe = !0)), (je = !0);
            } else return "/";
          }
        } while (je);
        var De = ne;
        U.lastIndex = 0;
        var Ge = U.test(ge(De++));
        if (!Ge) for (; De < ae && !U.test(ge(De)); ) ++De;
        var pe = Z.substring(ne, (ne = De));
        return (pe === '"' || pe === "'") && (he = pe), pe;
      }
      function be(je) {
        ue.push(je);
      }
      function Le() {
        if (!ue.length) {
          var je = Ae();
          if (je === null) return null;
          be(je);
        }
        return ue[0];
      }
      function Fe(je, Te) {
        var xe = Le(),
          He = xe === je;
        if (He) return Ae(), !0;
        if (!Te) throw me("token '" + xe + "', '" + je + "' expected");
        return !1;
      }
      function Me(je) {
        var Te = null,
          xe;
        return (
          je === void 0
            ? ((xe = ce[se - 1]),
              delete ce[se - 1],
              xe &&
                (te || xe.type === "*" || xe.lineEmpty) &&
                (Te = xe.leading ? xe.text : null))
            : (fe < je && Le(),
              (xe = ce[je]),
              delete ce[je],
              xe &&
                !xe.lineEmpty &&
                (te || xe.type === "/") &&
                (Te = xe.leading ? null : xe.text)),
          Te
        );
      }
      return Object.defineProperty(
        { next: Ae, peek: Le, push: be, skip: Fe, cmnt: Me },
        "line",
        {
          get: function () {
            return se;
          },
        }
      );
    }
    return tokenize_1;
  }
  var parse_1, hasRequiredParse;
  function requireParse() {
    if (hasRequiredParse) return parse_1;
    (hasRequiredParse = 1),
      (parse_1 = ve),
      (ve.filename = null),
      (ve.defaults = { keepCase: !1 });
    var U = requireTokenize(),
      j = requireRoot(),
      V = requireType(),
      B = requireField(),
      q = requireMapfield(),
      $ = requireOneof(),
      H = require_enum(),
      G = requireService(),
      Y = requireMethod(),
      Q = requireObject(),
      X = requireTypes(),
      Z = requireUtil(),
      te = /^[1-9][0-9]*$/,
      ne = /^-?[1-9][0-9]*$/,
      ae = /^0[x][0-9a-fA-F]+$/,
      se = /^-?0[x][0-9a-fA-F]+$/,
      fe = /^0[0-7]+$/,
      ce = /^-?0[0-7]+$/,
      ue = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,
      he = /^[a-zA-Z_][a-zA-Z_0-9]*$/,
      me = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    function ve(ge, Ee, Ce) {
      Ee instanceof j || ((Ce = Ee), (Ee = new j())), Ce || (Ce = ve.defaults);
      var Re = Ce.preferTrailingComment || !1,
        Ae = U(ge, Ce.alternateCommentMode || !1),
        be = Ae.next,
        Le = Ae.push,
        Fe = Ae.peek,
        Me = Ae.skip,
        je = Ae.cmnt,
        Te = !0,
        xe,
        He,
        Je,
        oe = "proto2",
        De = Ee,
        Ge = [],
        pe = {},
        Ye = Ce.keepCase
          ? function (Be) {
              return Be;
            }
          : Z.camelCase;
      function Qe() {
        Ge.forEach((Be) => {
          (Be._edition = oe),
            Object.keys(pe).forEach((Ue) => {
              Be.getOption(Ue) === void 0 && Be.setOption(Ue, pe[Ue], !0);
            });
        });
      }
      function Ie(Be, Ue, qe) {
        var Xe = ve.filename;
        return (
          qe || (ve.filename = null),
          Error(
            "illegal " +
              (Ue || "token") +
              " '" +
              Be +
              "' (" +
              (Xe ? Xe + ", " : "") +
              "line " +
              Ae.line +
              ")"
          )
        );
      }
      function pt() {
        var Be = [],
          Ue;
        do {
          if ((Ue = be()) !== '"' && Ue !== "'") throw Ie(Ue);
          Be.push(be()), Me(Ue), (Ue = Fe());
        } while (Ue === '"' || Ue === "'");
        return Be.join("");
      }
      function ct(Be) {
        var Ue = be();
        switch (Ue) {
          case "'":
          case '"':
            return Le(Ue), pt();
          case "true":
          case "TRUE":
            return !0;
          case "false":
          case "FALSE":
            return !1;
        }
        try {
          return tt(Ue, !0);
        } catch {
          if (me.test(Ue)) return Ue;
          throw Ie(Ue, "value");
        }
      }
      function We(Be, Ue) {
        var qe, Xe;
        do
          if (Ue && ((qe = Fe()) === '"' || qe === "'")) {
            var Ze = pt();
            if ((Be.push(Ze), oe >= 2023)) throw Ie(Ze, "id");
          } else
            try {
              Be.push([(Xe = gt(be())), Me("to", !0) ? gt(be()) : Xe]);
            } catch (Rt) {
              if (Ue && me.test(qe) && oe >= 2023) Be.push(qe);
              else throw Rt;
            }
        while (Me(",", !0));
        var lt = { options: void 0 };
        (lt.setOption = function (Rt, jt) {
          this.options === void 0 && (this.options = {}),
            (this.options[Rt] = jt);
        }),
          At(
            lt,
            function (jt) {
              if (jt === "option") Zt(lt, jt), Me(";");
              else throw Ie(jt);
            },
            function () {
              rt(lt);
            }
          );
      }
      function tt(Be, Ue) {
        var qe = 1;
        switch (
          (Be.charAt(0) === "-" && ((qe = -1), (Be = Be.substring(1))), Be)
        ) {
          case "inf":
          case "INF":
          case "Inf":
            return qe * (1 / 0);
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (te.test(Be)) return qe * parseInt(Be, 10);
        if (ae.test(Be)) return qe * parseInt(Be, 16);
        if (fe.test(Be)) return qe * parseInt(Be, 8);
        if (ue.test(Be)) return qe * parseFloat(Be);
        throw Ie(Be, "number", Ue);
      }
      function gt(Be, Ue) {
        switch (Be) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!Ue && Be.charAt(0) === "-") throw Ie(Be, "id");
        if (ne.test(Be)) return parseInt(Be, 10);
        if (se.test(Be)) return parseInt(Be, 16);
        if (ce.test(Be)) return parseInt(Be, 8);
        throw Ie(Be, "id");
      }
      function Jt() {
        if (xe !== void 0) throw Ie("package");
        if (((xe = be()), !me.test(xe))) throw Ie(xe, "name");
        (De = De.define(xe)), Me(";");
      }
      function nn() {
        var Be = Fe(),
          Ue;
        switch (Be) {
          case "weak":
            (Ue = Je || (Je = [])), be();
            break;
          case "public":
            be();
          default:
            Ue = He || (He = []);
            break;
        }
        (Be = pt()), Me(";"), Ue.push(Be);
      }
      function gn() {
        if ((Me("="), (oe = pt()), oe < 2023)) throw Ie(oe, "syntax");
        Me(";");
      }
      function Bi() {
        if ((Me("="), (oe = pt()), !["2023"].includes(oe)))
          throw Ie(oe, "edition");
        Me(";");
      }
      function Wn(Be, Ue) {
        switch (Ue) {
          case "option":
            return Zt(Be, Ue), Me(";"), !0;
          case "message":
            return Fi(Be, Ue), !0;
          case "enum":
            return ki(Be, Ue), !0;
          case "service":
            return bt(Be, Ue), !0;
          case "extend":
            return Rn(Be, Ue), !0;
        }
        return !1;
      }
      function At(Be, Ue, qe) {
        var Xe = Ae.line;
        if (
          (Be &&
            (typeof Be.comment != "string" && (Be.comment = je()),
            (Be.filename = ve.filename)),
          Me("{", !0))
        ) {
          for (var Ze; (Ze = be()) !== "}"; ) Ue(Ze);
          Me(";", !0);
        } else
          qe && qe(),
            Me(";"),
            Be &&
              (typeof Be.comment != "string" || Re) &&
              (Be.comment = je(Xe) || Be.comment);
      }
      function Fi(Be, Ue) {
        if (!he.test((Ue = be()))) throw Ie(Ue, "type name");
        var qe = new V(Ue);
        At(qe, function (Ze) {
          if (!Wn(qe, Ze))
            switch (Ze) {
              case "map":
                Xn(qe);
                break;
              case "required":
                if (oe !== "proto2") throw Ie(Ze);
              case "repeated":
                qt(qe, Ze);
                break;
              case "optional":
                if (oe === "proto3") qt(qe, "proto3_optional");
                else {
                  if (oe !== "proto2") throw Ie(Ze);
                  qt(qe, "optional");
                }
                break;
              case "oneof":
                Ar(qe, Ze);
                break;
              case "extensions":
                We(qe.extensions || (qe.extensions = []));
                break;
              case "reserved":
                We(qe.reserved || (qe.reserved = []), !0);
                break;
              default:
                if (oe === "proto2" || !me.test(Ze)) throw Ie(Ze);
                Le(Ze), qt(qe, "optional");
                break;
            }
        }),
          Be.add(qe),
          Be === De && Ge.push(qe);
      }
      function qt(Be, Ue, qe) {
        var Xe = be();
        if (Xe === "group") {
          Ti(Be, Ue);
          return;
        }
        for (; Xe.endsWith(".") || Fe().startsWith("."); ) Xe += be();
        if (!me.test(Xe)) throw Ie(Xe, "type");
        var Ze = be();
        if (!he.test(Ze)) throw Ie(Ze, "name");
        (Ze = Ye(Ze)), Me("=");
        var lt = new B(Ze, gt(be()), Xe, Ue, qe);
        if (
          (At(
            lt,
            function (It) {
              if (It === "option") Zt(lt, It), Me(";");
              else throw Ie(It);
            },
            function () {
              rt(lt);
            }
          ),
          Ue === "proto3_optional")
        ) {
          var Rt = new $("_" + Ze);
          lt.setOption("proto3_optional", !0), Rt.add(lt), Be.add(Rt);
        } else Be.add(lt);
        Be === De && Ge.push(lt);
      }
      function Ti(Be, Ue) {
        if (oe >= 2023) throw Ie("group");
        var qe = be();
        if (!he.test(qe)) throw Ie(qe, "name");
        var Xe = Z.lcFirst(qe);
        qe === Xe && (qe = Z.ucFirst(qe)), Me("=");
        var Ze = gt(be()),
          lt = new V(qe);
        lt.group = !0;
        var Rt = new B(Xe, Ze, qe, Ue);
        (Rt.filename = ve.filename),
          At(lt, function (It) {
            switch (It) {
              case "option":
                Zt(lt, It), Me(";");
                break;
              case "required":
              case "repeated":
                qt(lt, It);
                break;
              case "optional":
                oe === "proto3"
                  ? qt(lt, "proto3_optional")
                  : qt(lt, "optional");
                break;
              case "message":
                Fi(lt, It);
                break;
              case "enum":
                ki(lt, It);
                break;
              case "reserved":
                We(lt.reserved || (lt.reserved = []), !0);
                break;
              default:
                throw Ie(It);
            }
          }),
          Be.add(lt).add(Rt);
      }
      function Xn(Be) {
        Me("<");
        var Ue = be();
        if (X.mapKey[Ue] === void 0) throw Ie(Ue, "type");
        Me(",");
        var qe = be();
        if (!me.test(qe)) throw Ie(qe, "type");
        Me(">");
        var Xe = be();
        if (!he.test(Xe)) throw Ie(Xe, "name");
        Me("=");
        var Ze = new q(Ye(Xe), gt(be()), Ue, qe);
        At(
          Ze,
          function (Rt) {
            if (Rt === "option") Zt(Ze, Rt), Me(";");
            else throw Ie(Rt);
          },
          function () {
            rt(Ze);
          }
        ),
          Be.add(Ze);
      }
      function Ar(Be, Ue) {
        if (!he.test((Ue = be()))) throw Ie(Ue, "name");
        var qe = new $(Ye(Ue));
        At(qe, function (Ze) {
          Ze === "option"
            ? (Zt(qe, Ze), Me(";"))
            : (Le(Ze), qt(qe, "optional"));
        }),
          Be.add(qe);
      }
      function ki(Be, Ue) {
        if (!he.test((Ue = be()))) throw Ie(Ue, "name");
        var qe = new H(Ue);
        At(qe, function (Ze) {
          switch (Ze) {
            case "option":
              Zt(qe, Ze), Me(";");
              break;
            case "reserved":
              We(qe.reserved || (qe.reserved = []), !0),
                qe.reserved === void 0 && (qe.reserved = []);
              break;
            default:
              Pr(qe, Ze);
          }
        }),
          Be.add(qe),
          Be === De && Ge.push(qe);
      }
      function Pr(Be, Ue) {
        if (!he.test(Ue)) throw Ie(Ue, "name");
        Me("=");
        var qe = gt(be(), !0),
          Xe = { options: void 0 };
        (Xe.getOption = function (Ze) {
          return this.options[Ze];
        }),
          (Xe.setOption = function (Ze, lt) {
            Q.prototype.setOption.call(Xe, Ze, lt);
          }),
          (Xe.setParsedOption = function () {}),
          At(
            Xe,
            function (lt) {
              if (lt === "option") Zt(Xe, lt), Me(";");
              else throw Ie(lt);
            },
            function () {
              rt(Xe);
            }
          ),
          Be.add(Ue, qe, Xe.comment, Xe.parsedOptions || Xe.options);
      }
      function Zt(Be, Ue) {
        var qe,
          Xe,
          Ze = !0;
        for (Ue === "option" && (Ue = be()); Ue !== "="; ) {
          if (Ue === "(") {
            var lt = be();
            Me(")"), (Ue = "(" + lt + ")");
          }
          if (Ze) {
            if (((Ze = !1), Ue.includes(".") && !Ue.includes("("))) {
              var Rt = Ue.split(".");
              (qe = Rt[0] + "."), (Ue = Rt[1]);
              continue;
            }
            qe = Ue;
          } else Xe = Xe ? (Xe += Ue) : Ue;
          Ue = be();
        }
        var jt = Xe ? qe.concat(Xe) : qe,
          It = Ne(Be, jt);
        (Xe = Xe && Xe[0] === "." ? Xe.slice(1) : Xe),
          (qe = qe && qe[qe.length - 1] === "." ? qe.slice(0, -1) : qe),
          it(Be, qe, It, Xe);
      }
      function Ne(Be, Ue) {
        if (Me("{", !0)) {
          for (var qe = {}; !Me("}", !0); ) {
            if (!he.test((vt = be()))) throw Ie(vt, "name");
            if (vt === null) throw Ie(vt, "end of input");
            var Xe,
              Ze = vt;
            if ((Me(":", !0), Fe() === "{")) Xe = Ne(Be, Ue + "." + vt);
            else if (Fe() === "[") {
              Xe = [];
              var lt;
              if (Me("[", !0)) {
                do (lt = ct()), Xe.push(lt);
                while (Me(",", !0));
                Me("]"), typeof lt < "u" && Ke(Be, Ue + "." + vt, lt);
              }
            } else (Xe = ct()), Ke(Be, Ue + "." + vt, Xe);
            var Rt = qe[Ze];
            Rt && (Xe = [].concat(Rt).concat(Xe)),
              (qe[Ze] = Xe),
              Me(",", !0),
              Me(";", !0);
          }
          return qe;
        }
        var jt = ct();
        return Ke(Be, Ue, jt), jt;
      }
      function Ke(Be, Ue, qe) {
        if (De === Be && /^features\./.test(Ue)) {
          pe[Ue] = qe;
          return;
        }
        Be.setOption && Be.setOption(Ue, qe);
      }
      function it(Be, Ue, qe, Xe) {
        Be.setParsedOption && Be.setParsedOption(Ue, qe, Xe);
      }
      function rt(Be) {
        if (Me("[", !0)) {
          do Zt(Be, "option");
          while (Me(",", !0));
          Me("]");
        }
        return Be;
      }
      function bt(Be, Ue) {
        if (!he.test((Ue = be()))) throw Ie(Ue, "service name");
        var qe = new G(Ue);
        At(qe, function (Ze) {
          if (!Wn(qe, Ze))
            if (Ze === "rpc") en(qe, Ze);
            else throw Ie(Ze);
        }),
          Be.add(qe),
          Be === De && Ge.push(qe);
      }
      function en(Be, Ue) {
        var qe = je(),
          Xe = Ue;
        if (!he.test((Ue = be()))) throw Ie(Ue, "name");
        var Ze = Ue,
          lt,
          Rt,
          jt,
          It;
        if (
          (Me("("),
          Me("stream", !0) && (Rt = !0),
          !me.test((Ue = be())) ||
            ((lt = Ue),
            Me(")"),
            Me("returns"),
            Me("("),
            Me("stream", !0) && (It = !0),
            !me.test((Ue = be()))))
        )
          throw Ie(Ue);
        (jt = Ue), Me(")");
        var qi = new Y(Ze, Xe, lt, jt, Rt, It);
        (qi.comment = qe),
          At(qi, function (zi) {
            if (zi === "option") Zt(qi, zi), Me(";");
            else throw Ie(zi);
          }),
          Be.add(qi);
      }
      function Rn(Be, Ue) {
        if (!me.test((Ue = be()))) throw Ie(Ue, "reference");
        var qe = Ue;
        At(null, function (Ze) {
          switch (Ze) {
            case "required":
            case "repeated":
              qt(Be, Ze, qe);
              break;
            case "optional":
              oe === "proto3"
                ? qt(Be, "proto3_optional", qe)
                : qt(Be, "optional", qe);
              break;
            default:
              if (oe === "proto2" || !me.test(Ze)) throw Ie(Ze);
              Le(Ze), qt(Be, "optional", qe);
              break;
          }
        });
      }
      for (var vt; (vt = be()) !== null; )
        switch (vt) {
          case "package":
            if (!Te) throw Ie(vt);
            Jt();
            break;
          case "import":
            if (!Te) throw Ie(vt);
            nn();
            break;
          case "syntax":
            if (!Te) throw Ie(vt);
            gn();
            break;
          case "edition":
            if (!Te) throw Ie(vt);
            Bi();
            break;
          case "option":
            Zt(De, vt), Me(";", !0);
            break;
          default:
            if (Wn(De, vt)) {
              Te = !1;
              continue;
            }
            throw Ie(vt);
        }
      return (
        Qe(),
        (ve.filename = null),
        { package: xe, imports: He, weakImports: Je, root: Ee }
      );
    }
    return parse_1;
  }
  var common_1, hasRequiredCommon;
  function requireCommon() {
    if (hasRequiredCommon) return common_1;
    (hasRequiredCommon = 1), (common_1 = j);
    var U = /\/|\./;
    function j(B, q) {
      U.test(B) ||
        ((B = "google/protobuf/" + B + ".proto"),
        (q = { nested: { google: { nested: { protobuf: { nested: q } } } } })),
        (j[B] = q);
    }
    j("any", {
      Any: {
        fields: {
          type_url: { type: "string", id: 1 },
          value: { type: "bytes", id: 2 },
        },
      },
    });
    var V;
    return (
      j("duration", {
        Duration: (V = {
          fields: {
            seconds: { type: "int64", id: 1 },
            nanos: { type: "int32", id: 2 },
          },
        }),
      }),
      j("timestamp", { Timestamp: V }),
      j("empty", { Empty: { fields: {} } }),
      j("struct", {
        Struct: {
          fields: { fields: { keyType: "string", type: "Value", id: 1 } },
        },
        Value: {
          oneofs: {
            kind: {
              oneof: [
                "nullValue",
                "numberValue",
                "stringValue",
                "boolValue",
                "structValue",
                "listValue",
              ],
            },
          },
          fields: {
            nullValue: { type: "NullValue", id: 1 },
            numberValue: { type: "double", id: 2 },
            stringValue: { type: "string", id: 3 },
            boolValue: { type: "bool", id: 4 },
            structValue: { type: "Struct", id: 5 },
            listValue: { type: "ListValue", id: 6 },
          },
        },
        NullValue: { values: { NULL_VALUE: 0 } },
        ListValue: {
          fields: { values: { rule: "repeated", type: "Value", id: 1 } },
        },
      }),
      j("wrappers", {
        DoubleValue: { fields: { value: { type: "double", id: 1 } } },
        FloatValue: { fields: { value: { type: "float", id: 1 } } },
        Int64Value: { fields: { value: { type: "int64", id: 1 } } },
        UInt64Value: { fields: { value: { type: "uint64", id: 1 } } },
        Int32Value: { fields: { value: { type: "int32", id: 1 } } },
        UInt32Value: { fields: { value: { type: "uint32", id: 1 } } },
        BoolValue: { fields: { value: { type: "bool", id: 1 } } },
        StringValue: { fields: { value: { type: "string", id: 1 } } },
        BytesValue: { fields: { value: { type: "bytes", id: 1 } } },
      }),
      j("field_mask", {
        FieldMask: {
          fields: { paths: { rule: "repeated", type: "string", id: 1 } },
        },
      }),
      (j.get = function (q) {
        return j[q] || null;
      }),
      common_1
    );
  }
  var hasRequiredSrc;
  function requireSrc() {
    if (hasRequiredSrc) return src.exports;
    hasRequiredSrc = 1;
    var U = (src.exports = requireIndexLight());
    return (
      (U.build = "full"),
      (U.tokenize = requireTokenize()),
      (U.parse = requireParse()),
      (U.common = requireCommon()),
      U.Root._configure(U.Type, U.parse, U.common),
      src.exports
    );
  }
  var protobufjs, hasRequiredProtobufjs;
  function requireProtobufjs() {
    return (
      hasRequiredProtobufjs ||
        ((hasRequiredProtobufjs = 1), (protobufjs = requireSrc())),
      protobufjs
    );
  }
  var protobufjsExports = requireProtobufjs();
  const protobuf = getDefaultExportFromCjs$1(protobufjsExports);
  var extendStatics = function (U, j) {
    return (
      (extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (V, B) {
            V.__proto__ = B;
          }) ||
        function (V, B) {
          for (var q in B)
            Object.prototype.hasOwnProperty.call(B, q) && (V[q] = B[q]);
        }),
      extendStatics(U, j)
    );
  };
  function __extends(U, j) {
    if (typeof j != "function" && j !== null)
      throw new TypeError(
        "Class extends value " + String(j) + " is not a constructor or null"
      );
    extendStatics(U, j);
    function V() {
      this.constructor = U;
    }
    U.prototype =
      j === null ? Object.create(j) : ((V.prototype = j.prototype), new V());
  }
  var __assign = function () {
    return (
      (__assign =
        Object.assign ||
        function (j) {
          for (var V, B = 1, q = arguments.length; B < q; B++) {
            V = arguments[B];
            for (var $ in V)
              Object.prototype.hasOwnProperty.call(V, $) && (j[$] = V[$]);
          }
          return j;
        }),
      __assign.apply(this, arguments)
    );
  };
  function __awaiter(U, j, V, B) {
    function q($) {
      return $ instanceof V
        ? $
        : new V(function (H) {
            H($);
          });
    }
    return new (V || (V = Promise))(function ($, H) {
      function G(X) {
        try {
          Q(B.next(X));
        } catch (Z) {
          H(Z);
        }
      }
      function Y(X) {
        try {
          Q(B.throw(X));
        } catch (Z) {
          H(Z);
        }
      }
      function Q(X) {
        X.done ? $(X.value) : q(X.value).then(G, Y);
      }
      Q((B = B.apply(U, j || [])).next());
    });
  }
  function __generator(U, j) {
    var V = {
        label: 0,
        sent: function () {
          if ($[0] & 1) throw $[1];
          return $[1];
        },
        trys: [],
        ops: [],
      },
      B,
      q,
      $,
      H;
    return (
      (H = { next: G(0), throw: G(1), return: G(2) }),
      typeof Symbol == "function" &&
        (H[Symbol.iterator] = function () {
          return this;
        }),
      H
    );
    function G(Q) {
      return function (X) {
        return Y([Q, X]);
      };
    }
    function Y(Q) {
      if (B) throw new TypeError("Generator is already executing.");
      for (; H && ((H = 0), Q[0] && (V = 0)), V; )
        try {
          if (
            ((B = 1),
            q &&
              ($ =
                Q[0] & 2
                  ? q.return
                  : Q[0]
                  ? q.throw || (($ = q.return) && $.call(q), 0)
                  : q.next) &&
              !($ = $.call(q, Q[1])).done)
          )
            return $;
          switch (((q = 0), $ && (Q = [Q[0] & 2, $.value]), Q[0])) {
            case 0:
            case 1:
              $ = Q;
              break;
            case 4:
              return V.label++, { value: Q[1], done: !1 };
            case 5:
              V.label++, (q = Q[1]), (Q = [0]);
              continue;
            case 7:
              (Q = V.ops.pop()), V.trys.pop();
              continue;
            default:
              if (
                (($ = V.trys),
                !($ = $.length > 0 && $[$.length - 1]) &&
                  (Q[0] === 6 || Q[0] === 2))
              ) {
                V = 0;
                continue;
              }
              if (Q[0] === 3 && (!$ || (Q[1] > $[0] && Q[1] < $[3]))) {
                V.label = Q[1];
                break;
              }
              if (Q[0] === 6 && V.label < $[1]) {
                (V.label = $[1]), ($ = Q);
                break;
              }
              if ($ && V.label < $[2]) {
                (V.label = $[2]), V.ops.push(Q);
                break;
              }
              $[2] && V.ops.pop(), V.trys.pop();
              continue;
          }
          Q = j.call(U, V);
        } catch (X) {
          (Q = [6, X]), (q = 0);
        } finally {
          B = $ = 0;
        }
      if (Q[0] & 5) throw Q[1];
      return { value: Q[0] ? Q[1] : void 0, done: !0 };
    }
  }
  typeof SuppressedError == "function" && SuppressedError;
  var options = { syntax: "proto3" },
    nested = {
      pipecat: {
        nested: {
          TextFrame: {
            fields: {
              id: { type: "uint64", id: 1 },
              name: { type: "string", id: 2 },
              text: { type: "string", id: 3 },
            },
          },
          AudioRawFrame: {
            fields: {
              id: { type: "uint64", id: 1 },
              name: { type: "string", id: 2 },
              audio: { type: "bytes", id: 3 },
              sampleRate: { type: "uint32", id: 4 },
              numChannels: { type: "uint32", id: 5 },
            },
          },
          TranscriptionFrame: {
            fields: {
              id: { type: "uint64", id: 1 },
              name: { type: "string", id: 2 },
              text: { type: "string", id: 3 },
              userId: { type: "string", id: 4 },
              timestamp: { type: "string", id: 5 },
            },
          },
          Frame: {
            oneofs: { frame: { oneof: ["text", "audio", "transcription"] } },
            fields: {
              text: { type: "TextFrame", id: 1 },
              audio: { type: "AudioRawFrame", id: 2 },
              transcription: { type: "TranscriptionFrame", id: 3 },
            },
          },
        },
      },
    },
    jsonDescriptor = { options, nested },
    ConnectionQuality;
  (function (U) {
    (U.UNKNOWN = "UNKNOWN"), (U.GOOD = "GOOD"), (U.BAD = "BAD");
  })(ConnectionQuality || (ConnectionQuality = {}));
  var AbstractConnectionQualityIndicator = (function () {
    function U(j) {
      (this._connectionQuality = ConnectionQuality.UNKNOWN),
        (this.onConnectionQualityChanged = j);
    }
    return (
      Object.defineProperty(U.prototype, "connectionQuality", {
        get: function () {
          return this._connectionQuality;
        },
        enumerable: !1,
        configurable: !0,
      }),
      (U.prototype.handleStatsChanged = function () {
        var j = this.calculateConnectionQuality();
        j !== this._connectionQuality &&
          ((this._connectionQuality = j), this.onConnectionQualityChanged(j));
      }),
      (U.prototype.start = function (j) {
        this.stop(!0), this._start(j);
      }),
      (U.prototype.stop = function (j) {
        j === void 0 && (j = !1),
          this._stop(),
          (this._connectionQuality = ConnectionQuality.UNKNOWN),
          j || this.onConnectionQualityChanged(ConnectionQuality.UNKNOWN);
      }),
      U
    );
  })();
  function QualityIndicatorMixer() {
    for (var U = [], j = 0; j < arguments.length; j++) U[j] = arguments[j];
    var V = (function (B) {
      __extends(q, B);
      function q($) {
        var H = B.call(this, $) || this;
        return (
          (H.childTrackers = U.map(function (G) {
            var Y = G.getParams,
              Q = G.TrackerClass;
            return {
              tracker: new Q(function () {
                return H.handleStatsChanged();
              }),
              getParams: Y,
            };
          })),
          H
        );
      }
      return (
        (q.prototype.calculateConnectionQuality = function () {
          var $ = this.childTrackers.map(function (H) {
            var G = H.tracker;
            return G.connectionQuality;
          });
          return $.some(function (H) {
            return H === ConnectionQuality.BAD;
          })
            ? ConnectionQuality.BAD
            : $.every(function (H) {
                return H === ConnectionQuality.UNKNOWN;
              })
            ? ConnectionQuality.UNKNOWN
            : ConnectionQuality.GOOD;
        }),
        (q.prototype._start = function ($) {
          this.childTrackers.forEach(function (H) {
            var G = H.tracker,
              Y = H.getParams;
            return G.start(Y($));
          });
        }),
        (q.prototype._stop = function () {
          this.childTrackers.forEach(function ($) {
            var H = $.tracker;
            return H.stop(!0);
          });
        }),
        q
      );
    })(AbstractConnectionQualityIndicator);
    return V;
  }
  var LiveKitConnectionQualityIndicator = (function (U) {
      __extends(j, U);
      function j() {
        var V = (U !== null && U.apply(this, arguments)) || this;
        return (
          (V.room = null),
          (V.liveKitConnectionQuality = ConnectionQuality$2.Unknown),
          (V.liveKitConnectionState = null),
          (V.handleConnectionQualityChanged = function (B) {
            (V.liveKitConnectionQuality = B), V.handleStatsChanged();
          }),
          (V.handleConnectionStateChanged = function (B) {
            (V.liveKitConnectionState = B), V.handleStatsChanged();
          }),
          V
        );
      }
      return (
        (j.prototype._start = function (V) {
          (this.room = V),
            this.room.localParticipant.on(
              ParticipantEvent.ConnectionQualityChanged,
              this.handleConnectionQualityChanged
            ),
            this.room.on(
              RoomEvent.ConnectionStateChanged,
              this.handleConnectionStateChanged
            );
        }),
        (j.prototype._stop = function () {
          this.room &&
            (this.room.localParticipant.off(
              RoomEvent.ConnectionQualityChanged,
              this.handleConnectionQualityChanged
            ),
            this.room.off(
              RoomEvent.ConnectionStateChanged,
              this.handleConnectionStateChanged
            ));
        }),
        (j.prototype.calculateConnectionQuality = function () {
          return [ConnectionQuality$2.Lost, ConnectionQuality$2.Poor].includes(
            this.liveKitConnectionQuality
          ) ||
            (this.liveKitConnectionState &&
              [
                ConnectionState.Disconnected,
                ConnectionState.Reconnecting,
                ConnectionState.SignalReconnecting,
              ].includes(this.liveKitConnectionState))
            ? ConnectionQuality.BAD
            : ConnectionQuality.GOOD;
        }),
        j
      );
    })(AbstractConnectionQualityIndicator),
    t,
    e,
    s,
    n;
  function r() {}
  function o() {
    o.init.call(this);
  }
  function i(U) {
    return U._maxListeners === void 0 ? o.defaultMaxListeners : U._maxListeners;
  }
  function a(U, j, V) {
    if (j) U.call(V);
    else for (var B = U.length, q = m(U, B), $ = 0; $ < B; ++$) q[$].call(V);
  }
  function c(U, j, V, B) {
    if (j) U.call(V, B);
    else for (var q = U.length, $ = m(U, q), H = 0; H < q; ++H) $[H].call(V, B);
  }
  function d(U, j, V, B, q) {
    if (j) U.call(V, B, q);
    else
      for (var $ = U.length, H = m(U, $), G = 0; G < $; ++G) H[G].call(V, B, q);
  }
  function u(U, j, V, B, q, $) {
    if (j) U.call(V, B, q, $);
    else
      for (var H = U.length, G = m(U, H), Y = 0; Y < H; ++Y)
        G[Y].call(V, B, q, $);
  }
  function h(U, j, V, B) {
    if (j) U.apply(V, B);
    else
      for (var q = U.length, $ = m(U, q), H = 0; H < q; ++H) $[H].apply(V, B);
  }
  function l(U, j, V, B) {
    var q, $, H, G;
    if (typeof V != "function")
      throw new TypeError('"listener" argument must be a function');
    if (
      (($ = U._events)
        ? ($.newListener &&
            (U.emit("newListener", j, V.listener ? V.listener : V),
            ($ = U._events)),
          (H = $[j]))
        : (($ = U._events = new r()), (U._eventsCount = 0)),
      H)
    ) {
      if (
        (typeof H == "function"
          ? (H = $[j] = B ? [V, H] : [H, V])
          : B
          ? H.unshift(V)
          : H.push(V),
        !H.warned && (q = i(U)) && q > 0 && H.length > q)
      ) {
        H.warned = !0;
        var Y = new Error(
          "Possible EventEmitter memory leak detected. " +
            H.length +
            " " +
            j +
            " listeners added. Use emitter.setMaxListeners() to increase limit"
        );
        (Y.name = "MaxListenersExceededWarning"),
          (Y.emitter = U),
          (Y.type = j),
          (Y.count = H.length),
          (G = Y),
          typeof console.warn == "function" ? console.warn(G) : console.log(G);
      }
    } else (H = $[j] = V), ++U._eventsCount;
    return U;
  }
  function p(U, j, V) {
    var B = !1;
    function q() {
      U.removeListener(j, q), B || ((B = !0), V.apply(U, arguments));
    }
    return (q.listener = V), q;
  }
  function f(U) {
    var j = this._events;
    if (j) {
      var V = j[U];
      if (typeof V == "function") return 1;
      if (V) return V.length;
    }
    return 0;
  }
  function m(U, j) {
    for (var V = new Array(j); j--; ) V[j] = U[j];
    return V;
  }
  (r.prototype = Object.create(null)),
    (o.EventEmitter = o),
    (o.usingDomains = !1),
    (o.prototype.domain = void 0),
    (o.prototype._events = void 0),
    (o.prototype._maxListeners = void 0),
    (o.defaultMaxListeners = 10),
    (o.init = function () {
      (this.domain = null),
        o.usingDomains && (void 0).active,
        (this._events &&
          this._events !== Object.getPrototypeOf(this)._events) ||
          ((this._events = new r()), (this._eventsCount = 0)),
        (this._maxListeners = this._maxListeners || void 0);
    }),
    (o.prototype.setMaxListeners = function (U) {
      if (typeof U != "number" || U < 0 || isNaN(U))
        throw new TypeError('"n" argument must be a positive number');
      return (this._maxListeners = U), this;
    }),
    (o.prototype.getMaxListeners = function () {
      return i(this);
    }),
    (o.prototype.emit = function (U) {
      var j,
        V,
        B,
        q,
        $,
        H,
        G,
        Y = U === "error";
      if ((H = this._events)) Y = Y && H.error == null;
      else if (!Y) return !1;
      if (((G = this.domain), Y)) {
        if (((j = arguments[1]), !G)) {
          if (j instanceof Error) throw j;
          var Q = new Error('Uncaught, unspecified "error" event. (' + j + ")");
          throw ((Q.context = j), Q);
        }
        return (
          j || (j = new Error('Uncaught, unspecified "error" event')),
          (j.domainEmitter = this),
          (j.domain = G),
          (j.domainThrown = !1),
          G.emit("error", j),
          !1
        );
      }
      if (!(V = H[U])) return !1;
      var X = typeof V == "function";
      switch ((B = arguments.length)) {
        case 1:
          a(V, X, this);
          break;
        case 2:
          c(V, X, this, arguments[1]);
          break;
        case 3:
          d(V, X, this, arguments[1], arguments[2]);
          break;
        case 4:
          u(V, X, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          for (q = new Array(B - 1), $ = 1; $ < B; $++) q[$ - 1] = arguments[$];
          h(V, X, this, q);
      }
      return !0;
    }),
    (o.prototype.addListener = function (U, j) {
      return l(this, U, j, !1);
    }),
    (o.prototype.on = o.prototype.addListener),
    (o.prototype.prependListener = function (U, j) {
      return l(this, U, j, !0);
    }),
    (o.prototype.once = function (U, j) {
      if (typeof j != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.on(U, p(this, U, j)), this;
    }),
    (o.prototype.prependOnceListener = function (U, j) {
      if (typeof j != "function")
        throw new TypeError('"listener" argument must be a function');
      return this.prependListener(U, p(this, U, j)), this;
    }),
    (o.prototype.removeListener = function (U, j) {
      var V, B, q, $, H;
      if (typeof j != "function")
        throw new TypeError('"listener" argument must be a function');
      if (!(B = this._events)) return this;
      if (!(V = B[U])) return this;
      if (V === j || (V.listener && V.listener === j))
        --this._eventsCount == 0
          ? (this._events = new r())
          : (delete B[U],
            B.removeListener &&
              this.emit("removeListener", U, V.listener || j));
      else if (typeof V != "function") {
        for (q = -1, $ = V.length; $-- > 0; )
          if (V[$] === j || (V[$].listener && V[$].listener === j)) {
            (H = V[$].listener), (q = $);
            break;
          }
        if (q < 0) return this;
        if (V.length === 1) {
          if (((V[0] = void 0), --this._eventsCount == 0))
            return (this._events = new r()), this;
          delete B[U];
        } else
          (function (G, Y) {
            for (var Q = Y, X = Q + 1, Z = G.length; X < Z; Q += 1, X += 1)
              G[Q] = G[X];
            G.pop();
          })(V, q);
        B.removeListener && this.emit("removeListener", U, H || j);
      }
      return this;
    }),
    (o.prototype.off = function (U, j) {
      return this.removeListener(U, j);
    }),
    (o.prototype.removeAllListeners = function (U) {
      var j, V;
      if (!(V = this._events)) return this;
      if (!V.removeListener)
        return (
          arguments.length === 0
            ? ((this._events = new r()), (this._eventsCount = 0))
            : V[U] &&
              (--this._eventsCount == 0
                ? (this._events = new r())
                : delete V[U]),
          this
        );
      if (arguments.length === 0) {
        for (var B, q = Object.keys(V), $ = 0; $ < q.length; ++$)
          (B = q[$]) !== "removeListener" && this.removeAllListeners(B);
        return (
          this.removeAllListeners("removeListener"),
          (this._events = new r()),
          (this._eventsCount = 0),
          this
        );
      }
      if (typeof (j = V[U]) == "function") this.removeListener(U, j);
      else if (j)
        do this.removeListener(U, j[j.length - 1]);
        while (j[0]);
      return this;
    }),
    (o.prototype.listeners = function (U) {
      var j,
        V = this._events;
      return V && (j = V[U])
        ? typeof j == "function"
          ? [j.listener || j]
          : (function (B) {
              for (var q = new Array(B.length), $ = 0; $ < q.length; ++$)
                q[$] = B[$].listener || B[$];
              return q;
            })(j)
        : [];
    }),
    (o.listenerCount = function (U, j) {
      return typeof U.listenerCount == "function"
        ? U.listenerCount(j)
        : f.call(U, j);
    }),
    (o.prototype.listenerCount = f),
    (o.prototype.eventNames = function () {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    });
  class g extends o {}
  (function (U) {
    (U.Issue = "issue"),
      (U.NetworkScoresUpdated = "network-scores-updated"),
      (U.StatsParsingFinished = "stats-parsing-finished");
  })(t || (t = {})),
    (function (U) {
      (U.Network = "network"),
        (U.CPU = "cpu"),
        (U.Server = "server"),
        (U.Stream = "stream");
    })(e || (e = {})),
    (function (U) {
      (U.OutboundNetworkQuality = "outbound-network-quality"),
        (U.InboundNetworkQuality = "inbound-network-quality"),
        (U.OutboundNetworkMediaLatency = "outbound-network-media-latency"),
        (U.InboundNetworkMediaLatency = "inbound-network-media-latency"),
        (U.NetworkMediaSyncFailure = "network-media-sync-failure"),
        (U.OutboundNetworkThroughput = "outbound-network-throughput"),
        (U.InboundNetworkThroughput = "inbound-network-throughput"),
        (U.EncoderCPUThrottling = "encoder-cpu-throttling"),
        (U.DecoderCPUThrottling = "decoder-cpu-throttling"),
        (U.ServerIssue = "server-issue"),
        (U.UnknownVideoDecoderIssue = "unknown-video-decoder"),
        (U.LowInboundMOS = "low-inbound-mean-opinion-score"),
        (U.LowOutboundMOS = "low-outbound-mean-opinion-score"),
        (U.FrozenVideoTrack = "frozen-video-track"),
        (U.MissingVideoStreamData = "missing-video-stream-data"),
        (U.MissingAudioStreamData = "missing-audio-stream-data");
    })(s || (s = {})),
    (function (U) {
      (U[(U.BAD = 2.1)] = "BAD"),
        (U[(U.POOR = 2.6)] = "POOR"),
        (U[(U.FAIR = 3.1)] = "FAIR"),
        (U[(U.GOOD = 3.8)] = "GOOD"),
        (U[(U.EXCELLENT = 4.3)] = "EXCELLENT");
    })(n || (n = {}));
  class S extends o {
    static STATS_REPORT_READY_EVENT = "stats-report-ready";
    static STATS_REPORTS_PARSED = "stats-reports-parsed";
    isStopped = !1;
    reportTimer;
    getStatsInterval;
    compositeStatsParser;
    constructor(j) {
      super(),
        (this.compositeStatsParser = j.compositeStatsParser),
        (this.getStatsInterval = j.getStatsInterval ?? 1e4);
    }
    get isRunning() {
      return !!this.reportTimer && !this.isStopped;
    }
    startReporting() {
      if (this.reportTimer) return;
      const j = () =>
        setTimeout(() => {
          this.isStopped
            ? (this.reportTimer = void 0)
            : this.parseReports().finally(() => {
                this.reportTimer = j();
              });
        }, this.getStatsInterval);
      (this.isStopped = !1), (this.reportTimer = j());
    }
    stopReporting() {
      (this.isStopped = !0),
        this.reportTimer &&
          (clearTimeout(this.reportTimer), (this.reportTimer = void 0));
    }
    async parseReports() {
      const j = Date.now(),
        V = await this.compositeStatsParser.parse(),
        B = Date.now() - j;
      this.emit(S.STATS_REPORTS_PARSED, { timeTaken: B, reportItems: V }),
        V.forEach((q) => {
          this.emit(S.STATS_REPORT_READY_EVENT, q);
        });
    }
  }
  const v = (() => {
    const U = new Map();
    return (j) => {
      const { taskId: V, delayMs: B, maxJitterMs: q, callback: $ } = j,
        H = Math.ceil(Math.random() * (q || 0)),
        G = U.get(V);
      G && clearTimeout(G);
      const Y = setTimeout(() => {
        $(), U.delete(V);
      }, B + H);
      U.set(V, Y);
    };
  })();
  class k {
    #e = {};
    calculate(j) {
      const {
          connection: { id: V },
        } = j,
        { mos: B, stats: q } = this.calculateOutboundScore(j) || {},
        { mos: $, stats: H } = this.calculateInboundScore(j) || {};
      return (
        (this.#e[V] = j),
        v({ taskId: V, delayMs: 35e3, callback: () => delete this.#e[V] }),
        {
          outbound: B,
          inbound: $,
          connectionId: V,
          statsSamples: { inboundStatsSample: H, outboundStatsSample: q },
        }
      );
    }
    calculateOutboundScore(j) {
      const V = [
        ...(j.remote?.audio.inbound || []),
        ...(j.remote?.video.inbound || []),
      ];
      if (!V.length) return;
      const B = this.#e[j.connection.id];
      if (!B) return;
      const q = [
          ...(B.remote?.audio.inbound || []),
          ...(B.remote?.video.inbound || []),
        ],
        { packetsSent: $ } = j.connection,
        H = B.connection.packetsSent,
        G = V.reduce(
          (ae, se) => {
            const fe = q.find((ce) => ce.ssrc === se.ssrc);
            return {
              sumJitter: ae.sumJitter + se.jitter,
              packetsLost: ae.packetsLost + se.packetsLost,
              lastPacketsLost: ae.lastPacketsLost + (fe?.packetsLost || 0),
            };
          },
          { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
        ),
        Y = 1e3 * j.connection.currentRoundTripTime || 0,
        { sumJitter: Q } = G,
        X = Q / V.length,
        Z = $ - H,
        te = G.packetsLost - G.lastPacketsLost,
        ne = Z && te ? Math.round((100 * te) / (Z + te)) : 0;
      return {
        mos: this.calculateMOS({ avgJitter: X, rtt: Y, packetsLoss: ne }),
        stats: { avgJitter: X, rtt: Y, packetsLoss: ne },
      };
    }
    calculateInboundScore(j) {
      const V = [...j.audio?.inbound, ...j.video?.inbound];
      if (!V.length) return;
      const B = this.#e[j.connection.id];
      if (!B) return;
      const q = [...B.video?.inbound, ...B.audio?.inbound],
        { packetsReceived: $ } = j.connection,
        H = B.connection.packetsReceived,
        G = V.reduce(
          (ae, se) => {
            const fe = q.find((ce) => ce.ssrc === se.ssrc);
            return {
              sumJitter: ae.sumJitter + se.jitter,
              packetsLost: ae.packetsLost + se.packetsLost,
              lastPacketsLost: ae.lastPacketsLost + (fe?.packetsLost || 0),
            };
          },
          { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
        ),
        Y = 1e3 * j.connection.currentRoundTripTime || 0,
        { sumJitter: Q } = G,
        X = Q / V.length,
        Z = $ - H,
        te = G.packetsLost - G.lastPacketsLost,
        ne = Z && te ? Math.round((100 * te) / (Z + te)) : 0;
      return {
        mos: this.calculateMOS({ avgJitter: X, rtt: Y, packetsLoss: ne }),
        stats: { avgJitter: X, rtt: Y, packetsLoss: ne },
      };
    }
    calculateMOS({ avgJitter: j, rtt: V, packetsLoss: B }) {
      const q = V + 2 * j + 10;
      let $ = q < 160 ? 93.2 - q / 40 : 93.2 - q / 120 - 10;
      return ($ -= 2.5 * B), 1 + 0.035 * $ + 7e-6 * $ * ($ - 60) * (100 - $);
    }
  }
  class y {
    #e = new Map();
    #t;
    #n;
    constructor(j = {}) {
      (this.#t = j.statsCleanupTtlMs ?? 35e3),
        (this.#n = j.maxParsedStatsStorageSize ?? 5);
    }
    detect(j, V) {
      const B = {
          ...j,
          networkScores: { ...V, statsSamples: V?.statsSamples || {} },
        },
        q = this.performDetection(B);
      return (
        this.setLastProcessedStats(j.connection.id, B),
        this.performPrevStatsCleanup({ connectionId: j.connection.id }),
        q
      );
    }
    performPrevStatsCleanup(j) {
      const { connectionId: V, cleanupCallback: B } = j;
      this.#e.has(V) &&
        v({
          taskId: V,
          delayMs: this.#t,
          callback: () => {
            this.deleteLastProcessedStats(V), typeof B == "function" && B();
          },
        });
    }
    setLastProcessedStats(j, V) {
      if (!j || V.connection.id !== j) return;
      const B = this.#e.get(j) ?? [];
      B.push(V), B.length > this.#n && B.shift(), this.#e.set(j, B);
    }
    getLastProcessedStats(j) {
      const V = this.#e.get(j);
      return V?.[V.length - 1];
    }
    getAllLastProcessedStats(j) {
      return this.#e.get(j) ?? [];
    }
    deleteLastProcessedStats(j) {
      this.#e.delete(j);
    }
  }
  class w extends y {
    #e;
    constructor(j = {}) {
      super(j), (this.#e = j.availableOutgoingBitrateThreshold ?? 1e5);
    }
    performDetection(j) {
      const V = [],
        { availableOutgoingBitrate: B } = j.connection;
      if (B === void 0) return V;
      const q = j.audio.outbound.reduce((G, Y) => G + Y.targetBitrate, 0),
        $ = j.video.outbound.reduce((G, Y) => G + Y.bitrate, 0);
      if (!q && !$) return V;
      const H = {
        availableOutgoingBitrate: B,
        videoStreamsTotalBitrate: $,
        audioStreamsTotalTargetBitrate: q,
      };
      return (
        (q > B || ($ > 0 && B < this.#e)) &&
          V.push({
            statsSample: H,
            type: e.Network,
            reason: s.OutboundNetworkThroughput,
          }),
        V
      );
    }
  }
  class b extends y {
    #e;
    #t;
    #n;
    #i;
    constructor(j = {}) {
      super(),
        (this.#e = j.highPacketLossThresholdPct ?? 5),
        (this.#t = j.highJitterThreshold ?? 200),
        (this.#n = j.highJitterBufferDelayThresholdMs ?? 500),
        (this.#i = j.highRttThresholdMs ?? 250);
    }
    performDetection(j) {
      return this.processData(j);
    }
    processData(j) {
      const V = [],
        B = [...j.audio?.inbound, ...j.video?.inbound];
      if (!B.length) return V;
      const q = this.getLastProcessedStats(j.connection.id);
      if (!q) return V;
      const $ = [...q.video?.inbound, ...q.audio?.inbound],
        { packetsReceived: H } = j.connection,
        G = q.connection.packetsReceived,
        Y = B.reduce(
          (Re, Ae) => {
            const be = $.find((xe) => xe.ssrc === Ae.ssrc),
              Le = be?.jitterBufferDelay || 0,
              Fe = be?.jitterBufferEmittedCount || 0,
              Me = Ae.jitterBufferDelay - Le,
              je = Ae.jitterBufferEmittedCount - Fe,
              Te = Me && je ? (1e3 * Me) / je : 0;
            return {
              sumJitter: Re.sumJitter + Ae.jitter,
              sumJitterBufferDelayMs: Re.sumJitterBufferDelayMs + Te,
              packetsLost: Re.packetsLost + Ae.packetsLost,
              lastPacketsLost: Re.lastPacketsLost + (be?.packetsLost || 0),
            };
          },
          {
            sumJitter: 0,
            sumJitterBufferDelayMs: 0,
            packetsLost: 0,
            lastPacketsLost: 0,
          }
        ),
        Q = 1e3 * j.connection.currentRoundTripTime || 0,
        { sumJitter: X, sumJitterBufferDelayMs: Z } = Y,
        te = X / B.length,
        ne = Z / B.length,
        ae = H - G,
        se = Y.packetsLost - Y.lastPacketsLost,
        fe = ae && se ? Math.round((100 * se) / (ae + se)) : 0,
        ce = fe > this.#e,
        ue = te >= this.#t,
        he = Q >= this.#i,
        me = ne > this.#n,
        ve = he && !ue && !ce,
        ge = ce && ue,
        Ee = ue && me,
        Ce = {
          rtt: Q,
          packetLossPct: fe,
          avgJitter: te,
          avgJitterBufferDelay: ne,
        };
      return (
        (ue || ce) &&
          V.push({
            statsSample: Ce,
            type: e.Network,
            reason: s.InboundNetworkQuality,
            iceCandidate: j.connection.local.id,
          }),
        ve &&
          V.push({
            statsSample: Ce,
            type: e.Server,
            reason: s.ServerIssue,
            iceCandidate: j.connection.remote.id,
          }),
        ge &&
          V.push({
            statsSample: Ce,
            type: e.Network,
            reason: s.InboundNetworkMediaLatency,
            iceCandidate: j.connection.local.id,
          }),
        Ee &&
          V.push({
            statsSample: Ce,
            type: e.Network,
            reason: s.NetworkMediaSyncFailure,
            iceCandidate: j.connection.local.id,
          }),
        V
      );
    }
  }
  class P extends y {
    #e;
    constructor(j = {}) {
      super(), (this.#e = j.correctedSamplesThresholdPct ?? 5);
    }
    performDetection(j) {
      return this.processData(j);
    }
    processData(j) {
      const V = j.audio.inbound,
        B = [],
        q = this.getLastProcessedStats(j.connection.id)?.audio.inbound;
      return (
        q &&
          V.forEach(($) => {
            const H = q.find((ne) => ne.ssrc === $.ssrc);
            if (!H) return;
            const G =
                $.track.insertedSamplesForDeceleration +
                $.track.removedSamplesForAcceleration,
              Y =
                H.track.insertedSamplesForDeceleration +
                H.track.removedSamplesForAcceleration;
            if (G === Y) return;
            const Q =
                $.track.totalSamplesReceived - H.track.totalSamplesReceived,
              X = G - Y,
              Z = Math.round((100 * X) / Q),
              te = { correctedSamplesPct: Z };
            Z > this.#e &&
              B.push({
                statsSample: te,
                type: e.Network,
                reason: s.NetworkMediaSyncFailure,
                ssrc: $.ssrc,
              });
          }),
        B
      );
    }
  }
  class T extends y {
    #e;
    #t;
    constructor(j = {}) {
      super(),
        (this.#e = j.highPacketLossThresholdPct ?? 5),
        (this.#t = j.highJitterThreshold ?? 200);
    }
    performDetection(j) {
      return this.processData(j);
    }
    processData(j) {
      const V = [],
        B = [
          ...(j.remote?.audio.inbound || []),
          ...(j.remote?.video.inbound || []),
        ];
      if (!B.length) return V;
      const q = this.getLastProcessedStats(j.connection.id);
      if (!q) return V;
      const $ = [
          ...(q.remote?.audio.inbound || []),
          ...(q.remote?.video.inbound || []),
        ],
        { packetsSent: H } = j.connection,
        G = q.connection.packetsSent,
        Y = B.reduce(
          (he, me) => {
            const ve = $.find((ge) => ge.ssrc === me.ssrc);
            return {
              sumJitter: he.sumJitter + me.jitter,
              packetsLost: he.packetsLost + me.packetsLost,
              lastPacketsLost: he.lastPacketsLost + (ve?.packetsLost || 0),
            };
          },
          { sumJitter: 0, packetsLost: 0, lastPacketsLost: 0 }
        ),
        Q = 1e3 * j.connection.currentRoundTripTime || 0,
        { sumJitter: X } = Y,
        Z = X / B.length,
        te = H - G,
        ne = Y.packetsLost - Y.lastPacketsLost,
        ae = te && ne ? Math.round((100 * ne) / (te + ne)) : 0,
        se = ae > this.#e,
        fe = Z >= this.#t,
        ce = (!se && fe) || fe || se,
        ue = { rtt: Q, avgJitter: Z, packetLossPct: ae };
      return (
        se &&
          fe &&
          V.push({
            statsSample: ue,
            type: e.Network,
            reason: s.OutboundNetworkMediaLatency,
            iceCandidate: j.connection.local.id,
          }),
        ce &&
          V.push({
            statsSample: ue,
            type: e.Network,
            reason: s.OutboundNetworkQuality,
            iceCandidate: j.connection.local.id,
          }),
        V
      );
    }
  }
  class L extends y {
    performDetection(j) {
      return this.processData(j);
    }
    processData(j) {
      const V = j.video.outbound.filter(
          ($) => $.qualityLimitationReason !== "none"
        ),
        B = [],
        q = this.getLastProcessedStats(j.connection.id)?.video.outbound;
      return (
        q &&
          V.forEach(($) => {
            const H = q.find((Y) => Y.ssrc === $.ssrc);
            if (!H) return;
            const G = { qualityLimitationReason: $.qualityLimitationReason };
            $.framesSent > H.framesSent ||
              ($.qualityLimitationReason === "cpu" &&
                B.push({
                  statsSample: G,
                  type: e.CPU,
                  reason: s.EncoderCPUThrottling,
                  ssrc: $.ssrc,
                }),
              $.qualityLimitationReason === "bandwidth" &&
                B.push({
                  statsSample: G,
                  type: e.Network,
                  reason: s.OutboundNetworkThroughput,
                  ssrc: $.ssrc,
                }));
          }),
        B
      );
    }
  }
  class D extends y {
    UNKNOWN_DECODER = "unknown";
    #e = {};
    performDetection(j) {
      return this.processData(j);
    }
    performPrevStatsCleanup(j) {
      const { connectionId: V, cleanupCallback: B } = j;
      super.performPrevStatsCleanup({
        ...j,
        cleanupCallback: () => {
          delete this.#e[V], typeof B == "function" && B();
        },
      });
    }
    processData(j) {
      const V = [],
        { id: B } = j.connection,
        q = this.getLastProcessedStats(B)?.video.inbound;
      return (
        j.video.inbound.forEach(($) => {
          const { decoderImplementation: H, ssrc: G } = $;
          if (q?.find((Q) => Q.ssrc === G))
            if (H === this.UNKNOWN_DECODER) {
              if (!this.hadLastDecoderWithIssue(B, G)) {
                this.setLastDecoderWithIssue(B, G, this.UNKNOWN_DECODER);
                const Q = { mimeType: $.mimeType, decoderImplementation: H };
                V.push({
                  ssrc: G,
                  statsSample: Q,
                  type: e.Stream,
                  reason: s.UnknownVideoDecoderIssue,
                  trackIdentifier: $.track.trackIdentifier,
                });
              }
            } else this.setLastDecoderWithIssue(B, G, void 0);
        }),
        V
      );
    }
    setLastDecoderWithIssue(j, V, B) {
      const q = this.#e[j] ?? {};
      B === void 0 ? delete q[V] : (q[V] = B), (this.#e[j] = q);
    }
    hadLastDecoderWithIssue(j, V) {
      const B = this.#e[j];
      return (B && B[V]) === this.UNKNOWN_DECODER;
    }
  }
  const C = (U) => U.reduce((j, V) => j + V, 0) / U.length,
    R = (U, j, V = 30) => {
      const B = [];
      for (let q = 1; q < j.length - 1; q += 1) {
        const $ = j[q]?.video?.inbound.find((Q) => Q.ssrc === U);
        if (!$) continue;
        const H = j[q - 1]?.video?.inbound?.find((Q) => Q.ssrc === U);
        if (!$ || !H) continue;
        const G = $.timestamp - H.timestamp,
          Y = $.framesDecoded - H.framesDecoded;
        if (Y > 0) {
          const Q = G / Y;
          B.push(Q);
        }
      }
      return B.length <= 1
        ? !1
        : ((q) => {
            const $ = ((H, G) =>
              G.reduce((Y, Q) => Y + (Q - H) ** 2, 0) / G.length)(C(q), q);
            return Math.sqrt($);
          })(B) > V;
    },
    M = (U, j) => {
      for (let V = 1; V < j.length; V += 1) {
        const B = j[V].video.inbound.find((G) => G.ssrc === U);
        if (!B) continue;
        const q = j[V - 1].video.inbound.find((G) => G.ssrc === U),
          $ = B.frameWidth !== q?.frameWidth,
          H = B.frameHeight !== q?.frameHeight;
        if ($ || H) return !0;
      }
      return !1;
    };
  class I extends y {
    #e;
    #t;
    #n;
    constructor(j = {}) {
      super(),
        (this.#e = j.avgFreezeDurationThresholdMs ?? 1e3),
        (this.#t = j.frozenDurationThresholdPct ?? 30),
        (this.#n = j.minMosQuality ?? n.BAD);
    }
    performDetection(j) {
      const V = j.networkScores.inbound;
      return V !== void 0 && V <= this.#n ? [] : this.processData(j);
    }
    processData(j) {
      const V = [],
        B = this.getAllLastProcessedStats(j.connection.id);
      if (B.length === 0) return [];
      const q = j.video.inbound
        .map(($) => {
          const H = B[B.length - 1].video.inbound.find(
            (Z) => Z.ssrc === $.ssrc
          );
          if (!H || M($.ssrc, [B[B.length - 1], j]) || R($.ssrc, B)) return;
          const G = $.freezeCount - (H.freezeCount ?? 0),
            Y = 1e3 * ($.totalFreezesDuration - (H.totalFreezesDuration ?? 0)),
            Q = G > 0 ? Y / G : 0,
            X = (Y / ($.timestamp - H.timestamp)) * 100;
          return X > this.#t || Q > this.#e
            ? { ssrc: $.ssrc, avgFreezeDurationMs: Q, frozenDurationPct: X }
            : void 0;
        })
        .filter(($) => $ !== void 0);
      return (
        q.length > 0 &&
          (V.push({
            type: e.Stream,
            reason: s.FrozenVideoTrack,
            statsSample: { ssrcs: q.map(($) => $.ssrc) },
          }),
          this.deleteLastProcessedStats(j.connection.id)),
        V
      );
    }
  }
  class E extends y {
    #e;
    #t;
    #n;
    constructor(j = {}) {
      super(j),
        (this.#e = j.volatilityThreshold ?? 8),
        (this.#t = j.affectedStreamsPercentThreshold ?? 30),
        (this.#n = j.minMosQuality ?? n.BAD);
    }
    performDetection(j) {
      return [...this.getAllLastProcessedStats(j.connection.id), j].find(
        (V) =>
          V.networkScores.inbound !== void 0 &&
          V.networkScores.inbound <= this.#n
      )
        ? []
        : this.processData(j);
    }
    processData(j) {
      const V = [],
        B = [...this.getAllLastProcessedStats(j.connection.id), j],
        q = j.video.inbound
          .map((H) => {
            if (B.length < 5 || M(H.ssrc, B)) return;
            const G = [];
            for (let Q = 0; Q < B.length - 1; Q += 1) {
              const X = B[Q].video.inbound.find((Z) => Z.ssrc === H.ssrc);
              X?.framesPerSecond !== void 0 && G.push(X.framesPerSecond);
            }
            if (G.length < 5 || R(H.ssrc, B)) return;
            const Y = ((Q) => {
              if (Q.length === 0)
                throw new Error("Cannot calculate volatility for empty array");
              const X = C(Q);
              return (
                ((Q.reduce((Z, te) => Z + Math.abs(te - X), 0) / Q.length) *
                  100) /
                X
              );
            })(G);
            return Y > this.#e
              ? { ssrc: H.ssrc, allFps: G, volatility: Y }
              : void 0;
          })
          .filter((H) => !!H);
      if (q.length === 0) return V;
      const $ = q.length / (j.video.inbound.length / 100);
      return (
        $ > this.#t &&
          (V.push({
            type: e.CPU,
            reason: s.DecoderCPUThrottling,
            statsSample: { affectedStreamsPercent: $, throtthedStreams: q },
          }),
          this.deleteLastProcessedStats(j.connection.id)),
        V
      );
    }
  }
  const N = (U) =>
      U.iceConnectionState === "closed" || U.connectionState === "closed",
    _ = (U, j, V) =>
      8 *
      ((B, q, $) => {
        if (!q) return 0;
        const H = B[$],
          G = q[$];
        if (H == null || G == null) return 0;
        const Y = Math.floor(B.timestamp) - Math.floor(q.timestamp);
        return Y === 0 ? 0 : ((Number(H) - Number(G)) / Y) * 1e3;
      })(U, j, V);
  class A {
    connections = [];
    statsParser;
    constructor(j) {
      this.statsParser = j.statsParser;
    }
    listConnections() {
      return [...this.connections];
    }
    addPeerConnection(j) {
      this.connections.push({
        id: j.id ?? String(Date.now() + Math.random().toString(32)),
        pc: j.pc,
      });
    }
    removePeerConnection(j) {
      const V = this.connections.findIndex(({ pc: B }) => B === j.pc);
      V >= 0 && this.removeConnectionsByIndexes([V]);
    }
    async parse() {
      const j = [],
        V = this.connections.map(async (B, q) => {
          if (!N(B.pc)) return this.statsParser.parse(B);
          j.unshift(q);
        });
      return (
        j.length && this.removeConnectionsByIndexes(j),
        (await Promise.all(V)).filter((B) => B !== void 0)
      );
    }
    removeConnectionsByIndexes(j) {
      j.forEach((V) => {
        this.connections.splice(V, 1);
      });
    }
  }
  class O {
    prevStats = new Map();
    allowedReportTypes = new Set([
      "candidate-pair",
      "inbound-rtp",
      "outbound-rtp",
      "remote-outbound-rtp",
      "remote-inbound-rtp",
      "track",
      "transport",
    ]);
    ignoreSSRCList;
    logger;
    constructor(j) {
      (this.ignoreSSRCList = j.ignoreSSRCList ?? []), (this.logger = j.logger);
    }
    get previouslyParsedStatsConnectionsIds() {
      return [...this.prevStats.keys()];
    }
    async parse(j) {
      if (!N(j.pc)) return this.getConnectionStats(j);
      this.logger.debug("Skip stats parsing. Connection is closed.", {
        connection: j,
      });
    }
    async getConnectionStats(j) {
      const { pc: V, id: B } = j;
      try {
        const q = Date.now(),
          $ = V.getReceivers().filter((Q) => Q.track?.enabled),
          H = V.getSenders().filter((Q) => Q.track?.enabled),
          G = await Promise.all($.map((Q) => Q.getStats())),
          Y = await Promise.all(H.map((Q) => Q.getStats()));
        return {
          id: B,
          stats: this.mapReportsStats([...G, ...Y], j),
          timeTaken: Date.now() - q,
        };
      } catch (q) {
        return void this.logger.error("Failed to get stats for PC", {
          id: B,
          pc: V,
          error: q,
        });
      }
    }
    mapReportsStats(j, V) {
      const B = {
        audio: { inbound: [], outbound: [] },
        video: { inbound: [], outbound: [] },
        connection: {},
        remote: {
          video: { inbound: [], outbound: [] },
          audio: { inbound: [], outbound: [] },
        },
      };
      j.forEach((H) => {
        H.forEach((G) => {
          this.allowedReportTypes.has(G.type) &&
            this.updateMappedStatsWithReportItemData(G, B, H);
        });
      });
      const { id: q } = V,
        $ = this.prevStats.get(q);
      return (
        $ && this.propagateStatsWithRateValues(B, $.stats),
        this.prevStats.set(q, { stats: B, ts: Date.now() }),
        v({
          taskId: q,
          delayMs: 35e3,
          callback: () => this.prevStats.delete(q),
        }),
        B
      );
    }
    updateMappedStatsWithReportItemData(j, V, B) {
      const q = j.type;
      if (q === "candidate-pair" && j.state === "succeeded" && j.nominated)
        return void (V.connection = this.prepareConnectionStats(j, B));
      const $ = this.getMediaType(j);
      if (!$) return;
      const H = j.ssrc;
      if (!H || !this.ignoreSSRCList.includes(H))
        if (q !== "outbound-rtp")
          if (q !== "inbound-rtp")
            q !== "remote-outbound-rtp"
              ? q === "remote-inbound-rtp" &&
                (this.mapConnectionStatsIfNecessary(V, j, B),
                V.remote[$].inbound.push({ ...j }))
              : V.remote[$].outbound.push({ ...j });
          else {
            const G = B.get(j.trackId) || B.get(j.mediaSourceId) || {};
            this.mapConnectionStatsIfNecessary(V, j, B);
            const Y = { ...j, track: { ...G } };
            V[$].inbound.push(Y);
          }
        else {
          const G = B.get(j.trackId) || B.get(j.mediaSourceId) || {},
            Y = { ...j, track: { ...G } };
          V[$].outbound.push(Y);
        }
    }
    getMediaType(j) {
      const V = j.mediaType || j.kind;
      if (!["audio", "video"].includes(V)) {
        const { id: B } = j;
        return B
          ? String(B).includes("Video")
            ? "video"
            : String(B).includes("Audio")
            ? "audio"
            : void 0
          : void 0;
      }
      return V;
    }
    propagateStatsWithRateValues(j, V) {
      j.audio.inbound.forEach((B) => {
        const q = V.audio.inbound.find(({ id: $ }) => $ === B.id);
        (B.bitrate = _(B, q, "bytesReceived")),
          (B.packetRate = _(B, q, "packetsReceived"));
      }),
        j.audio.outbound.forEach((B) => {
          const q = V.audio.outbound.find(({ id: $ }) => $ === B.id);
          (B.bitrate = _(B, q, "bytesSent")),
            (B.packetRate = _(B, q, "packetsSent"));
        }),
        j.video.inbound.forEach((B) => {
          const q = V.video.inbound.find(({ id: $ }) => $ === B.id);
          (B.bitrate = _(B, q, "bytesReceived")),
            (B.packetRate = _(B, q, "packetsReceived"));
        }),
        j.video.outbound.forEach((B) => {
          const q = V.video.outbound.find(({ id: $ }) => $ === B.id);
          (B.bitrate = _(B, q, "bytesSent")),
            (B.packetRate = _(B, q, "packetsSent"));
        });
    }
    mapConnectionStatsIfNecessary(j, V, B) {
      if (j.connection.id || !V.transportId) return;
      const q = B.get(V.transportId);
      if (q && q.selectedCandidatePairId) {
        const $ = B.get(q.selectedCandidatePairId);
        j.connection = this.prepareConnectionStats($, B);
      }
    }
    prepareConnectionStats(j, V) {
      if (!j || !V) return {};
      const B = { ...j };
      if (B.remoteCandidateId) {
        const q = V.get(B.remoteCandidateId);
        B.remote = { ...q };
      }
      if (B.localCandidateId) {
        const q = V.get(B.localCandidateId);
        B.local = { ...q };
      }
      return B;
    }
  }
  class J extends y {
    #e = new Map();
    #t;
    #n;
    constructor(j = {}) {
      super(), (this.#t = j.timeoutMs ?? 15e3), (this.#n = j.steps ?? 3);
    }
    performDetection(j) {
      return this.processData(j);
    }
    processData(j) {
      const V = [],
        B = [...this.getAllLastProcessedStats(j.connection.id), j];
      if (B.length < this.#n) return V;
      const q = B.slice(-this.#n),
        $ = q.map((G) => G.video.inbound),
        H = q.map((G) => G.audio.inbound);
      return (
        V.push(
          ...this.detectMissingData(H, e.Stream, s.MissingAudioStreamData)
        ),
        V.push(
          ...this.detectMissingData($, e.Stream, s.MissingVideoStreamData)
        ),
        new Set(this.#e.keys()).forEach((G) => {
          const Y = this.#e.get(G);
          Y && Date.now() - Y > this.#t && this.removeMarkedIssue(G);
        }),
        V
      );
    }
    detectMissingData(j, V, B) {
      const q = [],
        $ = j.pop(),
        H = J.mapStatsByTrackId(j);
      return (
        $.forEach((G) => {
          const Y = G.track.trackIdentifier,
            Q = H.get(Y);
          if (
            !Array.isArray(Q) ||
            Q.length === 0 ||
            G.track.detached ||
            G.track.ended
          )
            return;
          if (!J.isAllBytesReceivedDidntChange(G.bytesReceived, Q))
            return void this.removeMarkedIssue(Y);
          if (!this.markIssue(Y)) return;
          const X = { bytesReceived: G.bytesReceived };
          q.push({ type: V, reason: B, statsSample: X, trackIdentifier: Y });
        }),
        q
      );
    }
    static mapStatsByTrackId(j) {
      const V = new Map();
      return (
        j.forEach((B) => {
          B.forEach((q) => {
            const $ = V.get(q.track.trackIdentifier) || [];
            $.push(q), V.set(q.track.trackIdentifier, $);
          });
        }),
        V
      );
    }
    static isAllBytesReceivedDidntChange(j, V) {
      for (let B = 0; B < V.length; B += 1)
        if (V[B].bytesReceived !== j) return !1;
      return !0;
    }
    markIssue(j) {
      const V = Date.now(),
        B = this.#e.get(j);
      return (!B || V - B > this.#t) && (this.#e.set(j, V), !0);
    }
    removeMarkedIssue(j) {
      this.#e.delete(j);
    }
  }
  class x {
    eventEmitter;
    #e = !1;
    detectors = [];
    networkScoresCalculator;
    statsReporter;
    compositeStatsParser;
    logger;
    autoAddPeerConnections;
    constructor(j) {
      (this.logger = j.logger ?? {
        debug: () => {},
        info: () => {},
        warn: () => {},
        error: () => {},
      }),
        (this.eventEmitter = j.issueEmitter ?? new g()),
        j.onIssues && this.eventEmitter.on(t.Issue, j.onIssues),
        j.onNetworkScoresUpdated &&
          this.eventEmitter.on(
            t.NetworkScoresUpdated,
            j.onNetworkScoresUpdated
          ),
        (this.detectors = j.detectors ?? [
          new L(),
          new b(),
          new T(),
          new P(),
          new w(),
          new D(),
          new I(),
          new E(),
          new J(),
        ]),
        (this.networkScoresCalculator = j.networkScoresCalculator ?? new k()),
        (this.compositeStatsParser =
          j.compositeStatsParser ??
          new A({
            statsParser: new O({
              ignoreSSRCList: j.ignoreSSRCList,
              logger: this.logger,
            }),
          })),
        (this.statsReporter =
          j.statsReporter ??
          new S({
            compositeStatsParser: this.compositeStatsParser,
            getStatsInterval: j.getStatsInterval ?? 5e3,
          })),
        (window.wid = this),
        (this.autoAddPeerConnections = j.autoAddPeerConnections ?? !0),
        this.autoAddPeerConnections && this.wrapRTCPeerConnection(),
        this.statsReporter.on(S.STATS_REPORT_READY_EVENT, (V) => {
          const B = this.calculateNetworkScores(V.stats);
          this.detectIssues({ data: V.stats }, B);
        }),
        this.statsReporter.on(S.STATS_REPORTS_PARSED, (V) => {
          const B = { timeTaken: V.timeTaken, ts: Date.now() };
          j.onStats && j.onStats(V.reportItems),
            this.eventEmitter.emit(t.StatsParsingFinished, B);
        });
    }
    watchNewPeerConnections() {
      if (!this.autoAddPeerConnections)
        throw new Error(
          "Auto add peer connections was disabled in the constructor."
        );
      this.#e
        ? this.logger.warn(
            "WebRTCIssueDetector is already started. Skip processing"
          )
        : (this.logger.info("Start watching peer connections"),
          (this.#e = !0),
          this.statsReporter.startReporting());
    }
    stopWatchingNewPeerConnections() {
      this.#e
        ? (this.logger.info("Stop watching peer connections"),
          (this.#e = !1),
          this.statsReporter.stopReporting())
        : this.logger.warn(
            "WebRTCIssueDetector is already stopped. Skip processing"
          );
    }
    handleNewPeerConnection(j, V) {
      this.#e || !this.autoAddPeerConnections
        ? (this.#e ||
            this.autoAddPeerConnections !== !1 ||
            (this.logger.info(
              "Starting stats reporting for new peer connection"
            ),
            (this.#e = !0),
            this.statsReporter.startReporting()),
          this.logger.debug("Handling new peer connection", j),
          this.compositeStatsParser.addPeerConnection({ pc: j, id: V }))
        : this.logger.debug(
            "Skip handling new peer connection. Detector is not running",
            j
          );
    }
    emitIssues(j) {
      this.eventEmitter.emit(t.Issue, j);
    }
    detectIssues({ data: j }, V) {
      const B = this.detectors.reduce((q, $) => [...q, ...$.detect(j, V)], []);
      B.length > 0 && this.emitIssues(B);
    }
    calculateNetworkScores(j) {
      const V = this.networkScoresCalculator.calculate(j);
      return this.eventEmitter.emit(t.NetworkScoresUpdated, V), V;
    }
    wrapRTCPeerConnection() {
      if (!window.RTCPeerConnection)
        return void this.logger.warn(
          "No RTCPeerConnection found in browser window. Skipping"
        );
      const j = window.RTCPeerConnection,
        V = (q) => this.handleNewPeerConnection(q);
      function B(q) {
        const $ = new j(q);
        return V($), $;
      }
      (B.prototype = j.prototype), (window.RTCPeerConnection = B);
    }
  }
  var WebRTCConnectionQualityIndicator = (function (U) {
      __extends(j, U);
      function j() {
        var V = (U !== null && U.apply(this, arguments)) || this;
        return (V.issueDetector = null), (V.mosScores = null), V;
      }
      return (
        (j.prototype._start = function (V) {
          var B = this;
          (this.issueDetector = new x({
            autoAddPeerConnections: !1,
            getStatsInterval: 3e3,
            onNetworkScoresUpdated: function (q) {
              (B.mosScores = q), B.handleStatsChanged();
            },
          })),
            this.issueDetector.handleNewPeerConnection(V);
        }),
        (j.prototype._stop = function () {
          this.issueDetector &&
            (this.issueDetector.stopWatchingNewPeerConnections(),
            (this.issueDetector = null)),
            (this.mosScores = null);
        }),
        (j.prototype.calculateConnectionQuality = function () {
          return !this.mosScores ||
            (this.mosScores.inbound && this.mosScores.outbound)
            ? ConnectionQuality.UNKNOWN
            : (this.mosScores.inbound && this.mosScores.inbound < 3) ||
              (this.mosScores.outbound && this.mosScores.outbound < 3)
            ? ConnectionQuality.BAD
            : ConnectionQuality.GOOD;
        }),
        j
      );
    })(AbstractConnectionQualityIndicator),
    VoiceChatState;
  (function (U) {
    (U.INACTIVE = "inactive"),
      (U.STARTING = "starting"),
      (U.ACTIVE = "started"),
      (U.STOPPING = "stopping");
  })(VoiceChatState || (VoiceChatState = {}));
  var AbstractVoiceChat = (function () {
      function U() {}
      return U;
    })(),
    AbstractVoiceChatImplementation = (function (U) {
      __extends(j, U);
      function j() {
        var V = (U !== null && U.apply(this, arguments)) || this;
        return (V._isMuted = !0), (V.state = VoiceChatState.INACTIVE), V;
      }
      return (
        Object.defineProperty(j.prototype, "isMuted", {
          get: function () {
            return this._isMuted;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(j.prototype, "isVoiceChatting", {
          get: function () {
            return this.state !== VoiceChatState.INACTIVE;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (j.prototype.startVoiceChat = function (V) {
          return __awaiter(this, void 0, void 0, function () {
            var B;
            return __generator(this, function (q) {
              switch (q.label) {
                case 0:
                  return this.state === VoiceChatState.INACTIVE
                    ? [3, 2]
                    : [4, this.stopVoiceChat()];
                case 1:
                  q.sent(), (q.label = 2);
                case 2:
                  return (
                    q.trys.push([2, 4, , 6]),
                    (this.state = VoiceChatState.STARTING),
                    [4, this._startVoiceChat(V)]
                  );
                case 3:
                  return q.sent(), (this.state = VoiceChatState.ACTIVE), [3, 6];
                case 4:
                  return (B = q.sent()), [4, this.stopVoiceChat()];
                case 5:
                  throw (q.sent(), B);
                case 6:
                  return [2];
              }
            });
          });
        }),
        (j.prototype.stopVoiceChat = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (V) {
              switch (V.label) {
                case 0:
                  return this.state === VoiceChatState.INACTIVE
                    ? [2]
                    : ((this.state = VoiceChatState.STOPPING),
                      [4, this._stopVoiceChat()]);
                case 1:
                  return (
                    V.sent(),
                    (this._isMuted = !0),
                    (this.state = VoiceChatState.INACTIVE),
                    [2]
                  );
              }
            });
          });
        }),
        (j.prototype._mute = function () {}),
        (j.prototype._unmute = function () {}),
        (j.prototype.mute = function () {
          this.isVoiceChatting && (this._mute(), (this._isMuted = !0));
        }),
        (j.prototype.unmute = function () {
          this.isVoiceChatting && (this._unmute(), (this._isMuted = !1));
        }),
        j
      );
    })(AbstractVoiceChat);
  function sleep(U) {
    return new Promise(function (j) {
      return setTimeout(j, U);
    });
  }
  function convertFloat32ToS16PCM(U) {
    for (var j = new Int16Array(U.length), V = 0; V < U.length; V++) {
      var B = Math.max(-1, Math.min(1, U[V]));
      j[V] = B < 0 ? B * 32768 : B * 32767;
    }
    return j;
  }
  var LivekitVoiceChat = (function (U) {
      __extends(j, U);
      function j() {
        var V = (U !== null && U.apply(this, arguments)) || this;
        return (V.room = null), (V.track = null), V;
      }
      return (
        (j.prototype._startVoiceChat = function (V) {
          return __awaiter(this, void 0, void 0, function () {
            var B, q;
            return __generator(this, function ($) {
              switch ($.label) {
                case 0:
                  return (
                    (this.room = V.room),
                    (B = this),
                    [
                      4,
                      createLocalAudioTrack({
                        echoCancellation: !0,
                        noiseSuppression: !0,
                        autoGainControl: !0,
                      }),
                    ]
                  );
                case 1:
                  return (
                    (B.track = $.sent()),
                    [4, this.room.localParticipant.publishTrack(this.track)]
                  );
                case 2:
                  return (
                    $.sent(),
                    !((q = V.config) === null || q === void 0) && q.defaultMuted
                      ? this.mute()
                      : this.unmute(),
                    [4, sleep(4e3)]
                  );
                case 3:
                  return $.sent(), [2];
              }
            });
          });
        }),
        (j.prototype._stopVoiceChat = function () {
          return __awaiter(this, void 0, void 0, function () {
            var V;
            return __generator(this, function (B) {
              return (
                !((V = this.room) === null || V === void 0) &&
                  V.localParticipant &&
                  this.room.localParticipant
                    .getTrackPublications()
                    .forEach(function (q) {
                      q.track &&
                        q.track.kind === Track.Kind.Audio &&
                        q.track.stop();
                    }),
                this.track && (this.track.stop(), (this.track = null)),
                [2]
              );
            });
          });
        }),
        (j.prototype._mute = function () {
          this.track && !this.track.isMuted && this.track.mute();
        }),
        (j.prototype._unmute = function () {
          this.track && this.track.isMuted && this.track.unmute();
        }),
        j
      );
    })(AbstractVoiceChatImplementation),
    WebSocketVoiceChat = (function (U) {
      __extends(j, U);
      function j() {
        var V = (U !== null && U.apply(this, arguments)) || this;
        return (
          (V.audioContext = null),
          (V.webSocket = null),
          (V.scriptProcessor = null),
          (V.mediaStreamAudioSource = null),
          (V.mediaDevicesStream = null),
          (V.audioRawFrame = null),
          V
        );
      }
      return (
        (j.prototype._startVoiceChat = function (V) {
          return __awaiter(this, void 0, void 0, function () {
            var B,
              q = this,
              $,
              H,
              G,
              Y;
            return __generator(this, function (Q) {
              switch (Q.label) {
                case 0:
                  if (
                    !navigator.mediaDevices ||
                    !navigator.mediaDevices.getUserMedia
                  )
                    throw new Error(
                      "Cannot start voice chat without media devices"
                    );
                  return (
                    (this.webSocket = V.webSocket),
                    (this.audioRawFrame = V.audioRawFrame),
                    (this.audioContext = new window.AudioContext({
                      latencyHint: "interactive",
                      sampleRate: 16e3,
                    })),
                    (!(($ = V.config) === null || $ === void 0) &&
                      $.defaultMuted) ||
                      this.unmute(),
                    [
                      4,
                      navigator.mediaDevices.getUserMedia({
                        audio: {
                          sampleRate: 16e3,
                          channelCount: 1,
                          autoGainControl: !0,
                          echoCancellation: !0,
                          noiseSuppression: !0,
                        },
                      }),
                    ]
                  );
                case 1:
                  return (
                    (B = Q.sent()),
                    (this.mediaDevicesStream = B),
                    (this.mediaStreamAudioSource =
                      (H = this.audioContext) === null || H === void 0
                        ? void 0
                        : H.createMediaStreamSource(B)),
                    (this.scriptProcessor =
                      (G = this.audioContext) === null || G === void 0
                        ? void 0
                        : G.createScriptProcessor(512, 1, 1)),
                    this.mediaStreamAudioSource.connect(this.scriptProcessor),
                    this.scriptProcessor.connect(
                      (Y = this.audioContext) === null || Y === void 0
                        ? void 0
                        : Y.destination
                    ),
                    (this.scriptProcessor.onaudioprocess = function (X) {
                      var Z;
                      if (!(!q.webSocket || !q.audioRawFrame)) {
                        var te;
                        q.isMuted
                          ? (te = new Float32Array(512))
                          : (te = X.inputBuffer.getChannelData(0));
                        var ne = convertFloat32ToS16PCM(te),
                          ae = new Uint8Array(ne.buffer),
                          se = q.audioRawFrame.create({
                            audio: {
                              audio: Array.from(ae),
                              sampleRate: 16e3,
                              numChannels: 1,
                            },
                          }),
                          fe = new Uint8Array(
                            q.audioRawFrame.encode(se).finish()
                          );
                        (Z = q.webSocket) === null ||
                          Z === void 0 ||
                          Z.send(fe);
                      }
                    }),
                    [4, sleep(2e3)]
                  );
                case 2:
                  return Q.sent(), [2];
              }
            });
          });
        }),
        (j.prototype._stopVoiceChat = function () {
          return __awaiter(this, void 0, void 0, function () {
            var V, B;
            return __generator(this, function (q) {
              return (
                this.audioContext && (this.audioContext = null),
                this.scriptProcessor &&
                  (this.scriptProcessor.disconnect(),
                  (this.scriptProcessor = null)),
                this.mediaStreamAudioSource &&
                  (this.mediaStreamAudioSource.disconnect(),
                  (this.mediaStreamAudioSource = null)),
                this.mediaDevicesStream &&
                  ((B =
                    (V = this.mediaDevicesStream) === null || V === void 0
                      ? void 0
                      : V.getTracks()) === null ||
                    B === void 0 ||
                    B.forEach(function ($) {
                      return $.stop();
                    }),
                  (this.mediaDevicesStream = null)),
                [2]
              );
            });
          });
        }),
        j
      );
    })(AbstractVoiceChatImplementation),
    VoiceChatTransport;
  (function (U) {
    (U.LIVEKIT = "livekit"), (U.WEBSOCKET = "websocket");
  })(VoiceChatTransport || (VoiceChatTransport = {}));
  var VoiceChatFactory = (function (U) {
      __extends(j, U);
      function j(V) {
        var B = V.voiceChatInstance,
          q = V.initialConfig,
          $ = U.call(this) || this;
        return ($.initialConfig = q), ($.voiceChat = B), $;
      }
      return (
        Object.defineProperty(j.prototype, "isMuted", {
          get: function () {
            return this.voiceChat.isMuted;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(j.prototype, "isVoiceChatting", {
          get: function () {
            return this.voiceChat.isVoiceChatting;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (j.prototype.startVoiceChat = function (V) {
          return __awaiter(this, arguments, void 0, function (B) {
            var q = B.config;
            return __generator(this, function ($) {
              switch ($.label) {
                case 0:
                  return [
                    4,
                    this.voiceChat.startVoiceChat(
                      __assign(__assign({}, this.initialConfig), { config: q })
                    ),
                  ];
                case 1:
                  return $.sent(), [2];
              }
            });
          });
        }),
        (j.prototype.stopVoiceChat = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (V) {
              switch (V.label) {
                case 0:
                  return [4, this.voiceChat.stopVoiceChat()];
                case 1:
                  return V.sent(), [2];
              }
            });
          });
        }),
        (j.prototype.mute = function () {
          this.voiceChat.mute();
        }),
        (j.prototype.unmute = function () {
          this.voiceChat.unmute();
        }),
        (j.createLiveKitVoiceChat = function (V) {
          return new this({
            voiceChatInstance: new LivekitVoiceChat(),
            initialConfig: V,
          });
        }),
        (j.createWebSocketVoiceChat = function (V) {
          return new this({
            voiceChatInstance: new WebSocketVoiceChat(),
            initialConfig: V,
          });
        }),
        j
      );
    })(AbstractVoiceChat),
    AvatarQuality;
  (function (U) {
    (U.Low = "low"), (U.Medium = "medium"), (U.High = "high");
  })(AvatarQuality || (AvatarQuality = {}));
  var VoiceEmotion;
  (function (U) {
    (U.EXCITED = "excited"),
      (U.SERIOUS = "serious"),
      (U.FRIENDLY = "friendly"),
      (U.SOOTHING = "soothing"),
      (U.BROADCASTER = "broadcaster");
  })(VoiceEmotion || (VoiceEmotion = {}));
  var ElevenLabsModel;
  (function (U) {
    (U.eleven_flash_v2_5 = "eleven_flash_v2_5"),
      (U.eleven_multilingual_v2 = "eleven_multilingual_v2");
  })(ElevenLabsModel || (ElevenLabsModel = {}));
  var STTProvider;
  (function (U) {
    (U.DEEPGRAM = "deepgram"), (U.GLADIA = "gladia");
  })(STTProvider || (STTProvider = {}));
  var TaskType;
  (function (U) {
    (U.TALK = "talk"), (U.REPEAT = "repeat");
  })(TaskType || (TaskType = {}));
  var TaskMode;
  (function (U) {
    (U.SYNC = "sync"), (U.ASYNC = "async");
  })(TaskMode || (TaskMode = {}));
  var StreamingEvents;
  (function (U) {
    (U.AVATAR_START_TALKING = "avatar_start_talking"),
      (U.AVATAR_STOP_TALKING = "avatar_stop_talking"),
      (U.AVATAR_TALKING_MESSAGE = "avatar_talking_message"),
      (U.AVATAR_END_MESSAGE = "avatar_end_message"),
      (U.USER_TALKING_MESSAGE = "user_talking_message"),
      (U.USER_END_MESSAGE = "user_end_message"),
      (U.USER_START = "user_start"),
      (U.USER_STOP = "user_stop"),
      (U.USER_SILENCE = "user_silence"),
      (U.STREAM_READY = "stream_ready"),
      (U.STREAM_DISCONNECTED = "stream_disconnected"),
      (U.CONNECTION_QUALITY_CHANGED = "connection_quality_changed");
  })(StreamingEvents || (StreamingEvents = {}));
  var APIError = (function (U) {
      __extends(j, U);
      function j(V, B, q) {
        var $ = U.call(this, V) || this;
        return ($.name = "APIError"), ($.status = B), ($.responseText = q), $;
      }
      return j;
    })(Error),
    ConnectionQualityIndicatorClass = QualityIndicatorMixer(
      {
        TrackerClass: LiveKitConnectionQualityIndicator,
        getParams: function (U) {
          return U;
        },
      },
      {
        TrackerClass: WebRTCConnectionQualityIndicator,
        getParams: function (U) {
          var j;
          return (
            (j = U.engine.pcManager) === null || j === void 0
              ? void 0
              : j.subscriber
          )._pc;
        },
      }
    ),
    StreamingAvatar = (function () {
      function U(j) {
        var V = j.token,
          B = j.basePath,
          q = B === void 0 ? "https://api.heygen.com" : B,
          $ = this;
        (this.room = null),
          (this.mediaStream = null),
          (this.eventTarget = new EventTarget()),
          (this.webSocket = null),
          (this.sessionId = null),
          (this.voiceChat = null),
          (this.isLiveKitTransport = !1),
          (this.token = V),
          (this.basePath = q),
          (this.connectionQualityIndicator =
            new ConnectionQualityIndicatorClass(function (H) {
              return $.emit(StreamingEvents.CONNECTION_QUALITY_CHANGED, H);
            }));
      }
      return (
        Object.defineProperty(U.prototype, "connectionQuality", {
          get: function () {
            return this.connectionQualityIndicator.connectionQuality;
          },
          enumerable: !1,
          configurable: !0,
        }),
        Object.defineProperty(U.prototype, "isInputAudioMuted", {
          get: function () {
            var j, V;
            return (V =
              (j = this.voiceChat) === null || j === void 0
                ? void 0
                : j.isMuted) !== null && V !== void 0
              ? V
              : !0;
          },
          enumerable: !1,
          configurable: !0,
        }),
        (U.prototype.muteInputAudio = function () {
          var j;
          (j = this.voiceChat) === null || j === void 0 || j.mute();
        }),
        (U.prototype.unmuteInputAudio = function () {
          var j;
          (j = this.voiceChat) === null || j === void 0 || j.unmute();
        }),
        (U.prototype.createStartAvatar = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V;
            return __generator(this, function (B) {
              switch (B.label) {
                case 0:
                  return [4, this.newSession(j)];
                case 1:
                  return (V = B.sent()), [2, this.startAvatar(j, V)];
              }
            });
          });
        }),
        (U.prototype.startAvatar = function (j, V) {
          return __awaiter(this, void 0, void 0, function () {
            var B,
              q,
              $ = this;
            return __generator(this, function (H) {
              switch (H.label) {
                case 0:
                  (this.sessionId = V.session_id),
                    (this.isLiveKitTransport =
                      j.voiceChatTransport === VoiceChatTransport.LIVEKIT),
                    (B = new Room({
                      adaptiveStream: !0,
                      dynacast: !0,
                      videoCaptureDefaults: {
                        resolution: VideoPresets.h720.resolution,
                      },
                    })),
                    (this.room = B),
                    (this.mediaStream = null),
                    B.on(RoomEvent.DataReceived, function (G) {
                      var Y = null;
                      try {
                        var Q = new TextDecoder().decode(G);
                        Y = JSON.parse(Q);
                      } catch (X) {
                        console.error(X);
                      }
                      Y && $.emit(Y.type, Y);
                    }),
                    (q = new MediaStream()),
                    B.on(RoomEvent.TrackSubscribed, function (G) {
                      if (G.kind === "video" || G.kind === "audio") {
                        q.addTrack(G.mediaStreamTrack);
                        var Y = q.getVideoTracks().length > 0,
                          Q = q.getAudioTracks().length > 0;
                        Y &&
                          Q &&
                          !$.mediaStream &&
                          (($.mediaStream = q),
                          $.emit(StreamingEvents.STREAM_READY, $.mediaStream));
                      }
                    }),
                    B.on(RoomEvent.TrackUnsubscribed, function (G) {
                      var Y = G.mediaStreamTrack;
                      Y && q.removeTrack(Y);
                    }),
                    B.on(RoomEvent.Disconnected, function (G) {
                      $.emit(StreamingEvents.STREAM_DISCONNECTED, G);
                    }),
                    (H.label = 1);
                case 1:
                  return (
                    H.trys.push([1, 3, , 4]),
                    [4, B.prepareConnection(V.url, V.access_token)]
                  );
                case 2:
                  return H.sent(), [3, 4];
                case 3:
                  return H.sent(), [3, 4];
                case 4:
                  return [4, this.startSession()];
                case 5:
                  return H.sent(), [4, B.connect(V.url, V.access_token)];
                case 6:
                  return (
                    H.sent(),
                    [
                      4,
                      this.connectWebSocket({
                        useSilencePrompt: !!j.useSilencePrompt,
                      }),
                    ]
                  );
                case 7:
                  return (
                    H.sent(),
                    this.initVoiceChat(
                      j.voiceChatTransport || VoiceChatTransport.WEBSOCKET
                    ),
                    this.connectionQualityIndicator.start(B),
                    [2, V]
                  );
              }
            });
          });
        }),
        (U.prototype.startVoiceChat = function () {
          return __awaiter(this, arguments, void 0, function (j) {
            var V,
              B = j === void 0 ? {} : j,
              q = B.isInputAudioMuted;
            return __generator(this, function ($) {
              switch ($.label) {
                case 0:
                  return [
                    4,
                    (V = this.voiceChat) === null || V === void 0
                      ? void 0
                      : V.startVoiceChat({ config: { defaultMuted: q } }),
                  ];
                case 1:
                  return $.sent(), [2];
              }
            });
          });
        }),
        (U.prototype.closeVoiceChat = function () {
          return __awaiter(this, void 0, void 0, function () {
            var j;
            return __generator(this, function (V) {
              switch (V.label) {
                case 0:
                  return [
                    4,
                    (j = this.voiceChat) === null || j === void 0
                      ? void 0
                      : j.stopVoiceChat(),
                  ];
                case 1:
                  return V.sent(), [2];
              }
            });
          });
        }),
        (U.prototype.newSession = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V, B, q, $, H;
            return __generator(this, function (G) {
              return [
                2,
                this.request("/v1/streaming.new", {
                  avatar_name: j.avatarName,
                  quality: j.quality,
                  knowledge_base_id: j.knowledgeId,
                  knowledge_base: j.knowledgeBase,
                  voice: {
                    voice_id:
                      (V = j.voice) === null || V === void 0
                        ? void 0
                        : V.voiceId,
                    rate:
                      (B = j.voice) === null || B === void 0 ? void 0 : B.rate,
                    emotion:
                      (q = j.voice) === null || q === void 0
                        ? void 0
                        : q.emotion,
                    elevenlabs_settings: __assign(
                      __assign(
                        {},
                        ($ = j?.voice) === null || $ === void 0
                          ? void 0
                          : $.elevenlabsSettings
                      ),
                      {
                        model_id:
                          (H = j.voice) === null || H === void 0
                            ? void 0
                            : H.model,
                      }
                    ),
                  },
                  language: j.language,
                  version: "v2",
                  video_encoding: "H264",
                  source: "sdk",
                  disable_idle_timeout: j.disableIdleTimeout,
                  stt_settings: j.sttSettings,
                  ia_is_livekit_transport:
                    j.voiceChatTransport === VoiceChatTransport.LIVEKIT,
                  silence_response: j.useSilencePrompt,
                  activity_idle_timeout: j.activityIdleTimeout,
                }),
              ];
            });
          });
        }),
        (U.prototype.startSession = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return [
                2,
                this.request("/v1/streaming.start", {
                  session_id: this.sessionId,
                }),
              ];
            });
          });
        }),
        (U.prototype.speak = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V, B;
            return __generator(this, function (q) {
              if (
                ((V = j.taskType || j.task_type || TaskType.TALK),
                (B = j.taskMode || TaskMode.ASYNC),
                V === TaskType.TALK && B === TaskMode.ASYNC)
              ) {
                if (this.isLiveKitTransport && this.room)
                  return this.sendLivekitMessage(j.text), [2];
                if (
                  !this.isLiveKitTransport &&
                  this.webSocket &&
                  this.audioRawFrame
                )
                  return this.sendWebsocketMessage(j.text), [2];
              }
              return [
                2,
                this.request("/v1/streaming.task", {
                  text: j.text,
                  session_id: this.sessionId,
                  task_mode: j.taskMode,
                  task_type: j.taskType,
                }),
              ];
            });
          });
        }),
        (U.prototype.startListening = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return [
                2,
                this.request("/v1/streaming.start_listening", {
                  session_id: this.sessionId,
                }),
              ];
            });
          });
        }),
        (U.prototype.stopListening = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return [
                2,
                this.request("/v1/streaming.stop_listening", {
                  session_id: this.sessionId,
                }),
              ];
            });
          });
        }),
        (U.prototype.interrupt = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return [
                2,
                this.request("/v1/streaming.interrupt", {
                  session_id: this.sessionId,
                }),
              ];
            });
          });
        }),
        (U.prototype.stopAvatar = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return (
                this.closeVoiceChat(),
                this.connectionQualityIndicator.stop(),
                (this.voiceChat = null),
                this.webSocket &&
                  (this.webSocket.close(), (this.webSocket = null)),
                [
                  2,
                  this.request("/v1/streaming.stop", {
                    session_id: this.sessionId,
                  }),
                ]
              );
            });
          });
        }),
        (U.prototype.keepAlive = function () {
          return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (j) {
              return [
                2,
                this.request("/v1/streaming.keep_alive", {
                  session_id: this.sessionId,
                }),
              ];
            });
          });
        }),
        (U.prototype.on = function (j, V) {
          return this.eventTarget.addEventListener(j, V), this;
        }),
        (U.prototype.off = function (j, V) {
          return this.eventTarget.removeEventListener(j, V), this;
        }),
        (U.prototype.sendLivekitMessage = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V;
            return __generator(this, function (B) {
              return this.room
                ? ((V = new TextEncoder().encode(JSON.stringify(j))),
                  this.room.localParticipant.publishData(V, { reliable: !0 }),
                  [2])
                : [2];
            });
          });
        }),
        (U.prototype.sendWebsocketMessage = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V, B, q, $;
            return __generator(this, function (H) {
              return !this.webSocket || !this.audioRawFrame
                ? [2]
                : ((V =
                    (q = this.audioRawFrame) === null || q === void 0
                      ? void 0
                      : q.create({ text: { text: j } })),
                  (B = new Uint8Array(
                    ($ = this.audioRawFrame) === null || $ === void 0
                      ? void 0
                      : $.encode(V).finish()
                  )),
                  this.webSocket.send(B),
                  [2]);
            });
          });
        }),
        (U.prototype.initVoiceChat = function (j) {
          if (j === VoiceChatTransport.WEBSOCKET) {
            if (
              (this.loadAudioRawFrame(), !this.audioRawFrame || !this.webSocket)
            )
              return;
            this.voiceChat = VoiceChatFactory.createWebSocketVoiceChat({
              webSocket: this.webSocket,
              audioRawFrame: this.audioRawFrame,
            });
          } else {
            if (!this.room) return;
            this.voiceChat = VoiceChatFactory.createLiveKitVoiceChat({
              room: this.room,
            });
          }
        }),
        (U.prototype.request = function (j, V, B) {
          return __awaiter(this, void 0, void 0, function () {
            var q, $, H, G;
            return __generator(this, function (Y) {
              switch (Y.label) {
                case 0:
                  return (
                    Y.trys.push([0, 5, , 6]),
                    [
                      4,
                      fetch(this.getRequestUrl(j), {
                        method: "POST",
                        headers: {
                          Authorization: "Bearer ".concat(this.token),
                          "Content-Type": "application/json",
                        },
                        body: JSON.stringify(V),
                      }),
                    ]
                  );
                case 1:
                  return (q = Y.sent()), q.ok ? [3, 3] : [4, q.text()];
                case 2:
                  throw (
                    (($ = Y.sent()),
                    new APIError(
                      "API request failed with status ".concat(q.status),
                      q.status,
                      $
                    ))
                  );
                case 3:
                  return [4, q.json()];
                case 4:
                  return (H = Y.sent()), [2, H.data];
                case 5:
                  throw ((G = Y.sent()), G);
                case 6:
                  return [2];
              }
            });
          });
        }),
        (U.prototype.emit = function (j, V) {
          var B = new CustomEvent(j, { detail: V });
          this.eventTarget.dispatchEvent(B);
        }),
        (U.prototype.getRequestUrl = function (j) {
          return "".concat(this.basePath).concat(j);
        }),
        (U.prototype.connectWebSocket = function (j) {
          return __awaiter(this, void 0, void 0, function () {
            var V,
              B = this;
            return __generator(this, function (q) {
              return (
                (V = "wss://"
                  .concat(
                    new URL(this.basePath).hostname,
                    "/v1/ws/streaming.chat?session_id="
                  )
                  .concat(this.sessionId, "&session_token=")
                  .concat(this.token)
                  .concat(
                    this.isLiveKitTransport ? "&arch_version=v2" : "",
                    "&silence_response="
                  )
                  .concat(j.useSilencePrompt)),
                (this.webSocket = new WebSocket(V)),
                this.webSocket.addEventListener("message", function ($) {
                  var H = null;
                  try {
                    H = JSON.parse($.data);
                  } catch (G) {
                    console.error(G);
                    return;
                  }
                  H && B.emit(H.event_type, H);
                }),
                this.webSocket.addEventListener("close", function ($) {
                  B.webSocket = null;
                }),
                [
                  2,
                  new Promise(function ($, H) {
                    var G, Y;
                    (G = B.webSocket) === null ||
                      G === void 0 ||
                      G.addEventListener("error", function (Q) {
                        (B.webSocket = null), H(Q);
                      }),
                      (Y = B.webSocket) === null ||
                        Y === void 0 ||
                        Y.addEventListener("open", function () {
                          $(!0);
                        });
                  }),
                ]
              );
            });
          });
        }),
        (U.prototype.loadAudioRawFrame = function () {
          return __awaiter(this, void 0, void 0, function () {
            var j;
            return __generator(this, function (V) {
              return (
                this.audioRawFrame ||
                  ((j = protobuf.Root.fromJSON(jsonDescriptor)),
                  (this.audioRawFrame = j?.lookupType("pipecat.Frame"))),
                [2]
              );
            });
          });
        }),
        U
      );
    })();
  const generateUserFingerprint = (U) => {
      const j = [
        U.userAgent,
        U.language,
        U.timezone,
        U.screenResolution,
        U.colorDepth,
        U.pixelRatio,
        U.platform,
        U.cookieEnabled,
        U.doNotTrack,
        U.hardwareConcurrency,
        U.deviceMemory,
        U.connectionType,
        U.customUserId,
      ]
        .filter(Boolean)
        .join("|");
      let V = 0;
      for (let B = 0; B < j.length; B++) {
        const q = j.charCodeAt(B);
        (V = (V << 5) - V + q), (V = V & V);
      }
      return Math.abs(V).toString(36);
    },
    collectUserInfo = (U) => {
      const j = navigator;
      return {
        userAgent: navigator.userAgent,
        language: navigator.language || "en-US",
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screenResolution: `${screen.width}x${screen.height}`,
        colorDepth: screen.colorDepth,
        pixelRatio: window.devicePixelRatio || 1,
        platform: navigator.platform,
        cookieEnabled: navigator.cookieEnabled,
        doNotTrack: navigator.doNotTrack,
        hardwareConcurrency: j.hardwareConcurrency || 0,
        deviceMemory: j.deviceMemory || 0,
        connectionType: j.connection?.effectiveType,
        customUserId: U,
      };
    },
    getUserFingerprint = () => {
      const U = localStorage.getItem("chatUserFingerprint");
      if (U) return U;
      const j = collectUserInfo(),
        V = generateUserFingerprint(j);
      return localStorage.setItem("chatUserFingerprint", V), V;
    },
    getSessionId = () => {
      const U = sessionStorage.getItem("chatSessionId");
      if (U) return U;
      const j = `session_${Date.now()}_${Math.random()
        .toString(36)
        .substr(2, 9)}`;
      return sessionStorage.setItem("chatSessionId", j), j;
    },
    clearOldClientKeys = (U) => {
      try {
        const j = sessionStorage.getItem("chatSession");
        if (j)
          try {
            const V = JSON.parse(j);
            V.clientKey &&
              V.clientKey !== U &&
              (sessionStorage.removeItem("chatSession"),
              console.log("Cleared session from different client key"));
          } catch {
            console.warn("Invalid session data, clearing"),
              sessionStorage.removeItem("chatSession");
          }
      } catch (j) {
        console.error("Error clearing old client keys:", j);
      }
    },
    startConversation = async (U, j, V) => {
      try {
        clearOldClientKeys(U);
        const B = collectUserInfo(V),
          q = getUserFingerprint(),
          $ = getSessionId(),
          H = getUserEmail();
        H && (B.email = H);
        const G = await fetch(`${j}/api/conversation/start`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ clientKey: U, userInfo: B, customUserId: V }),
        });
        if (!G.ok) throw new Error("Failed to start conversation");
        const Y = await G.json(),
          Q = {
            sessionId: Y.sessionId || $,
            fingerprint: Y.fingerprint || q,
            userInfo: B,
            isActive: !0,
          };
        return (
          sessionStorage.setItem(
            "chatSession",
            JSON.stringify({ ...Q, clientKey: U })
          ),
          console.log("Conversation started:", Q),
          Q
        );
      } catch (B) {
        console.error("Error starting conversation:", B);
        const q = collectUserInfo(V),
          $ = getUserFingerprint(),
          G = {
            sessionId: getSessionId(),
            fingerprint: $,
            userInfo: q,
            isActive: !0,
          };
        return (
          sessionStorage.setItem(
            "chatSession",
            JSON.stringify({ ...G, clientKey: U })
          ),
          G
        );
      }
    },
    getOrStartConversation = async (U, j, V) => {
      clearOldClientKeys(U);
      const B = sessionStorage.getItem("chatSession");
      if (B)
        try {
          const q = JSON.parse(B);
          if (q.isActive && q.clientKey === U) {
            const $ = getUserEmail();
            return (
              $ &&
                !q.userInfo.email &&
                ((q.userInfo.email = $),
                sessionStorage.setItem("chatSession", JSON.stringify(q))),
              console.log("Using existing conversation session:", q),
              q
            );
          } else
            sessionStorage.removeItem("chatSession"),
              console.log("Cleared session from different client key");
        } catch {
          console.warn("Invalid session data, starting new conversation"),
            sessionStorage.removeItem("chatSession");
        }
      return startConversation(U, j, V);
    },
    addMessageToConversation = async (U, j, V, B, q) => {
      try {
        await fetch(`${j}/api/conversation/${V}/message`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ role: B, content: q, clientKey: U }),
        });
      } catch ($) {
        console.error("Error adding message to conversation:", $);
      }
    },
    getUserEmail = () => localStorage.getItem("userEmail"),
    hasUserEmail = () => !!getUserEmail(),
    VideoAgent = ({
      isVideoMode: U,
      setIsVideoMode: j,
      theme: V,
      setMessages: B,
      prompt: q,
      clientKey: $,
      apiUrl: H,
      sessionId: G,
    }) => {
      const [Y, Q] = reactExports.useState(!1),
        [X, Z] = reactExports.useState(!1),
        [te, ne] = reactExports.useState(!0),
        [ae, se] = reactExports.useState(!0),
        [fe, ce] = reactExports.useState(!1),
        [ue, he] = reactExports.useState("excellent"),
        [me, ve] = reactExports.useState(!1),
        [ge, Ee] = reactExports.useState(!1),
        [Ce, Re] = reactExports.useState(null),
        [Ae, be] = reactExports.useState(!1),
        [Le, Fe] = reactExports.useState(null),
        Me = reactExports.useRef(null),
        je = reactExports.useRef(null),
        Te = reactExports.useRef(null),
        [xe, He] = reactExports.useState(null);
      reactExports.useEffect(() => {
        U && (Je(), he("excellent"));
      }, [U]);
      const Je = async () => {
          try {
            Q(!0), Re(null);
            const Qe = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 1280, max: 1920 },
                height: { ideal: 720, max: 1080 },
                frameRate: { ideal: 30 },
              },
              audio: {
                echoCancellation: !0,
                noiseSuppression: !0,
                autoGainControl: !0,
              },
            });
            (Te.current = Qe),
              Me.current && (Me.current.srcObject = Qe),
              Ee(!0),
              setTimeout(() => {
                Z(!0), Q(!1), Ye();
              }, 2e3);
          } catch (Qe) {
            console.error("Permission error:", Qe),
              Re("Camera and microphone access required for video calls"),
              Q(!1);
          }
        },
        oe = () => {
          if (Te.current) {
            const Qe = Te.current.getVideoTracks()[0];
            Qe && ((Qe.enabled = !te), ne(!te));
          }
        },
        De = async () => {
          if (Te.current && xe) {
            const Qe = Te.current.getAudioTracks()[0];
            if (Qe)
              if (ae) {
                Qe.enabled = !1;
                try {
                  await xe.closeVoiceChat();
                } catch {}
                se(!1);
              } else {
                Qe.enabled = !0;
                try {
                  await xe.startVoiceChat();
                } catch {}
                se(!0);
              }
          }
        },
        Ge = async () => {
          const Qe = await fetch(`${H}/api/video/token`);
          if (!Qe.ok) {
            const pt = await Qe.json();
            throw new Error(`Failed to fetch access token: ${pt}`);
          }
          return (await Qe.json()).data.token;
        },
        pe = async () => {
          let Qe = [];
          console.log("[terminateAvatarSession] Called");
          try {
            if (xe) {
              console.log(
                "[terminateAvatarSession] Avatar ref exists, attempting to close voice chat"
              );
              try {
                await xe.closeVoiceChat(),
                  await xe.stopAvatar(),
                  console.log("[terminateAvatarSession] stopAvatar succeeded");
              } catch (Ie) {
                console.error(
                  "[terminateAvatarSession] Error stopping avatar:",
                  Ie
                ),
                  Qe.push("stopAvatar failed");
              }
              He(null),
                j(!1),
                console.log("[terminateAvatarSession] avatarRef set to null");
            } else
              console.log("[terminateAvatarSession] No avatarRef to clean up");
            Te.current &&
              (console.log(
                "[terminateAvatarSession] Stopping user media tracks"
              ),
              Te.current.getTracks().forEach((Ie) => {
                Ie.stop(),
                  console.log(
                    `[terminateAvatarSession] Stopped track: ${Ie.kind}`
                  );
              }),
              (Te.current = null)),
              Me.current &&
                ((Me.current.srcObject = null),
                console.log(
                  "[terminateAvatarSession] Cleared user video source"
                )),
              je.current &&
                ((je.current.srcObject = null),
                console.log(
                  "[terminateAvatarSession] Cleared AI video source"
                )),
              Z(!1),
              Q(!1),
              Ee(!1),
              be(!1),
              Fe(null),
              se(!1),
              ne(!1),
              Re(null),
              ce(!1),
              ve(!1),
              console.log("[terminateAvatarSession] State reset complete");
          } catch (Ie) {
            console.error("[terminateAvatarSession] General error:", Ie),
              Qe.push("General error in terminateAvatarSession");
          }
          Qe.length > 0
            ? (alert("Some errors occurred during cleanup: " + Qe.join(", ")),
              console.warn(
                "[terminateAvatarSession] completed with errors:",
                Qe
              ))
            : console.log("[terminateAvatarSession] completed successfully");
        },
        Ye = async () => {
          console.log("Initializing session...");
          try {
            const Qe = await Ge();
            if (!Qe) {
              alert("Unable to Start Session,please try again");
              return;
            }
            const Ie = new StreamingAvatar({ token: Qe });
            He(Ie),
              Ie.on(StreamingEvents.USER_START, () => {
                console.log("User started speaking");
              }),
              Ie.on(StreamingEvents.USER_STOP, () => {
                console.log("User stopped speaking");
              }),
              Ie.on(StreamingEvents.USER_TALKING_MESSAGE, async (tt) => {
                console.log("User message:", tt.detail.message);
                const gt = {
                  id: Date.now().toString(),
                  content: tt.detail.message,
                  sender: "user",
                  timestamp: new Date(),
                };
                B(gt),
                  $ &&
                    H &&
                    G &&
                    tt.detail.message &&
                    addMessageToConversation(
                      $,
                      H,
                      G,
                      "user",
                      tt.detail.message
                    );
              }),
              Ie.on(StreamingEvents.AVATAR_START_TALKING, () => {
                console.log("Agent started");
              }),
              Ie.on(StreamingEvents.AVATAR_STOP_TALKING, () => {
                console.log("Agent stopped");
              });
            let pt = "";
            Ie.on(StreamingEvents.AVATAR_TALKING_MESSAGE, async (tt) => {
              if (
                (console.log("Agent message:", tt.detail.message),
                (pt += tt.detail.message + " "),
                tt.detail.message.match(/[.!?]$/))
              )
                try {
                  const gt = [],
                    Jt = pt.trim().split(" ");
                  for (let gn = 0; gn < Jt.length; gn += 20)
                    gt.push(Jt.slice(gn, gn + 20).join(" "));
                  console.log(gt);
                  const nn = {
                    id: Date.now().toString(),
                    content: gt.join(""),
                    sender: "bot",
                    timestamp: new Date(),
                  };
                  B(nn),
                    $ &&
                      H &&
                      G &&
                      pt &&
                      addMessageToConversation($, H, G, "assistant", pt),
                    (pt = "");
                } catch (gt) {
                  console.error("Error processing message:", gt);
                }
            }),
              Ie.on(StreamingEvents.STREAM_DISCONNECTED, () => {
                console.log("Stream disconnected"), xe && pe(), ce(!0);
              }),
              Ie.on(StreamingEvents.STREAM_READY, (tt) => {
                console.log("Stream is ready"),
                  tt.detail && (Fe(tt.detail), be(!0));
              }),
              (await Ie.createStartAvatar({
                quality: AvatarQuality.High,
                avatarName: "SilasHR_public",
                disableIdleTimeout: !1,
                knowledgeBase: q,
                language: "en",
                voice: {
                  voiceId: "76d38d2180e74bf29baf916be2578bac",
                  rate: 1,
                  emotion: VoiceEmotion.SOOTHING,
                },
              })) || alert("Unable to Start Session,please try again");
            const We = {
              text: "Hello! I am your exthalpy Ai Assistant , here to guide you on our platform free to start the conversation!",
              task_type: TaskType.REPEAT,
            };
            if ((Ie.speak(We), Te.current)) {
              const tt = Te.current.getAudioTracks()[0];
              tt && (tt.enabled = ae);
            }
            ae ? await Ie.startVoiceChat() : await Ie.closeVoiceChat();
          } catch (Qe) {
            console.log(Qe),
              console.error("Error initializing avatar session:", Qe);
          }
        };
      return (
        reactExports.useEffect(() => {
          je.current &&
            Le &&
            (console.log("Loading AI Stream"),
            (je.current.srcObject = Le),
            je.current.play().catch((Qe) => {
              console.error("Error playing AI video:", Qe);
            }));
        }, [Le]),
        U
          ? jsxRuntimeExports.jsx(AnimatePresence, {
              children: jsxRuntimeExports.jsxs(motion.div, {
                initial: { opacity: 0, scale: 0.8 },
                animate: { opacity: 1, scale: 1 },
                exit: { opacity: 0, scale: 0.8 },
                transition: { type: "spring", stiffness: 300, damping: 30 },
                style: {
                  position: "fixed",
                  top: me ? "0" : "30%",
                  right: me ? "0" : "5%",
                  transform: me ? "none" : "translate(-50%, -50%)",
                  width: me ? "100vw" : fe ? "320px" : "480px",
                  height: me ? "100vh" : fe ? "240px" : "360px",
                  backgroundColor: "#000",
                  borderRadius: me ? "0" : V.borderRadius,
                  overflow: "hidden",
                  boxShadow: me
                    ? "none"
                    : "0 25px 50px -12px rgba(0, 0, 0, 0.5)",
                  zIndex: 1e3,
                  border: me ? "none" : `2px solid ${V.primaryColor}`,
                },
                children: [
                  jsxRuntimeExports.jsxs("div", {
                    style: {
                      position: "relative",
                      width: "100%",
                      height: "100%",
                    },
                    children: [
                      Ae
                        ? jsxRuntimeExports.jsx("video", {
                            ref: je,
                            autoPlay: !0,
                            playsInline: !0,
                            style: {
                              width: "100%",
                              height: "100%",
                              objectFit: "cover",
                            },
                          })
                        : jsxRuntimeExports.jsx("div", {
                            style: {
                              position: "absolute",
                              top: 0,
                              left: 0,
                              width: "100%",
                              height: "100%",
                              backgroundColor: "#1a1a1a",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                            },
                            children: X
                              ? jsxRuntimeExports.jsxs(motion.div, {
                                  initial: { scale: 0.8, opacity: 0 },
                                  animate: { scale: 1, opacity: 1 },
                                  style: {
                                    width: "100%",
                                    height: "100%",
                                    background:
                                      "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
                                    display: "flex",
                                    flexDirection: "column",
                                    alignItems: "center",
                                    justifyContent: "center",
                                    position: "relative",
                                  },
                                  children: [
                                    jsxRuntimeExports.jsx(motion.div, {
                                      animate: {
                                        scale: [1, 1.1, 1],
                                        rotate: [0, 5, -5, 0],
                                      },
                                      transition: {
                                        duration: 4,
                                        repeat: 1 / 0,
                                        ease: "easeInOut",
                                      },
                                      style: {
                                        width: "90px",
                                        height: "90px",
                                        borderRadius: "50%",
                                        backgroundColor: V.primaryColor,
                                        display: "flex",
                                        alignItems: "center",
                                        justifyContent: "center",
                                        marginBottom: "20px",
                                        boxShadow:
                                          "0 0 40px rgba(255, 255, 255, 0.3)",
                                      },
                                      children: jsxRuntimeExports.jsx("img", {
                                        src: V.companyLogo,
                                        alt: "AI Assistant",
                                        style: {
                                          width: "60px",
                                          height: "60px",
                                          borderRadius: "50%",
                                          objectFit: "cover",
                                        },
                                      }),
                                    }),
                                    jsxRuntimeExports.jsx(motion.div, {
                                      animate: { opacity: [0.7, 1, 0.7] },
                                      transition: {
                                        duration: 2,
                                        repeat: 1 / 0,
                                      },
                                      style: {
                                        color: "white",
                                        fontSize: "18px",
                                        fontWeight: "600",
                                        textAlign: "center",
                                      },
                                      children: "Video Agent connecting ...",
                                    }),
                                    jsxRuntimeExports.jsx("div", {
                                      style: {
                                        display: "flex",
                                        alignItems: "center",
                                        gap: "4px",
                                        marginTop: "16px",
                                      },
                                      children: [...Array(5)].map((Qe, Ie) =>
                                        jsxRuntimeExports.jsx(
                                          motion.div,
                                          {
                                            animate: {
                                              height: [8, 20, 8],
                                              backgroundColor: [
                                                "#ffffff80",
                                                "#ffffff",
                                                "#ffffff80",
                                              ],
                                            },
                                            transition: {
                                              duration: 1,
                                              repeat: 1 / 0,
                                              delay: Ie * 0.1,
                                            },
                                            style: {
                                              width: "3px",
                                              height: "8px",
                                              backgroundColor: "#ffffff80",
                                              borderRadius: "2px",
                                            },
                                          },
                                          Ie
                                        )
                                      ),
                                    }),
                                  ],
                                })
                              : Y
                              ? jsxRuntimeExports.jsxs(motion.div, {
                                  initial: { opacity: 0 },
                                  animate: { opacity: 1 },
                                  style: {
                                    display: "flex",
                                    flexDirection: "column",
                                    alignItems: "center",
                                    color: "white",
                                    gap: "16px",
                                  },
                                  children: [
                                    jsxRuntimeExports.jsx(LoaderCircle, {
                                      size: 32,
                                      style: {
                                        animation: "spin 1s linear infinite",
                                      },
                                    }),
                                    jsxRuntimeExports.jsx("p", {
                                      style: { margin: 0, fontSize: "16px" },
                                      children: "Connecting to AI Assistant...",
                                    }),
                                  ],
                                })
                              : jsxRuntimeExports.jsxs(motion.div, {
                                  initial: { opacity: 0 },
                                  animate: { opacity: 1 },
                                  style: {
                                    display: "flex",
                                    flexDirection: "column",
                                    alignItems: "center",
                                    color: "white",
                                    gap: "16px",
                                    textAlign: "center",
                                    padding: "20px",
                                  },
                                  children: [
                                    jsxRuntimeExports.jsx(VideoOff, {
                                      size: 48,
                                      style: { opacity: 0.5 },
                                    }),
                                    Ce
                                      ? jsxRuntimeExports.jsx("p", {
                                          style: {
                                            margin: 0,
                                            fontSize: "14px",
                                            color: "#ff6b6b",
                                          },
                                          children: Ce,
                                        })
                                      : jsxRuntimeExports.jsx("p", {
                                          style: {
                                            margin: 0,
                                            fontSize: "14px",
                                          },
                                          children:
                                            "AI Assistant video call ready",
                                        }),
                                  ],
                                }),
                          }),
                      jsxRuntimeExports.jsxs(motion.div, {
                        initial: { opacity: 0, scale: 0.8 },
                        animate: { opacity: 1, scale: 1 },
                        style: {
                          position: "absolute",
                          top: "16px",
                          right: "16px",
                          width: fe ? "80px" : "120px",
                          height: fe ? "60px" : "90px",
                          borderRadius: "12px",
                          overflow: "hidden",
                          border: `2px solid ${V.primaryColor}`,
                          backgroundColor: "#000",
                        },
                        children: [
                          jsxRuntimeExports.jsx("video", {
                            ref: Me,
                            autoPlay: !0,
                            muted: !0,
                            playsInline: !0,
                            style: {
                              width: "100%",
                              height: "100%",
                              objectFit: "cover",
                              transform: "scaleX(-1)",
                            },
                          }),
                          !te &&
                            jsxRuntimeExports.jsx("div", {
                              style: {
                                position: "absolute",
                                top: 0,
                                left: 0,
                                width: "100%",
                                height: "100%",
                                backgroundColor: "#1a1a1a",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                              },
                              children: jsxRuntimeExports.jsx(VideoOff, {
                                size: 24,
                                color: "white",
                              }),
                            }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs(motion.div, {
                        initial: { opacity: 0 },
                        animate: { opacity: 1 },
                        style: {
                          position: "absolute",
                          top: "16px",
                          left: "16px",
                          display: "flex",
                          alignItems: "center",
                          gap: "8px",
                          padding: "8px 12px",
                          backgroundColor: "rgba(0, 0, 0, 0.7)",
                          borderRadius: "20px",
                          backdropFilter: "blur(10px)",
                        },
                        children: [
                          ue === "excellent" &&
                            jsxRuntimeExports.jsx(Wifi, {
                              size: 16,
                              color: "#10b981",
                            }),
                          ue === "good" &&
                            jsxRuntimeExports.jsx(Wifi, {
                              size: 16,
                              color: "#f59e0b",
                            }),
                          ue === "poor" &&
                            jsxRuntimeExports.jsx(WifiOff, {
                              size: 16,
                              color: "#ef4444",
                            }),
                          jsxRuntimeExports.jsx("span", {
                            style: {
                              fontSize: "12px",
                              color: "white",
                              fontWeight: "500",
                            },
                            children: ue,
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsxs(motion.div, {
                        initial: { y: 20, opacity: 0 },
                        animate: { y: 0, opacity: 1 },
                        style: {
                          position: "absolute",
                          width: fe ? "100%" : "auto",
                          bottom: "16px",
                          left: "40%",
                          transform: "translateX(-50%)",
                          display: "flex",
                          alignItems: "center",
                          gap: "25px",
                          padding: "12px 16px",
                          background: "rgba(255, 255, 255, 0.15)",
                          borderRadius: "50px",
                          backdropFilter: "blur(20px)",
                          border: "1px solid rgba(255, 255, 255, 0.2)",
                          boxShadow: "0 8px 32px 0 rgba(31, 38, 135, 0.18)",
                        },
                        children: [
                          jsxRuntimeExports.jsx(motion.button, {
                            whileHover: { scale: 1.1 },
                            whileTap: { scale: 0.9 },
                            onClick: oe,
                            style: {
                              width: "44px",
                              height: "44px",
                              borderRadius: "50%",
                              backgroundColor: te ? V.primaryColor : "#ef4444",
                              border: "none",
                              cursor: "pointer",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              color: "white",
                              transition: "all 0.2s ease",
                              padding: "12px",
                            },
                            children: te
                              ? jsxRuntimeExports.jsx(Video, {})
                              : jsxRuntimeExports.jsx(VideoOff, {}),
                          }),
                          jsxRuntimeExports.jsx(motion.button, {
                            whileHover: { scale: 1.1 },
                            whileTap: { scale: 0.9 },
                            onClick: De,
                            style: {
                              width: "44px",
                              height: "44px",
                              borderRadius: "50%",
                              backgroundColor: ae ? V.primaryColor : "#ef4444",
                              border: "none",
                              cursor: "pointer",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              color: "white",
                              transition: "all 0.2s ease",
                              padding: "12px",
                            },
                            children: ae
                              ? jsxRuntimeExports.jsx(Mic, { size: 20 })
                              : jsxRuntimeExports.jsx(MicOff, { size: 20 }),
                          }),
                          jsxRuntimeExports.jsx(motion.button, {
                            whileHover: { scale: 1.1 },
                            whileTap: { scale: 0.9 },
                            onClick: () => ve(!me),
                            style: {
                              width: "44px",
                              height: "44px",
                              borderRadius: "50%",
                              backgroundColor: "rgba(255, 255, 255, 0.1)",
                              border: "none",
                              cursor: "pointer",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              color: "white",
                              transition: "all 0.2s ease",
                              padding: "12px",
                            },
                            children: me
                              ? jsxRuntimeExports.jsx(Minimize2, { size: 20 })
                              : jsxRuntimeExports.jsx(Maximize2, { size: 20 }),
                          }),
                          jsxRuntimeExports.jsx(motion.button, {
                            whileHover: { scale: 1.1 },
                            whileTap: { scale: 0.9 },
                            onClick: () => pe(),
                            style: {
                              width: "44px",
                              height: "44px",
                              borderRadius: "50%",
                              backgroundColor: "#ef4444",
                              border: "none",
                              cursor: "pointer",
                              display: "flex",
                              alignItems: "center",
                              justifyContent: "center",
                              color: "white",
                              transition: "all 0.2s ease",
                              padding: "12px",
                            },
                            children: jsxRuntimeExports.jsx(PhoneOff, {
                              size: 20,
                            }),
                          }),
                        ],
                      }),
                    ],
                  }),
                  jsxRuntimeExports.jsx("style", {
                    children: `
            @keyframes spin {
              from { transform: rotate(0deg); }
              to { transform: rotate(360deg); }
            }
          `,
                  }),
                ],
              }),
            })
          : null
      );
    },
    TOKEN_API = "https://chat-bot-backend-1-28ro.onrender.com/api/voice/token",
    VoiceAgent = ({
      setMessages: U,
      setGenerating: j,
      prompt: V,
      clientKey: B,
      apiUrl: q,
      sessionId: $,
      theme: H,
    }) => {
      const G = reactExports.useRef(null),
        Y = reactExports.useRef(null),
        Q = reactExports.useRef(null),
        X = reactExports.useRef(null),
        Z = reactExports.useRef(null),
        te = reactExports.useRef(null),
        ne = reactExports.useRef(""),
        [ae, se] = reactExports.useState(!1),
        [fe, ce] = reactExports.useState(!1);
      reactExports.useEffect(() => {
        const Ce = document.createElement("style");
        return (
          (Ce.innerHTML = `
      @keyframes voice-pulse {
        0%, 100% { transform: scaleY(0.3); opacity: 0.3; }
        50%      { transform: scaleY(1);   opacity: 1;   }
      }
    `),
          document.head.appendChild(Ce),
          () => {
            document.head.removeChild(Ce);
          }
        );
      }, []);
      const ue = async () => {
          console.log("End call Start"),
            Y.current?.getSenders().forEach((Ce) => Ce.track?.stop()),
            Y.current?.close(),
            (Y.current = null),
            G.current?.readyState === "open" && G.current.close(),
            Q.current?.getTracks().forEach((Ce) => Ce.stop()),
            (Q.current = null),
            X.current &&
              (X.current.pause(),
              (X.current.currentTime = 0),
              (X.current.srcObject = null)),
            te.current?.disconnect(),
            (te.current = null),
            await Z.current?.close(),
            (Z.current = null),
            ce(!1),
            j(!1),
            console.log("End call End");
        },
        he = async () => {
          try {
            j(!0);
            const Ce = await fetch(TOKEN_API, { method: "GET" }),
              { client_secret: Re } = await Ce.json(),
              Ae = Re.value,
              be = new RTCPeerConnection();
            (Y.current = be),
              (Q.current = await navigator.mediaDevices.getUserMedia({
                audio: !0,
              }));
            const [Le] = Q.current.getTracks();
            be.addTrack(Le);
            const Fe = be.createDataChannel("oai-events");
            (G.current = Fe),
              (Fe.onopen = () => {
                const xe = {
                  type: "session.update",
                  session: {
                    instructions: `Speak in a warm, clear and strong Indian accent. Keep conversation friendly and educational.


+${V}`,
                    input_audio_transcription: { model: "whisper-1" },
                  },
                };
                Fe.send(JSON.stringify(xe));
              }),
              (Fe.onmessage = (xe) => {
                const He = JSON.parse(xe.data),
                  { type: Je, transcript: oe, text: De, delta: Ge } = He;
                if (
                  Je === "conversation.item.input_audio_transcription.completed"
                ) {
                  j(!0);
                  const pe = oe || De;
                  if (pe) {
                    const Ye = {
                      id: Date.now().toString(),
                      content: pe,
                      sender: "user",
                      timestamp: new Date(),
                    };
                    U(Ye),
                      B &&
                        q &&
                        $ &&
                        addMessageToConversation(B, q, $, "user", pe);
                  }
                }
                if (
                  (Je === "response.audio_transcript.delta" &&
                    (ne.current += Ge),
                  Je === "response.audio_transcript.done")
                ) {
                  const pe = ne.current.trim();
                  if (pe) {
                    const Ye = {
                      id: (Date.now() + 1).toString(),
                      content: pe,
                      sender: "bot",
                      timestamp: new Date(),
                    };
                    U(Ye),
                      j(!1),
                      B &&
                        q &&
                        $ &&
                        addMessageToConversation(B, q, $, "assistant", pe);
                  }
                  ne.current = "";
                }
              }),
              (be.ontrack = (xe) => {
                const He = xe.streams[0];
                if (X.current) {
                  (X.current.srcObject = He), (X.current.volume = 1);
                  const Ye = X.current.play();
                  Ye !== void 0 &&
                    Ye.catch((Qe) => {
                      console.error("Audio playback error:", Qe),
                        Z.current?.state === "suspended" && Z.current.resume();
                    });
                }
                const Je = new AudioContext();
                Z.current = Je;
                const oe = Je.createMediaStreamSource(He);
                te.current = oe;
                const De = Je.createAnalyser();
                (De.fftSize = 512), oe.connect(De);
                const Ge = new Uint8Array(De.frequencyBinCount),
                  pe = setInterval(() => {
                    De.getByteFrequencyData(Ge);
                    const Ye = Ge.reduce((Qe, Ie) => Qe + Ie, 0) / Ge.length;
                    se(Ye > 10);
                  }, 300);
                He.getTracks().forEach((Ye) =>
                  Ye.addEventListener("ended", () => {
                    clearInterval(pe), se(!1);
                  })
                );
              });
            const Me = await be.createOffer();
            await be.setLocalDescription(Me);
            const Te = {
              type: "answer",
              sdp: await (
                await fetch(
                  "https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-12-17",
                  {
                    method: "POST",
                    body: Me.sdp,
                    headers: {
                      Authorization: `Bearer ${Ae}`,
                      "Content-Type": "application/sdp",
                    },
                  }
                )
              ).text(),
            };
            await be.setRemoteDescription(Te), ce(!0), j(!1);
          } catch (Ce) {
            console.error("Start call error:", Ce), j(!1), ue();
          }
        };
      reactExports.useEffect(
        () => () => {
          console.log("Unmounting Voice"), ue();
        },
        []
      );
      const me = {
          border: "none",
          borderRadius: "50%",
          padding: "5px",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          transition: "all 0.3s",
          backgroundColor: fe ? "red" : H.primaryColor,
          opacity: fe ? "0.75" : "1",
        },
        ve = { height: "1.5rem", width: "1.5rem", color: "#ffffff" },
        ge = {
          display: "flex",
          alignItems: "flex-end",
          gap: "0.25rem",
          height: "1.5rem",
        },
        Ee = {
          width: "3px",
          height: "100%",
          backgroundColor: "#FFFFFF",
          borderRadius: "2px",
          animation: "voice-pulse 1s infinite ease-in-out",
        };
      return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx("button", {
            onClick: () => (fe ? ue() : he()),
            style: me,
            children:
              fe && ae
                ? jsxRuntimeExports.jsx("div", {
                    style: ge,
                    children: [0, 1, 2, 3].map((Ce) =>
                      jsxRuntimeExports.jsx(
                        "div",
                        { style: { ...Ee, animationDelay: `${Ce * 0.15}s` } },
                        Ce
                      )
                    ),
                  })
                : jsxRuntimeExports.jsx(Mic, { style: ve }),
          }),
          jsxRuntimeExports.jsx("audio", {
            ref: X,
            autoPlay: !0,
            playsInline: !0,
            controls: !1,
            style: { display: "none" },
          }),
        ],
      });
    },
    EmailCollector = ({ onEmailCollected: U, theme: j }) => {
      const [V, B] = reactExports.useState(""),
        [q, $] = reactExports.useState(!0),
        [H, G] = reactExports.useState(!1),
        Y = (te) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(te),
        Q = (te) => {
          localStorage.setItem("userEmail", te);
        },
        X = (te) => {
          const ne = te.target.value;
          B(ne), $(!0);
        },
        Z = (te) => {
          if ((te.preventDefault(), !Y(V))) {
            $(!1);
            return;
          }
          Q(V), G(!0), U(V);
        };
      return H
        ? jsxRuntimeExports.jsxs(motion.div, {
            initial: { opacity: 0, scale: 0.9 },
            animate: { opacity: 1, scale: 1 },
            style: { padding: "20px", textAlign: "center", color: j.textColor },
            children: [
              jsxRuntimeExports.jsx(Check, {
                size: 24,
                color: j.primaryColor,
                style: { marginBottom: "8px" },
              }),
              jsxRuntimeExports.jsx("div", {
                style: { fontSize: "14px", fontWeight: "500" },
                children: "Email saved successfully!",
              }),
              jsxRuntimeExports.jsx("div", {
                style: { fontSize: "12px", opacity: 0.7, marginTop: "4px" },
                children: "You can now start chatting",
              }),
            ],
          })
        : jsxRuntimeExports.jsxs(motion.div, {
            initial: { opacity: 0, y: 20 },
            animate: { opacity: 1, y: 0 },
            style: {
              padding: "20px",
              borderBottom: `1px solid ${j.primaryColor}20`,
              maxWidth: "100%",
            },
            children: [
              jsxRuntimeExports.jsxs("div", {
                style: {
                  display: "flex",
                  alignItems: "center",
                  gap: "8px",
                  marginBottom: "12px",
                  color: j.textColor,
                },
                children: [
                  jsxRuntimeExports.jsx(Mail, {
                    size: 16,
                    color: j.primaryColor,
                  }),
                  jsxRuntimeExports.jsx("span", {
                    style: { fontSize: "14px", fontWeight: "500" },
                    children: "Welcome! Please enter your email to continue",
                  }),
                ],
              }),
              jsxRuntimeExports.jsxs("form", {
                onSubmit: Z,
                children: [
                  jsxRuntimeExports.jsx("input", {
                    type: "email",
                    value: V,
                    onChange: X,
                    placeholder: "your.email@example.com",
                    style: {
                      width: "100%",
                      padding: "12px 16px",
                      borderRadius: "8px",
                      border: `1px solid ${
                        q ? j.primaryColor + "20" : "#ef4444"
                      }`,
                      backgroundColor: j.backgroundColor,
                      color: j.textColor,
                      fontSize: "14px",
                      outline: "none",
                      marginBottom: "8px",
                      maxWidth: "100%",
                      boxSizing: "border-box",
                    },
                  }),
                  !q &&
                    jsxRuntimeExports.jsx("div", {
                      style: {
                        color: "#ef4444",
                        fontSize: "12px",
                        marginBottom: "8px",
                      },
                      children: "Please enter a valid email address",
                    }),
                  jsxRuntimeExports.jsx("button", {
                    type: "submit",
                    style: {
                      width: "100%",
                      padding: "12px 16px",
                      borderRadius: "8px",
                      backgroundColor: j.primaryColor,
                      color: "white",
                      border: "none",
                      fontSize: "14px",
                      fontWeight: "500",
                      cursor: "pointer",
                    },
                    children: "Continue",
                  }),
                ],
              }),
              jsxRuntimeExports.jsx("div", {
                style: {
                  fontSize: "11px",
                  opacity: 0.6,
                  marginTop: "8px",
                  textAlign: "center",
                  color: j.textColor,
                },
                children: "We'll use this to save your conversation history",
              }),
            ],
          });
    },
    defaultTheme = {
      primaryColor: "#1d4ed8",
      secondaryColor: "#3b82f6",
      backgroundColor: "#ffffff",
      headerFooterBgColor: "#f8fafc",
      userMessageBgColor: "#1d4ed8",
      aiMessageBgColor: "#f8fafc",
      inputContainerBgColor: "#f1f5f9",
      textColor: "#1f2937",
      borderRadius: "1rem",
      fontSize: "1rem",
      position: "bottom-right",
      shadowColor: "rgba(0, 0, 0, 0.1)",
      companyName: "ChatBot",
      companyLogo: "https://placehold.co/32x32",
      prompt:
        "You are a helpful AI assistant. Please provide clear and concise responses.",
      voiceEnabled: !0,
      soundEnabled: !0,
    },
    loadTheme = async (U) => {
      try {
        try {
          const V = await fetch(
            `https://chat-bot-backend-1-28ro.onrender.com/api/client/${U}/theme`
          );
          if (V.ok) {
            const B = await V.json();
            return { ...defaultTheme, ...B };
          }
        } catch (j) {
          console.warn("Failed to load theme from backend:", j);
        }
        return defaultTheme;
      } catch (j) {
        return console.error("Error loading theme:", j), defaultTheme;
      }
    };
  function ok$1() {}
  function unreachable() {}
  function stringify$1(U, j) {
    const V = {};
    return (U[U.length - 1] === "" ? [...U, ""] : U)
      .join((V.padRight ? " " : "") + "," + (V.padLeft === !1 ? "" : " "))
      .trim();
  }
  const nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
    nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u,
    emptyOptions$2 = {};
  function name(U, j) {
    return (emptyOptions$2.jsx ? nameReJsx : nameRe).test(U);
  }
  const re = /[ \t\n\f\r]/g;
  function whitespace(U) {
    return typeof U == "object"
      ? U.type === "text"
        ? empty$1(U.value)
        : !1
      : empty$1(U);
  }
  function empty$1(U) {
    return U.replace(re, "") === "";
  }
  class Schema {
    constructor(j, V, B) {
      (this.normal = V), (this.property = j), B && (this.space = B);
    }
  }
  (Schema.prototype.normal = {}),
    (Schema.prototype.property = {}),
    (Schema.prototype.space = void 0);
  function merge(U, j) {
    const V = {},
      B = {};
    for (const q of U) Object.assign(V, q.property), Object.assign(B, q.normal);
    return new Schema(V, B, j);
  }
  function normalize$1(U) {
    return U.toLowerCase();
  }
  class Info {
    constructor(j, V) {
      (this.attribute = V), (this.property = j);
    }
  }
  (Info.prototype.attribute = ""),
    (Info.prototype.booleanish = !1),
    (Info.prototype.boolean = !1),
    (Info.prototype.commaOrSpaceSeparated = !1),
    (Info.prototype.commaSeparated = !1),
    (Info.prototype.defined = !1),
    (Info.prototype.mustUseProperty = !1),
    (Info.prototype.number = !1),
    (Info.prototype.overloadedBoolean = !1),
    (Info.prototype.property = ""),
    (Info.prototype.spaceSeparated = !1),
    (Info.prototype.space = void 0);
  let powers = 0;
  const boolean = increment(),
    booleanish = increment(),
    overloadedBoolean = increment(),
    number = increment(),
    spaceSeparated = increment(),
    commaSeparated = increment(),
    commaOrSpaceSeparated = increment();
  function increment() {
    return 2 ** ++powers;
  }
  const types = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          boolean,
          booleanish,
          commaOrSpaceSeparated,
          commaSeparated,
          number,
          overloadedBoolean,
          spaceSeparated,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    ),
    checks = Object.keys(types);
  class DefinedInfo extends Info {
    constructor(j, V, B, q) {
      let $ = -1;
      if ((super(j, V), mark(this, "space", q), typeof B == "number"))
        for (; ++$ < checks.length; ) {
          const H = checks[$];
          mark(this, checks[$], (B & types[H]) === types[H]);
        }
    }
  }
  DefinedInfo.prototype.defined = !0;
  function mark(U, j, V) {
    V && (U[j] = V);
  }
  function create(U) {
    const j = {},
      V = {};
    for (const [B, q] of Object.entries(U.properties)) {
      const $ = new DefinedInfo(
        B,
        U.transform(U.attributes || {}, B),
        q,
        U.space
      );
      U.mustUseProperty &&
        U.mustUseProperty.includes(B) &&
        ($.mustUseProperty = !0),
        (j[B] = $),
        (V[normalize$1(B)] = B),
        (V[normalize$1($.attribute)] = B);
    }
    return new Schema(j, V, U.space);
  }
  const aria = create({
    properties: {
      ariaActiveDescendant: null,
      ariaAtomic: booleanish,
      ariaAutoComplete: null,
      ariaBusy: booleanish,
      ariaChecked: booleanish,
      ariaColCount: number,
      ariaColIndex: number,
      ariaColSpan: number,
      ariaControls: spaceSeparated,
      ariaCurrent: null,
      ariaDescribedBy: spaceSeparated,
      ariaDetails: null,
      ariaDisabled: booleanish,
      ariaDropEffect: spaceSeparated,
      ariaErrorMessage: null,
      ariaExpanded: booleanish,
      ariaFlowTo: spaceSeparated,
      ariaGrabbed: booleanish,
      ariaHasPopup: null,
      ariaHidden: booleanish,
      ariaInvalid: null,
      ariaKeyShortcuts: null,
      ariaLabel: null,
      ariaLabelledBy: spaceSeparated,
      ariaLevel: number,
      ariaLive: null,
      ariaModal: booleanish,
      ariaMultiLine: booleanish,
      ariaMultiSelectable: booleanish,
      ariaOrientation: null,
      ariaOwns: spaceSeparated,
      ariaPlaceholder: null,
      ariaPosInSet: number,
      ariaPressed: booleanish,
      ariaReadOnly: booleanish,
      ariaRelevant: null,
      ariaRequired: booleanish,
      ariaRoleDescription: spaceSeparated,
      ariaRowCount: number,
      ariaRowIndex: number,
      ariaRowSpan: number,
      ariaSelected: booleanish,
      ariaSetSize: number,
      ariaSort: null,
      ariaValueMax: number,
      ariaValueMin: number,
      ariaValueNow: number,
      ariaValueText: null,
      role: null,
    },
    transform(U, j) {
      return j === "role" ? j : "aria-" + j.slice(4).toLowerCase();
    },
  });
  function caseSensitiveTransform(U, j) {
    return j in U ? U[j] : j;
  }
  function caseInsensitiveTransform(U, j) {
    return caseSensitiveTransform(U, j.toLowerCase());
  }
  const html$2 = create({
      attributes: {
        acceptcharset: "accept-charset",
        classname: "class",
        htmlfor: "for",
        httpequiv: "http-equiv",
      },
      mustUseProperty: ["checked", "multiple", "muted", "selected"],
      properties: {
        abbr: null,
        accept: commaSeparated,
        acceptCharset: spaceSeparated,
        accessKey: spaceSeparated,
        action: null,
        allow: null,
        allowFullScreen: boolean,
        allowPaymentRequest: boolean,
        allowUserMedia: boolean,
        alt: null,
        as: null,
        async: boolean,
        autoCapitalize: null,
        autoComplete: spaceSeparated,
        autoFocus: boolean,
        autoPlay: boolean,
        blocking: spaceSeparated,
        capture: null,
        charSet: null,
        checked: boolean,
        cite: null,
        className: spaceSeparated,
        cols: number,
        colSpan: null,
        content: null,
        contentEditable: booleanish,
        controls: boolean,
        controlsList: spaceSeparated,
        coords: number | commaSeparated,
        crossOrigin: null,
        data: null,
        dateTime: null,
        decoding: null,
        default: boolean,
        defer: boolean,
        dir: null,
        dirName: null,
        disabled: boolean,
        download: overloadedBoolean,
        draggable: booleanish,
        encType: null,
        enterKeyHint: null,
        fetchPriority: null,
        form: null,
        formAction: null,
        formEncType: null,
        formMethod: null,
        formNoValidate: boolean,
        formTarget: null,
        headers: spaceSeparated,
        height: number,
        hidden: overloadedBoolean,
        high: number,
        href: null,
        hrefLang: null,
        htmlFor: spaceSeparated,
        httpEquiv: spaceSeparated,
        id: null,
        imageSizes: null,
        imageSrcSet: null,
        inert: boolean,
        inputMode: null,
        integrity: null,
        is: null,
        isMap: boolean,
        itemId: null,
        itemProp: spaceSeparated,
        itemRef: spaceSeparated,
        itemScope: boolean,
        itemType: spaceSeparated,
        kind: null,
        label: null,
        lang: null,
        language: null,
        list: null,
        loading: null,
        loop: boolean,
        low: number,
        manifest: null,
        max: null,
        maxLength: number,
        media: null,
        method: null,
        min: null,
        minLength: number,
        multiple: boolean,
        muted: boolean,
        name: null,
        nonce: null,
        noModule: boolean,
        noValidate: boolean,
        onAbort: null,
        onAfterPrint: null,
        onAuxClick: null,
        onBeforeMatch: null,
        onBeforePrint: null,
        onBeforeToggle: null,
        onBeforeUnload: null,
        onBlur: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onContextLost: null,
        onContextMenu: null,
        onContextRestored: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFormData: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLanguageChange: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadEnd: null,
        onLoadStart: null,
        onMessage: null,
        onMessageError: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRejectionHandled: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onScrollEnd: null,
        onSecurityPolicyViolation: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onSlotChange: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnhandledRejection: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onWheel: null,
        open: boolean,
        optimum: number,
        pattern: null,
        ping: spaceSeparated,
        placeholder: null,
        playsInline: boolean,
        popover: null,
        popoverTarget: null,
        popoverTargetAction: null,
        poster: null,
        preload: null,
        readOnly: boolean,
        referrerPolicy: null,
        rel: spaceSeparated,
        required: boolean,
        reversed: boolean,
        rows: number,
        rowSpan: number,
        sandbox: spaceSeparated,
        scope: null,
        scoped: boolean,
        seamless: boolean,
        selected: boolean,
        shadowRootClonable: boolean,
        shadowRootDelegatesFocus: boolean,
        shadowRootMode: null,
        shape: null,
        size: number,
        sizes: null,
        slot: null,
        span: number,
        spellCheck: booleanish,
        src: null,
        srcDoc: null,
        srcLang: null,
        srcSet: null,
        start: number,
        step: null,
        style: null,
        tabIndex: number,
        target: null,
        title: null,
        translate: null,
        type: null,
        typeMustMatch: boolean,
        useMap: null,
        value: booleanish,
        width: number,
        wrap: null,
        writingSuggestions: null,
        align: null,
        aLink: null,
        archive: spaceSeparated,
        axis: null,
        background: null,
        bgColor: null,
        border: number,
        borderColor: null,
        bottomMargin: number,
        cellPadding: null,
        cellSpacing: null,
        char: null,
        charOff: null,
        classId: null,
        clear: null,
        code: null,
        codeBase: null,
        codeType: null,
        color: null,
        compact: boolean,
        declare: boolean,
        event: null,
        face: null,
        frame: null,
        frameBorder: null,
        hSpace: number,
        leftMargin: number,
        link: null,
        longDesc: null,
        lowSrc: null,
        marginHeight: number,
        marginWidth: number,
        noResize: boolean,
        noHref: boolean,
        noShade: boolean,
        noWrap: boolean,
        object: null,
        profile: null,
        prompt: null,
        rev: null,
        rightMargin: number,
        rules: null,
        scheme: null,
        scrolling: booleanish,
        standby: null,
        summary: null,
        text: null,
        topMargin: number,
        valueType: null,
        version: null,
        vAlign: null,
        vLink: null,
        vSpace: number,
        allowTransparency: null,
        autoCorrect: null,
        autoSave: null,
        disablePictureInPicture: boolean,
        disableRemotePlayback: boolean,
        prefix: null,
        property: null,
        results: number,
        security: null,
        unselectable: null,
      },
      space: "html",
      transform: caseInsensitiveTransform,
    }),
    svg$1 = create({
      attributes: {
        accentHeight: "accent-height",
        alignmentBaseline: "alignment-baseline",
        arabicForm: "arabic-form",
        baselineShift: "baseline-shift",
        capHeight: "cap-height",
        className: "class",
        clipPath: "clip-path",
        clipRule: "clip-rule",
        colorInterpolation: "color-interpolation",
        colorInterpolationFilters: "color-interpolation-filters",
        colorProfile: "color-profile",
        colorRendering: "color-rendering",
        crossOrigin: "crossorigin",
        dataType: "datatype",
        dominantBaseline: "dominant-baseline",
        enableBackground: "enable-background",
        fillOpacity: "fill-opacity",
        fillRule: "fill-rule",
        floodColor: "flood-color",
        floodOpacity: "flood-opacity",
        fontFamily: "font-family",
        fontSize: "font-size",
        fontSizeAdjust: "font-size-adjust",
        fontStretch: "font-stretch",
        fontStyle: "font-style",
        fontVariant: "font-variant",
        fontWeight: "font-weight",
        glyphName: "glyph-name",
        glyphOrientationHorizontal: "glyph-orientation-horizontal",
        glyphOrientationVertical: "glyph-orientation-vertical",
        hrefLang: "hreflang",
        horizAdvX: "horiz-adv-x",
        horizOriginX: "horiz-origin-x",
        horizOriginY: "horiz-origin-y",
        imageRendering: "image-rendering",
        letterSpacing: "letter-spacing",
        lightingColor: "lighting-color",
        markerEnd: "marker-end",
        markerMid: "marker-mid",
        markerStart: "marker-start",
        navDown: "nav-down",
        navDownLeft: "nav-down-left",
        navDownRight: "nav-down-right",
        navLeft: "nav-left",
        navNext: "nav-next",
        navPrev: "nav-prev",
        navRight: "nav-right",
        navUp: "nav-up",
        navUpLeft: "nav-up-left",
        navUpRight: "nav-up-right",
        onAbort: "onabort",
        onActivate: "onactivate",
        onAfterPrint: "onafterprint",
        onBeforePrint: "onbeforeprint",
        onBegin: "onbegin",
        onCancel: "oncancel",
        onCanPlay: "oncanplay",
        onCanPlayThrough: "oncanplaythrough",
        onChange: "onchange",
        onClick: "onclick",
        onClose: "onclose",
        onCopy: "oncopy",
        onCueChange: "oncuechange",
        onCut: "oncut",
        onDblClick: "ondblclick",
        onDrag: "ondrag",
        onDragEnd: "ondragend",
        onDragEnter: "ondragenter",
        onDragExit: "ondragexit",
        onDragLeave: "ondragleave",
        onDragOver: "ondragover",
        onDragStart: "ondragstart",
        onDrop: "ondrop",
        onDurationChange: "ondurationchange",
        onEmptied: "onemptied",
        onEnd: "onend",
        onEnded: "onended",
        onError: "onerror",
        onFocus: "onfocus",
        onFocusIn: "onfocusin",
        onFocusOut: "onfocusout",
        onHashChange: "onhashchange",
        onInput: "oninput",
        onInvalid: "oninvalid",
        onKeyDown: "onkeydown",
        onKeyPress: "onkeypress",
        onKeyUp: "onkeyup",
        onLoad: "onload",
        onLoadedData: "onloadeddata",
        onLoadedMetadata: "onloadedmetadata",
        onLoadStart: "onloadstart",
        onMessage: "onmessage",
        onMouseDown: "onmousedown",
        onMouseEnter: "onmouseenter",
        onMouseLeave: "onmouseleave",
        onMouseMove: "onmousemove",
        onMouseOut: "onmouseout",
        onMouseOver: "onmouseover",
        onMouseUp: "onmouseup",
        onMouseWheel: "onmousewheel",
        onOffline: "onoffline",
        onOnline: "ononline",
        onPageHide: "onpagehide",
        onPageShow: "onpageshow",
        onPaste: "onpaste",
        onPause: "onpause",
        onPlay: "onplay",
        onPlaying: "onplaying",
        onPopState: "onpopstate",
        onProgress: "onprogress",
        onRateChange: "onratechange",
        onRepeat: "onrepeat",
        onReset: "onreset",
        onResize: "onresize",
        onScroll: "onscroll",
        onSeeked: "onseeked",
        onSeeking: "onseeking",
        onSelect: "onselect",
        onShow: "onshow",
        onStalled: "onstalled",
        onStorage: "onstorage",
        onSubmit: "onsubmit",
        onSuspend: "onsuspend",
        onTimeUpdate: "ontimeupdate",
        onToggle: "ontoggle",
        onUnload: "onunload",
        onVolumeChange: "onvolumechange",
        onWaiting: "onwaiting",
        onZoom: "onzoom",
        overlinePosition: "overline-position",
        overlineThickness: "overline-thickness",
        paintOrder: "paint-order",
        panose1: "panose-1",
        pointerEvents: "pointer-events",
        referrerPolicy: "referrerpolicy",
        renderingIntent: "rendering-intent",
        shapeRendering: "shape-rendering",
        stopColor: "stop-color",
        stopOpacity: "stop-opacity",
        strikethroughPosition: "strikethrough-position",
        strikethroughThickness: "strikethrough-thickness",
        strokeDashArray: "stroke-dasharray",
        strokeDashOffset: "stroke-dashoffset",
        strokeLineCap: "stroke-linecap",
        strokeLineJoin: "stroke-linejoin",
        strokeMiterLimit: "stroke-miterlimit",
        strokeOpacity: "stroke-opacity",
        strokeWidth: "stroke-width",
        tabIndex: "tabindex",
        textAnchor: "text-anchor",
        textDecoration: "text-decoration",
        textRendering: "text-rendering",
        transformOrigin: "transform-origin",
        typeOf: "typeof",
        underlinePosition: "underline-position",
        underlineThickness: "underline-thickness",
        unicodeBidi: "unicode-bidi",
        unicodeRange: "unicode-range",
        unitsPerEm: "units-per-em",
        vAlphabetic: "v-alphabetic",
        vHanging: "v-hanging",
        vIdeographic: "v-ideographic",
        vMathematical: "v-mathematical",
        vectorEffect: "vector-effect",
        vertAdvY: "vert-adv-y",
        vertOriginX: "vert-origin-x",
        vertOriginY: "vert-origin-y",
        wordSpacing: "word-spacing",
        writingMode: "writing-mode",
        xHeight: "x-height",
        playbackOrder: "playbackorder",
        timelineBegin: "timelinebegin",
      },
      properties: {
        about: commaOrSpaceSeparated,
        accentHeight: number,
        accumulate: null,
        additive: null,
        alignmentBaseline: null,
        alphabetic: number,
        amplitude: number,
        arabicForm: null,
        ascent: number,
        attributeName: null,
        attributeType: null,
        azimuth: number,
        bandwidth: null,
        baselineShift: null,
        baseFrequency: null,
        baseProfile: null,
        bbox: null,
        begin: null,
        bias: number,
        by: null,
        calcMode: null,
        capHeight: number,
        className: spaceSeparated,
        clip: null,
        clipPath: null,
        clipPathUnits: null,
        clipRule: null,
        color: null,
        colorInterpolation: null,
        colorInterpolationFilters: null,
        colorProfile: null,
        colorRendering: null,
        content: null,
        contentScriptType: null,
        contentStyleType: null,
        crossOrigin: null,
        cursor: null,
        cx: null,
        cy: null,
        d: null,
        dataType: null,
        defaultAction: null,
        descent: number,
        diffuseConstant: number,
        direction: null,
        display: null,
        dur: null,
        divisor: number,
        dominantBaseline: null,
        download: boolean,
        dx: null,
        dy: null,
        edgeMode: null,
        editable: null,
        elevation: number,
        enableBackground: null,
        end: null,
        event: null,
        exponent: number,
        externalResourcesRequired: null,
        fill: null,
        fillOpacity: number,
        fillRule: null,
        filter: null,
        filterRes: null,
        filterUnits: null,
        floodColor: null,
        floodOpacity: null,
        focusable: null,
        focusHighlight: null,
        fontFamily: null,
        fontSize: null,
        fontSizeAdjust: null,
        fontStretch: null,
        fontStyle: null,
        fontVariant: null,
        fontWeight: null,
        format: null,
        fr: null,
        from: null,
        fx: null,
        fy: null,
        g1: commaSeparated,
        g2: commaSeparated,
        glyphName: commaSeparated,
        glyphOrientationHorizontal: null,
        glyphOrientationVertical: null,
        glyphRef: null,
        gradientTransform: null,
        gradientUnits: null,
        handler: null,
        hanging: number,
        hatchContentUnits: null,
        hatchUnits: null,
        height: null,
        href: null,
        hrefLang: null,
        horizAdvX: number,
        horizOriginX: number,
        horizOriginY: number,
        id: null,
        ideographic: number,
        imageRendering: null,
        initialVisibility: null,
        in: null,
        in2: null,
        intercept: number,
        k: number,
        k1: number,
        k2: number,
        k3: number,
        k4: number,
        kernelMatrix: commaOrSpaceSeparated,
        kernelUnitLength: null,
        keyPoints: null,
        keySplines: null,
        keyTimes: null,
        kerning: null,
        lang: null,
        lengthAdjust: null,
        letterSpacing: null,
        lightingColor: null,
        limitingConeAngle: number,
        local: null,
        markerEnd: null,
        markerMid: null,
        markerStart: null,
        markerHeight: null,
        markerUnits: null,
        markerWidth: null,
        mask: null,
        maskContentUnits: null,
        maskUnits: null,
        mathematical: null,
        max: null,
        media: null,
        mediaCharacterEncoding: null,
        mediaContentEncodings: null,
        mediaSize: number,
        mediaTime: null,
        method: null,
        min: null,
        mode: null,
        name: null,
        navDown: null,
        navDownLeft: null,
        navDownRight: null,
        navLeft: null,
        navNext: null,
        navPrev: null,
        navRight: null,
        navUp: null,
        navUpLeft: null,
        navUpRight: null,
        numOctaves: null,
        observer: null,
        offset: null,
        onAbort: null,
        onActivate: null,
        onAfterPrint: null,
        onBeforePrint: null,
        onBegin: null,
        onCancel: null,
        onCanPlay: null,
        onCanPlayThrough: null,
        onChange: null,
        onClick: null,
        onClose: null,
        onCopy: null,
        onCueChange: null,
        onCut: null,
        onDblClick: null,
        onDrag: null,
        onDragEnd: null,
        onDragEnter: null,
        onDragExit: null,
        onDragLeave: null,
        onDragOver: null,
        onDragStart: null,
        onDrop: null,
        onDurationChange: null,
        onEmptied: null,
        onEnd: null,
        onEnded: null,
        onError: null,
        onFocus: null,
        onFocusIn: null,
        onFocusOut: null,
        onHashChange: null,
        onInput: null,
        onInvalid: null,
        onKeyDown: null,
        onKeyPress: null,
        onKeyUp: null,
        onLoad: null,
        onLoadedData: null,
        onLoadedMetadata: null,
        onLoadStart: null,
        onMessage: null,
        onMouseDown: null,
        onMouseEnter: null,
        onMouseLeave: null,
        onMouseMove: null,
        onMouseOut: null,
        onMouseOver: null,
        onMouseUp: null,
        onMouseWheel: null,
        onOffline: null,
        onOnline: null,
        onPageHide: null,
        onPageShow: null,
        onPaste: null,
        onPause: null,
        onPlay: null,
        onPlaying: null,
        onPopState: null,
        onProgress: null,
        onRateChange: null,
        onRepeat: null,
        onReset: null,
        onResize: null,
        onScroll: null,
        onSeeked: null,
        onSeeking: null,
        onSelect: null,
        onShow: null,
        onStalled: null,
        onStorage: null,
        onSubmit: null,
        onSuspend: null,
        onTimeUpdate: null,
        onToggle: null,
        onUnload: null,
        onVolumeChange: null,
        onWaiting: null,
        onZoom: null,
        opacity: null,
        operator: null,
        order: null,
        orient: null,
        orientation: null,
        origin: null,
        overflow: null,
        overlay: null,
        overlinePosition: number,
        overlineThickness: number,
        paintOrder: null,
        panose1: null,
        path: null,
        pathLength: number,
        patternContentUnits: null,
        patternTransform: null,
        patternUnits: null,
        phase: null,
        ping: spaceSeparated,
        pitch: null,
        playbackOrder: null,
        pointerEvents: null,
        points: null,
        pointsAtX: number,
        pointsAtY: number,
        pointsAtZ: number,
        preserveAlpha: null,
        preserveAspectRatio: null,
        primitiveUnits: null,
        propagate: null,
        property: commaOrSpaceSeparated,
        r: null,
        radius: null,
        referrerPolicy: null,
        refX: null,
        refY: null,
        rel: commaOrSpaceSeparated,
        rev: commaOrSpaceSeparated,
        renderingIntent: null,
        repeatCount: null,
        repeatDur: null,
        requiredExtensions: commaOrSpaceSeparated,
        requiredFeatures: commaOrSpaceSeparated,
        requiredFonts: commaOrSpaceSeparated,
        requiredFormats: commaOrSpaceSeparated,
        resource: null,
        restart: null,
        result: null,
        rotate: null,
        rx: null,
        ry: null,
        scale: null,
        seed: null,
        shapeRendering: null,
        side: null,
        slope: null,
        snapshotTime: null,
        specularConstant: number,
        specularExponent: number,
        spreadMethod: null,
        spacing: null,
        startOffset: null,
        stdDeviation: null,
        stemh: null,
        stemv: null,
        stitchTiles: null,
        stopColor: null,
        stopOpacity: null,
        strikethroughPosition: number,
        strikethroughThickness: number,
        string: null,
        stroke: null,
        strokeDashArray: commaOrSpaceSeparated,
        strokeDashOffset: null,
        strokeLineCap: null,
        strokeLineJoin: null,
        strokeMiterLimit: number,
        strokeOpacity: number,
        strokeWidth: null,
        style: null,
        surfaceScale: number,
        syncBehavior: null,
        syncBehaviorDefault: null,
        syncMaster: null,
        syncTolerance: null,
        syncToleranceDefault: null,
        systemLanguage: commaOrSpaceSeparated,
        tabIndex: number,
        tableValues: null,
        target: null,
        targetX: number,
        targetY: number,
        textAnchor: null,
        textDecoration: null,
        textRendering: null,
        textLength: null,
        timelineBegin: null,
        title: null,
        transformBehavior: null,
        type: null,
        typeOf: commaOrSpaceSeparated,
        to: null,
        transform: null,
        transformOrigin: null,
        u1: null,
        u2: null,
        underlinePosition: number,
        underlineThickness: number,
        unicode: null,
        unicodeBidi: null,
        unicodeRange: null,
        unitsPerEm: number,
        values: null,
        vAlphabetic: number,
        vMathematical: number,
        vectorEffect: null,
        vHanging: number,
        vIdeographic: number,
        version: null,
        vertAdvY: number,
        vertOriginX: number,
        vertOriginY: number,
        viewBox: null,
        viewTarget: null,
        visibility: null,
        width: null,
        widths: null,
        wordSpacing: null,
        writingMode: null,
        x: null,
        x1: null,
        x2: null,
        xChannelSelector: null,
        xHeight: number,
        y: null,
        y1: null,
        y2: null,
        yChannelSelector: null,
        z: null,
        zoomAndPan: null,
      },
      space: "svg",
      transform: caseSensitiveTransform,
    }),
    xlink = create({
      properties: {
        xLinkActuate: null,
        xLinkArcRole: null,
        xLinkHref: null,
        xLinkRole: null,
        xLinkShow: null,
        xLinkTitle: null,
        xLinkType: null,
      },
      space: "xlink",
      transform(U, j) {
        return "xlink:" + j.slice(5).toLowerCase();
      },
    }),
    xmlns = create({
      attributes: { xmlnsxlink: "xmlns:xlink" },
      properties: { xmlnsXLink: null, xmlns: null },
      space: "xmlns",
      transform: caseInsensitiveTransform,
    }),
    xml = create({
      properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
      space: "xml",
      transform(U, j) {
        return "xml:" + j.slice(3).toLowerCase();
      },
    }),
    hastToReact = {
      classId: "classID",
      dataType: "datatype",
      itemId: "itemID",
      strokeDashArray: "strokeDasharray",
      strokeDashOffset: "strokeDashoffset",
      strokeLineCap: "strokeLinecap",
      strokeLineJoin: "strokeLinejoin",
      strokeMiterLimit: "strokeMiterlimit",
      typeOf: "typeof",
      xLinkActuate: "xlinkActuate",
      xLinkArcRole: "xlinkArcrole",
      xLinkHref: "xlinkHref",
      xLinkRole: "xlinkRole",
      xLinkShow: "xlinkShow",
      xLinkTitle: "xlinkTitle",
      xLinkType: "xlinkType",
      xmlnsXLink: "xmlnsXlink",
    },
    cap$1 = /[A-Z]/g,
    dash = /-[a-z]/g,
    valid = /^data[-\w.:]+$/i;
  function find(U, j) {
    const V = normalize$1(j);
    let B = j,
      q = Info;
    if (V in U.normal) return U.property[U.normal[V]];
    if (V.length > 4 && V.slice(0, 4) === "data" && valid.test(j)) {
      if (j.charAt(4) === "-") {
        const $ = j.slice(5).replace(dash, camelcase);
        B = "data" + $.charAt(0).toUpperCase() + $.slice(1);
      } else {
        const $ = j.slice(4);
        if (!dash.test($)) {
          let H = $.replace(cap$1, kebab);
          H.charAt(0) !== "-" && (H = "-" + H), (j = "data" + H);
        }
      }
      q = DefinedInfo;
    }
    return new q(B, j);
  }
  function kebab(U) {
    return "-" + U.toLowerCase();
  }
  function camelcase(U) {
    return U.charAt(1).toUpperCase();
  }
  const html$1 = merge([aria, html$2, xlink, xmlns, xml], "html"),
    svg = merge([aria, svg$1, xlink, xmlns, xml], "svg");
  function stringify(U) {
    return U.join(" ").trim();
  }
  var cjs$1 = {},
    inlineStyleParser,
    hasRequiredInlineStyleParser;
  function requireInlineStyleParser() {
    if (hasRequiredInlineStyleParser) return inlineStyleParser;
    hasRequiredInlineStyleParser = 1;
    var U = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
      j = /\n/g,
      V = /^\s*/,
      B = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/,
      q = /^:\s*/,
      $ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/,
      H = /^[;\s]*/,
      G = /^\s+|\s+$/g,
      Y = `
`,
      Q = "/",
      X = "*",
      Z = "",
      te = "comment",
      ne = "declaration";
    inlineStyleParser = function (se, fe) {
      if (typeof se != "string")
        throw new TypeError("First argument must be a string");
      if (!se) return [];
      fe = fe || {};
      var ce = 1,
        ue = 1;
      function he(Fe) {
        var Me = Fe.match(j);
        Me && (ce += Me.length);
        var je = Fe.lastIndexOf(Y);
        ue = ~je ? Fe.length - je : ue + Fe.length;
      }
      function me() {
        var Fe = { line: ce, column: ue };
        return function (Me) {
          return (Me.position = new ve(Fe)), Ce(), Me;
        };
      }
      function ve(Fe) {
        (this.start = Fe),
          (this.end = { line: ce, column: ue }),
          (this.source = fe.source);
      }
      ve.prototype.content = se;
      function ge(Fe) {
        var Me = new Error(fe.source + ":" + ce + ":" + ue + ": " + Fe);
        if (
          ((Me.reason = Fe),
          (Me.filename = fe.source),
          (Me.line = ce),
          (Me.column = ue),
          (Me.source = se),
          !fe.silent)
        )
          throw Me;
      }
      function Ee(Fe) {
        var Me = Fe.exec(se);
        if (Me) {
          var je = Me[0];
          return he(je), (se = se.slice(je.length)), Me;
        }
      }
      function Ce() {
        Ee(V);
      }
      function Re(Fe) {
        var Me;
        for (Fe = Fe || []; (Me = Ae()); ) Me !== !1 && Fe.push(Me);
        return Fe;
      }
      function Ae() {
        var Fe = me();
        if (!(Q != se.charAt(0) || X != se.charAt(1))) {
          for (
            var Me = 2;
            Z != se.charAt(Me) &&
            (X != se.charAt(Me) || Q != se.charAt(Me + 1));

          )
            ++Me;
          if (((Me += 2), Z === se.charAt(Me - 1)))
            return ge("End of comment missing");
          var je = se.slice(2, Me - 2);
          return (
            (ue += 2),
            he(je),
            (se = se.slice(Me)),
            (ue += 2),
            Fe({ type: te, comment: je })
          );
        }
      }
      function be() {
        var Fe = me(),
          Me = Ee(B);
        if (Me) {
          if ((Ae(), !Ee(q))) return ge("property missing ':'");
          var je = Ee($),
            Te = Fe({
              type: ne,
              property: ae(Me[0].replace(U, Z)),
              value: je ? ae(je[0].replace(U, Z)) : Z,
            });
          return Ee(H), Te;
        }
      }
      function Le() {
        var Fe = [];
        Re(Fe);
        for (var Me; (Me = be()); ) Me !== !1 && (Fe.push(Me), Re(Fe));
        return Fe;
      }
      return Ce(), Le();
    };
    function ae(se) {
      return se ? se.replace(G, Z) : Z;
    }
    return inlineStyleParser;
  }
  var hasRequiredCjs$1;
  function requireCjs$1() {
    if (hasRequiredCjs$1) return cjs$1;
    hasRequiredCjs$1 = 1;
    var U =
      (cjs$1 && cjs$1.__importDefault) ||
      function (B) {
        return B && B.__esModule ? B : { default: B };
      };
    Object.defineProperty(cjs$1, "__esModule", { value: !0 }),
      (cjs$1.default = V);
    var j = U(requireInlineStyleParser());
    function V(B, q) {
      var $ = null;
      if (!B || typeof B != "string") return $;
      var H = (0, j.default)(B),
        G = typeof q == "function";
      return (
        H.forEach(function (Y) {
          if (Y.type === "declaration") {
            var Q = Y.property,
              X = Y.value;
            G ? q(Q, X, Y) : X && (($ = $ || {}), ($[Q] = X));
          }
        }),
        $
      );
    }
    return cjs$1;
  }
  var utilities = {},
    hasRequiredUtilities;
  function requireUtilities() {
    if (hasRequiredUtilities) return utilities;
    (hasRequiredUtilities = 1),
      Object.defineProperty(utilities, "__esModule", { value: !0 }),
      (utilities.camelCase = void 0);
    var U = /^--[a-zA-Z0-9_-]+$/,
      j = /-([a-z])/g,
      V = /^[^-]+$/,
      B = /^-(webkit|moz|ms|o|khtml)-/,
      q = /^-(ms)-/,
      $ = function (Q) {
        return !Q || V.test(Q) || U.test(Q);
      },
      H = function (Q, X) {
        return X.toUpperCase();
      },
      G = function (Q, X) {
        return "".concat(X, "-");
      },
      Y = function (Q, X) {
        return (
          X === void 0 && (X = {}),
          $(Q)
            ? Q
            : ((Q = Q.toLowerCase()),
              X.reactCompat ? (Q = Q.replace(q, G)) : (Q = Q.replace(B, G)),
              Q.replace(j, H))
        );
      };
    return (utilities.camelCase = Y), utilities;
  }
  var cjs, hasRequiredCjs;
  function requireCjs() {
    if (hasRequiredCjs) return cjs;
    hasRequiredCjs = 1;
    var U =
        (cjs && cjs.__importDefault) ||
        function (q) {
          return q && q.__esModule ? q : { default: q };
        },
      j = U(requireCjs$1()),
      V = requireUtilities();
    function B(q, $) {
      var H = {};
      return (
        !q ||
          typeof q != "string" ||
          (0, j.default)(q, function (G, Y) {
            G && Y && (H[(0, V.camelCase)(G, $)] = Y);
          }),
        H
      );
    }
    return (B.default = B), (cjs = B), cjs;
  }
  var cjsExports = requireCjs();
  const styleToJs = getDefaultExportFromCjs$1(cjsExports),
    pointEnd = point$2("end"),
    pointStart = point$2("start");
  function point$2(U) {
    return j;
    function j(V) {
      const B = (V && V.position && V.position[U]) || {};
      if (
        typeof B.line == "number" &&
        B.line > 0 &&
        typeof B.column == "number" &&
        B.column > 0
      )
        return {
          line: B.line,
          column: B.column,
          offset:
            typeof B.offset == "number" && B.offset > -1 ? B.offset : void 0,
        };
    }
  }
  function position$1(U) {
    const j = pointStart(U),
      V = pointEnd(U);
    if (j && V) return { start: j, end: V };
  }
  function stringifyPosition(U) {
    return !U || typeof U != "object"
      ? ""
      : "position" in U || "type" in U
      ? position(U.position)
      : "start" in U || "end" in U
      ? position(U)
      : "line" in U || "column" in U
      ? point$1(U)
      : "";
  }
  function point$1(U) {
    return index(U && U.line) + ":" + index(U && U.column);
  }
  function position(U) {
    return point$1(U && U.start) + "-" + point$1(U && U.end);
  }
  function index(U) {
    return U && typeof U == "number" ? U : 1;
  }
  class VFileMessage extends Error {
    constructor(j, V, B) {
      super(), typeof V == "string" && ((B = V), (V = void 0));
      let q = "",
        $ = {},
        H = !1;
      if (
        (V &&
          ("line" in V && "column" in V
            ? ($ = { place: V })
            : "start" in V && "end" in V
            ? ($ = { place: V })
            : "type" in V
            ? ($ = { ancestors: [V], place: V.position })
            : ($ = { ...V })),
        typeof j == "string"
          ? (q = j)
          : !$.cause && j && ((H = !0), (q = j.message), ($.cause = j)),
        !$.ruleId && !$.source && typeof B == "string")
      ) {
        const Y = B.indexOf(":");
        Y === -1
          ? ($.ruleId = B)
          : (($.source = B.slice(0, Y)), ($.ruleId = B.slice(Y + 1)));
      }
      if (!$.place && $.ancestors && $.ancestors) {
        const Y = $.ancestors[$.ancestors.length - 1];
        Y && ($.place = Y.position);
      }
      const G = $.place && "start" in $.place ? $.place.start : $.place;
      (this.ancestors = $.ancestors || void 0),
        (this.cause = $.cause || void 0),
        (this.column = G ? G.column : void 0),
        (this.fatal = void 0),
        this.file,
        (this.message = q),
        (this.line = G ? G.line : void 0),
        (this.name = stringifyPosition($.place) || "1:1"),
        (this.place = $.place || void 0),
        (this.reason = this.message),
        (this.ruleId = $.ruleId || void 0),
        (this.source = $.source || void 0),
        (this.stack =
          H && $.cause && typeof $.cause.stack == "string"
            ? $.cause.stack
            : ""),
        this.actual,
        this.expected,
        this.note,
        this.url;
    }
  }
  (VFileMessage.prototype.file = ""),
    (VFileMessage.prototype.name = ""),
    (VFileMessage.prototype.reason = ""),
    (VFileMessage.prototype.message = ""),
    (VFileMessage.prototype.stack = ""),
    (VFileMessage.prototype.column = void 0),
    (VFileMessage.prototype.line = void 0),
    (VFileMessage.prototype.ancestors = void 0),
    (VFileMessage.prototype.cause = void 0),
    (VFileMessage.prototype.fatal = void 0),
    (VFileMessage.prototype.place = void 0),
    (VFileMessage.prototype.ruleId = void 0),
    (VFileMessage.prototype.source = void 0);
  const own$3 = {}.hasOwnProperty,
    emptyMap = new Map(),
    cap = /[A-Z]/g,
    tableElements = new Set(["table", "tbody", "thead", "tfoot", "tr"]),
    tableCellElement = new Set(["td", "th"]),
    docs = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
  function toJsxRuntime(U, j) {
    if (!j || j.Fragment === void 0)
      throw new TypeError("Expected `Fragment` in options");
    const V = j.filePath || void 0;
    let B;
    if (j.development) {
      if (typeof j.jsxDEV != "function")
        throw new TypeError(
          "Expected `jsxDEV` in options when `development: true`"
        );
      B = developmentCreate(V, j.jsxDEV);
    } else {
      if (typeof j.jsx != "function")
        throw new TypeError("Expected `jsx` in production options");
      if (typeof j.jsxs != "function")
        throw new TypeError("Expected `jsxs` in production options");
      B = productionCreate(V, j.jsx, j.jsxs);
    }
    const q = {
        Fragment: j.Fragment,
        ancestors: [],
        components: j.components || {},
        create: B,
        elementAttributeNameCase: j.elementAttributeNameCase || "react",
        evaluater: j.createEvaluater ? j.createEvaluater() : void 0,
        filePath: V,
        ignoreInvalidStyle: j.ignoreInvalidStyle || !1,
        passKeys: j.passKeys !== !1,
        passNode: j.passNode || !1,
        schema: j.space === "svg" ? svg : html$1,
        stylePropertyNameCase: j.stylePropertyNameCase || "dom",
        tableCellAlignToStyle: j.tableCellAlignToStyle !== !1,
      },
      $ = one$1(q, U, void 0);
    return $ && typeof $ != "string"
      ? $
      : q.create(U, q.Fragment, { children: $ || void 0 }, void 0);
  }
  function one$1(U, j, V) {
    if (j.type === "element") return element$1(U, j, V);
    if (j.type === "mdxFlowExpression" || j.type === "mdxTextExpression")
      return mdxExpression(U, j);
    if (j.type === "mdxJsxFlowElement" || j.type === "mdxJsxTextElement")
      return mdxJsxElement(U, j, V);
    if (j.type === "mdxjsEsm") return mdxEsm(U, j);
    if (j.type === "root") return root$1(U, j, V);
    if (j.type === "text") return text$3(U, j);
  }
  function element$1(U, j, V) {
    const B = U.schema;
    let q = B;
    j.tagName.toLowerCase() === "svg" &&
      B.space === "html" &&
      ((q = svg), (U.schema = q)),
      U.ancestors.push(j);
    const $ = findComponentFromName(U, j.tagName, !1),
      H = createElementProps(U, j);
    let G = createChildren(U, j);
    return (
      tableElements.has(j.tagName) &&
        (G = G.filter(function (Y) {
          return typeof Y == "string" ? !whitespace(Y) : !0;
        })),
      addNode(U, H, $, j),
      addChildren(H, G),
      U.ancestors.pop(),
      (U.schema = B),
      U.create(j, $, H, V)
    );
  }
  function mdxExpression(U, j) {
    if (j.data && j.data.estree && U.evaluater) {
      const B = j.data.estree.body[0];
      return B.type, U.evaluater.evaluateExpression(B.expression);
    }
    crashEstree(U, j.position);
  }
  function mdxEsm(U, j) {
    if (j.data && j.data.estree && U.evaluater)
      return U.evaluater.evaluateProgram(j.data.estree);
    crashEstree(U, j.position);
  }
  function mdxJsxElement(U, j, V) {
    const B = U.schema;
    let q = B;
    j.name === "svg" && B.space === "html" && ((q = svg), (U.schema = q)),
      U.ancestors.push(j);
    const $ =
        j.name === null ? U.Fragment : findComponentFromName(U, j.name, !0),
      H = createJsxElementProps(U, j),
      G = createChildren(U, j);
    return (
      addNode(U, H, $, j),
      addChildren(H, G),
      U.ancestors.pop(),
      (U.schema = B),
      U.create(j, $, H, V)
    );
  }
  function root$1(U, j, V) {
    const B = {};
    return addChildren(B, createChildren(U, j)), U.create(j, U.Fragment, B, V);
  }
  function text$3(U, j) {
    return j.value;
  }
  function addNode(U, j, V, B) {
    typeof V != "string" && V !== U.Fragment && U.passNode && (j.node = B);
  }
  function addChildren(U, j) {
    if (j.length > 0) {
      const V = j.length > 1 ? j : j[0];
      V && (U.children = V);
    }
  }
  function productionCreate(U, j, V) {
    return B;
    function B(q, $, H, G) {
      const Q = Array.isArray(H.children) ? V : j;
      return G ? Q($, H, G) : Q($, H);
    }
  }
  function developmentCreate(U, j) {
    return V;
    function V(B, q, $, H) {
      const G = Array.isArray($.children),
        Y = pointStart(B);
      return j(
        q,
        $,
        H,
        G,
        {
          columnNumber: Y ? Y.column - 1 : void 0,
          fileName: U,
          lineNumber: Y ? Y.line : void 0,
        },
        void 0
      );
    }
  }
  function createElementProps(U, j) {
    const V = {};
    let B, q;
    for (q in j.properties)
      if (q !== "children" && own$3.call(j.properties, q)) {
        const $ = createProperty(U, q, j.properties[q]);
        if ($) {
          const [H, G] = $;
          U.tableCellAlignToStyle &&
          H === "align" &&
          typeof G == "string" &&
          tableCellElement.has(j.tagName)
            ? (B = G)
            : (V[H] = G);
        }
      }
    if (B) {
      const $ = V.style || (V.style = {});
      $[U.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = B;
    }
    return V;
  }
  function createJsxElementProps(U, j) {
    const V = {};
    for (const B of j.attributes)
      if (B.type === "mdxJsxExpressionAttribute")
        if (B.data && B.data.estree && U.evaluater) {
          const $ = B.data.estree.body[0];
          $.type;
          const H = $.expression;
          H.type;
          const G = H.properties[0];
          G.type, Object.assign(V, U.evaluater.evaluateExpression(G.argument));
        } else crashEstree(U, j.position);
      else {
        const q = B.name;
        let $;
        if (B.value && typeof B.value == "object")
          if (B.value.data && B.value.data.estree && U.evaluater) {
            const G = B.value.data.estree.body[0];
            G.type, ($ = U.evaluater.evaluateExpression(G.expression));
          } else crashEstree(U, j.position);
        else $ = B.value === null ? !0 : B.value;
        V[q] = $;
      }
    return V;
  }
  function createChildren(U, j) {
    const V = [];
    let B = -1;
    const q = U.passKeys ? new Map() : emptyMap;
    for (; ++B < j.children.length; ) {
      const $ = j.children[B];
      let H;
      if (U.passKeys) {
        const Y =
          $.type === "element"
            ? $.tagName
            : $.type === "mdxJsxFlowElement" || $.type === "mdxJsxTextElement"
            ? $.name
            : void 0;
        if (Y) {
          const Q = q.get(Y) || 0;
          (H = Y + "-" + Q), q.set(Y, Q + 1);
        }
      }
      const G = one$1(U, $, H);
      G !== void 0 && V.push(G);
    }
    return V;
  }
  function createProperty(U, j, V) {
    const B = find(U.schema, j);
    if (!(V == null || (typeof V == "number" && Number.isNaN(V)))) {
      if (
        (Array.isArray(V) &&
          (V = B.commaSeparated ? stringify$1(V) : stringify(V)),
        B.property === "style")
      ) {
        let q = typeof V == "object" ? V : parseStyle(U, String(V));
        return (
          U.stylePropertyNameCase === "css" &&
            (q = transformStylesToCssCasing(q)),
          ["style", q]
        );
      }
      return [
        U.elementAttributeNameCase === "react" && B.space
          ? hastToReact[B.property] || B.property
          : B.attribute,
        V,
      ];
    }
  }
  function parseStyle(U, j) {
    try {
      return styleToJs(j, { reactCompat: !0 });
    } catch (V) {
      if (U.ignoreInvalidStyle) return {};
      const B = V,
        q = new VFileMessage("Cannot parse `style` attribute", {
          ancestors: U.ancestors,
          cause: B,
          ruleId: "style",
          source: "hast-util-to-jsx-runtime",
        });
      throw (
        ((q.file = U.filePath || void 0),
        (q.url = docs + "#cannot-parse-style-attribute"),
        q)
      );
    }
  }
  function findComponentFromName(U, j, V) {
    let B;
    if (!V) B = { type: "Literal", value: j };
    else if (j.includes(".")) {
      const q = j.split(".");
      let $ = -1,
        H;
      for (; ++$ < q.length; ) {
        const G = name(q[$])
          ? { type: "Identifier", name: q[$] }
          : { type: "Literal", value: q[$] };
        H = H
          ? {
              type: "MemberExpression",
              object: H,
              property: G,
              computed: !!($ && G.type === "Literal"),
              optional: !1,
            }
          : G;
      }
      B = H;
    } else
      B =
        name(j) && !/^[a-z]/.test(j)
          ? { type: "Identifier", name: j }
          : { type: "Literal", value: j };
    if (B.type === "Literal") {
      const q = B.value;
      return own$3.call(U.components, q) ? U.components[q] : q;
    }
    if (U.evaluater) return U.evaluater.evaluateExpression(B);
    crashEstree(U);
  }
  function crashEstree(U, j) {
    const V = new VFileMessage(
      "Cannot handle MDX estrees without `createEvaluater`",
      {
        ancestors: U.ancestors,
        place: j,
        ruleId: "mdx-estree",
        source: "hast-util-to-jsx-runtime",
      }
    );
    throw (
      ((V.file = U.filePath || void 0),
      (V.url = docs + "#cannot-handle-mdx-estrees-without-createevaluater"),
      V)
    );
  }
  function transformStylesToCssCasing(U) {
    const j = {};
    let V;
    for (V in U) own$3.call(U, V) && (j[transformStyleToCssCasing(V)] = U[V]);
    return j;
  }
  function transformStyleToCssCasing(U) {
    let j = U.replace(cap, toDash);
    return j.slice(0, 3) === "ms-" && (j = "-" + j), j;
  }
  function toDash(U) {
    return "-" + U.toLowerCase();
  }
  const urlAttributes = {
      action: ["form"],
      cite: ["blockquote", "del", "ins", "q"],
      data: ["object"],
      formAction: ["button", "input"],
      href: ["a", "area", "base", "link"],
      icon: ["menuitem"],
      itemId: null,
      manifest: ["html"],
      ping: ["a", "area"],
      poster: ["video"],
      src: [
        "audio",
        "embed",
        "iframe",
        "img",
        "input",
        "script",
        "source",
        "track",
        "video",
      ],
    },
    emptyOptions$1 = {};
  function toString$1(U, j) {
    const V = emptyOptions$1,
      B = typeof V.includeImageAlt == "boolean" ? V.includeImageAlt : !0,
      q = typeof V.includeHtml == "boolean" ? V.includeHtml : !0;
    return one(U, B, q);
  }
  function one(U, j, V) {
    if (node(U)) {
      if ("value" in U) return U.type === "html" && !V ? "" : U.value;
      if (j && "alt" in U && U.alt) return U.alt;
      if ("children" in U) return all(U.children, j, V);
    }
    return Array.isArray(U) ? all(U, j, V) : "";
  }
  function all(U, j, V) {
    const B = [];
    let q = -1;
    for (; ++q < U.length; ) B[q] = one(U[q], j, V);
    return B.join("");
  }
  function node(U) {
    return !!(U && typeof U == "object");
  }
  const element = document.createElement("i");
  function decodeNamedCharacterReference(U) {
    const j = "&" + U + ";";
    element.innerHTML = j;
    const V = element.textContent;
    return (V.charCodeAt(V.length - 1) === 59 && U !== "semi") || V === j
      ? !1
      : V;
  }
  function splice(U, j, V, B) {
    const q = U.length;
    let $ = 0,
      H;
    if (
      (j < 0 ? (j = -j > q ? 0 : q + j) : (j = j > q ? q : j),
      (V = V > 0 ? V : 0),
      B.length < 1e4)
    )
      (H = Array.from(B)), H.unshift(j, V), U.splice(...H);
    else
      for (V && U.splice(j, V); $ < B.length; )
        (H = B.slice($, $ + 1e4)),
          H.unshift(j, 0),
          U.splice(...H),
          ($ += 1e4),
          (j += 1e4);
  }
  function push(U, j) {
    return U.length > 0 ? (splice(U, U.length, 0, j), U) : j;
  }
  const hasOwnProperty = {}.hasOwnProperty;
  function combineExtensions(U) {
    const j = {};
    let V = -1;
    for (; ++V < U.length; ) syntaxExtension(j, U[V]);
    return j;
  }
  function syntaxExtension(U, j) {
    let V;
    for (V in j) {
      const q = (hasOwnProperty.call(U, V) ? U[V] : void 0) || (U[V] = {}),
        $ = j[V];
      let H;
      if ($)
        for (H in $) {
          hasOwnProperty.call(q, H) || (q[H] = []);
          const G = $[H];
          constructs(q[H], Array.isArray(G) ? G : G ? [G] : []);
        }
    }
  }
  function constructs(U, j) {
    let V = -1;
    const B = [];
    for (; ++V < j.length; ) (j[V].add === "after" ? U : B).push(j[V]);
    splice(U, 0, 0, B);
  }
  function decodeNumericCharacterReference(U, j) {
    const V = Number.parseInt(U, j);
    return V < 9 ||
      V === 11 ||
      (V > 13 && V < 32) ||
      (V > 126 && V < 160) ||
      (V > 55295 && V < 57344) ||
      (V > 64975 && V < 65008) ||
      (V & 65535) === 65535 ||
      (V & 65535) === 65534 ||
      V > 1114111
      ? "�"
      : String.fromCodePoint(V);
  }
  function normalizeIdentifier(U) {
    return U.replace(/[\t\n\r ]+/g, " ")
      .replace(/^ | $/g, "")
      .toLowerCase()
      .toUpperCase();
  }
  const asciiAlpha = regexCheck(/[A-Za-z]/),
    asciiAlphanumeric = regexCheck(/[\dA-Za-z]/),
    asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
  function asciiControl(U) {
    return U !== null && (U < 32 || U === 127);
  }
  const asciiDigit = regexCheck(/\d/),
    asciiHexDigit = regexCheck(/[\dA-Fa-f]/),
    asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
  function markdownLineEnding(U) {
    return U !== null && U < -2;
  }
  function markdownLineEndingOrSpace(U) {
    return U !== null && (U < 0 || U === 32);
  }
  function markdownSpace(U) {
    return U === -2 || U === -1 || U === 32;
  }
  const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u")),
    unicodeWhitespace = regexCheck(/\s/);
  function regexCheck(U) {
    return j;
    function j(V) {
      return V !== null && V > -1 && U.test(String.fromCharCode(V));
    }
  }
  function normalizeUri(U) {
    const j = [];
    let V = -1,
      B = 0,
      q = 0;
    for (; ++V < U.length; ) {
      const $ = U.charCodeAt(V);
      let H = "";
      if (
        $ === 37 &&
        asciiAlphanumeric(U.charCodeAt(V + 1)) &&
        asciiAlphanumeric(U.charCodeAt(V + 2))
      )
        q = 2;
      else if ($ < 128)
        /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode($)) ||
          (H = String.fromCharCode($));
      else if ($ > 55295 && $ < 57344) {
        const G = U.charCodeAt(V + 1);
        $ < 56320 && G > 56319 && G < 57344
          ? ((H = String.fromCharCode($, G)), (q = 1))
          : (H = "�");
      } else H = String.fromCharCode($);
      H &&
        (j.push(U.slice(B, V), encodeURIComponent(H)),
        (B = V + q + 1),
        (H = "")),
        q && ((V += q), (q = 0));
    }
    return j.join("") + U.slice(B);
  }
  function factorySpace(U, j, V, B) {
    const q = B ? B - 1 : Number.POSITIVE_INFINITY;
    let $ = 0;
    return H;
    function H(Y) {
      return markdownSpace(Y) ? (U.enter(V), G(Y)) : j(Y);
    }
    function G(Y) {
      return markdownSpace(Y) && $++ < q
        ? (U.consume(Y), G)
        : (U.exit(V), j(Y));
    }
  }
  const content$1 = { tokenize: initializeContent };
  function initializeContent(U) {
    const j = U.attempt(this.parser.constructs.contentInitial, B, q);
    let V;
    return j;
    function B(G) {
      if (G === null) {
        U.consume(G);
        return;
      }
      return (
        U.enter("lineEnding"),
        U.consume(G),
        U.exit("lineEnding"),
        factorySpace(U, j, "linePrefix")
      );
    }
    function q(G) {
      return U.enter("paragraph"), $(G);
    }
    function $(G) {
      const Y = U.enter("chunkText", { contentType: "text", previous: V });
      return V && (V.next = Y), (V = Y), H(G);
    }
    function H(G) {
      if (G === null) {
        U.exit("chunkText"), U.exit("paragraph"), U.consume(G);
        return;
      }
      return markdownLineEnding(G)
        ? (U.consume(G), U.exit("chunkText"), $)
        : (U.consume(G), H);
    }
  }
  const document$2 = { tokenize: initializeDocument },
    containerConstruct = { tokenize: tokenizeContainer };
  function initializeDocument(U) {
    const j = this,
      V = [];
    let B = 0,
      q,
      $,
      H;
    return G;
    function G(he) {
      if (B < V.length) {
        const me = V[B];
        return (
          (j.containerState = me[1]), U.attempt(me[0].continuation, Y, Q)(he)
        );
      }
      return Q(he);
    }
    function Y(he) {
      if ((B++, j.containerState._closeFlow)) {
        (j.containerState._closeFlow = void 0), q && ue();
        const me = j.events.length;
        let ve = me,
          ge;
        for (; ve--; )
          if (
            j.events[ve][0] === "exit" &&
            j.events[ve][1].type === "chunkFlow"
          ) {
            ge = j.events[ve][1].end;
            break;
          }
        ce(B);
        let Ee = me;
        for (; Ee < j.events.length; ) (j.events[Ee][1].end = { ...ge }), Ee++;
        return (
          splice(j.events, ve + 1, 0, j.events.slice(me)),
          (j.events.length = Ee),
          Q(he)
        );
      }
      return G(he);
    }
    function Q(he) {
      if (B === V.length) {
        if (!q) return te(he);
        if (q.currentConstruct && q.currentConstruct.concrete) return ae(he);
        j.interrupt = !!(
          q.currentConstruct && !q._gfmTableDynamicInterruptHack
        );
      }
      return (j.containerState = {}), U.check(containerConstruct, X, Z)(he);
    }
    function X(he) {
      return q && ue(), ce(B), te(he);
    }
    function Z(he) {
      return (
        (j.parser.lazy[j.now().line] = B !== V.length),
        (H = j.now().offset),
        ae(he)
      );
    }
    function te(he) {
      return (j.containerState = {}), U.attempt(containerConstruct, ne, ae)(he);
    }
    function ne(he) {
      return B++, V.push([j.currentConstruct, j.containerState]), te(he);
    }
    function ae(he) {
      if (he === null) {
        q && ue(), ce(0), U.consume(he);
        return;
      }
      return (
        (q = q || j.parser.flow(j.now())),
        U.enter("chunkFlow", {
          _tokenizer: q,
          contentType: "flow",
          previous: $,
        }),
        se(he)
      );
    }
    function se(he) {
      if (he === null) {
        fe(U.exit("chunkFlow"), !0), ce(0), U.consume(he);
        return;
      }
      return markdownLineEnding(he)
        ? (U.consume(he),
          fe(U.exit("chunkFlow")),
          (B = 0),
          (j.interrupt = void 0),
          G)
        : (U.consume(he), se);
    }
    function fe(he, me) {
      const ve = j.sliceStream(he);
      if (
        (me && ve.push(null),
        (he.previous = $),
        $ && ($.next = he),
        ($ = he),
        q.defineSkip(he.start),
        q.write(ve),
        j.parser.lazy[he.start.line])
      ) {
        let ge = q.events.length;
        for (; ge--; )
          if (
            q.events[ge][1].start.offset < H &&
            (!q.events[ge][1].end || q.events[ge][1].end.offset > H)
          )
            return;
        const Ee = j.events.length;
        let Ce = Ee,
          Re,
          Ae;
        for (; Ce--; )
          if (
            j.events[Ce][0] === "exit" &&
            j.events[Ce][1].type === "chunkFlow"
          ) {
            if (Re) {
              Ae = j.events[Ce][1].end;
              break;
            }
            Re = !0;
          }
        for (ce(B), ge = Ee; ge < j.events.length; )
          (j.events[ge][1].end = { ...Ae }), ge++;
        splice(j.events, Ce + 1, 0, j.events.slice(Ee)), (j.events.length = ge);
      }
    }
    function ce(he) {
      let me = V.length;
      for (; me-- > he; ) {
        const ve = V[me];
        (j.containerState = ve[1]), ve[0].exit.call(j, U);
      }
      V.length = he;
    }
    function ue() {
      q.write([null]),
        ($ = void 0),
        (q = void 0),
        (j.containerState._closeFlow = void 0);
    }
  }
  function tokenizeContainer(U, j, V) {
    return factorySpace(
      U,
      U.attempt(this.parser.constructs.document, j, V),
      "linePrefix",
      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    );
  }
  function classifyCharacter(U) {
    if (U === null || markdownLineEndingOrSpace(U) || unicodeWhitespace(U))
      return 1;
    if (unicodePunctuation(U)) return 2;
  }
  function resolveAll(U, j, V) {
    const B = [];
    let q = -1;
    for (; ++q < U.length; ) {
      const $ = U[q].resolveAll;
      $ && !B.includes($) && ((j = $(j, V)), B.push($));
    }
    return j;
  }
  const attention = {
    name: "attention",
    resolveAll: resolveAllAttention,
    tokenize: tokenizeAttention,
  };
  function resolveAllAttention(U, j) {
    let V = -1,
      B,
      q,
      $,
      H,
      G,
      Y,
      Q,
      X;
    for (; ++V < U.length; )
      if (
        U[V][0] === "enter" &&
        U[V][1].type === "attentionSequence" &&
        U[V][1]._close
      ) {
        for (B = V; B--; )
          if (
            U[B][0] === "exit" &&
            U[B][1].type === "attentionSequence" &&
            U[B][1]._open &&
            j.sliceSerialize(U[B][1]).charCodeAt(0) ===
              j.sliceSerialize(U[V][1]).charCodeAt(0)
          ) {
            if (
              (U[B][1]._close || U[V][1]._open) &&
              (U[V][1].end.offset - U[V][1].start.offset) % 3 &&
              !(
                (U[B][1].end.offset -
                  U[B][1].start.offset +
                  U[V][1].end.offset -
                  U[V][1].start.offset) %
                3
              )
            )
              continue;
            Y =
              U[B][1].end.offset - U[B][1].start.offset > 1 &&
              U[V][1].end.offset - U[V][1].start.offset > 1
                ? 2
                : 1;
            const Z = { ...U[B][1].end },
              te = { ...U[V][1].start };
            movePoint(Z, -Y),
              movePoint(te, Y),
              (H = {
                type: Y > 1 ? "strongSequence" : "emphasisSequence",
                start: Z,
                end: { ...U[B][1].end },
              }),
              (G = {
                type: Y > 1 ? "strongSequence" : "emphasisSequence",
                start: { ...U[V][1].start },
                end: te,
              }),
              ($ = {
                type: Y > 1 ? "strongText" : "emphasisText",
                start: { ...U[B][1].end },
                end: { ...U[V][1].start },
              }),
              (q = {
                type: Y > 1 ? "strong" : "emphasis",
                start: { ...H.start },
                end: { ...G.end },
              }),
              (U[B][1].end = { ...H.start }),
              (U[V][1].start = { ...G.end }),
              (Q = []),
              U[B][1].end.offset - U[B][1].start.offset &&
                (Q = push(Q, [
                  ["enter", U[B][1], j],
                  ["exit", U[B][1], j],
                ])),
              (Q = push(Q, [
                ["enter", q, j],
                ["enter", H, j],
                ["exit", H, j],
                ["enter", $, j],
              ])),
              (Q = push(
                Q,
                resolveAll(
                  j.parser.constructs.insideSpan.null,
                  U.slice(B + 1, V),
                  j
                )
              )),
              (Q = push(Q, [
                ["exit", $, j],
                ["enter", G, j],
                ["exit", G, j],
                ["exit", q, j],
              ])),
              U[V][1].end.offset - U[V][1].start.offset
                ? ((X = 2),
                  (Q = push(Q, [
                    ["enter", U[V][1], j],
                    ["exit", U[V][1], j],
                  ])))
                : (X = 0),
              splice(U, B - 1, V - B + 3, Q),
              (V = B + Q.length - X - 2);
            break;
          }
      }
    for (V = -1; ++V < U.length; )
      U[V][1].type === "attentionSequence" && (U[V][1].type = "data");
    return U;
  }
  function tokenizeAttention(U, j) {
    const V = this.parser.constructs.attentionMarkers.null,
      B = this.previous,
      q = classifyCharacter(B);
    let $;
    return H;
    function H(Y) {
      return ($ = Y), U.enter("attentionSequence"), G(Y);
    }
    function G(Y) {
      if (Y === $) return U.consume(Y), G;
      const Q = U.exit("attentionSequence"),
        X = classifyCharacter(Y),
        Z = !X || (X === 2 && q) || V.includes(Y),
        te = !q || (q === 2 && X) || V.includes(B);
      return (
        (Q._open = !!($ === 42 ? Z : Z && (q || !te))),
        (Q._close = !!($ === 42 ? te : te && (X || !Z))),
        j(Y)
      );
    }
  }
  function movePoint(U, j) {
    (U.column += j), (U.offset += j), (U._bufferIndex += j);
  }
  const autolink = { name: "autolink", tokenize: tokenizeAutolink };
  function tokenizeAutolink(U, j, V) {
    let B = 0;
    return q;
    function q(ne) {
      return (
        U.enter("autolink"),
        U.enter("autolinkMarker"),
        U.consume(ne),
        U.exit("autolinkMarker"),
        U.enter("autolinkProtocol"),
        $
      );
    }
    function $(ne) {
      return asciiAlpha(ne) ? (U.consume(ne), H) : ne === 64 ? V(ne) : Q(ne);
    }
    function H(ne) {
      return ne === 43 || ne === 45 || ne === 46 || asciiAlphanumeric(ne)
        ? ((B = 1), G(ne))
        : Q(ne);
    }
    function G(ne) {
      return ne === 58
        ? (U.consume(ne), (B = 0), Y)
        : (ne === 43 || ne === 45 || ne === 46 || asciiAlphanumeric(ne)) &&
          B++ < 32
        ? (U.consume(ne), G)
        : ((B = 0), Q(ne));
    }
    function Y(ne) {
      return ne === 62
        ? (U.exit("autolinkProtocol"),
          U.enter("autolinkMarker"),
          U.consume(ne),
          U.exit("autolinkMarker"),
          U.exit("autolink"),
          j)
        : ne === null || ne === 32 || ne === 60 || asciiControl(ne)
        ? V(ne)
        : (U.consume(ne), Y);
    }
    function Q(ne) {
      return ne === 64
        ? (U.consume(ne), X)
        : asciiAtext(ne)
        ? (U.consume(ne), Q)
        : V(ne);
    }
    function X(ne) {
      return asciiAlphanumeric(ne) ? Z(ne) : V(ne);
    }
    function Z(ne) {
      return ne === 46
        ? (U.consume(ne), (B = 0), X)
        : ne === 62
        ? ((U.exit("autolinkProtocol").type = "autolinkEmail"),
          U.enter("autolinkMarker"),
          U.consume(ne),
          U.exit("autolinkMarker"),
          U.exit("autolink"),
          j)
        : te(ne);
    }
    function te(ne) {
      if ((ne === 45 || asciiAlphanumeric(ne)) && B++ < 63) {
        const ae = ne === 45 ? te : Z;
        return U.consume(ne), ae;
      }
      return V(ne);
    }
  }
  const blankLine = { partial: !0, tokenize: tokenizeBlankLine };
  function tokenizeBlankLine(U, j, V) {
    return B;
    function B($) {
      return markdownSpace($) ? factorySpace(U, q, "linePrefix")($) : q($);
    }
    function q($) {
      return $ === null || markdownLineEnding($) ? j($) : V($);
    }
  }
  const blockQuote = {
    continuation: { tokenize: tokenizeBlockQuoteContinuation },
    exit,
    name: "blockQuote",
    tokenize: tokenizeBlockQuoteStart,
  };
  function tokenizeBlockQuoteStart(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      if (H === 62) {
        const G = B.containerState;
        return (
          G.open || (U.enter("blockQuote", { _container: !0 }), (G.open = !0)),
          U.enter("blockQuotePrefix"),
          U.enter("blockQuoteMarker"),
          U.consume(H),
          U.exit("blockQuoteMarker"),
          $
        );
      }
      return V(H);
    }
    function $(H) {
      return markdownSpace(H)
        ? (U.enter("blockQuotePrefixWhitespace"),
          U.consume(H),
          U.exit("blockQuotePrefixWhitespace"),
          U.exit("blockQuotePrefix"),
          j)
        : (U.exit("blockQuotePrefix"), j(H));
    }
  }
  function tokenizeBlockQuoteContinuation(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return markdownSpace(H)
        ? factorySpace(
            U,
            $,
            "linePrefix",
            B.parser.constructs.disable.null.includes("codeIndented")
              ? void 0
              : 4
          )(H)
        : $(H);
    }
    function $(H) {
      return U.attempt(blockQuote, j, V)(H);
    }
  }
  function exit(U) {
    U.exit("blockQuote");
  }
  const characterEscape = {
    name: "characterEscape",
    tokenize: tokenizeCharacterEscape,
  };
  function tokenizeCharacterEscape(U, j, V) {
    return B;
    function B($) {
      return (
        U.enter("characterEscape"),
        U.enter("escapeMarker"),
        U.consume($),
        U.exit("escapeMarker"),
        q
      );
    }
    function q($) {
      return asciiPunctuation($)
        ? (U.enter("characterEscapeValue"),
          U.consume($),
          U.exit("characterEscapeValue"),
          U.exit("characterEscape"),
          j)
        : V($);
    }
  }
  const characterReference = {
    name: "characterReference",
    tokenize: tokenizeCharacterReference,
  };
  function tokenizeCharacterReference(U, j, V) {
    const B = this;
    let q = 0,
      $,
      H;
    return G;
    function G(Z) {
      return (
        U.enter("characterReference"),
        U.enter("characterReferenceMarker"),
        U.consume(Z),
        U.exit("characterReferenceMarker"),
        Y
      );
    }
    function Y(Z) {
      return Z === 35
        ? (U.enter("characterReferenceMarkerNumeric"),
          U.consume(Z),
          U.exit("characterReferenceMarkerNumeric"),
          Q)
        : (U.enter("characterReferenceValue"),
          ($ = 31),
          (H = asciiAlphanumeric),
          X(Z));
    }
    function Q(Z) {
      return Z === 88 || Z === 120
        ? (U.enter("characterReferenceMarkerHexadecimal"),
          U.consume(Z),
          U.exit("characterReferenceMarkerHexadecimal"),
          U.enter("characterReferenceValue"),
          ($ = 6),
          (H = asciiHexDigit),
          X)
        : (U.enter("characterReferenceValue"), ($ = 7), (H = asciiDigit), X(Z));
    }
    function X(Z) {
      if (Z === 59 && q) {
        const te = U.exit("characterReferenceValue");
        return H === asciiAlphanumeric &&
          !decodeNamedCharacterReference(B.sliceSerialize(te))
          ? V(Z)
          : (U.enter("characterReferenceMarker"),
            U.consume(Z),
            U.exit("characterReferenceMarker"),
            U.exit("characterReference"),
            j);
      }
      return H(Z) && q++ < $ ? (U.consume(Z), X) : V(Z);
    }
  }
  const nonLazyContinuation = {
      partial: !0,
      tokenize: tokenizeNonLazyContinuation,
    },
    codeFenced = {
      concrete: !0,
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
    };
  function tokenizeCodeFenced(U, j, V) {
    const B = this,
      q = { partial: !0, tokenize: ve };
    let $ = 0,
      H = 0,
      G;
    return Y;
    function Y(ge) {
      return Q(ge);
    }
    function Q(ge) {
      const Ee = B.events[B.events.length - 1];
      return (
        ($ =
          Ee && Ee[1].type === "linePrefix"
            ? Ee[2].sliceSerialize(Ee[1], !0).length
            : 0),
        (G = ge),
        U.enter("codeFenced"),
        U.enter("codeFencedFence"),
        U.enter("codeFencedFenceSequence"),
        X(ge)
      );
    }
    function X(ge) {
      return ge === G
        ? (H++, U.consume(ge), X)
        : H < 3
        ? V(ge)
        : (U.exit("codeFencedFenceSequence"),
          markdownSpace(ge) ? factorySpace(U, Z, "whitespace")(ge) : Z(ge));
    }
    function Z(ge) {
      return ge === null || markdownLineEnding(ge)
        ? (U.exit("codeFencedFence"),
          B.interrupt ? j(ge) : U.check(nonLazyContinuation, se, me)(ge))
        : (U.enter("codeFencedFenceInfo"),
          U.enter("chunkString", { contentType: "string" }),
          te(ge));
    }
    function te(ge) {
      return ge === null || markdownLineEnding(ge)
        ? (U.exit("chunkString"), U.exit("codeFencedFenceInfo"), Z(ge))
        : markdownSpace(ge)
        ? (U.exit("chunkString"),
          U.exit("codeFencedFenceInfo"),
          factorySpace(U, ne, "whitespace")(ge))
        : ge === 96 && ge === G
        ? V(ge)
        : (U.consume(ge), te);
    }
    function ne(ge) {
      return ge === null || markdownLineEnding(ge)
        ? Z(ge)
        : (U.enter("codeFencedFenceMeta"),
          U.enter("chunkString", { contentType: "string" }),
          ae(ge));
    }
    function ae(ge) {
      return ge === null || markdownLineEnding(ge)
        ? (U.exit("chunkString"), U.exit("codeFencedFenceMeta"), Z(ge))
        : ge === 96 && ge === G
        ? V(ge)
        : (U.consume(ge), ae);
    }
    function se(ge) {
      return U.attempt(q, me, fe)(ge);
    }
    function fe(ge) {
      return U.enter("lineEnding"), U.consume(ge), U.exit("lineEnding"), ce;
    }
    function ce(ge) {
      return $ > 0 && markdownSpace(ge)
        ? factorySpace(U, ue, "linePrefix", $ + 1)(ge)
        : ue(ge);
    }
    function ue(ge) {
      return ge === null || markdownLineEnding(ge)
        ? U.check(nonLazyContinuation, se, me)(ge)
        : (U.enter("codeFlowValue"), he(ge));
    }
    function he(ge) {
      return ge === null || markdownLineEnding(ge)
        ? (U.exit("codeFlowValue"), ue(ge))
        : (U.consume(ge), he);
    }
    function me(ge) {
      return U.exit("codeFenced"), j(ge);
    }
    function ve(ge, Ee, Ce) {
      let Re = 0;
      return Ae;
      function Ae(je) {
        return (
          ge.enter("lineEnding"), ge.consume(je), ge.exit("lineEnding"), be
        );
      }
      function be(je) {
        return (
          ge.enter("codeFencedFence"),
          markdownSpace(je)
            ? factorySpace(
                ge,
                Le,
                "linePrefix",
                B.parser.constructs.disable.null.includes("codeIndented")
                  ? void 0
                  : 4
              )(je)
            : Le(je)
        );
      }
      function Le(je) {
        return je === G
          ? (ge.enter("codeFencedFenceSequence"), Fe(je))
          : Ce(je);
      }
      function Fe(je) {
        return je === G
          ? (Re++, ge.consume(je), Fe)
          : Re >= H
          ? (ge.exit("codeFencedFenceSequence"),
            markdownSpace(je) ? factorySpace(ge, Me, "whitespace")(je) : Me(je))
          : Ce(je);
      }
      function Me(je) {
        return je === null || markdownLineEnding(je)
          ? (ge.exit("codeFencedFence"), Ee(je))
          : Ce(je);
      }
    }
  }
  function tokenizeNonLazyContinuation(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return H === null
        ? V(H)
        : (U.enter("lineEnding"), U.consume(H), U.exit("lineEnding"), $);
    }
    function $(H) {
      return B.parser.lazy[B.now().line] ? V(H) : j(H);
    }
  }
  const codeIndented = { name: "codeIndented", tokenize: tokenizeCodeIndented },
    furtherStart = { partial: !0, tokenize: tokenizeFurtherStart };
  function tokenizeCodeIndented(U, j, V) {
    const B = this;
    return q;
    function q(Q) {
      return U.enter("codeIndented"), factorySpace(U, $, "linePrefix", 5)(Q);
    }
    function $(Q) {
      const X = B.events[B.events.length - 1];
      return X &&
        X[1].type === "linePrefix" &&
        X[2].sliceSerialize(X[1], !0).length >= 4
        ? H(Q)
        : V(Q);
    }
    function H(Q) {
      return Q === null
        ? Y(Q)
        : markdownLineEnding(Q)
        ? U.attempt(furtherStart, H, Y)(Q)
        : (U.enter("codeFlowValue"), G(Q));
    }
    function G(Q) {
      return Q === null || markdownLineEnding(Q)
        ? (U.exit("codeFlowValue"), H(Q))
        : (U.consume(Q), G);
    }
    function Y(Q) {
      return U.exit("codeIndented"), j(Q);
    }
  }
  function tokenizeFurtherStart(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return B.parser.lazy[B.now().line]
        ? V(H)
        : markdownLineEnding(H)
        ? (U.enter("lineEnding"), U.consume(H), U.exit("lineEnding"), q)
        : factorySpace(U, $, "linePrefix", 5)(H);
    }
    function $(H) {
      const G = B.events[B.events.length - 1];
      return G &&
        G[1].type === "linePrefix" &&
        G[2].sliceSerialize(G[1], !0).length >= 4
        ? j(H)
        : markdownLineEnding(H)
        ? q(H)
        : V(H);
    }
  }
  const codeText = {
    name: "codeText",
    previous,
    resolve: resolveCodeText,
    tokenize: tokenizeCodeText,
  };
  function resolveCodeText(U) {
    let j = U.length - 4,
      V = 3,
      B,
      q;
    if (
      (U[V][1].type === "lineEnding" || U[V][1].type === "space") &&
      (U[j][1].type === "lineEnding" || U[j][1].type === "space")
    ) {
      for (B = V; ++B < j; )
        if (U[B][1].type === "codeTextData") {
          (U[V][1].type = "codeTextPadding"),
            (U[j][1].type = "codeTextPadding"),
            (V += 2),
            (j -= 2);
          break;
        }
    }
    for (B = V - 1, j++; ++B <= j; )
      q === void 0
        ? B !== j && U[B][1].type !== "lineEnding" && (q = B)
        : (B === j || U[B][1].type === "lineEnding") &&
          ((U[q][1].type = "codeTextData"),
          B !== q + 2 &&
            ((U[q][1].end = U[B - 1][1].end),
            U.splice(q + 2, B - q - 2),
            (j -= B - q - 2),
            (B = q + 2)),
          (q = void 0));
    return U;
  }
  function previous(U) {
    return (
      U !== 96 ||
      this.events[this.events.length - 1][1].type === "characterEscape"
    );
  }
  function tokenizeCodeText(U, j, V) {
    let B = 0,
      q,
      $;
    return H;
    function H(Z) {
      return U.enter("codeText"), U.enter("codeTextSequence"), G(Z);
    }
    function G(Z) {
      return Z === 96
        ? (U.consume(Z), B++, G)
        : (U.exit("codeTextSequence"), Y(Z));
    }
    function Y(Z) {
      return Z === null
        ? V(Z)
        : Z === 32
        ? (U.enter("space"), U.consume(Z), U.exit("space"), Y)
        : Z === 96
        ? (($ = U.enter("codeTextSequence")), (q = 0), X(Z))
        : markdownLineEnding(Z)
        ? (U.enter("lineEnding"), U.consume(Z), U.exit("lineEnding"), Y)
        : (U.enter("codeTextData"), Q(Z));
    }
    function Q(Z) {
      return Z === null || Z === 32 || Z === 96 || markdownLineEnding(Z)
        ? (U.exit("codeTextData"), Y(Z))
        : (U.consume(Z), Q);
    }
    function X(Z) {
      return Z === 96
        ? (U.consume(Z), q++, X)
        : q === B
        ? (U.exit("codeTextSequence"), U.exit("codeText"), j(Z))
        : (($.type = "codeTextData"), Q(Z));
    }
  }
  class SpliceBuffer {
    constructor(j) {
      (this.left = j ? [...j] : []), (this.right = []);
    }
    get(j) {
      if (j < 0 || j >= this.left.length + this.right.length)
        throw new RangeError(
          "Cannot access index `" +
            j +
            "` in a splice buffer of size `" +
            (this.left.length + this.right.length) +
            "`"
        );
      return j < this.left.length
        ? this.left[j]
        : this.right[this.right.length - j + this.left.length - 1];
    }
    get length() {
      return this.left.length + this.right.length;
    }
    shift() {
      return this.setCursor(0), this.right.pop();
    }
    slice(j, V) {
      const B = V ?? Number.POSITIVE_INFINITY;
      return B < this.left.length
        ? this.left.slice(j, B)
        : j > this.left.length
        ? this.right
            .slice(
              this.right.length - B + this.left.length,
              this.right.length - j + this.left.length
            )
            .reverse()
        : this.left
            .slice(j)
            .concat(
              this.right
                .slice(this.right.length - B + this.left.length)
                .reverse()
            );
    }
    splice(j, V, B) {
      const q = V || 0;
      this.setCursor(Math.trunc(j));
      const $ = this.right.splice(
        this.right.length - q,
        Number.POSITIVE_INFINITY
      );
      return B && chunkedPush(this.left, B), $.reverse();
    }
    pop() {
      return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
    }
    push(j) {
      this.setCursor(Number.POSITIVE_INFINITY), this.left.push(j);
    }
    pushMany(j) {
      this.setCursor(Number.POSITIVE_INFINITY), chunkedPush(this.left, j);
    }
    unshift(j) {
      this.setCursor(0), this.right.push(j);
    }
    unshiftMany(j) {
      this.setCursor(0), chunkedPush(this.right, j.reverse());
    }
    setCursor(j) {
      if (
        !(
          j === this.left.length ||
          (j > this.left.length && this.right.length === 0) ||
          (j < 0 && this.left.length === 0)
        )
      )
        if (j < this.left.length) {
          const V = this.left.splice(j, Number.POSITIVE_INFINITY);
          chunkedPush(this.right, V.reverse());
        } else {
          const V = this.right.splice(
            this.left.length + this.right.length - j,
            Number.POSITIVE_INFINITY
          );
          chunkedPush(this.left, V.reverse());
        }
    }
  }
  function chunkedPush(U, j) {
    let V = 0;
    if (j.length < 1e4) U.push(...j);
    else for (; V < j.length; ) U.push(...j.slice(V, V + 1e4)), (V += 1e4);
  }
  function subtokenize(U) {
    const j = {};
    let V = -1,
      B,
      q,
      $,
      H,
      G,
      Y,
      Q;
    const X = new SpliceBuffer(U);
    for (; ++V < X.length; ) {
      for (; V in j; ) V = j[V];
      if (
        ((B = X.get(V)),
        V &&
          B[1].type === "chunkFlow" &&
          X.get(V - 1)[1].type === "listItemPrefix" &&
          ((Y = B[1]._tokenizer.events),
          ($ = 0),
          $ < Y.length && Y[$][1].type === "lineEndingBlank" && ($ += 2),
          $ < Y.length && Y[$][1].type === "content"))
      )
        for (; ++$ < Y.length && Y[$][1].type !== "content"; )
          Y[$][1].type === "chunkText" &&
            ((Y[$][1]._isInFirstContentOfListItem = !0), $++);
      if (B[0] === "enter")
        B[1].contentType &&
          (Object.assign(j, subcontent(X, V)), (V = j[V]), (Q = !0));
      else if (B[1]._container) {
        for ($ = V, q = void 0; $--; )
          if (
            ((H = X.get($)),
            H[1].type === "lineEnding" || H[1].type === "lineEndingBlank")
          )
            H[0] === "enter" &&
              (q && (X.get(q)[1].type = "lineEndingBlank"),
              (H[1].type = "lineEnding"),
              (q = $));
          else if (
            !(H[1].type === "linePrefix" || H[1].type === "listItemIndent")
          )
            break;
        q &&
          ((B[1].end = { ...X.get(q)[1].start }),
          (G = X.slice(q, V)),
          G.unshift(B),
          X.splice(q, V - q + 1, G));
      }
    }
    return splice(U, 0, Number.POSITIVE_INFINITY, X.slice(0)), !Q;
  }
  function subcontent(U, j) {
    const V = U.get(j)[1],
      B = U.get(j)[2];
    let q = j - 1;
    const $ = [];
    let H = V._tokenizer;
    H ||
      ((H = B.parser[V.contentType](V.start)),
      V._contentTypeTextTrailing && (H._contentTypeTextTrailing = !0));
    const G = H.events,
      Y = [],
      Q = {};
    let X,
      Z,
      te = -1,
      ne = V,
      ae = 0,
      se = 0;
    const fe = [se];
    for (; ne; ) {
      for (; U.get(++q)[1] !== ne; );
      $.push(q),
        ne._tokenizer ||
          ((X = B.sliceStream(ne)),
          ne.next || X.push(null),
          Z && H.defineSkip(ne.start),
          ne._isInFirstContentOfListItem &&
            (H._gfmTasklistFirstContentOfListItem = !0),
          H.write(X),
          ne._isInFirstContentOfListItem &&
            (H._gfmTasklistFirstContentOfListItem = void 0)),
        (Z = ne),
        (ne = ne.next);
    }
    for (ne = V; ++te < G.length; )
      G[te][0] === "exit" &&
        G[te - 1][0] === "enter" &&
        G[te][1].type === G[te - 1][1].type &&
        G[te][1].start.line !== G[te][1].end.line &&
        ((se = te + 1),
        fe.push(se),
        (ne._tokenizer = void 0),
        (ne.previous = void 0),
        (ne = ne.next));
    for (
      H.events = [],
        ne ? ((ne._tokenizer = void 0), (ne.previous = void 0)) : fe.pop(),
        te = fe.length;
      te--;

    ) {
      const ce = G.slice(fe[te], fe[te + 1]),
        ue = $.pop();
      Y.push([ue, ue + ce.length - 1]), U.splice(ue, 2, ce);
    }
    for (Y.reverse(), te = -1; ++te < Y.length; )
      (Q[ae + Y[te][0]] = ae + Y[te][1]), (ae += Y[te][1] - Y[te][0] - 1);
    return Q;
  }
  const content = { resolve: resolveContent, tokenize: tokenizeContent },
    continuationConstruct = { partial: !0, tokenize: tokenizeContinuation };
  function resolveContent(U) {
    return subtokenize(U), U;
  }
  function tokenizeContent(U, j) {
    let V;
    return B;
    function B(G) {
      return (
        U.enter("content"),
        (V = U.enter("chunkContent", { contentType: "content" })),
        q(G)
      );
    }
    function q(G) {
      return G === null
        ? $(G)
        : markdownLineEnding(G)
        ? U.check(continuationConstruct, H, $)(G)
        : (U.consume(G), q);
    }
    function $(G) {
      return U.exit("chunkContent"), U.exit("content"), j(G);
    }
    function H(G) {
      return (
        U.consume(G),
        U.exit("chunkContent"),
        (V.next = U.enter("chunkContent", {
          contentType: "content",
          previous: V,
        })),
        (V = V.next),
        q
      );
    }
  }
  function tokenizeContinuation(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return (
        U.exit("chunkContent"),
        U.enter("lineEnding"),
        U.consume(H),
        U.exit("lineEnding"),
        factorySpace(U, $, "linePrefix")
      );
    }
    function $(H) {
      if (H === null || markdownLineEnding(H)) return V(H);
      const G = B.events[B.events.length - 1];
      return !B.parser.constructs.disable.null.includes("codeIndented") &&
        G &&
        G[1].type === "linePrefix" &&
        G[2].sliceSerialize(G[1], !0).length >= 4
        ? j(H)
        : U.interrupt(B.parser.constructs.flow, V, j)(H);
    }
  }
  function factoryDestination(U, j, V, B, q, $, H, G, Y) {
    const Q = Y || Number.POSITIVE_INFINITY;
    let X = 0;
    return Z;
    function Z(ce) {
      return ce === 60
        ? (U.enter(B), U.enter(q), U.enter($), U.consume(ce), U.exit($), te)
        : ce === null || ce === 32 || ce === 41 || asciiControl(ce)
        ? V(ce)
        : (U.enter(B),
          U.enter(H),
          U.enter(G),
          U.enter("chunkString", { contentType: "string" }),
          se(ce));
    }
    function te(ce) {
      return ce === 62
        ? (U.enter($), U.consume(ce), U.exit($), U.exit(q), U.exit(B), j)
        : (U.enter(G),
          U.enter("chunkString", { contentType: "string" }),
          ne(ce));
    }
    function ne(ce) {
      return ce === 62
        ? (U.exit("chunkString"), U.exit(G), te(ce))
        : ce === null || ce === 60 || markdownLineEnding(ce)
        ? V(ce)
        : (U.consume(ce), ce === 92 ? ae : ne);
    }
    function ae(ce) {
      return ce === 60 || ce === 62 || ce === 92 ? (U.consume(ce), ne) : ne(ce);
    }
    function se(ce) {
      return !X && (ce === null || ce === 41 || markdownLineEndingOrSpace(ce))
        ? (U.exit("chunkString"), U.exit(G), U.exit(H), U.exit(B), j(ce))
        : X < Q && ce === 40
        ? (U.consume(ce), X++, se)
        : ce === 41
        ? (U.consume(ce), X--, se)
        : ce === null || ce === 32 || ce === 40 || asciiControl(ce)
        ? V(ce)
        : (U.consume(ce), ce === 92 ? fe : se);
    }
    function fe(ce) {
      return ce === 40 || ce === 41 || ce === 92 ? (U.consume(ce), se) : se(ce);
    }
  }
  function factoryLabel(U, j, V, B, q, $) {
    const H = this;
    let G = 0,
      Y;
    return Q;
    function Q(ne) {
      return U.enter(B), U.enter(q), U.consume(ne), U.exit(q), U.enter($), X;
    }
    function X(ne) {
      return G > 999 ||
        ne === null ||
        ne === 91 ||
        (ne === 93 && !Y) ||
        (ne === 94 && !G && "_hiddenFootnoteSupport" in H.parser.constructs)
        ? V(ne)
        : ne === 93
        ? (U.exit($), U.enter(q), U.consume(ne), U.exit(q), U.exit(B), j)
        : markdownLineEnding(ne)
        ? (U.enter("lineEnding"), U.consume(ne), U.exit("lineEnding"), X)
        : (U.enter("chunkString", { contentType: "string" }), Z(ne));
    }
    function Z(ne) {
      return ne === null ||
        ne === 91 ||
        ne === 93 ||
        markdownLineEnding(ne) ||
        G++ > 999
        ? (U.exit("chunkString"), X(ne))
        : (U.consume(ne), Y || (Y = !markdownSpace(ne)), ne === 92 ? te : Z);
    }
    function te(ne) {
      return ne === 91 || ne === 92 || ne === 93
        ? (U.consume(ne), G++, Z)
        : Z(ne);
    }
  }
  function factoryTitle(U, j, V, B, q, $) {
    let H;
    return G;
    function G(te) {
      return te === 34 || te === 39 || te === 40
        ? (U.enter(B),
          U.enter(q),
          U.consume(te),
          U.exit(q),
          (H = te === 40 ? 41 : te),
          Y)
        : V(te);
    }
    function Y(te) {
      return te === H
        ? (U.enter(q), U.consume(te), U.exit(q), U.exit(B), j)
        : (U.enter($), Q(te));
    }
    function Q(te) {
      return te === H
        ? (U.exit($), Y(H))
        : te === null
        ? V(te)
        : markdownLineEnding(te)
        ? (U.enter("lineEnding"),
          U.consume(te),
          U.exit("lineEnding"),
          factorySpace(U, Q, "linePrefix"))
        : (U.enter("chunkString", { contentType: "string" }), X(te));
    }
    function X(te) {
      return te === H || te === null || markdownLineEnding(te)
        ? (U.exit("chunkString"), Q(te))
        : (U.consume(te), te === 92 ? Z : X);
    }
    function Z(te) {
      return te === H || te === 92 ? (U.consume(te), X) : X(te);
    }
  }
  function factoryWhitespace(U, j) {
    let V;
    return B;
    function B(q) {
      return markdownLineEnding(q)
        ? (U.enter("lineEnding"),
          U.consume(q),
          U.exit("lineEnding"),
          (V = !0),
          B)
        : markdownSpace(q)
        ? factorySpace(U, B, V ? "linePrefix" : "lineSuffix")(q)
        : j(q);
    }
  }
  const definition = { name: "definition", tokenize: tokenizeDefinition },
    titleBefore = { partial: !0, tokenize: tokenizeTitleBefore };
  function tokenizeDefinition(U, j, V) {
    const B = this;
    let q;
    return $;
    function $(ne) {
      return U.enter("definition"), H(ne);
    }
    function H(ne) {
      return factoryLabel.call(
        B,
        U,
        G,
        V,
        "definitionLabel",
        "definitionLabelMarker",
        "definitionLabelString"
      )(ne);
    }
    function G(ne) {
      return (
        (q = normalizeIdentifier(
          B.sliceSerialize(B.events[B.events.length - 1][1]).slice(1, -1)
        )),
        ne === 58
          ? (U.enter("definitionMarker"),
            U.consume(ne),
            U.exit("definitionMarker"),
            Y)
          : V(ne)
      );
    }
    function Y(ne) {
      return markdownLineEndingOrSpace(ne)
        ? factoryWhitespace(U, Q)(ne)
        : Q(ne);
    }
    function Q(ne) {
      return factoryDestination(
        U,
        X,
        V,
        "definitionDestination",
        "definitionDestinationLiteral",
        "definitionDestinationLiteralMarker",
        "definitionDestinationRaw",
        "definitionDestinationString"
      )(ne);
    }
    function X(ne) {
      return U.attempt(titleBefore, Z, Z)(ne);
    }
    function Z(ne) {
      return markdownSpace(ne) ? factorySpace(U, te, "whitespace")(ne) : te(ne);
    }
    function te(ne) {
      return ne === null || markdownLineEnding(ne)
        ? (U.exit("definition"), B.parser.defined.push(q), j(ne))
        : V(ne);
    }
  }
  function tokenizeTitleBefore(U, j, V) {
    return B;
    function B(G) {
      return markdownLineEndingOrSpace(G) ? factoryWhitespace(U, q)(G) : V(G);
    }
    function q(G) {
      return factoryTitle(
        U,
        $,
        V,
        "definitionTitle",
        "definitionTitleMarker",
        "definitionTitleString"
      )(G);
    }
    function $(G) {
      return markdownSpace(G) ? factorySpace(U, H, "whitespace")(G) : H(G);
    }
    function H(G) {
      return G === null || markdownLineEnding(G) ? j(G) : V(G);
    }
  }
  const hardBreakEscape = {
    name: "hardBreakEscape",
    tokenize: tokenizeHardBreakEscape,
  };
  function tokenizeHardBreakEscape(U, j, V) {
    return B;
    function B($) {
      return U.enter("hardBreakEscape"), U.consume($), q;
    }
    function q($) {
      return markdownLineEnding($) ? (U.exit("hardBreakEscape"), j($)) : V($);
    }
  }
  const headingAtx = {
    name: "headingAtx",
    resolve: resolveHeadingAtx,
    tokenize: tokenizeHeadingAtx,
  };
  function resolveHeadingAtx(U, j) {
    let V = U.length - 2,
      B = 3,
      q,
      $;
    return (
      U[B][1].type === "whitespace" && (B += 2),
      V - 2 > B && U[V][1].type === "whitespace" && (V -= 2),
      U[V][1].type === "atxHeadingSequence" &&
        (B === V - 1 || (V - 4 > B && U[V - 2][1].type === "whitespace")) &&
        (V -= B + 1 === V ? 2 : 4),
      V > B &&
        ((q = {
          type: "atxHeadingText",
          start: U[B][1].start,
          end: U[V][1].end,
        }),
        ($ = {
          type: "chunkText",
          start: U[B][1].start,
          end: U[V][1].end,
          contentType: "text",
        }),
        splice(U, B, V - B + 1, [
          ["enter", q, j],
          ["enter", $, j],
          ["exit", $, j],
          ["exit", q, j],
        ])),
      U
    );
  }
  function tokenizeHeadingAtx(U, j, V) {
    let B = 0;
    return q;
    function q(X) {
      return U.enter("atxHeading"), $(X);
    }
    function $(X) {
      return U.enter("atxHeadingSequence"), H(X);
    }
    function H(X) {
      return X === 35 && B++ < 6
        ? (U.consume(X), H)
        : X === null || markdownLineEndingOrSpace(X)
        ? (U.exit("atxHeadingSequence"), G(X))
        : V(X);
    }
    function G(X) {
      return X === 35
        ? (U.enter("atxHeadingSequence"), Y(X))
        : X === null || markdownLineEnding(X)
        ? (U.exit("atxHeading"), j(X))
        : markdownSpace(X)
        ? factorySpace(U, G, "whitespace")(X)
        : (U.enter("atxHeadingText"), Q(X));
    }
    function Y(X) {
      return X === 35
        ? (U.consume(X), Y)
        : (U.exit("atxHeadingSequence"), G(X));
    }
    function Q(X) {
      return X === null || X === 35 || markdownLineEndingOrSpace(X)
        ? (U.exit("atxHeadingText"), G(X))
        : (U.consume(X), Q);
    }
  }
  const htmlBlockNames = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "search",
      "section",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul",
    ],
    htmlRawNames = ["pre", "script", "style", "textarea"],
    htmlFlow = {
      concrete: !0,
      name: "htmlFlow",
      resolveTo: resolveToHtmlFlow,
      tokenize: tokenizeHtmlFlow,
    },
    blankLineBefore = { partial: !0, tokenize: tokenizeBlankLineBefore },
    nonLazyContinuationStart = {
      partial: !0,
      tokenize: tokenizeNonLazyContinuationStart,
    };
  function resolveToHtmlFlow(U) {
    let j = U.length;
    for (; j-- && !(U[j][0] === "enter" && U[j][1].type === "htmlFlow"); );
    return (
      j > 1 &&
        U[j - 2][1].type === "linePrefix" &&
        ((U[j][1].start = U[j - 2][1].start),
        (U[j + 1][1].start = U[j - 2][1].start),
        U.splice(j - 2, 2)),
      U
    );
  }
  function tokenizeHtmlFlow(U, j, V) {
    const B = this;
    let q, $, H, G, Y;
    return Q;
    function Q(pe) {
      return X(pe);
    }
    function X(pe) {
      return U.enter("htmlFlow"), U.enter("htmlFlowData"), U.consume(pe), Z;
    }
    function Z(pe) {
      return pe === 33
        ? (U.consume(pe), te)
        : pe === 47
        ? (U.consume(pe), ($ = !0), se)
        : pe === 63
        ? (U.consume(pe), (q = 3), B.interrupt ? j : oe)
        : asciiAlpha(pe)
        ? (U.consume(pe), (H = String.fromCharCode(pe)), fe)
        : V(pe);
    }
    function te(pe) {
      return pe === 45
        ? (U.consume(pe), (q = 2), ne)
        : pe === 91
        ? (U.consume(pe), (q = 5), (G = 0), ae)
        : asciiAlpha(pe)
        ? (U.consume(pe), (q = 4), B.interrupt ? j : oe)
        : V(pe);
    }
    function ne(pe) {
      return pe === 45 ? (U.consume(pe), B.interrupt ? j : oe) : V(pe);
    }
    function ae(pe) {
      const Ye = "CDATA[";
      return pe === Ye.charCodeAt(G++)
        ? (U.consume(pe), G === Ye.length ? (B.interrupt ? j : Le) : ae)
        : V(pe);
    }
    function se(pe) {
      return asciiAlpha(pe)
        ? (U.consume(pe), (H = String.fromCharCode(pe)), fe)
        : V(pe);
    }
    function fe(pe) {
      if (
        pe === null ||
        pe === 47 ||
        pe === 62 ||
        markdownLineEndingOrSpace(pe)
      ) {
        const Ye = pe === 47,
          Qe = H.toLowerCase();
        return !Ye && !$ && htmlRawNames.includes(Qe)
          ? ((q = 1), B.interrupt ? j(pe) : Le(pe))
          : htmlBlockNames.includes(H.toLowerCase())
          ? ((q = 6), Ye ? (U.consume(pe), ce) : B.interrupt ? j(pe) : Le(pe))
          : ((q = 7),
            B.interrupt && !B.parser.lazy[B.now().line]
              ? V(pe)
              : $
              ? ue(pe)
              : he(pe));
      }
      return pe === 45 || asciiAlphanumeric(pe)
        ? (U.consume(pe), (H += String.fromCharCode(pe)), fe)
        : V(pe);
    }
    function ce(pe) {
      return pe === 62 ? (U.consume(pe), B.interrupt ? j : Le) : V(pe);
    }
    function ue(pe) {
      return markdownSpace(pe) ? (U.consume(pe), ue) : Ae(pe);
    }
    function he(pe) {
      return pe === 47
        ? (U.consume(pe), Ae)
        : pe === 58 || pe === 95 || asciiAlpha(pe)
        ? (U.consume(pe), me)
        : markdownSpace(pe)
        ? (U.consume(pe), he)
        : Ae(pe);
    }
    function me(pe) {
      return pe === 45 ||
        pe === 46 ||
        pe === 58 ||
        pe === 95 ||
        asciiAlphanumeric(pe)
        ? (U.consume(pe), me)
        : ve(pe);
    }
    function ve(pe) {
      return pe === 61
        ? (U.consume(pe), ge)
        : markdownSpace(pe)
        ? (U.consume(pe), ve)
        : he(pe);
    }
    function ge(pe) {
      return pe === null || pe === 60 || pe === 61 || pe === 62 || pe === 96
        ? V(pe)
        : pe === 34 || pe === 39
        ? (U.consume(pe), (Y = pe), Ee)
        : markdownSpace(pe)
        ? (U.consume(pe), ge)
        : Ce(pe);
    }
    function Ee(pe) {
      return pe === Y
        ? (U.consume(pe), (Y = null), Re)
        : pe === null || markdownLineEnding(pe)
        ? V(pe)
        : (U.consume(pe), Ee);
    }
    function Ce(pe) {
      return pe === null ||
        pe === 34 ||
        pe === 39 ||
        pe === 47 ||
        pe === 60 ||
        pe === 61 ||
        pe === 62 ||
        pe === 96 ||
        markdownLineEndingOrSpace(pe)
        ? ve(pe)
        : (U.consume(pe), Ce);
    }
    function Re(pe) {
      return pe === 47 || pe === 62 || markdownSpace(pe) ? he(pe) : V(pe);
    }
    function Ae(pe) {
      return pe === 62 ? (U.consume(pe), be) : V(pe);
    }
    function be(pe) {
      return pe === null || markdownLineEnding(pe)
        ? Le(pe)
        : markdownSpace(pe)
        ? (U.consume(pe), be)
        : V(pe);
    }
    function Le(pe) {
      return pe === 45 && q === 2
        ? (U.consume(pe), Te)
        : pe === 60 && q === 1
        ? (U.consume(pe), xe)
        : pe === 62 && q === 4
        ? (U.consume(pe), De)
        : pe === 63 && q === 3
        ? (U.consume(pe), oe)
        : pe === 93 && q === 5
        ? (U.consume(pe), Je)
        : markdownLineEnding(pe) && (q === 6 || q === 7)
        ? (U.exit("htmlFlowData"), U.check(blankLineBefore, Ge, Fe)(pe))
        : pe === null || markdownLineEnding(pe)
        ? (U.exit("htmlFlowData"), Fe(pe))
        : (U.consume(pe), Le);
    }
    function Fe(pe) {
      return U.check(nonLazyContinuationStart, Me, Ge)(pe);
    }
    function Me(pe) {
      return U.enter("lineEnding"), U.consume(pe), U.exit("lineEnding"), je;
    }
    function je(pe) {
      return pe === null || markdownLineEnding(pe)
        ? Fe(pe)
        : (U.enter("htmlFlowData"), Le(pe));
    }
    function Te(pe) {
      return pe === 45 ? (U.consume(pe), oe) : Le(pe);
    }
    function xe(pe) {
      return pe === 47 ? (U.consume(pe), (H = ""), He) : Le(pe);
    }
    function He(pe) {
      if (pe === 62) {
        const Ye = H.toLowerCase();
        return htmlRawNames.includes(Ye) ? (U.consume(pe), De) : Le(pe);
      }
      return asciiAlpha(pe) && H.length < 8
        ? (U.consume(pe), (H += String.fromCharCode(pe)), He)
        : Le(pe);
    }
    function Je(pe) {
      return pe === 93 ? (U.consume(pe), oe) : Le(pe);
    }
    function oe(pe) {
      return pe === 62
        ? (U.consume(pe), De)
        : pe === 45 && q === 2
        ? (U.consume(pe), oe)
        : Le(pe);
    }
    function De(pe) {
      return pe === null || markdownLineEnding(pe)
        ? (U.exit("htmlFlowData"), Ge(pe))
        : (U.consume(pe), De);
    }
    function Ge(pe) {
      return U.exit("htmlFlow"), j(pe);
    }
  }
  function tokenizeNonLazyContinuationStart(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return markdownLineEnding(H)
        ? (U.enter("lineEnding"), U.consume(H), U.exit("lineEnding"), $)
        : V(H);
    }
    function $(H) {
      return B.parser.lazy[B.now().line] ? V(H) : j(H);
    }
  }
  function tokenizeBlankLineBefore(U, j, V) {
    return B;
    function B(q) {
      return (
        U.enter("lineEnding"),
        U.consume(q),
        U.exit("lineEnding"),
        U.attempt(blankLine, j, V)
      );
    }
  }
  const htmlText = { name: "htmlText", tokenize: tokenizeHtmlText };
  function tokenizeHtmlText(U, j, V) {
    const B = this;
    let q, $, H;
    return G;
    function G(oe) {
      return U.enter("htmlText"), U.enter("htmlTextData"), U.consume(oe), Y;
    }
    function Y(oe) {
      return oe === 33
        ? (U.consume(oe), Q)
        : oe === 47
        ? (U.consume(oe), ve)
        : oe === 63
        ? (U.consume(oe), he)
        : asciiAlpha(oe)
        ? (U.consume(oe), Ce)
        : V(oe);
    }
    function Q(oe) {
      return oe === 45
        ? (U.consume(oe), X)
        : oe === 91
        ? (U.consume(oe), ($ = 0), ae)
        : asciiAlpha(oe)
        ? (U.consume(oe), ue)
        : V(oe);
    }
    function X(oe) {
      return oe === 45 ? (U.consume(oe), ne) : V(oe);
    }
    function Z(oe) {
      return oe === null
        ? V(oe)
        : oe === 45
        ? (U.consume(oe), te)
        : markdownLineEnding(oe)
        ? ((H = Z), xe(oe))
        : (U.consume(oe), Z);
    }
    function te(oe) {
      return oe === 45 ? (U.consume(oe), ne) : Z(oe);
    }
    function ne(oe) {
      return oe === 62 ? Te(oe) : oe === 45 ? te(oe) : Z(oe);
    }
    function ae(oe) {
      const De = "CDATA[";
      return oe === De.charCodeAt($++)
        ? (U.consume(oe), $ === De.length ? se : ae)
        : V(oe);
    }
    function se(oe) {
      return oe === null
        ? V(oe)
        : oe === 93
        ? (U.consume(oe), fe)
        : markdownLineEnding(oe)
        ? ((H = se), xe(oe))
        : (U.consume(oe), se);
    }
    function fe(oe) {
      return oe === 93 ? (U.consume(oe), ce) : se(oe);
    }
    function ce(oe) {
      return oe === 62 ? Te(oe) : oe === 93 ? (U.consume(oe), ce) : se(oe);
    }
    function ue(oe) {
      return oe === null || oe === 62
        ? Te(oe)
        : markdownLineEnding(oe)
        ? ((H = ue), xe(oe))
        : (U.consume(oe), ue);
    }
    function he(oe) {
      return oe === null
        ? V(oe)
        : oe === 63
        ? (U.consume(oe), me)
        : markdownLineEnding(oe)
        ? ((H = he), xe(oe))
        : (U.consume(oe), he);
    }
    function me(oe) {
      return oe === 62 ? Te(oe) : he(oe);
    }
    function ve(oe) {
      return asciiAlpha(oe) ? (U.consume(oe), ge) : V(oe);
    }
    function ge(oe) {
      return oe === 45 || asciiAlphanumeric(oe) ? (U.consume(oe), ge) : Ee(oe);
    }
    function Ee(oe) {
      return markdownLineEnding(oe)
        ? ((H = Ee), xe(oe))
        : markdownSpace(oe)
        ? (U.consume(oe), Ee)
        : Te(oe);
    }
    function Ce(oe) {
      return oe === 45 || asciiAlphanumeric(oe)
        ? (U.consume(oe), Ce)
        : oe === 47 || oe === 62 || markdownLineEndingOrSpace(oe)
        ? Re(oe)
        : V(oe);
    }
    function Re(oe) {
      return oe === 47
        ? (U.consume(oe), Te)
        : oe === 58 || oe === 95 || asciiAlpha(oe)
        ? (U.consume(oe), Ae)
        : markdownLineEnding(oe)
        ? ((H = Re), xe(oe))
        : markdownSpace(oe)
        ? (U.consume(oe), Re)
        : Te(oe);
    }
    function Ae(oe) {
      return oe === 45 ||
        oe === 46 ||
        oe === 58 ||
        oe === 95 ||
        asciiAlphanumeric(oe)
        ? (U.consume(oe), Ae)
        : be(oe);
    }
    function be(oe) {
      return oe === 61
        ? (U.consume(oe), Le)
        : markdownLineEnding(oe)
        ? ((H = be), xe(oe))
        : markdownSpace(oe)
        ? (U.consume(oe), be)
        : Re(oe);
    }
    function Le(oe) {
      return oe === null || oe === 60 || oe === 61 || oe === 62 || oe === 96
        ? V(oe)
        : oe === 34 || oe === 39
        ? (U.consume(oe), (q = oe), Fe)
        : markdownLineEnding(oe)
        ? ((H = Le), xe(oe))
        : markdownSpace(oe)
        ? (U.consume(oe), Le)
        : (U.consume(oe), Me);
    }
    function Fe(oe) {
      return oe === q
        ? (U.consume(oe), (q = void 0), je)
        : oe === null
        ? V(oe)
        : markdownLineEnding(oe)
        ? ((H = Fe), xe(oe))
        : (U.consume(oe), Fe);
    }
    function Me(oe) {
      return oe === null ||
        oe === 34 ||
        oe === 39 ||
        oe === 60 ||
        oe === 61 ||
        oe === 96
        ? V(oe)
        : oe === 47 || oe === 62 || markdownLineEndingOrSpace(oe)
        ? Re(oe)
        : (U.consume(oe), Me);
    }
    function je(oe) {
      return oe === 47 || oe === 62 || markdownLineEndingOrSpace(oe)
        ? Re(oe)
        : V(oe);
    }
    function Te(oe) {
      return oe === 62
        ? (U.consume(oe), U.exit("htmlTextData"), U.exit("htmlText"), j)
        : V(oe);
    }
    function xe(oe) {
      return (
        U.exit("htmlTextData"),
        U.enter("lineEnding"),
        U.consume(oe),
        U.exit("lineEnding"),
        He
      );
    }
    function He(oe) {
      return markdownSpace(oe)
        ? factorySpace(
            U,
            Je,
            "linePrefix",
            B.parser.constructs.disable.null.includes("codeIndented")
              ? void 0
              : 4
          )(oe)
        : Je(oe);
    }
    function Je(oe) {
      return U.enter("htmlTextData"), H(oe);
    }
  }
  const labelEnd = {
      name: "labelEnd",
      resolveAll: resolveAllLabelEnd,
      resolveTo: resolveToLabelEnd,
      tokenize: tokenizeLabelEnd,
    },
    resourceConstruct = { tokenize: tokenizeResource },
    referenceFullConstruct = { tokenize: tokenizeReferenceFull },
    referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };
  function resolveAllLabelEnd(U) {
    let j = -1;
    const V = [];
    for (; ++j < U.length; ) {
      const B = U[j][1];
      if (
        (V.push(U[j]),
        B.type === "labelImage" ||
          B.type === "labelLink" ||
          B.type === "labelEnd")
      ) {
        const q = B.type === "labelImage" ? 4 : 2;
        (B.type = "data"), (j += q);
      }
    }
    return U.length !== V.length && splice(U, 0, U.length, V), U;
  }
  function resolveToLabelEnd(U, j) {
    let V = U.length,
      B = 0,
      q,
      $,
      H,
      G;
    for (; V--; )
      if (((q = U[V][1]), $)) {
        if (q.type === "link" || (q.type === "labelLink" && q._inactive)) break;
        U[V][0] === "enter" && q.type === "labelLink" && (q._inactive = !0);
      } else if (H) {
        if (
          U[V][0] === "enter" &&
          (q.type === "labelImage" || q.type === "labelLink") &&
          !q._balanced &&
          (($ = V), q.type !== "labelLink")
        ) {
          B = 2;
          break;
        }
      } else q.type === "labelEnd" && (H = V);
    const Y = {
        type: U[$][1].type === "labelLink" ? "link" : "image",
        start: { ...U[$][1].start },
        end: { ...U[U.length - 1][1].end },
      },
      Q = {
        type: "label",
        start: { ...U[$][1].start },
        end: { ...U[H][1].end },
      },
      X = {
        type: "labelText",
        start: { ...U[$ + B + 2][1].end },
        end: { ...U[H - 2][1].start },
      };
    return (
      (G = [
        ["enter", Y, j],
        ["enter", Q, j],
      ]),
      (G = push(G, U.slice($ + 1, $ + B + 3))),
      (G = push(G, [["enter", X, j]])),
      (G = push(
        G,
        resolveAll(
          j.parser.constructs.insideSpan.null,
          U.slice($ + B + 4, H - 3),
          j
        )
      )),
      (G = push(G, [["exit", X, j], U[H - 2], U[H - 1], ["exit", Q, j]])),
      (G = push(G, U.slice(H + 1))),
      (G = push(G, [["exit", Y, j]])),
      splice(U, $, U.length, G),
      U
    );
  }
  function tokenizeLabelEnd(U, j, V) {
    const B = this;
    let q = B.events.length,
      $,
      H;
    for (; q--; )
      if (
        (B.events[q][1].type === "labelImage" ||
          B.events[q][1].type === "labelLink") &&
        !B.events[q][1]._balanced
      ) {
        $ = B.events[q][1];
        break;
      }
    return G;
    function G(te) {
      return $
        ? $._inactive
          ? Z(te)
          : ((H = B.parser.defined.includes(
              normalizeIdentifier(
                B.sliceSerialize({ start: $.end, end: B.now() })
              )
            )),
            U.enter("labelEnd"),
            U.enter("labelMarker"),
            U.consume(te),
            U.exit("labelMarker"),
            U.exit("labelEnd"),
            Y)
        : V(te);
    }
    function Y(te) {
      return te === 40
        ? U.attempt(resourceConstruct, X, H ? X : Z)(te)
        : te === 91
        ? U.attempt(referenceFullConstruct, X, H ? Q : Z)(te)
        : H
        ? X(te)
        : Z(te);
    }
    function Q(te) {
      return U.attempt(referenceCollapsedConstruct, X, Z)(te);
    }
    function X(te) {
      return j(te);
    }
    function Z(te) {
      return ($._balanced = !0), V(te);
    }
  }
  function tokenizeResource(U, j, V) {
    return B;
    function B(Z) {
      return (
        U.enter("resource"),
        U.enter("resourceMarker"),
        U.consume(Z),
        U.exit("resourceMarker"),
        q
      );
    }
    function q(Z) {
      return markdownLineEndingOrSpace(Z) ? factoryWhitespace(U, $)(Z) : $(Z);
    }
    function $(Z) {
      return Z === 41
        ? X(Z)
        : factoryDestination(
            U,
            H,
            G,
            "resourceDestination",
            "resourceDestinationLiteral",
            "resourceDestinationLiteralMarker",
            "resourceDestinationRaw",
            "resourceDestinationString",
            32
          )(Z);
    }
    function H(Z) {
      return markdownLineEndingOrSpace(Z) ? factoryWhitespace(U, Y)(Z) : X(Z);
    }
    function G(Z) {
      return V(Z);
    }
    function Y(Z) {
      return Z === 34 || Z === 39 || Z === 40
        ? factoryTitle(
            U,
            Q,
            V,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(Z)
        : X(Z);
    }
    function Q(Z) {
      return markdownLineEndingOrSpace(Z) ? factoryWhitespace(U, X)(Z) : X(Z);
    }
    function X(Z) {
      return Z === 41
        ? (U.enter("resourceMarker"),
          U.consume(Z),
          U.exit("resourceMarker"),
          U.exit("resource"),
          j)
        : V(Z);
    }
  }
  function tokenizeReferenceFull(U, j, V) {
    const B = this;
    return q;
    function q(G) {
      return factoryLabel.call(
        B,
        U,
        $,
        H,
        "reference",
        "referenceMarker",
        "referenceString"
      )(G);
    }
    function $(G) {
      return B.parser.defined.includes(
        normalizeIdentifier(
          B.sliceSerialize(B.events[B.events.length - 1][1]).slice(1, -1)
        )
      )
        ? j(G)
        : V(G);
    }
    function H(G) {
      return V(G);
    }
  }
  function tokenizeReferenceCollapsed(U, j, V) {
    return B;
    function B($) {
      return (
        U.enter("reference"),
        U.enter("referenceMarker"),
        U.consume($),
        U.exit("referenceMarker"),
        q
      );
    }
    function q($) {
      return $ === 93
        ? (U.enter("referenceMarker"),
          U.consume($),
          U.exit("referenceMarker"),
          U.exit("reference"),
          j)
        : V($);
    }
  }
  const labelStartImage = {
    name: "labelStartImage",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartImage,
  };
  function tokenizeLabelStartImage(U, j, V) {
    const B = this;
    return q;
    function q(G) {
      return (
        U.enter("labelImage"),
        U.enter("labelImageMarker"),
        U.consume(G),
        U.exit("labelImageMarker"),
        $
      );
    }
    function $(G) {
      return G === 91
        ? (U.enter("labelMarker"),
          U.consume(G),
          U.exit("labelMarker"),
          U.exit("labelImage"),
          H)
        : V(G);
    }
    function H(G) {
      return G === 94 && "_hiddenFootnoteSupport" in B.parser.constructs
        ? V(G)
        : j(G);
    }
  }
  const labelStartLink = {
    name: "labelStartLink",
    resolveAll: labelEnd.resolveAll,
    tokenize: tokenizeLabelStartLink,
  };
  function tokenizeLabelStartLink(U, j, V) {
    const B = this;
    return q;
    function q(H) {
      return (
        U.enter("labelLink"),
        U.enter("labelMarker"),
        U.consume(H),
        U.exit("labelMarker"),
        U.exit("labelLink"),
        $
      );
    }
    function $(H) {
      return H === 94 && "_hiddenFootnoteSupport" in B.parser.constructs
        ? V(H)
        : j(H);
    }
  }
  const lineEnding = { name: "lineEnding", tokenize: tokenizeLineEnding };
  function tokenizeLineEnding(U, j) {
    return V;
    function V(B) {
      return (
        U.enter("lineEnding"),
        U.consume(B),
        U.exit("lineEnding"),
        factorySpace(U, j, "linePrefix")
      );
    }
  }
  const thematicBreak$1 = {
    name: "thematicBreak",
    tokenize: tokenizeThematicBreak,
  };
  function tokenizeThematicBreak(U, j, V) {
    let B = 0,
      q;
    return $;
    function $(Q) {
      return U.enter("thematicBreak"), H(Q);
    }
    function H(Q) {
      return (q = Q), G(Q);
    }
    function G(Q) {
      return Q === q
        ? (U.enter("thematicBreakSequence"), Y(Q))
        : B >= 3 && (Q === null || markdownLineEnding(Q))
        ? (U.exit("thematicBreak"), j(Q))
        : V(Q);
    }
    function Y(Q) {
      return Q === q
        ? (U.consume(Q), B++, Y)
        : (U.exit("thematicBreakSequence"),
          markdownSpace(Q) ? factorySpace(U, G, "whitespace")(Q) : G(Q));
    }
  }
  const list$1 = {
      continuation: { tokenize: tokenizeListContinuation },
      exit: tokenizeListEnd,
      name: "list",
      tokenize: tokenizeListStart,
    },
    listItemPrefixWhitespaceConstruct = {
      partial: !0,
      tokenize: tokenizeListItemPrefixWhitespace,
    },
    indentConstruct = { partial: !0, tokenize: tokenizeIndent };
  function tokenizeListStart(U, j, V) {
    const B = this,
      q = B.events[B.events.length - 1];
    let $ =
        q && q[1].type === "linePrefix"
          ? q[2].sliceSerialize(q[1], !0).length
          : 0,
      H = 0;
    return G;
    function G(ne) {
      const ae =
        B.containerState.type ||
        (ne === 42 || ne === 43 || ne === 45 ? "listUnordered" : "listOrdered");
      if (
        ae === "listUnordered"
          ? !B.containerState.marker || ne === B.containerState.marker
          : asciiDigit(ne)
      ) {
        if (
          (B.containerState.type ||
            ((B.containerState.type = ae), U.enter(ae, { _container: !0 })),
          ae === "listUnordered")
        )
          return (
            U.enter("listItemPrefix"),
            ne === 42 || ne === 45 ? U.check(thematicBreak$1, V, Q)(ne) : Q(ne)
          );
        if (!B.interrupt || ne === 49)
          return U.enter("listItemPrefix"), U.enter("listItemValue"), Y(ne);
      }
      return V(ne);
    }
    function Y(ne) {
      return asciiDigit(ne) && ++H < 10
        ? (U.consume(ne), Y)
        : (!B.interrupt || H < 2) &&
          (B.containerState.marker
            ? ne === B.containerState.marker
            : ne === 41 || ne === 46)
        ? (U.exit("listItemValue"), Q(ne))
        : V(ne);
    }
    function Q(ne) {
      return (
        U.enter("listItemMarker"),
        U.consume(ne),
        U.exit("listItemMarker"),
        (B.containerState.marker = B.containerState.marker || ne),
        U.check(
          blankLine,
          B.interrupt ? V : X,
          U.attempt(listItemPrefixWhitespaceConstruct, te, Z)
        )
      );
    }
    function X(ne) {
      return (B.containerState.initialBlankLine = !0), $++, te(ne);
    }
    function Z(ne) {
      return markdownSpace(ne)
        ? (U.enter("listItemPrefixWhitespace"),
          U.consume(ne),
          U.exit("listItemPrefixWhitespace"),
          te)
        : V(ne);
    }
    function te(ne) {
      return (
        (B.containerState.size =
          $ + B.sliceSerialize(U.exit("listItemPrefix"), !0).length),
        j(ne)
      );
    }
  }
  function tokenizeListContinuation(U, j, V) {
    const B = this;
    return (B.containerState._closeFlow = void 0), U.check(blankLine, q, $);
    function q(G) {
      return (
        (B.containerState.furtherBlankLines =
          B.containerState.furtherBlankLines ||
          B.containerState.initialBlankLine),
        factorySpace(U, j, "listItemIndent", B.containerState.size + 1)(G)
      );
    }
    function $(G) {
      return B.containerState.furtherBlankLines || !markdownSpace(G)
        ? ((B.containerState.furtherBlankLines = void 0),
          (B.containerState.initialBlankLine = void 0),
          H(G))
        : ((B.containerState.furtherBlankLines = void 0),
          (B.containerState.initialBlankLine = void 0),
          U.attempt(indentConstruct, j, H)(G));
    }
    function H(G) {
      return (
        (B.containerState._closeFlow = !0),
        (B.interrupt = void 0),
        factorySpace(
          U,
          U.attempt(list$1, j, V),
          "linePrefix",
          B.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
        )(G)
      );
    }
  }
  function tokenizeIndent(U, j, V) {
    const B = this;
    return factorySpace(U, q, "listItemIndent", B.containerState.size + 1);
    function q($) {
      const H = B.events[B.events.length - 1];
      return H &&
        H[1].type === "listItemIndent" &&
        H[2].sliceSerialize(H[1], !0).length === B.containerState.size
        ? j($)
        : V($);
    }
  }
  function tokenizeListEnd(U) {
    U.exit(this.containerState.type);
  }
  function tokenizeListItemPrefixWhitespace(U, j, V) {
    const B = this;
    return factorySpace(
      U,
      q,
      "listItemPrefixWhitespace",
      B.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
    );
    function q($) {
      const H = B.events[B.events.length - 1];
      return !markdownSpace($) && H && H[1].type === "listItemPrefixWhitespace"
        ? j($)
        : V($);
    }
  }
  const setextUnderline = {
    name: "setextUnderline",
    resolveTo: resolveToSetextUnderline,
    tokenize: tokenizeSetextUnderline,
  };
  function resolveToSetextUnderline(U, j) {
    let V = U.length,
      B,
      q,
      $;
    for (; V--; )
      if (U[V][0] === "enter") {
        if (U[V][1].type === "content") {
          B = V;
          break;
        }
        U[V][1].type === "paragraph" && (q = V);
      } else
        U[V][1].type === "content" && U.splice(V, 1),
          !$ && U[V][1].type === "definition" && ($ = V);
    const H = {
      type: "setextHeading",
      start: { ...U[B][1].start },
      end: { ...U[U.length - 1][1].end },
    };
    return (
      (U[q][1].type = "setextHeadingText"),
      $
        ? (U.splice(q, 0, ["enter", H, j]),
          U.splice($ + 1, 0, ["exit", U[B][1], j]),
          (U[B][1].end = { ...U[$][1].end }))
        : (U[B][1] = H),
      U.push(["exit", H, j]),
      U
    );
  }
  function tokenizeSetextUnderline(U, j, V) {
    const B = this;
    let q;
    return $;
    function $(Q) {
      let X = B.events.length,
        Z;
      for (; X--; )
        if (
          B.events[X][1].type !== "lineEnding" &&
          B.events[X][1].type !== "linePrefix" &&
          B.events[X][1].type !== "content"
        ) {
          Z = B.events[X][1].type === "paragraph";
          break;
        }
      return !B.parser.lazy[B.now().line] && (B.interrupt || Z)
        ? (U.enter("setextHeadingLine"), (q = Q), H(Q))
        : V(Q);
    }
    function H(Q) {
      return U.enter("setextHeadingLineSequence"), G(Q);
    }
    function G(Q) {
      return Q === q
        ? (U.consume(Q), G)
        : (U.exit("setextHeadingLineSequence"),
          markdownSpace(Q) ? factorySpace(U, Y, "lineSuffix")(Q) : Y(Q));
    }
    function Y(Q) {
      return Q === null || markdownLineEnding(Q)
        ? (U.exit("setextHeadingLine"), j(Q))
        : V(Q);
    }
  }
  const flow$1 = { tokenize: initializeFlow };
  function initializeFlow(U) {
    const j = this,
      V = U.attempt(
        blankLine,
        B,
        U.attempt(
          this.parser.constructs.flowInitial,
          q,
          factorySpace(
            U,
            U.attempt(this.parser.constructs.flow, q, U.attempt(content, q)),
            "linePrefix"
          )
        )
      );
    return V;
    function B($) {
      if ($ === null) {
        U.consume($);
        return;
      }
      return (
        U.enter("lineEndingBlank"),
        U.consume($),
        U.exit("lineEndingBlank"),
        (j.currentConstruct = void 0),
        V
      );
    }
    function q($) {
      if ($ === null) {
        U.consume($);
        return;
      }
      return (
        U.enter("lineEnding"),
        U.consume($),
        U.exit("lineEnding"),
        (j.currentConstruct = void 0),
        V
      );
    }
  }
  const resolver = { resolveAll: createResolver() },
    string$1 = initializeFactory("string"),
    text$2 = initializeFactory("text");
  function initializeFactory(U) {
    return {
      resolveAll: createResolver(
        U === "text" ? resolveAllLineSuffixes : void 0
      ),
      tokenize: j,
    };
    function j(V) {
      const B = this,
        q = this.parser.constructs[U],
        $ = V.attempt(q, H, G);
      return H;
      function H(X) {
        return Q(X) ? $(X) : G(X);
      }
      function G(X) {
        if (X === null) {
          V.consume(X);
          return;
        }
        return V.enter("data"), V.consume(X), Y;
      }
      function Y(X) {
        return Q(X) ? (V.exit("data"), $(X)) : (V.consume(X), Y);
      }
      function Q(X) {
        if (X === null) return !0;
        const Z = q[X];
        let te = -1;
        if (Z)
          for (; ++te < Z.length; ) {
            const ne = Z[te];
            if (!ne.previous || ne.previous.call(B, B.previous)) return !0;
          }
        return !1;
      }
    }
  }
  function createResolver(U) {
    return j;
    function j(V, B) {
      let q = -1,
        $;
      for (; ++q <= V.length; )
        $ === void 0
          ? V[q] && V[q][1].type === "data" && (($ = q), q++)
          : (!V[q] || V[q][1].type !== "data") &&
            (q !== $ + 2 &&
              ((V[$][1].end = V[q - 1][1].end),
              V.splice($ + 2, q - $ - 2),
              (q = $ + 2)),
            ($ = void 0));
      return U ? U(V, B) : V;
    }
  }
  function resolveAllLineSuffixes(U, j) {
    let V = 0;
    for (; ++V <= U.length; )
      if (
        (V === U.length || U[V][1].type === "lineEnding") &&
        U[V - 1][1].type === "data"
      ) {
        const B = U[V - 1][1],
          q = j.sliceStream(B);
        let $ = q.length,
          H = -1,
          G = 0,
          Y;
        for (; $--; ) {
          const Q = q[$];
          if (typeof Q == "string") {
            for (H = Q.length; Q.charCodeAt(H - 1) === 32; ) G++, H--;
            if (H) break;
            H = -1;
          } else if (Q === -2) (Y = !0), G++;
          else if (Q !== -1) {
            $++;
            break;
          }
        }
        if ((j._contentTypeTextTrailing && V === U.length && (G = 0), G)) {
          const Q = {
            type:
              V === U.length || Y || G < 2 ? "lineSuffix" : "hardBreakTrailing",
            start: {
              _bufferIndex: $ ? H : B.start._bufferIndex + H,
              _index: B.start._index + $,
              line: B.end.line,
              column: B.end.column - G,
              offset: B.end.offset - G,
            },
            end: { ...B.end },
          };
          (B.end = { ...Q.start }),
            B.start.offset === B.end.offset
              ? Object.assign(B, Q)
              : (U.splice(V, 0, ["enter", Q, j], ["exit", Q, j]), (V += 2));
        }
        V++;
      }
    return U;
  }
  const document$1 = {
      42: list$1,
      43: list$1,
      45: list$1,
      48: list$1,
      49: list$1,
      50: list$1,
      51: list$1,
      52: list$1,
      53: list$1,
      54: list$1,
      55: list$1,
      56: list$1,
      57: list$1,
      62: blockQuote,
    },
    contentInitial = { 91: definition },
    flowInitial = { [-2]: codeIndented, [-1]: codeIndented, 32: codeIndented },
    flow = {
      35: headingAtx,
      42: thematicBreak$1,
      45: [setextUnderline, thematicBreak$1],
      60: htmlFlow,
      61: setextUnderline,
      95: thematicBreak$1,
      96: codeFenced,
      126: codeFenced,
    },
    string = { 38: characterReference, 92: characterEscape },
    text$1 = {
      [-5]: lineEnding,
      [-4]: lineEnding,
      [-3]: lineEnding,
      33: labelStartImage,
      38: characterReference,
      42: attention,
      60: [autolink, htmlText],
      91: labelStartLink,
      92: [hardBreakEscape, characterEscape],
      93: labelEnd,
      95: attention,
      96: codeText,
    },
    insideSpan = { null: [attention, resolver] },
    attentionMarkers = { null: [42, 95] },
    disable = { null: [] },
    defaultConstructs = Object.freeze(
      Object.defineProperty(
        {
          __proto__: null,
          attentionMarkers,
          contentInitial,
          disable,
          document: document$1,
          flow,
          flowInitial,
          insideSpan,
          string,
          text: text$1,
        },
        Symbol.toStringTag,
        { value: "Module" }
      )
    );
  function createTokenizer(U, j, V) {
    let B = {
      _bufferIndex: -1,
      _index: 0,
      line: (V && V.line) || 1,
      column: (V && V.column) || 1,
      offset: (V && V.offset) || 0,
    };
    const q = {},
      $ = [];
    let H = [],
      G = [];
    const Y = {
        attempt: Ee(ve),
        check: Ee(ge),
        consume: ue,
        enter: he,
        exit: me,
        interrupt: Ee(ge, { interrupt: !0 }),
      },
      Q = {
        code: null,
        containerState: {},
        defineSkip: se,
        events: [],
        now: ae,
        parser: U,
        previous: null,
        sliceSerialize: te,
        sliceStream: ne,
        write: Z,
      };
    let X = j.tokenize.call(Q, Y);
    return j.resolveAll && $.push(j), Q;
    function Z(be) {
      return (
        (H = push(H, be)),
        fe(),
        H[H.length - 1] !== null
          ? []
          : (Ce(j, 0), (Q.events = resolveAll($, Q.events, Q)), Q.events)
      );
    }
    function te(be, Le) {
      return serializeChunks(ne(be), Le);
    }
    function ne(be) {
      return sliceChunks(H, be);
    }
    function ae() {
      const {
        _bufferIndex: be,
        _index: Le,
        line: Fe,
        column: Me,
        offset: je,
      } = B;
      return { _bufferIndex: be, _index: Le, line: Fe, column: Me, offset: je };
    }
    function se(be) {
      (q[be.line] = be.column), Ae();
    }
    function fe() {
      let be;
      for (; B._index < H.length; ) {
        const Le = H[B._index];
        if (typeof Le == "string")
          for (
            be = B._index, B._bufferIndex < 0 && (B._bufferIndex = 0);
            B._index === be && B._bufferIndex < Le.length;

          )
            ce(Le.charCodeAt(B._bufferIndex));
        else ce(Le);
      }
    }
    function ce(be) {
      X = X(be);
    }
    function ue(be) {
      markdownLineEnding(be)
        ? (B.line++, (B.column = 1), (B.offset += be === -3 ? 2 : 1), Ae())
        : be !== -1 && (B.column++, B.offset++),
        B._bufferIndex < 0
          ? B._index++
          : (B._bufferIndex++,
            B._bufferIndex === H[B._index].length &&
              ((B._bufferIndex = -1), B._index++)),
        (Q.previous = be);
    }
    function he(be, Le) {
      const Fe = Le || {};
      return (
        (Fe.type = be),
        (Fe.start = ae()),
        Q.events.push(["enter", Fe, Q]),
        G.push(Fe),
        Fe
      );
    }
    function me(be) {
      const Le = G.pop();
      return (Le.end = ae()), Q.events.push(["exit", Le, Q]), Le;
    }
    function ve(be, Le) {
      Ce(be, Le.from);
    }
    function ge(be, Le) {
      Le.restore();
    }
    function Ee(be, Le) {
      return Fe;
      function Fe(Me, je, Te) {
        let xe, He, Je, oe;
        return Array.isArray(Me)
          ? Ge(Me)
          : "tokenize" in Me
          ? Ge([Me])
          : De(Me);
        function De(Ie) {
          return pt;
          function pt(ct) {
            const We = ct !== null && Ie[ct],
              tt = ct !== null && Ie.null,
              gt = [
                ...(Array.isArray(We) ? We : We ? [We] : []),
                ...(Array.isArray(tt) ? tt : tt ? [tt] : []),
              ];
            return Ge(gt)(ct);
          }
        }
        function Ge(Ie) {
          return (xe = Ie), (He = 0), Ie.length === 0 ? Te : pe(Ie[He]);
        }
        function pe(Ie) {
          return pt;
          function pt(ct) {
            return (
              (oe = Re()),
              (Je = Ie),
              Ie.partial || (Q.currentConstruct = Ie),
              Ie.name && Q.parser.constructs.disable.null.includes(Ie.name)
                ? Qe()
                : Ie.tokenize.call(
                    Le ? Object.assign(Object.create(Q), Le) : Q,
                    Y,
                    Ye,
                    Qe
                  )(ct)
            );
          }
        }
        function Ye(Ie) {
          return be(Je, oe), je;
        }
        function Qe(Ie) {
          return oe.restore(), ++He < xe.length ? pe(xe[He]) : Te;
        }
      }
    }
    function Ce(be, Le) {
      be.resolveAll && !$.includes(be) && $.push(be),
        be.resolve &&
          splice(
            Q.events,
            Le,
            Q.events.length - Le,
            be.resolve(Q.events.slice(Le), Q)
          ),
        be.resolveTo && (Q.events = be.resolveTo(Q.events, Q));
    }
    function Re() {
      const be = ae(),
        Le = Q.previous,
        Fe = Q.currentConstruct,
        Me = Q.events.length,
        je = Array.from(G);
      return { from: Me, restore: Te };
      function Te() {
        (B = be),
          (Q.previous = Le),
          (Q.currentConstruct = Fe),
          (Q.events.length = Me),
          (G = je),
          Ae();
      }
    }
    function Ae() {
      B.line in q &&
        B.column < 2 &&
        ((B.column = q[B.line]), (B.offset += q[B.line] - 1));
    }
  }
  function sliceChunks(U, j) {
    const V = j.start._index,
      B = j.start._bufferIndex,
      q = j.end._index,
      $ = j.end._bufferIndex;
    let H;
    if (V === q) H = [U[V].slice(B, $)];
    else {
      if (((H = U.slice(V, q)), B > -1)) {
        const G = H[0];
        typeof G == "string" ? (H[0] = G.slice(B)) : H.shift();
      }
      $ > 0 && H.push(U[q].slice(0, $));
    }
    return H;
  }
  function serializeChunks(U, j) {
    let V = -1;
    const B = [];
    let q;
    for (; ++V < U.length; ) {
      const $ = U[V];
      let H;
      if (typeof $ == "string") H = $;
      else
        switch ($) {
          case -5: {
            H = "\r";
            break;
          }
          case -4: {
            H = `
`;
            break;
          }
          case -3: {
            H = `\r
`;
            break;
          }
          case -2: {
            H = j ? " " : "	";
            break;
          }
          case -1: {
            if (!j && q) continue;
            H = " ";
            break;
          }
          default:
            H = String.fromCharCode($);
        }
      (q = $ === -2), B.push(H);
    }
    return B.join("");
  }
  function parse(U) {
    const B = {
      constructs: combineExtensions([
        defaultConstructs,
        ...((U || {}).extensions || []),
      ]),
      content: q(content$1),
      defined: [],
      document: q(document$2),
      flow: q(flow$1),
      lazy: {},
      string: q(string$1),
      text: q(text$2),
    };
    return B;
    function q($) {
      return H;
      function H(G) {
        return createTokenizer(B, $, G);
      }
    }
  }
  function postprocess(U) {
    for (; !subtokenize(U); );
    return U;
  }
  const search = /[\0\t\n\r]/g;
  function preprocess() {
    let U = 1,
      j = "",
      V = !0,
      B;
    return q;
    function q($, H, G) {
      const Y = [];
      let Q, X, Z, te, ne;
      for (
        $ =
          j +
          (typeof $ == "string"
            ? $.toString()
            : new TextDecoder(H || void 0).decode($)),
          Z = 0,
          j = "",
          V && ($.charCodeAt(0) === 65279 && Z++, (V = void 0));
        Z < $.length;

      ) {
        if (
          ((search.lastIndex = Z),
          (Q = search.exec($)),
          (te = Q && Q.index !== void 0 ? Q.index : $.length),
          (ne = $.charCodeAt(te)),
          !Q)
        ) {
          j = $.slice(Z);
          break;
        }
        if (ne === 10 && Z === te && B) Y.push(-3), (B = void 0);
        else
          switch (
            (B && (Y.push(-5), (B = void 0)),
            Z < te && (Y.push($.slice(Z, te)), (U += te - Z)),
            ne)
          ) {
            case 0: {
              Y.push(65533), U++;
              break;
            }
            case 9: {
              for (X = Math.ceil(U / 4) * 4, Y.push(-2); U++ < X; ) Y.push(-1);
              break;
            }
            case 10: {
              Y.push(-4), (U = 1);
              break;
            }
            default:
              (B = !0), (U = 1);
          }
        Z = te + 1;
      }
      return G && (B && Y.push(-5), j && Y.push(j), Y.push(null)), Y;
    }
  }
  const characterEscapeOrReference =
    /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
  function decodeString(U) {
    return U.replace(characterEscapeOrReference, decode);
  }
  function decode(U, j, V) {
    if (j) return j;
    if (V.charCodeAt(0) === 35) {
      const q = V.charCodeAt(1),
        $ = q === 120 || q === 88;
      return decodeNumericCharacterReference(V.slice($ ? 2 : 1), $ ? 16 : 10);
    }
    return decodeNamedCharacterReference(V) || U;
  }
  const own$2 = {}.hasOwnProperty;
  function fromMarkdown(U, j, V) {
    return (
      typeof j != "string" && ((V = j), (j = void 0)),
      compiler(V)(
        postprocess(parse(V).document().write(preprocess()(U, j, !0)))
      )
    );
  }
  function compiler(U) {
    const j = {
      transforms: [],
      canContainEols: [
        "emphasis",
        "fragment",
        "heading",
        "paragraph",
        "strong",
      ],
      enter: {
        autolink: $(qt),
        autolinkProtocol: Re,
        autolinkEmail: Re,
        atxHeading: $(Bi),
        blockQuote: $(tt),
        characterEscape: Re,
        characterReference: Re,
        codeFenced: $(gt),
        codeFencedFenceInfo: H,
        codeFencedFenceMeta: H,
        codeIndented: $(gt, H),
        codeText: $(Jt, H),
        codeTextData: Re,
        data: Re,
        codeFlowValue: Re,
        definition: $(nn),
        definitionDestinationString: H,
        definitionLabelString: H,
        definitionTitleString: H,
        emphasis: $(gn),
        hardBreakEscape: $(Wn),
        hardBreakTrailing: $(Wn),
        htmlFlow: $(At, H),
        htmlFlowData: Re,
        htmlText: $(At, H),
        htmlTextData: Re,
        image: $(Fi),
        label: H,
        link: $(qt),
        listItem: $(Xn),
        listItemValue: te,
        listOrdered: $(Ti, Z),
        listUnordered: $(Ti),
        paragraph: $(Ar),
        reference: pe,
        referenceString: H,
        resourceDestinationString: H,
        resourceTitleString: H,
        setextHeading: $(Bi),
        strong: $(ki),
        thematicBreak: $(Zt),
      },
      exit: {
        atxHeading: Y(),
        atxHeadingSequence: ve,
        autolink: Y(),
        autolinkEmail: We,
        autolinkProtocol: ct,
        blockQuote: Y(),
        characterEscapeValue: Ae,
        characterReferenceMarkerHexadecimal: Qe,
        characterReferenceMarkerNumeric: Qe,
        characterReferenceValue: Ie,
        characterReference: pt,
        codeFenced: Y(fe),
        codeFencedFence: se,
        codeFencedFenceInfo: ne,
        codeFencedFenceMeta: ae,
        codeFlowValue: Ae,
        codeIndented: Y(ce),
        codeText: Y(je),
        codeTextData: Ae,
        data: Ae,
        definition: Y(),
        definitionDestinationString: me,
        definitionLabelString: ue,
        definitionTitleString: he,
        emphasis: Y(),
        hardBreakEscape: Y(Le),
        hardBreakTrailing: Y(Le),
        htmlFlow: Y(Fe),
        htmlFlowData: Ae,
        htmlText: Y(Me),
        htmlTextData: Ae,
        image: Y(xe),
        label: Je,
        labelText: He,
        lineEnding: be,
        link: Y(Te),
        listItem: Y(),
        listOrdered: Y(),
        listUnordered: Y(),
        paragraph: Y(),
        referenceString: Ye,
        resourceDestinationString: oe,
        resourceTitleString: De,
        resource: Ge,
        setextHeading: Y(Ce),
        setextHeadingLineSequence: Ee,
        setextHeadingText: ge,
        strong: Y(),
        thematicBreak: Y(),
      },
    };
    configure(j, (U || {}).mdastExtensions || []);
    const V = {};
    return B;
    function B(Ne) {
      let Ke = { type: "root", children: [] };
      const it = {
          stack: [Ke],
          tokenStack: [],
          config: j,
          enter: G,
          exit: Q,
          buffer: H,
          resume: X,
          data: V,
        },
        rt = [];
      let bt = -1;
      for (; ++bt < Ne.length; )
        if (
          Ne[bt][1].type === "listOrdered" ||
          Ne[bt][1].type === "listUnordered"
        )
          if (Ne[bt][0] === "enter") rt.push(bt);
          else {
            const en = rt.pop();
            bt = q(Ne, en, bt);
          }
      for (bt = -1; ++bt < Ne.length; ) {
        const en = j[Ne[bt][0]];
        own$2.call(en, Ne[bt][1].type) &&
          en[Ne[bt][1].type].call(
            Object.assign({ sliceSerialize: Ne[bt][2].sliceSerialize }, it),
            Ne[bt][1]
          );
      }
      if (it.tokenStack.length > 0) {
        const en = it.tokenStack[it.tokenStack.length - 1];
        (en[1] || defaultOnError).call(it, void 0, en[0]);
      }
      for (
        Ke.position = {
          start: point(
            Ne.length > 0 ? Ne[0][1].start : { line: 1, column: 1, offset: 0 }
          ),
          end: point(
            Ne.length > 0
              ? Ne[Ne.length - 2][1].end
              : { line: 1, column: 1, offset: 0 }
          ),
        },
          bt = -1;
        ++bt < j.transforms.length;

      )
        Ke = j.transforms[bt](Ke) || Ke;
      return Ke;
    }
    function q(Ne, Ke, it) {
      let rt = Ke - 1,
        bt = -1,
        en = !1,
        Rn,
        vt,
        Be,
        Ue;
      for (; ++rt <= it; ) {
        const qe = Ne[rt];
        switch (qe[1].type) {
          case "listUnordered":
          case "listOrdered":
          case "blockQuote": {
            qe[0] === "enter" ? bt++ : bt--, (Ue = void 0);
            break;
          }
          case "lineEndingBlank": {
            qe[0] === "enter" &&
              (Rn && !Ue && !bt && !Be && (Be = rt), (Ue = void 0));
            break;
          }
          case "linePrefix":
          case "listItemValue":
          case "listItemMarker":
          case "listItemPrefix":
          case "listItemPrefixWhitespace":
            break;
          default:
            Ue = void 0;
        }
        if (
          (!bt && qe[0] === "enter" && qe[1].type === "listItemPrefix") ||
          (bt === -1 &&
            qe[0] === "exit" &&
            (qe[1].type === "listUnordered" || qe[1].type === "listOrdered"))
        ) {
          if (Rn) {
            let Xe = rt;
            for (vt = void 0; Xe--; ) {
              const Ze = Ne[Xe];
              if (
                Ze[1].type === "lineEnding" ||
                Ze[1].type === "lineEndingBlank"
              ) {
                if (Ze[0] === "exit") continue;
                vt && ((Ne[vt][1].type = "lineEndingBlank"), (en = !0)),
                  (Ze[1].type = "lineEnding"),
                  (vt = Xe);
              } else if (
                !(
                  Ze[1].type === "linePrefix" ||
                  Ze[1].type === "blockQuotePrefix" ||
                  Ze[1].type === "blockQuotePrefixWhitespace" ||
                  Ze[1].type === "blockQuoteMarker" ||
                  Ze[1].type === "listItemIndent"
                )
              )
                break;
            }
            Be && (!vt || Be < vt) && (Rn._spread = !0),
              (Rn.end = Object.assign({}, vt ? Ne[vt][1].start : qe[1].end)),
              Ne.splice(vt || rt, 0, ["exit", Rn, qe[2]]),
              rt++,
              it++;
          }
          if (qe[1].type === "listItemPrefix") {
            const Xe = {
              type: "listItem",
              _spread: !1,
              start: Object.assign({}, qe[1].start),
              end: void 0,
            };
            (Rn = Xe),
              Ne.splice(rt, 0, ["enter", Xe, qe[2]]),
              rt++,
              it++,
              (Be = void 0),
              (Ue = !0);
          }
        }
      }
      return (Ne[Ke][1]._spread = en), it;
    }
    function $(Ne, Ke) {
      return it;
      function it(rt) {
        G.call(this, Ne(rt), rt), Ke && Ke.call(this, rt);
      }
    }
    function H() {
      this.stack.push({ type: "fragment", children: [] });
    }
    function G(Ne, Ke, it) {
      this.stack[this.stack.length - 1].children.push(Ne),
        this.stack.push(Ne),
        this.tokenStack.push([Ke, it || void 0]),
        (Ne.position = { start: point(Ke.start), end: void 0 });
    }
    function Y(Ne) {
      return Ke;
      function Ke(it) {
        Ne && Ne.call(this, it), Q.call(this, it);
      }
    }
    function Q(Ne, Ke) {
      const it = this.stack.pop(),
        rt = this.tokenStack.pop();
      if (rt)
        rt[0].type !== Ne.type &&
          (Ke
            ? Ke.call(this, Ne, rt[0])
            : (rt[1] || defaultOnError).call(this, Ne, rt[0]));
      else
        throw new Error(
          "Cannot close `" +
            Ne.type +
            "` (" +
            stringifyPosition({ start: Ne.start, end: Ne.end }) +
            "): it’s not open"
        );
      it.position.end = point(Ne.end);
    }
    function X() {
      return toString$1(this.stack.pop());
    }
    function Z() {
      this.data.expectingFirstListItemValue = !0;
    }
    function te(Ne) {
      if (this.data.expectingFirstListItemValue) {
        const Ke = this.stack[this.stack.length - 2];
        (Ke.start = Number.parseInt(this.sliceSerialize(Ne), 10)),
          (this.data.expectingFirstListItemValue = void 0);
      }
    }
    function ne() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.lang = Ne;
    }
    function ae() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.meta = Ne;
    }
    function se() {
      this.data.flowCodeInside ||
        (this.buffer(), (this.data.flowCodeInside = !0));
    }
    function fe() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      (Ke.value = Ne.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")),
        (this.data.flowCodeInside = void 0);
    }
    function ce() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.value = Ne.replace(/(\r?\n|\r)$/g, "");
    }
    function ue(Ne) {
      const Ke = this.resume(),
        it = this.stack[this.stack.length - 1];
      (it.label = Ke),
        (it.identifier = normalizeIdentifier(
          this.sliceSerialize(Ne)
        ).toLowerCase());
    }
    function he() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.title = Ne;
    }
    function me() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.url = Ne;
    }
    function ve(Ne) {
      const Ke = this.stack[this.stack.length - 1];
      if (!Ke.depth) {
        const it = this.sliceSerialize(Ne).length;
        Ke.depth = it;
      }
    }
    function ge() {
      this.data.setextHeadingSlurpLineEnding = !0;
    }
    function Ee(Ne) {
      const Ke = this.stack[this.stack.length - 1];
      Ke.depth = this.sliceSerialize(Ne).codePointAt(0) === 61 ? 1 : 2;
    }
    function Ce() {
      this.data.setextHeadingSlurpLineEnding = void 0;
    }
    function Re(Ne) {
      const it = this.stack[this.stack.length - 1].children;
      let rt = it[it.length - 1];
      (!rt || rt.type !== "text") &&
        ((rt = Pr()),
        (rt.position = { start: point(Ne.start), end: void 0 }),
        it.push(rt)),
        this.stack.push(rt);
    }
    function Ae(Ne) {
      const Ke = this.stack.pop();
      (Ke.value += this.sliceSerialize(Ne)), (Ke.position.end = point(Ne.end));
    }
    function be(Ne) {
      const Ke = this.stack[this.stack.length - 1];
      if (this.data.atHardBreak) {
        const it = Ke.children[Ke.children.length - 1];
        (it.position.end = point(Ne.end)), (this.data.atHardBreak = void 0);
        return;
      }
      !this.data.setextHeadingSlurpLineEnding &&
        j.canContainEols.includes(Ke.type) &&
        (Re.call(this, Ne), Ae.call(this, Ne));
    }
    function Le() {
      this.data.atHardBreak = !0;
    }
    function Fe() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.value = Ne;
    }
    function Me() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.value = Ne;
    }
    function je() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.value = Ne;
    }
    function Te() {
      const Ne = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const Ke = this.data.referenceType || "shortcut";
        (Ne.type += "Reference"),
          (Ne.referenceType = Ke),
          delete Ne.url,
          delete Ne.title;
      } else delete Ne.identifier, delete Ne.label;
      this.data.referenceType = void 0;
    }
    function xe() {
      const Ne = this.stack[this.stack.length - 1];
      if (this.data.inReference) {
        const Ke = this.data.referenceType || "shortcut";
        (Ne.type += "Reference"),
          (Ne.referenceType = Ke),
          delete Ne.url,
          delete Ne.title;
      } else delete Ne.identifier, delete Ne.label;
      this.data.referenceType = void 0;
    }
    function He(Ne) {
      const Ke = this.sliceSerialize(Ne),
        it = this.stack[this.stack.length - 2];
      (it.label = decodeString(Ke)),
        (it.identifier = normalizeIdentifier(Ke).toLowerCase());
    }
    function Je() {
      const Ne = this.stack[this.stack.length - 1],
        Ke = this.resume(),
        it = this.stack[this.stack.length - 1];
      if (((this.data.inReference = !0), it.type === "link")) {
        const rt = Ne.children;
        it.children = rt;
      } else it.alt = Ke;
    }
    function oe() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.url = Ne;
    }
    function De() {
      const Ne = this.resume(),
        Ke = this.stack[this.stack.length - 1];
      Ke.title = Ne;
    }
    function Ge() {
      this.data.inReference = void 0;
    }
    function pe() {
      this.data.referenceType = "collapsed";
    }
    function Ye(Ne) {
      const Ke = this.resume(),
        it = this.stack[this.stack.length - 1];
      (it.label = Ke),
        (it.identifier = normalizeIdentifier(
          this.sliceSerialize(Ne)
        ).toLowerCase()),
        (this.data.referenceType = "full");
    }
    function Qe(Ne) {
      this.data.characterReferenceType = Ne.type;
    }
    function Ie(Ne) {
      const Ke = this.sliceSerialize(Ne),
        it = this.data.characterReferenceType;
      let rt;
      it
        ? ((rt = decodeNumericCharacterReference(
            Ke,
            it === "characterReferenceMarkerNumeric" ? 10 : 16
          )),
          (this.data.characterReferenceType = void 0))
        : (rt = decodeNamedCharacterReference(Ke));
      const bt = this.stack[this.stack.length - 1];
      bt.value += rt;
    }
    function pt(Ne) {
      const Ke = this.stack.pop();
      Ke.position.end = point(Ne.end);
    }
    function ct(Ne) {
      Ae.call(this, Ne);
      const Ke = this.stack[this.stack.length - 1];
      Ke.url = this.sliceSerialize(Ne);
    }
    function We(Ne) {
      Ae.call(this, Ne);
      const Ke = this.stack[this.stack.length - 1];
      Ke.url = "mailto:" + this.sliceSerialize(Ne);
    }
    function tt() {
      return { type: "blockquote", children: [] };
    }
    function gt() {
      return { type: "code", lang: null, meta: null, value: "" };
    }
    function Jt() {
      return { type: "inlineCode", value: "" };
    }
    function nn() {
      return {
        type: "definition",
        identifier: "",
        label: null,
        title: null,
        url: "",
      };
    }
    function gn() {
      return { type: "emphasis", children: [] };
    }
    function Bi() {
      return { type: "heading", depth: 0, children: [] };
    }
    function Wn() {
      return { type: "break" };
    }
    function At() {
      return { type: "html", value: "" };
    }
    function Fi() {
      return { type: "image", title: null, url: "", alt: null };
    }
    function qt() {
      return { type: "link", title: null, url: "", children: [] };
    }
    function Ti(Ne) {
      return {
        type: "list",
        ordered: Ne.type === "listOrdered",
        start: null,
        spread: Ne._spread,
        children: [],
      };
    }
    function Xn(Ne) {
      return {
        type: "listItem",
        spread: Ne._spread,
        checked: null,
        children: [],
      };
    }
    function Ar() {
      return { type: "paragraph", children: [] };
    }
    function ki() {
      return { type: "strong", children: [] };
    }
    function Pr() {
      return { type: "text", value: "" };
    }
    function Zt() {
      return { type: "thematicBreak" };
    }
  }
  function point(U) {
    return { line: U.line, column: U.column, offset: U.offset };
  }
  function configure(U, j) {
    let V = -1;
    for (; ++V < j.length; ) {
      const B = j[V];
      Array.isArray(B) ? configure(U, B) : extension(U, B);
    }
  }
  function extension(U, j) {
    let V;
    for (V in j)
      if (own$2.call(j, V))
        switch (V) {
          case "canContainEols": {
            const B = j[V];
            B && U[V].push(...B);
            break;
          }
          case "transforms": {
            const B = j[V];
            B && U[V].push(...B);
            break;
          }
          case "enter":
          case "exit": {
            const B = j[V];
            B && Object.assign(U[V], B);
            break;
          }
        }
  }
  function defaultOnError(U, j) {
    throw U
      ? new Error(
          "Cannot close `" +
            U.type +
            "` (" +
            stringifyPosition({ start: U.start, end: U.end }) +
            "): a different token (`" +
            j.type +
            "`, " +
            stringifyPosition({ start: j.start, end: j.end }) +
            ") is open"
        )
      : new Error(
          "Cannot close document, a token (`" +
            j.type +
            "`, " +
            stringifyPosition({ start: j.start, end: j.end }) +
            ") is still open"
        );
  }
  function remarkParse(U) {
    const j = this;
    j.parser = V;
    function V(B) {
      return fromMarkdown(B, {
        ...j.data("settings"),
        ...U,
        extensions: j.data("micromarkExtensions") || [],
        mdastExtensions: j.data("fromMarkdownExtensions") || [],
      });
    }
  }
  function blockquote(U, j) {
    const V = {
      type: "element",
      tagName: "blockquote",
      properties: {},
      children: U.wrap(U.all(j), !0),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function hardBreak(U, j) {
    const V = { type: "element", tagName: "br", properties: {}, children: [] };
    return (
      U.patch(j, V),
      [
        U.applyData(j, V),
        {
          type: "text",
          value: `
`,
        },
      ]
    );
  }
  function code(U, j) {
    const V = j.value
        ? j.value +
          `
`
        : "",
      B = {};
    j.lang && (B.className = ["language-" + j.lang]);
    let q = {
      type: "element",
      tagName: "code",
      properties: B,
      children: [{ type: "text", value: V }],
    };
    return (
      j.meta && (q.data = { meta: j.meta }),
      U.patch(j, q),
      (q = U.applyData(j, q)),
      (q = { type: "element", tagName: "pre", properties: {}, children: [q] }),
      U.patch(j, q),
      q
    );
  }
  function strikethrough(U, j) {
    const V = {
      type: "element",
      tagName: "del",
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function emphasis(U, j) {
    const V = {
      type: "element",
      tagName: "em",
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function footnoteReference(U, j) {
    const V =
        typeof U.options.clobberPrefix == "string"
          ? U.options.clobberPrefix
          : "user-content-",
      B = String(j.identifier).toUpperCase(),
      q = normalizeUri(B.toLowerCase()),
      $ = U.footnoteOrder.indexOf(B);
    let H,
      G = U.footnoteCounts.get(B);
    G === void 0
      ? ((G = 0), U.footnoteOrder.push(B), (H = U.footnoteOrder.length))
      : (H = $ + 1),
      (G += 1),
      U.footnoteCounts.set(B, G);
    const Y = {
      type: "element",
      tagName: "a",
      properties: {
        href: "#" + V + "fn-" + q,
        id: V + "fnref-" + q + (G > 1 ? "-" + G : ""),
        dataFootnoteRef: !0,
        ariaDescribedBy: ["footnote-label"],
      },
      children: [{ type: "text", value: String(H) }],
    };
    U.patch(j, Y);
    const Q = {
      type: "element",
      tagName: "sup",
      properties: {},
      children: [Y],
    };
    return U.patch(j, Q), U.applyData(j, Q);
  }
  function heading(U, j) {
    const V = {
      type: "element",
      tagName: "h" + j.depth,
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function html(U, j) {
    if (U.options.allowDangerousHtml) {
      const V = { type: "raw", value: j.value };
      return U.patch(j, V), U.applyData(j, V);
    }
  }
  function revert(U, j) {
    const V = j.referenceType;
    let B = "]";
    if (
      (V === "collapsed"
        ? (B += "[]")
        : V === "full" && (B += "[" + (j.label || j.identifier) + "]"),
      j.type === "imageReference")
    )
      return [{ type: "text", value: "![" + j.alt + B }];
    const q = U.all(j),
      $ = q[0];
    $ && $.type === "text"
      ? ($.value = "[" + $.value)
      : q.unshift({ type: "text", value: "[" });
    const H = q[q.length - 1];
    return (
      H && H.type === "text"
        ? (H.value += B)
        : q.push({ type: "text", value: B }),
      q
    );
  }
  function imageReference(U, j) {
    const V = String(j.identifier).toUpperCase(),
      B = U.definitionById.get(V);
    if (!B) return revert(U, j);
    const q = { src: normalizeUri(B.url || ""), alt: j.alt };
    B.title !== null && B.title !== void 0 && (q.title = B.title);
    const $ = { type: "element", tagName: "img", properties: q, children: [] };
    return U.patch(j, $), U.applyData(j, $);
  }
  function image(U, j) {
    const V = { src: normalizeUri(j.url) };
    j.alt !== null && j.alt !== void 0 && (V.alt = j.alt),
      j.title !== null && j.title !== void 0 && (V.title = j.title);
    const B = { type: "element", tagName: "img", properties: V, children: [] };
    return U.patch(j, B), U.applyData(j, B);
  }
  function inlineCode(U, j) {
    const V = { type: "text", value: j.value.replace(/\r?\n|\r/g, " ") };
    U.patch(j, V);
    const B = {
      type: "element",
      tagName: "code",
      properties: {},
      children: [V],
    };
    return U.patch(j, B), U.applyData(j, B);
  }
  function linkReference(U, j) {
    const V = String(j.identifier).toUpperCase(),
      B = U.definitionById.get(V);
    if (!B) return revert(U, j);
    const q = { href: normalizeUri(B.url || "") };
    B.title !== null && B.title !== void 0 && (q.title = B.title);
    const $ = {
      type: "element",
      tagName: "a",
      properties: q,
      children: U.all(j),
    };
    return U.patch(j, $), U.applyData(j, $);
  }
  function link(U, j) {
    const V = { href: normalizeUri(j.url) };
    j.title !== null && j.title !== void 0 && (V.title = j.title);
    const B = {
      type: "element",
      tagName: "a",
      properties: V,
      children: U.all(j),
    };
    return U.patch(j, B), U.applyData(j, B);
  }
  function listItem(U, j, V) {
    const B = U.all(j),
      q = V ? listLoose(V) : listItemLoose(j),
      $ = {},
      H = [];
    if (typeof j.checked == "boolean") {
      const X = B[0];
      let Z;
      X && X.type === "element" && X.tagName === "p"
        ? (Z = X)
        : ((Z = {
            type: "element",
            tagName: "p",
            properties: {},
            children: [],
          }),
          B.unshift(Z)),
        Z.children.length > 0 &&
          Z.children.unshift({ type: "text", value: " " }),
        Z.children.unshift({
          type: "element",
          tagName: "input",
          properties: { type: "checkbox", checked: j.checked, disabled: !0 },
          children: [],
        }),
        ($.className = ["task-list-item"]);
    }
    let G = -1;
    for (; ++G < B.length; ) {
      const X = B[G];
      (q || G !== 0 || X.type !== "element" || X.tagName !== "p") &&
        H.push({
          type: "text",
          value: `
`,
        }),
        X.type === "element" && X.tagName === "p" && !q
          ? H.push(...X.children)
          : H.push(X);
    }
    const Y = B[B.length - 1];
    Y &&
      (q || Y.type !== "element" || Y.tagName !== "p") &&
      H.push({
        type: "text",
        value: `
`,
      });
    const Q = { type: "element", tagName: "li", properties: $, children: H };
    return U.patch(j, Q), U.applyData(j, Q);
  }
  function listLoose(U) {
    let j = !1;
    if (U.type === "list") {
      j = U.spread || !1;
      const V = U.children;
      let B = -1;
      for (; !j && ++B < V.length; ) j = listItemLoose(V[B]);
    }
    return j;
  }
  function listItemLoose(U) {
    const j = U.spread;
    return j ?? U.children.length > 1;
  }
  function list(U, j) {
    const V = {},
      B = U.all(j);
    let q = -1;
    for (
      typeof j.start == "number" && j.start !== 1 && (V.start = j.start);
      ++q < B.length;

    ) {
      const H = B[q];
      if (
        H.type === "element" &&
        H.tagName === "li" &&
        H.properties &&
        Array.isArray(H.properties.className) &&
        H.properties.className.includes("task-list-item")
      ) {
        V.className = ["contains-task-list"];
        break;
      }
    }
    const $ = {
      type: "element",
      tagName: j.ordered ? "ol" : "ul",
      properties: V,
      children: U.wrap(B, !0),
    };
    return U.patch(j, $), U.applyData(j, $);
  }
  function paragraph(U, j) {
    const V = {
      type: "element",
      tagName: "p",
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function root(U, j) {
    const V = { type: "root", children: U.wrap(U.all(j)) };
    return U.patch(j, V), U.applyData(j, V);
  }
  function strong(U, j) {
    const V = {
      type: "element",
      tagName: "strong",
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  function table(U, j) {
    const V = U.all(j),
      B = V.shift(),
      q = [];
    if (B) {
      const H = {
        type: "element",
        tagName: "thead",
        properties: {},
        children: U.wrap([B], !0),
      };
      U.patch(j.children[0], H), q.push(H);
    }
    if (V.length > 0) {
      const H = {
          type: "element",
          tagName: "tbody",
          properties: {},
          children: U.wrap(V, !0),
        },
        G = pointStart(j.children[1]),
        Y = pointEnd(j.children[j.children.length - 1]);
      G && Y && (H.position = { start: G, end: Y }), q.push(H);
    }
    const $ = {
      type: "element",
      tagName: "table",
      properties: {},
      children: U.wrap(q, !0),
    };
    return U.patch(j, $), U.applyData(j, $);
  }
  function tableRow(U, j, V) {
    const B = V ? V.children : void 0,
      $ = (B ? B.indexOf(j) : 1) === 0 ? "th" : "td",
      H = V && V.type === "table" ? V.align : void 0,
      G = H ? H.length : j.children.length;
    let Y = -1;
    const Q = [];
    for (; ++Y < G; ) {
      const Z = j.children[Y],
        te = {},
        ne = H ? H[Y] : void 0;
      ne && (te.align = ne);
      let ae = { type: "element", tagName: $, properties: te, children: [] };
      Z &&
        ((ae.children = U.all(Z)), U.patch(Z, ae), (ae = U.applyData(Z, ae))),
        Q.push(ae);
    }
    const X = {
      type: "element",
      tagName: "tr",
      properties: {},
      children: U.wrap(Q, !0),
    };
    return U.patch(j, X), U.applyData(j, X);
  }
  function tableCell(U, j) {
    const V = {
      type: "element",
      tagName: "td",
      properties: {},
      children: U.all(j),
    };
    return U.patch(j, V), U.applyData(j, V);
  }
  const tab = 9,
    space = 32;
  function trimLines(U) {
    const j = String(U),
      V = /\r?\n|\r/g;
    let B = V.exec(j),
      q = 0;
    const $ = [];
    for (; B; )
      $.push(trimLine(j.slice(q, B.index), q > 0, !0), B[0]),
        (q = B.index + B[0].length),
        (B = V.exec(j));
    return $.push(trimLine(j.slice(q), q > 0, !1)), $.join("");
  }
  function trimLine(U, j, V) {
    let B = 0,
      q = U.length;
    if (j) {
      let $ = U.codePointAt(B);
      for (; $ === tab || $ === space; ) B++, ($ = U.codePointAt(B));
    }
    if (V) {
      let $ = U.codePointAt(q - 1);
      for (; $ === tab || $ === space; ) q--, ($ = U.codePointAt(q - 1));
    }
    return q > B ? U.slice(B, q) : "";
  }
  function text(U, j) {
    const V = { type: "text", value: trimLines(String(j.value)) };
    return U.patch(j, V), U.applyData(j, V);
  }
  function thematicBreak(U, j) {
    const V = { type: "element", tagName: "hr", properties: {}, children: [] };
    return U.patch(j, V), U.applyData(j, V);
  }
  const handlers = {
    blockquote,
    break: hardBreak,
    code,
    delete: strikethrough,
    emphasis,
    footnoteReference,
    heading,
    html,
    imageReference,
    image,
    inlineCode,
    linkReference,
    link,
    listItem,
    list,
    paragraph,
    root,
    strong,
    table,
    tableCell,
    tableRow,
    text,
    thematicBreak,
    toml: ignore,
    yaml: ignore,
    definition: ignore,
    footnoteDefinition: ignore,
  };
  function ignore() {}
  const VOID = -1,
    PRIMITIVE = 0,
    ARRAY = 1,
    OBJECT = 2,
    DATE = 3,
    REGEXP = 4,
    MAP = 5,
    SET = 6,
    ERROR = 7,
    BIGINT = 8,
    env = typeof self == "object" ? self : globalThis,
    deserializer = (U, j) => {
      const V = (q, $) => (U.set($, q), q),
        B = (q) => {
          if (U.has(q)) return U.get(q);
          const [$, H] = j[q];
          switch ($) {
            case PRIMITIVE:
            case VOID:
              return V(H, q);
            case ARRAY: {
              const G = V([], q);
              for (const Y of H) G.push(B(Y));
              return G;
            }
            case OBJECT: {
              const G = V({}, q);
              for (const [Y, Q] of H) G[B(Y)] = B(Q);
              return G;
            }
            case DATE:
              return V(new Date(H), q);
            case REGEXP: {
              const { source: G, flags: Y } = H;
              return V(new RegExp(G, Y), q);
            }
            case MAP: {
              const G = V(new Map(), q);
              for (const [Y, Q] of H) G.set(B(Y), B(Q));
              return G;
            }
            case SET: {
              const G = V(new Set(), q);
              for (const Y of H) G.add(B(Y));
              return G;
            }
            case ERROR: {
              const { name: G, message: Y } = H;
              return V(new env[G](Y), q);
            }
            case BIGINT:
              return V(BigInt(H), q);
            case "BigInt":
              return V(Object(BigInt(H)), q);
            case "ArrayBuffer":
              return V(new Uint8Array(H).buffer, H);
            case "DataView": {
              const { buffer: G } = new Uint8Array(H);
              return V(new DataView(G), H);
            }
          }
          return V(new env[$](H), q);
        };
      return B;
    },
    deserialize = (U) => deserializer(new Map(), U)(0),
    EMPTY = "",
    { toString } = {},
    { keys } = Object,
    typeOf = (U) => {
      const j = typeof U;
      if (j !== "object" || !U) return [PRIMITIVE, j];
      const V = toString.call(U).slice(8, -1);
      switch (V) {
        case "Array":
          return [ARRAY, EMPTY];
        case "Object":
          return [OBJECT, EMPTY];
        case "Date":
          return [DATE, EMPTY];
        case "RegExp":
          return [REGEXP, EMPTY];
        case "Map":
          return [MAP, EMPTY];
        case "Set":
          return [SET, EMPTY];
        case "DataView":
          return [ARRAY, V];
      }
      return V.includes("Array")
        ? [ARRAY, V]
        : V.includes("Error")
        ? [ERROR, V]
        : [OBJECT, V];
    },
    shouldSkip = ([U, j]) =>
      U === PRIMITIVE && (j === "function" || j === "symbol"),
    serializer = (U, j, V, B) => {
      const q = (H, G) => {
          const Y = B.push(H) - 1;
          return V.set(G, Y), Y;
        },
        $ = (H) => {
          if (V.has(H)) return V.get(H);
          let [G, Y] = typeOf(H);
          switch (G) {
            case PRIMITIVE: {
              let X = H;
              switch (Y) {
                case "bigint":
                  (G = BIGINT), (X = H.toString());
                  break;
                case "function":
                case "symbol":
                  if (U) throw new TypeError("unable to serialize " + Y);
                  X = null;
                  break;
                case "undefined":
                  return q([VOID], H);
              }
              return q([G, X], H);
            }
            case ARRAY: {
              if (Y) {
                let te = H;
                return (
                  Y === "DataView"
                    ? (te = new Uint8Array(H.buffer))
                    : Y === "ArrayBuffer" && (te = new Uint8Array(H)),
                  q([Y, [...te]], H)
                );
              }
              const X = [],
                Z = q([G, X], H);
              for (const te of H) X.push($(te));
              return Z;
            }
            case OBJECT: {
              if (Y)
                switch (Y) {
                  case "BigInt":
                    return q([Y, H.toString()], H);
                  case "Boolean":
                  case "Number":
                  case "String":
                    return q([Y, H.valueOf()], H);
                }
              if (j && "toJSON" in H) return $(H.toJSON());
              const X = [],
                Z = q([G, X], H);
              for (const te of keys(H))
                (U || !shouldSkip(typeOf(H[te]))) && X.push([$(te), $(H[te])]);
              return Z;
            }
            case DATE:
              return q([G, H.toISOString()], H);
            case REGEXP: {
              const { source: X, flags: Z } = H;
              return q([G, { source: X, flags: Z }], H);
            }
            case MAP: {
              const X = [],
                Z = q([G, X], H);
              for (const [te, ne] of H)
                (U || !(shouldSkip(typeOf(te)) || shouldSkip(typeOf(ne)))) &&
                  X.push([$(te), $(ne)]);
              return Z;
            }
            case SET: {
              const X = [],
                Z = q([G, X], H);
              for (const te of H)
                (U || !shouldSkip(typeOf(te))) && X.push($(te));
              return Z;
            }
          }
          const { message: Q } = H;
          return q([G, { name: Y, message: Q }], H);
        };
      return $;
    },
    serialize = (U, { json: j, lossy: V } = {}) => {
      const B = [];
      return serializer(!(j || V), !!j, new Map(), B)(U), B;
    },
    structuredClone$1 =
      typeof structuredClone == "function"
        ? (U, j) =>
            j && ("json" in j || "lossy" in j)
              ? deserialize(serialize(U, j))
              : structuredClone(U)
        : (U, j) => deserialize(serialize(U, j));
  function defaultFootnoteBackContent(U, j) {
    const V = [{ type: "text", value: "↩" }];
    return (
      j > 1 &&
        V.push({
          type: "element",
          tagName: "sup",
          properties: {},
          children: [{ type: "text", value: String(j) }],
        }),
      V
    );
  }
  function defaultFootnoteBackLabel(U, j) {
    return "Back to reference " + (U + 1) + (j > 1 ? "-" + j : "");
  }
  function footer(U) {
    const j =
        typeof U.options.clobberPrefix == "string"
          ? U.options.clobberPrefix
          : "user-content-",
      V = U.options.footnoteBackContent || defaultFootnoteBackContent,
      B = U.options.footnoteBackLabel || defaultFootnoteBackLabel,
      q = U.options.footnoteLabel || "Footnotes",
      $ = U.options.footnoteLabelTagName || "h2",
      H = U.options.footnoteLabelProperties || { className: ["sr-only"] },
      G = [];
    let Y = -1;
    for (; ++Y < U.footnoteOrder.length; ) {
      const Q = U.footnoteById.get(U.footnoteOrder[Y]);
      if (!Q) continue;
      const X = U.all(Q),
        Z = String(Q.identifier).toUpperCase(),
        te = normalizeUri(Z.toLowerCase());
      let ne = 0;
      const ae = [],
        se = U.footnoteCounts.get(Z);
      for (; se !== void 0 && ++ne <= se; ) {
        ae.length > 0 && ae.push({ type: "text", value: " " });
        let ue = typeof V == "string" ? V : V(Y, ne);
        typeof ue == "string" && (ue = { type: "text", value: ue }),
          ae.push({
            type: "element",
            tagName: "a",
            properties: {
              href: "#" + j + "fnref-" + te + (ne > 1 ? "-" + ne : ""),
              dataFootnoteBackref: "",
              ariaLabel: typeof B == "string" ? B : B(Y, ne),
              className: ["data-footnote-backref"],
            },
            children: Array.isArray(ue) ? ue : [ue],
          });
      }
      const fe = X[X.length - 1];
      if (fe && fe.type === "element" && fe.tagName === "p") {
        const ue = fe.children[fe.children.length - 1];
        ue && ue.type === "text"
          ? (ue.value += " ")
          : fe.children.push({ type: "text", value: " " }),
          fe.children.push(...ae);
      } else X.push(...ae);
      const ce = {
        type: "element",
        tagName: "li",
        properties: { id: j + "fn-" + te },
        children: U.wrap(X, !0),
      };
      U.patch(Q, ce), G.push(ce);
    }
    if (G.length !== 0)
      return {
        type: "element",
        tagName: "section",
        properties: { dataFootnotes: !0, className: ["footnotes"] },
        children: [
          {
            type: "element",
            tagName: $,
            properties: { ...structuredClone$1(H), id: "footnote-label" },
            children: [{ type: "text", value: q }],
          },
          {
            type: "text",
            value: `
`,
          },
          {
            type: "element",
            tagName: "ol",
            properties: {},
            children: U.wrap(G, !0),
          },
          {
            type: "text",
            value: `
`,
          },
        ],
      };
  }
  const convert = function (U) {
    if (U == null) return ok;
    if (typeof U == "function") return castFactory(U);
    if (typeof U == "object")
      return Array.isArray(U) ? anyFactory(U) : propsFactory(U);
    if (typeof U == "string") return typeFactory(U);
    throw new Error("Expected function, string, or object as test");
  };
  function anyFactory(U) {
    const j = [];
    let V = -1;
    for (; ++V < U.length; ) j[V] = convert(U[V]);
    return castFactory(B);
    function B(...q) {
      let $ = -1;
      for (; ++$ < j.length; ) if (j[$].apply(this, q)) return !0;
      return !1;
    }
  }
  function propsFactory(U) {
    const j = U;
    return castFactory(V);
    function V(B) {
      const q = B;
      let $;
      for ($ in U) if (q[$] !== j[$]) return !1;
      return !0;
    }
  }
  function typeFactory(U) {
    return castFactory(j);
    function j(V) {
      return V && V.type === U;
    }
  }
  function castFactory(U) {
    return j;
    function j(V, B, q) {
      return !!(
        looksLikeANode(V) &&
        U.call(this, V, typeof B == "number" ? B : void 0, q || void 0)
      );
    }
  }
  function ok() {
    return !0;
  }
  function looksLikeANode(U) {
    return U !== null && typeof U == "object" && "type" in U;
  }
  function color(U) {
    return U;
  }
  const empty = [],
    CONTINUE = !0,
    EXIT = !1,
    SKIP = "skip";
  function visitParents(U, j, V, B) {
    let q;
    typeof j == "function" && typeof V != "function"
      ? ((B = V), (V = j))
      : (q = j);
    const $ = convert(q),
      H = B ? -1 : 1;
    G(U, void 0, [])();
    function G(Y, Q, X) {
      const Z = Y && typeof Y == "object" ? Y : {};
      if (typeof Z.type == "string") {
        const ne =
          typeof Z.tagName == "string"
            ? Z.tagName
            : typeof Z.name == "string"
            ? Z.name
            : void 0;
        Object.defineProperty(te, "name", {
          value: "node (" + (Y.type + (ne ? "<" + ne + ">" : "")) + ")",
        });
      }
      return te;
      function te() {
        let ne = empty,
          ae,
          se,
          fe;
        if (
          (!j || $(Y, Q, X[X.length - 1] || void 0)) &&
          ((ne = toResult(V(Y, X))), ne[0] === EXIT)
        )
          return ne;
        if ("children" in Y && Y.children) {
          const ce = Y;
          if (ce.children && ne[0] !== SKIP)
            for (
              se = (B ? ce.children.length : -1) + H, fe = X.concat(ce);
              se > -1 && se < ce.children.length;

            ) {
              const ue = ce.children[se];
              if (((ae = G(ue, se, fe)()), ae[0] === EXIT)) return ae;
              se = typeof ae[1] == "number" ? ae[1] : se + H;
            }
        }
        return ne;
      }
    }
  }
  function toResult(U) {
    return Array.isArray(U)
      ? U
      : typeof U == "number"
      ? [CONTINUE, U]
      : U == null
      ? empty
      : [U];
  }
  function visit(U, j, V, B) {
    let q, $, H;
    typeof j == "function" && typeof V != "function"
      ? (($ = void 0), (H = j), (q = V))
      : (($ = j), (H = V), (q = B)),
      visitParents(U, $, G, q);
    function G(Y, Q) {
      const X = Q[Q.length - 1],
        Z = X ? X.children.indexOf(Y) : void 0;
      return H(Y, Z, X);
    }
  }
  const own$1 = {}.hasOwnProperty,
    emptyOptions = {};
  function createState(U, j) {
    const V = j || emptyOptions,
      B = new Map(),
      q = new Map(),
      $ = new Map(),
      H = { ...handlers, ...V.handlers },
      G = {
        all: Q,
        applyData,
        definitionById: B,
        footnoteById: q,
        footnoteCounts: $,
        footnoteOrder: [],
        handlers: H,
        one: Y,
        options: V,
        patch,
        wrap: wrap$1,
      };
    return (
      visit(U, function (X) {
        if (X.type === "definition" || X.type === "footnoteDefinition") {
          const Z = X.type === "definition" ? B : q,
            te = String(X.identifier).toUpperCase();
          Z.has(te) || Z.set(te, X);
        }
      }),
      G
    );
    function Y(X, Z) {
      const te = X.type,
        ne = G.handlers[te];
      if (own$1.call(G.handlers, te) && ne) return ne(G, X, Z);
      if (G.options.passThrough && G.options.passThrough.includes(te)) {
        if ("children" in X) {
          const { children: se, ...fe } = X,
            ce = structuredClone$1(fe);
          return (ce.children = G.all(X)), ce;
        }
        return structuredClone$1(X);
      }
      return (G.options.unknownHandler || defaultUnknownHandler)(G, X, Z);
    }
    function Q(X) {
      const Z = [];
      if ("children" in X) {
        const te = X.children;
        let ne = -1;
        for (; ++ne < te.length; ) {
          const ae = G.one(te[ne], X);
          if (ae) {
            if (
              ne &&
              te[ne - 1].type === "break" &&
              (!Array.isArray(ae) &&
                ae.type === "text" &&
                (ae.value = trimMarkdownSpaceStart(ae.value)),
              !Array.isArray(ae) && ae.type === "element")
            ) {
              const se = ae.children[0];
              se &&
                se.type === "text" &&
                (se.value = trimMarkdownSpaceStart(se.value));
            }
            Array.isArray(ae) ? Z.push(...ae) : Z.push(ae);
          }
        }
      }
      return Z;
    }
  }
  function patch(U, j) {
    U.position && (j.position = position$1(U));
  }
  function applyData(U, j) {
    let V = j;
    if (U && U.data) {
      const B = U.data.hName,
        q = U.data.hChildren,
        $ = U.data.hProperties;
      if (typeof B == "string")
        if (V.type === "element") V.tagName = B;
        else {
          const H = "children" in V ? V.children : [V];
          V = { type: "element", tagName: B, properties: {}, children: H };
        }
      V.type === "element" &&
        $ &&
        Object.assign(V.properties, structuredClone$1($)),
        "children" in V &&
          V.children &&
          q !== null &&
          q !== void 0 &&
          (V.children = q);
    }
    return V;
  }
  function defaultUnknownHandler(U, j) {
    const V = j.data || {},
      B =
        "value" in j &&
        !(own$1.call(V, "hProperties") || own$1.call(V, "hChildren"))
          ? { type: "text", value: j.value }
          : {
              type: "element",
              tagName: "div",
              properties: {},
              children: U.all(j),
            };
    return U.patch(j, B), U.applyData(j, B);
  }
  function wrap$1(U, j) {
    const V = [];
    let B = -1;
    for (
      j &&
      V.push({
        type: "text",
        value: `
`,
      });
      ++B < U.length;

    )
      B &&
        V.push({
          type: "text",
          value: `
`,
        }),
        V.push(U[B]);
    return (
      j &&
        U.length > 0 &&
        V.push({
          type: "text",
          value: `
`,
        }),
      V
    );
  }
  function trimMarkdownSpaceStart(U) {
    let j = 0,
      V = U.charCodeAt(j);
    for (; V === 9 || V === 32; ) j++, (V = U.charCodeAt(j));
    return U.slice(j);
  }
  function toHast(U, j) {
    const V = createState(U, j),
      B = V.one(U, void 0),
      q = footer(V),
      $ = Array.isArray(B)
        ? { type: "root", children: B }
        : B || { type: "root", children: [] };
    return (
      q &&
        $.children.push(
          {
            type: "text",
            value: `
`,
          },
          q
        ),
      $
    );
  }
  function remarkRehype(U, j) {
    return U && "run" in U
      ? async function (V, B) {
          const q = toHast(V, { file: B, ...j });
          await U.run(q, B);
        }
      : function (V, B) {
          return toHast(V, { file: B, ...(U || j) });
        };
  }
  function bail(U) {
    if (U) throw U;
  }
  var extend$1, hasRequiredExtend;
  function requireExtend() {
    if (hasRequiredExtend) return extend$1;
    hasRequiredExtend = 1;
    var U = Object.prototype.hasOwnProperty,
      j = Object.prototype.toString,
      V = Object.defineProperty,
      B = Object.getOwnPropertyDescriptor,
      q = function (Q) {
        return typeof Array.isArray == "function"
          ? Array.isArray(Q)
          : j.call(Q) === "[object Array]";
      },
      $ = function (Q) {
        if (!Q || j.call(Q) !== "[object Object]") return !1;
        var X = U.call(Q, "constructor"),
          Z =
            Q.constructor &&
            Q.constructor.prototype &&
            U.call(Q.constructor.prototype, "isPrototypeOf");
        if (Q.constructor && !X && !Z) return !1;
        var te;
        for (te in Q);
        return typeof te > "u" || U.call(Q, te);
      },
      H = function (Q, X) {
        V && X.name === "__proto__"
          ? V(Q, X.name, {
              enumerable: !0,
              configurable: !0,
              value: X.newValue,
              writable: !0,
            })
          : (Q[X.name] = X.newValue);
      },
      G = function (Q, X) {
        if (X === "__proto__")
          if (U.call(Q, X)) {
            if (B) return B(Q, X).value;
          } else return;
        return Q[X];
      };
    return (
      (extend$1 = function Y() {
        var Q,
          X,
          Z,
          te,
          ne,
          ae,
          se = arguments[0],
          fe = 1,
          ce = arguments.length,
          ue = !1;
        for (
          typeof se == "boolean" &&
            ((ue = se), (se = arguments[1] || {}), (fe = 2)),
            (se == null ||
              (typeof se != "object" && typeof se != "function")) &&
              (se = {});
          fe < ce;
          ++fe
        )
          if (((Q = arguments[fe]), Q != null))
            for (X in Q)
              (Z = G(se, X)),
                (te = G(Q, X)),
                se !== te &&
                  (ue && te && ($(te) || (ne = q(te)))
                    ? (ne
                        ? ((ne = !1), (ae = Z && q(Z) ? Z : []))
                        : (ae = Z && $(Z) ? Z : {}),
                      H(se, { name: X, newValue: Y(ue, ae, te) }))
                    : typeof te < "u" && H(se, { name: X, newValue: te }));
        return se;
      }),
      extend$1
    );
  }
  var extendExports = requireExtend();
  const extend = getDefaultExportFromCjs$1(extendExports);
  function isPlainObject(U) {
    if (typeof U != "object" || U === null) return !1;
    const j = Object.getPrototypeOf(U);
    return (
      (j === null ||
        j === Object.prototype ||
        Object.getPrototypeOf(j) === null) &&
      !(Symbol.toStringTag in U) &&
      !(Symbol.iterator in U)
    );
  }
  function trough() {
    const U = [],
      j = { run: V, use: B };
    return j;
    function V(...q) {
      let $ = -1;
      const H = q.pop();
      if (typeof H != "function")
        throw new TypeError("Expected function as last argument, not " + H);
      G(null, ...q);
      function G(Y, ...Q) {
        const X = U[++$];
        let Z = -1;
        if (Y) {
          H(Y);
          return;
        }
        for (; ++Z < q.length; )
          (Q[Z] === null || Q[Z] === void 0) && (Q[Z] = q[Z]);
        (q = Q), X ? wrap(X, G)(...Q) : H(null, ...Q);
      }
    }
    function B(q) {
      if (typeof q != "function")
        throw new TypeError("Expected `middelware` to be a function, not " + q);
      return U.push(q), j;
    }
  }
  function wrap(U, j) {
    let V;
    return B;
    function B(...H) {
      const G = U.length > H.length;
      let Y;
      G && H.push(q);
      try {
        Y = U.apply(this, H);
      } catch (Q) {
        const X = Q;
        if (G && V) throw X;
        return q(X);
      }
      G ||
        (Y && Y.then && typeof Y.then == "function"
          ? Y.then($, q)
          : Y instanceof Error
          ? q(Y)
          : $(Y));
    }
    function q(H, ...G) {
      V || ((V = !0), j(H, ...G));
    }
    function $(H) {
      q(null, H);
    }
  }
  const minpath = { basename, dirname, extname, join, sep: "/" };
  function basename(U, j) {
    if (j !== void 0 && typeof j != "string")
      throw new TypeError('"ext" argument must be a string');
    assertPath$1(U);
    let V = 0,
      B = -1,
      q = U.length,
      $;
    if (j === void 0 || j.length === 0 || j.length > U.length) {
      for (; q--; )
        if (U.codePointAt(q) === 47) {
          if ($) {
            V = q + 1;
            break;
          }
        } else B < 0 && (($ = !0), (B = q + 1));
      return B < 0 ? "" : U.slice(V, B);
    }
    if (j === U) return "";
    let H = -1,
      G = j.length - 1;
    for (; q--; )
      if (U.codePointAt(q) === 47) {
        if ($) {
          V = q + 1;
          break;
        }
      } else
        H < 0 && (($ = !0), (H = q + 1)),
          G > -1 &&
            (U.codePointAt(q) === j.codePointAt(G--)
              ? G < 0 && (B = q)
              : ((G = -1), (B = H)));
    return V === B ? (B = H) : B < 0 && (B = U.length), U.slice(V, B);
  }
  function dirname(U) {
    if ((assertPath$1(U), U.length === 0)) return ".";
    let j = -1,
      V = U.length,
      B;
    for (; --V; )
      if (U.codePointAt(V) === 47) {
        if (B) {
          j = V;
          break;
        }
      } else B || (B = !0);
    return j < 0
      ? U.codePointAt(0) === 47
        ? "/"
        : "."
      : j === 1 && U.codePointAt(0) === 47
      ? "//"
      : U.slice(0, j);
  }
  function extname(U) {
    assertPath$1(U);
    let j = U.length,
      V = -1,
      B = 0,
      q = -1,
      $ = 0,
      H;
    for (; j--; ) {
      const G = U.codePointAt(j);
      if (G === 47) {
        if (H) {
          B = j + 1;
          break;
        }
        continue;
      }
      V < 0 && ((H = !0), (V = j + 1)),
        G === 46 ? (q < 0 ? (q = j) : $ !== 1 && ($ = 1)) : q > -1 && ($ = -1);
    }
    return q < 0 || V < 0 || $ === 0 || ($ === 1 && q === V - 1 && q === B + 1)
      ? ""
      : U.slice(q, V);
  }
  function join(...U) {
    let j = -1,
      V;
    for (; ++j < U.length; )
      assertPath$1(U[j]), U[j] && (V = V === void 0 ? U[j] : V + "/" + U[j]);
    return V === void 0 ? "." : normalize(V);
  }
  function normalize(U) {
    assertPath$1(U);
    const j = U.codePointAt(0) === 47;
    let V = normalizeString(U, !j);
    return (
      V.length === 0 && !j && (V = "."),
      V.length > 0 && U.codePointAt(U.length - 1) === 47 && (V += "/"),
      j ? "/" + V : V
    );
  }
  function normalizeString(U, j) {
    let V = "",
      B = 0,
      q = -1,
      $ = 0,
      H = -1,
      G,
      Y;
    for (; ++H <= U.length; ) {
      if (H < U.length) G = U.codePointAt(H);
      else {
        if (G === 47) break;
        G = 47;
      }
      if (G === 47) {
        if (!(q === H - 1 || $ === 1))
          if (q !== H - 1 && $ === 2) {
            if (
              V.length < 2 ||
              B !== 2 ||
              V.codePointAt(V.length - 1) !== 46 ||
              V.codePointAt(V.length - 2) !== 46
            ) {
              if (V.length > 2) {
                if (((Y = V.lastIndexOf("/")), Y !== V.length - 1)) {
                  Y < 0
                    ? ((V = ""), (B = 0))
                    : ((V = V.slice(0, Y)),
                      (B = V.length - 1 - V.lastIndexOf("/"))),
                    (q = H),
                    ($ = 0);
                  continue;
                }
              } else if (V.length > 0) {
                (V = ""), (B = 0), (q = H), ($ = 0);
                continue;
              }
            }
            j && ((V = V.length > 0 ? V + "/.." : ".."), (B = 2));
          } else
            V.length > 0
              ? (V += "/" + U.slice(q + 1, H))
              : (V = U.slice(q + 1, H)),
              (B = H - q - 1);
        (q = H), ($ = 0);
      } else G === 46 && $ > -1 ? $++ : ($ = -1);
    }
    return V;
  }
  function assertPath$1(U) {
    if (typeof U != "string")
      throw new TypeError(
        "Path must be a string. Received " + JSON.stringify(U)
      );
  }
  const minproc = { cwd };
  function cwd() {
    return "/";
  }
  function isUrl(U) {
    return !!(
      U !== null &&
      typeof U == "object" &&
      "href" in U &&
      U.href &&
      "protocol" in U &&
      U.protocol &&
      U.auth === void 0
    );
  }
  function urlToPath(U) {
    if (typeof U == "string") U = new URL(U);
    else if (!isUrl(U)) {
      const j = new TypeError(
        'The "path" argument must be of type string or an instance of URL. Received `' +
          U +
          "`"
      );
      throw ((j.code = "ERR_INVALID_ARG_TYPE"), j);
    }
    if (U.protocol !== "file:") {
      const j = new TypeError("The URL must be of scheme file");
      throw ((j.code = "ERR_INVALID_URL_SCHEME"), j);
    }
    return getPathFromURLPosix(U);
  }
  function getPathFromURLPosix(U) {
    if (U.hostname !== "") {
      const B = new TypeError(
        'File URL host must be "localhost" or empty on darwin'
      );
      throw ((B.code = "ERR_INVALID_FILE_URL_HOST"), B);
    }
    const j = U.pathname;
    let V = -1;
    for (; ++V < j.length; )
      if (j.codePointAt(V) === 37 && j.codePointAt(V + 1) === 50) {
        const B = j.codePointAt(V + 2);
        if (B === 70 || B === 102) {
          const q = new TypeError(
            "File URL path must not include encoded / characters"
          );
          throw ((q.code = "ERR_INVALID_FILE_URL_PATH"), q);
        }
      }
    return decodeURIComponent(j);
  }
  const order = ["history", "path", "basename", "stem", "extname", "dirname"];
  class VFile {
    constructor(j) {
      let V;
      j
        ? isUrl(j)
          ? (V = { path: j })
          : typeof j == "string" || isUint8Array$1(j)
          ? (V = { value: j })
          : (V = j)
        : (V = {}),
        (this.cwd = "cwd" in V ? "" : minproc.cwd()),
        (this.data = {}),
        (this.history = []),
        (this.messages = []),
        this.value,
        this.map,
        this.result,
        this.stored;
      let B = -1;
      for (; ++B < order.length; ) {
        const $ = order[B];
        $ in V &&
          V[$] !== void 0 &&
          V[$] !== null &&
          (this[$] = $ === "history" ? [...V[$]] : V[$]);
      }
      let q;
      for (q in V) order.includes(q) || (this[q] = V[q]);
    }
    get basename() {
      return typeof this.path == "string"
        ? minpath.basename(this.path)
        : void 0;
    }
    set basename(j) {
      assertNonEmpty(j, "basename"),
        assertPart(j, "basename"),
        (this.path = minpath.join(this.dirname || "", j));
    }
    get dirname() {
      return typeof this.path == "string" ? minpath.dirname(this.path) : void 0;
    }
    set dirname(j) {
      assertPath(this.basename, "dirname"),
        (this.path = minpath.join(j || "", this.basename));
    }
    get extname() {
      return typeof this.path == "string" ? minpath.extname(this.path) : void 0;
    }
    set extname(j) {
      if ((assertPart(j, "extname"), assertPath(this.dirname, "extname"), j)) {
        if (j.codePointAt(0) !== 46)
          throw new Error("`extname` must start with `.`");
        if (j.includes(".", 1))
          throw new Error("`extname` cannot contain multiple dots");
      }
      this.path = minpath.join(this.dirname, this.stem + (j || ""));
    }
    get path() {
      return this.history[this.history.length - 1];
    }
    set path(j) {
      isUrl(j) && (j = urlToPath(j)),
        assertNonEmpty(j, "path"),
        this.path !== j && this.history.push(j);
    }
    get stem() {
      return typeof this.path == "string"
        ? minpath.basename(this.path, this.extname)
        : void 0;
    }
    set stem(j) {
      assertNonEmpty(j, "stem"),
        assertPart(j, "stem"),
        (this.path = minpath.join(
          this.dirname || "",
          j + (this.extname || "")
        ));
    }
    fail(j, V, B) {
      const q = this.message(j, V, B);
      throw ((q.fatal = !0), q);
    }
    info(j, V, B) {
      const q = this.message(j, V, B);
      return (q.fatal = void 0), q;
    }
    message(j, V, B) {
      const q = new VFileMessage(j, V, B);
      return (
        this.path &&
          ((q.name = this.path + ":" + q.name), (q.file = this.path)),
        (q.fatal = !1),
        this.messages.push(q),
        q
      );
    }
    toString(j) {
      return this.value === void 0
        ? ""
        : typeof this.value == "string"
        ? this.value
        : new TextDecoder(j || void 0).decode(this.value);
    }
  }
  function assertPart(U, j) {
    if (U && U.includes(minpath.sep))
      throw new Error(
        "`" + j + "` cannot be a path: did not expect `" + minpath.sep + "`"
      );
  }
  function assertNonEmpty(U, j) {
    if (!U) throw new Error("`" + j + "` cannot be empty");
  }
  function assertPath(U, j) {
    if (!U)
      throw new Error("Setting `" + j + "` requires `path` to be set too");
  }
  function isUint8Array$1(U) {
    return !!(
      U &&
      typeof U == "object" &&
      "byteLength" in U &&
      "byteOffset" in U
    );
  }
  const CallableInstance = function (U) {
      const B = this.constructor.prototype,
        q = B[U],
        $ = function () {
          return q.apply($, arguments);
        };
      return Object.setPrototypeOf($, B), $;
    },
    own = {}.hasOwnProperty;
  class Processor extends CallableInstance {
    constructor() {
      super("copy"),
        (this.Compiler = void 0),
        (this.Parser = void 0),
        (this.attachers = []),
        (this.compiler = void 0),
        (this.freezeIndex = -1),
        (this.frozen = void 0),
        (this.namespace = {}),
        (this.parser = void 0),
        (this.transformers = trough());
    }
    copy() {
      const j = new Processor();
      let V = -1;
      for (; ++V < this.attachers.length; ) {
        const B = this.attachers[V];
        j.use(...B);
      }
      return j.data(extend(!0, {}, this.namespace)), j;
    }
    data(j, V) {
      return typeof j == "string"
        ? arguments.length === 2
          ? (assertUnfrozen("data", this.frozen), (this.namespace[j] = V), this)
          : (own.call(this.namespace, j) && this.namespace[j]) || void 0
        : j
        ? (assertUnfrozen("data", this.frozen), (this.namespace = j), this)
        : this.namespace;
    }
    freeze() {
      if (this.frozen) return this;
      const j = this;
      for (; ++this.freezeIndex < this.attachers.length; ) {
        const [V, ...B] = this.attachers[this.freezeIndex];
        if (B[0] === !1) continue;
        B[0] === !0 && (B[0] = void 0);
        const q = V.call(j, ...B);
        typeof q == "function" && this.transformers.use(q);
      }
      return (
        (this.frozen = !0), (this.freezeIndex = Number.POSITIVE_INFINITY), this
      );
    }
    parse(j) {
      this.freeze();
      const V = vfile(j),
        B = this.parser || this.Parser;
      return assertParser("parse", B), B(String(V), V);
    }
    process(j, V) {
      const B = this;
      return (
        this.freeze(),
        assertParser("process", this.parser || this.Parser),
        assertCompiler("process", this.compiler || this.Compiler),
        V ? q(void 0, V) : new Promise(q)
      );
      function q($, H) {
        const G = vfile(j),
          Y = B.parse(G);
        B.run(Y, G, function (X, Z, te) {
          if (X || !Z || !te) return Q(X);
          const ne = Z,
            ae = B.stringify(ne, te);
          looksLikeAValue(ae) ? (te.value = ae) : (te.result = ae), Q(X, te);
        });
        function Q(X, Z) {
          X || !Z ? H(X) : $ ? $(Z) : V(void 0, Z);
        }
      }
    }
    processSync(j) {
      let V = !1,
        B;
      return (
        this.freeze(),
        assertParser("processSync", this.parser || this.Parser),
        assertCompiler("processSync", this.compiler || this.Compiler),
        this.process(j, q),
        assertDone("processSync", "process", V),
        B
      );
      function q($, H) {
        (V = !0), bail($), (B = H);
      }
    }
    run(j, V, B) {
      assertNode(j), this.freeze();
      const q = this.transformers;
      return (
        !B && typeof V == "function" && ((B = V), (V = void 0)),
        B ? $(void 0, B) : new Promise($)
      );
      function $(H, G) {
        const Y = vfile(V);
        q.run(j, Y, Q);
        function Q(X, Z, te) {
          const ne = Z || j;
          X ? G(X) : H ? H(ne) : B(void 0, ne, te);
        }
      }
    }
    runSync(j, V) {
      let B = !1,
        q;
      return this.run(j, V, $), assertDone("runSync", "run", B), q;
      function $(H, G) {
        bail(H), (q = G), (B = !0);
      }
    }
    stringify(j, V) {
      this.freeze();
      const B = vfile(V),
        q = this.compiler || this.Compiler;
      return assertCompiler("stringify", q), assertNode(j), q(j, B);
    }
    use(j, ...V) {
      const B = this.attachers,
        q = this.namespace;
      if ((assertUnfrozen("use", this.frozen), j != null))
        if (typeof j == "function") Y(j, V);
        else if (typeof j == "object") Array.isArray(j) ? G(j) : H(j);
        else throw new TypeError("Expected usable value, not `" + j + "`");
      return this;
      function $(Q) {
        if (typeof Q == "function") Y(Q, []);
        else if (typeof Q == "object")
          if (Array.isArray(Q)) {
            const [X, ...Z] = Q;
            Y(X, Z);
          } else H(Q);
        else throw new TypeError("Expected usable value, not `" + Q + "`");
      }
      function H(Q) {
        if (!("plugins" in Q) && !("settings" in Q))
          throw new Error(
            "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
          );
        G(Q.plugins),
          Q.settings && (q.settings = extend(!0, q.settings, Q.settings));
      }
      function G(Q) {
        let X = -1;
        if (Q != null)
          if (Array.isArray(Q))
            for (; ++X < Q.length; ) {
              const Z = Q[X];
              $(Z);
            }
          else
            throw new TypeError("Expected a list of plugins, not `" + Q + "`");
      }
      function Y(Q, X) {
        let Z = -1,
          te = -1;
        for (; ++Z < B.length; )
          if (B[Z][0] === Q) {
            te = Z;
            break;
          }
        if (te === -1) B.push([Q, ...X]);
        else if (X.length > 0) {
          let [ne, ...ae] = X;
          const se = B[te][1];
          isPlainObject(se) && isPlainObject(ne) && (ne = extend(!0, se, ne)),
            (B[te] = [Q, ne, ...ae]);
        }
      }
    }
  }
  const unified = new Processor().freeze();
  function assertParser(U, j) {
    if (typeof j != "function")
      throw new TypeError("Cannot `" + U + "` without `parser`");
  }
  function assertCompiler(U, j) {
    if (typeof j != "function")
      throw new TypeError("Cannot `" + U + "` without `compiler`");
  }
  function assertUnfrozen(U, j) {
    if (j)
      throw new Error(
        "Cannot call `" +
          U +
          "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
      );
  }
  function assertNode(U) {
    if (!isPlainObject(U) || typeof U.type != "string")
      throw new TypeError("Expected node, got `" + U + "`");
  }
  function assertDone(U, j, V) {
    if (!V)
      throw new Error("`" + U + "` finished async. Use `" + j + "` instead");
  }
  function vfile(U) {
    return looksLikeAVFile(U) ? U : new VFile(U);
  }
  function looksLikeAVFile(U) {
    return !!(U && typeof U == "object" && "message" in U && "messages" in U);
  }
  function looksLikeAValue(U) {
    return typeof U == "string" || isUint8Array(U);
  }
  function isUint8Array(U) {
    return !!(
      U &&
      typeof U == "object" &&
      "byteLength" in U &&
      "byteOffset" in U
    );
  }
  const changelog =
      "https://github.com/remarkjs/react-markdown/blob/main/changelog.md",
    emptyPlugins = [],
    emptyRemarkRehypeOptions = { allowDangerousHtml: !0 },
    safeProtocol = /^(https?|ircs?|mailto|xmpp)$/i,
    deprecations = [
      { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
      {
        from: "allowDangerousHtml",
        id: "remove-buggy-html-in-markdown-parser",
      },
      {
        from: "allowNode",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "allowElement",
      },
      {
        from: "allowedTypes",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "allowedElements",
      },
      { from: "className", id: "remove-classname" },
      {
        from: "disallowedTypes",
        id: "replace-allownode-allowedtypes-and-disallowedtypes",
        to: "disallowedElements",
      },
      { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
      { from: "includeElementIndex", id: "#remove-includeelementindex" },
      {
        from: "includeNodeIndex",
        id: "change-includenodeindex-to-includeelementindex",
      },
      { from: "linkTarget", id: "remove-linktarget" },
      {
        from: "plugins",
        id: "change-plugins-to-remarkplugins",
        to: "remarkPlugins",
      },
      { from: "rawSourcePos", id: "#remove-rawsourcepos" },
      {
        from: "renderers",
        id: "change-renderers-to-components",
        to: "components",
      },
      { from: "source", id: "change-source-to-children", to: "children" },
      { from: "sourcePos", id: "#remove-sourcepos" },
      {
        from: "transformImageUri",
        id: "#add-urltransform",
        to: "urlTransform",
      },
      { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" },
    ];
  function Markdown(U) {
    const j = createProcessor(U),
      V = createFile(U);
    return post(j.runSync(j.parse(V), V), U);
  }
  function createProcessor(U) {
    const j = U.rehypePlugins || emptyPlugins,
      V = U.remarkPlugins || emptyPlugins,
      B = U.remarkRehypeOptions
        ? { ...U.remarkRehypeOptions, ...emptyRemarkRehypeOptions }
        : emptyRemarkRehypeOptions;
    return unified().use(remarkParse).use(V).use(remarkRehype, B).use(j);
  }
  function createFile(U) {
    const j = U.children || "",
      V = new VFile();
    return typeof j == "string" && (V.value = j), V;
  }
  function post(U, j) {
    const V = j.allowedElements,
      B = j.allowElement,
      q = j.components,
      $ = j.disallowedElements,
      H = j.skipHtml,
      G = j.unwrapDisallowed,
      Y = j.urlTransform || defaultUrlTransform;
    for (const X of deprecations)
      Object.hasOwn(j, X.from) &&
        ("" +
          X.from +
          (X.to ? "use `" + X.to + "` instead" : "remove it") +
          changelog +
          X.id,
        void 0);
    return (
      visit(U, Q),
      toJsxRuntime(U, {
        Fragment: jsxRuntimeExports.Fragment,
        components: q,
        ignoreInvalidStyle: !0,
        jsx: jsxRuntimeExports.jsx,
        jsxs: jsxRuntimeExports.jsxs,
        passKeys: !0,
        passNode: !0,
      })
    );
    function Q(X, Z, te) {
      if (X.type === "raw" && te && typeof Z == "number")
        return (
          H
            ? te.children.splice(Z, 1)
            : (te.children[Z] = { type: "text", value: X.value }),
          Z
        );
      if (X.type === "element") {
        let ne;
        for (ne in urlAttributes)
          if (
            Object.hasOwn(urlAttributes, ne) &&
            Object.hasOwn(X.properties, ne)
          ) {
            const ae = X.properties[ne],
              se = urlAttributes[ne];
            (se === null || se.includes(X.tagName)) &&
              (X.properties[ne] = Y(String(ae || ""), ne, X));
          }
      }
      if (X.type === "element") {
        let ne = V ? !V.includes(X.tagName) : $ ? $.includes(X.tagName) : !1;
        if (
          (!ne && B && typeof Z == "number" && (ne = !B(X, Z, te)),
          ne && te && typeof Z == "number")
        )
          return (
            G && X.children
              ? te.children.splice(Z, 1, ...X.children)
              : te.children.splice(Z, 1),
            Z
          );
      }
    }
  }
  function defaultUrlTransform(U) {
    const j = U.indexOf(":"),
      V = U.indexOf("?"),
      B = U.indexOf("#"),
      q = U.indexOf("/");
    return j === -1 ||
      (q !== -1 && j > q) ||
      (V !== -1 && j > V) ||
      (B !== -1 && j > B) ||
      safeProtocol.test(U.slice(0, j))
      ? U
      : "";
  }
  function App({
    clientKey: U = "c3a94b703193354cdd5f647a8dc35f79",
    customUserId: j,
  }) {
    const V = "https://chat-bot-backend-1-28ro.onrender.com",
      [B, q] = reactExports.useState(null),
      [$, H] = reactExports.useState([]),
      [G, Y] = reactExports.useState(""),
      [Q, X] = reactExports.useState(!1),
      [Z, te] = reactExports.useState(!1),
      [ne, ae] = reactExports.useState(!1),
      [se, fe] = reactExports.useState(!0),
      [ce, ue] = reactExports.useState(!0),
      [he, me] = reactExports.useState(0),
      [ve, ge] = reactExports.useState(null),
      [Ee, Ce] = reactExports.useState(!1),
      [Re, Ae] = reactExports.useState(!1),
      [be, Le] = reactExports.useState("chat"),
      [Fe, Me] = reactExports.useState(!0),
      je = reactExports.useRef(null),
      Te = reactExports.useRef(null),
      xe = reactExports.useRef(null);
    reactExports.useEffect(() => {
      (async () => {
        try {
          const tt = await loadTheme(U);
          if ((q(tt), !hasUserEmail()))
            console.log("No email found, showing email collector", Fe), Me(!0);
          else {
            Me(!1);
            const gt = await getOrStartConversation(U, V, j);
            ge(gt.sessionId),
              console.log("App initialized:", {
                clientKey: U,
                sessionId: gt.sessionId,
                fingerprint: gt.fingerprint,
                theme: tt,
              });
          }
        } catch (tt) {
          console.error("Failed to initialize app:", tt), fe(!1);
        }
      })();
    }, [U, j]),
      reactExports.useEffect(() => {
        Z &&
          !ne &&
          je.current &&
          je.current.scrollIntoView({ behavior: "smooth" });
      }, [$, Z, ne, Q, be]),
      reactExports.useEffect(() => {
        Z &&
          !ne &&
          xe.current &&
          be === "chat" &&
          setTimeout(() => xe.current?.focus(), 100);
      }, [Z, ne, be]),
      reactExports.useEffect(() => {
        !Z &&
          $.length > 0 &&
          $[$.length - 1].sender === "bot" &&
          me((tt) => tt + 1);
      }, [$, Z]);
    const He = async (We) => {
        Me(!1);
        try {
          const tt = await getOrStartConversation(U, V, j);
          ge(tt.sessionId);
        } catch (tt) {
          console.error(
            "Failed to start conversation after email collection:",
            tt
          );
        }
      },
      Je = async () => {
        if (!G.trim() || !ve) return;
        const We = {
          id: Date.now().toString(),
          content: G,
          sender: "user",
          timestamp: new Date(),
        };
        H((tt) => [...tt, We]), Y(""), X(!0);
        try {
          await addMessageToConversation(U, V, ve, "user", We.content);
          const tt = await fetch(`${V}/api/chat/${U}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              messages: [...$, We].map((nn) => ({
                role: nn.sender === "user" ? "user" : "assistant",
                content: nn.content,
              })),
              sessionId: ve,
              prompt: B?.prompt,
            }),
          });
          if (!tt.ok) throw new Error("Failed to get response");
          const gt = await tt.json(),
            Jt = {
              id: (Date.now() + 1).toString(),
              content:
                gt.response || "I'm sorry, I couldn't process your request.",
              sender: "bot",
              timestamp: new Date(),
            };
          H((nn) => [...nn, Jt]),
            await addMessageToConversation(U, V, ve, "assistant", Jt.content),
            ce && oe(),
            fe(!0);
        } catch (tt) {
          console.error("Chat error:", tt), fe(!1);
          const gt = {
            id: (Date.now() + 1).toString(),
            content: "Sorry, there was an error. Please try again.",
            sender: "bot",
            timestamp: new Date(),
          };
          H((Jt) => [...Jt, gt]);
        } finally {
          X(!1),
            setTimeout(() => {
              xe.current && xe.current.focus();
            }, 100);
        }
      },
      oe = () => {
        Te.current && Te.current.play().catch(() => {});
      },
      De = (We) => {
        We.key === "Enter" && !We.shiftKey && (We.preventDefault(), Je());
      },
      Ge = () => {
        te(!Z), Z ? (Le("chat"), Ae(!1), Ce(!1)) : (me(0), ae(!1), Le("chat"));
      },
      pe = (We) => {
        Le(We),
          We === "video"
            ? Ce(!1)
            : We === "voice"
            ? (Ce(!0), Ae(!1))
            : (Ae(!1), Ce(!1));
      },
      Ye = () => {
        H([]);
      },
      Qe = (We) =>
        new Date(We).toLocaleTimeString([], {
          hour: "2-digit",
          minute: "2-digit",
        }),
      Ie = () => {
        if (!B)
          return {
            position: "fixed",
            bottom: "16px",
            right: "16px",
            zIndex: 50,
            display: "flex",
            flexDirection: "column",
            alignItems: "flex-end",
          };
        const { position: We } = B,
          tt = { position: "fixed", zIndex: 50, display: "flex" };
        switch (We) {
          case "bottom-right":
            return {
              ...tt,
              bottom: "16px",
              right: "16px",
              flexDirection: "column",
              alignItems: "flex-end",
            };
          case "bottom-left":
            return {
              ...tt,
              bottom: "16px",
              left: "16px",
              flexDirection: "column",
              alignItems: "flex-start",
            };
          case "top-right":
            return {
              ...tt,
              top: "16px",
              right: "16px",
              flexDirection: "column-reverse",
              alignItems: "flex-end",
            };
          case "top-left":
            return {
              ...tt,
              top: "16px",
              left: "16px",
              flexDirection: "column-reverse",
              alignItems: "flex-start",
            };
          default:
            return {
              ...tt,
              bottom: "16px",
              right: "16px",
              flexDirection: "column",
              alignItems: "flex-end",
            };
        }
      },
      pt = () => {
        if (!B) return { marginTop: "16px" };
        const { position: We } = B;
        return We.startsWith("top")
          ? { marginBottom: "16px" }
          : { marginTop: "16px" };
      },
      ct = () =>
        jsxRuntimeExports.jsxs("div", {
          style: { display: "inline-flex", alignItems: "center" },
          children: [
            [0, 1, 2].map((We) =>
              jsxRuntimeExports.jsx(
                "span",
                {
                  style: {
                    height: "6px",
                    width: "6px",
                    backgroundColor: "currentColor",
                    borderRadius: "50%",
                    display: "inline-block",
                    margin: "0 1px",
                    opacity: 0.4,
                    animation: "typing 1.4s infinite ease-in-out",
                    animationDelay:
                      We === 0 ? "-0.32s" : We === 1 ? "-0.16s" : "0s",
                  },
                },
                We
              )
            ),
            jsxRuntimeExports.jsx("style", {
              children: `
          @keyframes typing {
            0%, 80%, 100% {
              transform: scale(0.8);
              opacity: 0.4;
            }
            40% {
              transform: scale(1);
              opacity: 1;
            }
          }
        `,
            }),
          ],
        });
    return B
      ? jsxRuntimeExports.jsxs("div", {
          style: { fontFamily: "system-ui, -apple-system, sans-serif" },
          children: [
            jsxRuntimeExports.jsx("style", {
              children: `
          :root { --chat-primary: ${B.primaryColor}; }
          .chat-messages { scrollbar-width: thin; scrollbar-color: var(--chat-primary) transparent; }
          .chat-messages::-webkit-scrollbar { width: 0px; height: 5px; }
          .chat-messages::-webkit-scrollbar-track { background: transparent !important; }
          .chat-messages::-webkit-scrollbar-thumb {
            background-color: var(--chat-primary);
            background-image: linear-gradient(#030712, #111827, #030712);
            border-radius: 100px;
          }
        `,
            }),
            jsxRuntimeExports.jsx("audio", {
              ref: Te,
              autoPlay: !0,
              src: "https://exthalpy-public-bucket.blr1.cdn.digitaloceanspaces.com/mixkit-gaming-lock-2848.wav",
            }),
            jsxRuntimeExports.jsxs("div", {
              style: Ie(),
              children: [
                jsxRuntimeExports.jsxs(motion.button, {
                  initial: { scale: 0.8, opacity: 0 },
                  animate: { scale: 1, opacity: 1 },
                  whileHover: { scale: 1.05 },
                  whileTap: { scale: 0.95 },
                  onClick: Ge,
                  style: {
                    position: "relative",
                    background: `linear-gradient(135deg, ${B.primaryColor}, ${B.secondaryColor})`,
                    borderRadius: "50%",
                    boxShadow: `0 8px 32px ${B.shadowColor}`,
                    border: "none",
                    cursor: "pointer",
                    width: "64px",
                    height: "64px",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    color: "white",
                    overflow: "hidden",
                    transition: "all 0.3s ease",
                  },
                  "aria-label": Z ? "Close chat" : "Open chat",
                  children: [
                    jsxRuntimeExports.jsx(motion.div, {
                      style: {
                        position: "absolute",
                        inset: 0,
                        background:
                          "linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.05))",
                        borderRadius: "50%",
                        backdropFilter: "blur(10px)",
                      },
                      animate: { opacity: Z ? 0 : [0.2, 0.6, 0.2] },
                      transition: {
                        duration: 3,
                        repeat: 1 / 0,
                        ease: "easeInOut",
                      },
                    }),
                    jsxRuntimeExports.jsx(motion.div, {
                      style: {
                        position: "absolute",
                        inset: 0,
                        border: "2px solid rgba(255,255,255,0.3)",
                        borderRadius: "50%",
                      },
                      animate: {
                        scale: Z ? 1 : [1, 1.5, 1],
                        opacity: Z ? 1 : [0.8, 0, 0.8],
                      },
                      transition: {
                        duration: 2,
                        repeat: 1 / 0,
                        ease: "easeInOut",
                      },
                    }),
                    jsxRuntimeExports.jsx(AnimatePresence, {
                      mode: "wait",
                      children: Z
                        ? jsxRuntimeExports.jsxs(
                            motion.div,
                            {
                              initial: { rotate: -90, scale: 0 },
                              animate: { rotate: 0, scale: 1 },
                              exit: { rotate: 90, scale: 0 },
                              transition: { duration: 0.3, type: "spring" },
                              children: [
                                be === "chat" &&
                                  jsxRuntimeExports.jsx(MessageCircle, {
                                    size: 28,
                                  }),
                                be === "voice" &&
                                  jsxRuntimeExports.jsx(Phone, { size: 28 }),
                                be === "video" &&
                                  jsxRuntimeExports.jsx(Video, { size: 28 }),
                              ],
                            },
                            "close"
                          )
                        : jsxRuntimeExports.jsxs(
                            motion.div,
                            {
                              initial: { rotate: 90, scale: 0 },
                              animate: { rotate: 0, scale: 1 },
                              exit: { rotate: -90, scale: 0 },
                              transition: { duration: 0.3, type: "spring" },
                              style: { position: "relative", padding: "10px" },
                              children: [
                                be === "chat" &&
                                  jsxRuntimeExports.jsx(MessageCircle, {
                                    size: 28,
                                  }),
                                be === "voice" &&
                                  jsxRuntimeExports.jsx(Phone, { size: 28 }),
                                be === "video" &&
                                  jsxRuntimeExports.jsx(Video, { size: 28 }),
                                he > 0 &&
                                  jsxRuntimeExports.jsx(motion.div, {
                                    initial: { scale: 0 },
                                    animate: { scale: 1 },
                                    style: {
                                      position: "absolute",
                                      top: "-4px",
                                      right: "-4px",
                                      width: "24px",
                                      height: "24px",
                                      background:
                                        "linear-gradient(135deg, #ef4444, #dc2626)",
                                      borderRadius: "50%",
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                      fontSize: "12px",
                                      fontWeight: "bold",
                                      color: "white",
                                      boxShadow:
                                        "0 2px 8px rgba(239, 68, 68, 0.5)",
                                    },
                                    children: he > 9 ? "9+" : he,
                                  }),
                              ],
                            },
                            "chat"
                          ),
                    }),
                  ],
                }),
                Re
                  ? jsxRuntimeExports.jsx(VideoAgent, {
                      isVideoMode: Re,
                      setIsVideoMode: Ae,
                      theme: B,
                      messages: $,
                      setMessages: (We) => H((tt) => [...tt, We]),
                      prompt: B.prompt,
                      clientKey: U,
                      apiUrl: V,
                      sessionId: ve || void 0,
                    })
                  : jsxRuntimeExports.jsx(AnimatePresence, {
                      children:
                        Z &&
                        jsxRuntimeExports.jsxs(motion.div, {
                          initial: {
                            opacity: 0,
                            scale: 0.8,
                            y: B.position.startsWith("top") ? -20 : 20,
                          },
                          animate: { opacity: 1, scale: 1, y: 0 },
                          exit: {
                            opacity: 0,
                            scale: 0.8,
                            y: B.position.startsWith("top") ? -20 : 20,
                          },
                          transition: {
                            type: "spring",
                            stiffness: 300,
                            damping: 30,
                          },
                          style: {
                            background: `linear-gradient(135deg, ${B.backgroundColor}, ${B.backgroundColor}f0)`,
                            backdropFilter: "blur(20px)",
                            borderRadius: B.borderRadius,
                            width: "min(420px, 90vw)",
                            height: ne ? "80px" : "min(700px, 85vh)",
                            maxHeight: ne ? "80px" : "700px",
                            border: `1px solid ${B.primaryColor}30`,
                            display: "flex",
                            flexDirection: "column",
                            boxShadow:
                              "0 25px 50px -12px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1)",
                            overflow: "hidden",
                            ...pt(),
                          },
                          children: [
                            jsxRuntimeExports.jsxs(motion.div, {
                              initial: { y: -20, opacity: 0 },
                              animate: { y: 0, opacity: 1 },
                              transition: { delay: 0.1 },
                              style: {
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "space-between",
                                padding: "15px",
                                borderBottom: `1px solid ${B.primaryColor}15`,
                                background: `linear-gradient(135deg, ${B.headerFooterBgColor}, ${B.headerFooterBgColor}f0)`,
                                backdropFilter: "blur(20px)",
                                borderTopLeftRadius: B.borderRadius,
                                borderTopRightRadius: B.borderRadius,
                                position: "sticky",
                                top: 0,
                                zIndex: 2,
                              },
                              children: [
                                jsxRuntimeExports.jsxs("div", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    gap: "25px",
                                  },
                                  children: [
                                    B.companyLogo !=
                                    "https://placehold.co/32x32"
                                      ? jsxRuntimeExports.jsxs("div", {
                                          style: { position: "relative" },
                                          children: [
                                            jsxRuntimeExports.jsx("img", {
                                              src: B.companyLogo,
                                              alt: "Company Logo",
                                              style: {
                                                width: "32px",
                                                height: "32px",
                                              },
                                            }),
                                            jsxRuntimeExports.jsx(motion.div, {
                                              animate: {
                                                scale: se ? [1, 1.2, 1] : 1,
                                                opacity: se
                                                  ? [0.7, 1, 0.7]
                                                  : 0.3,
                                              },
                                              transition: {
                                                duration: 2,
                                                repeat: se ? 1 / 0 : 0,
                                              },
                                              style: {
                                                position: "absolute",
                                                bottom: "-2px",
                                                right: "-2px",
                                                width: "6px",
                                                height: "6px",
                                                borderRadius: "50%",
                                                background: se
                                                  ? "linear-gradient(135deg, #10b981, #059669)"
                                                  : "linear-gradient(135deg, #ef4444, #dc2626)",
                                                border: "2px solid white",
                                                boxShadow:
                                                  "0 2px 8px rgba(0, 0, 0, 0.2)",
                                              },
                                            }),
                                          ],
                                        })
                                      : jsxRuntimeExports.jsx("div", {
                                          style: {
                                            width: "32px",
                                            height: "32px",
                                            borderRadius: "50%",
                                            backgroundColor: B.primaryColor,
                                            display: "flex",
                                            alignItems: "center",
                                            justifyContent: "center",
                                          },
                                          children: jsxRuntimeExports.jsx(Bot, {
                                            size: 16,
                                            color: "white",
                                          }),
                                        }),
                                    jsxRuntimeExports.jsxs("div", {
                                      children: [
                                        jsxRuntimeExports.jsx("div", {
                                          style: {
                                            fontSize: "20px",
                                            fontWeight: "600",
                                            color: B.textColor,
                                          },
                                          children: B.companyName,
                                        }),
                                        jsxRuntimeExports.jsx("div", {
                                          style: {
                                            fontSize: "12px",
                                            color: B.textColor + "80",
                                            display: "flex",
                                            alignItems: "center",
                                            gap: "4px",
                                          },
                                          children: se
                                            ? jsxRuntimeExports.jsxs(
                                                jsxRuntimeExports.Fragment,
                                                {
                                                  children: [
                                                    jsxRuntimeExports.jsx(
                                                      Wifi,
                                                      {
                                                        size: 20,
                                                        style: {
                                                          color: "green",
                                                        },
                                                      }
                                                    ),
                                                    "Online",
                                                  ],
                                                }
                                              )
                                            : jsxRuntimeExports.jsxs(
                                                jsxRuntimeExports.Fragment,
                                                {
                                                  children: [
                                                    jsxRuntimeExports.jsx(
                                                      WifiOff,
                                                      { size: 12 }
                                                    ),
                                                    "Offline",
                                                  ],
                                                }
                                              ),
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                                jsxRuntimeExports.jsxs("div", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    padding: "5px",
                                    gap: "8px",
                                  },
                                  children: [
                                    jsxRuntimeExports.jsx("button", {
                                      onClick: () => ue(!ce),
                                      style: {
                                        background: "none",
                                        border: "none",
                                        cursor: "pointer",
                                        padding: "8px",
                                        borderRadius: "50%",
                                        color: ce
                                          ? B.primaryColor
                                          : B.textColor + "60",
                                      },
                                      children: ce
                                        ? jsxRuntimeExports.jsx(Volume2, {
                                            size: 20,
                                          })
                                        : jsxRuntimeExports.jsx(VolumeX, {
                                            size: 20,
                                          }),
                                    }),
                                    $.length > 0 &&
                                      jsxRuntimeExports.jsx("button", {
                                        onClick: Ye,
                                        style: {
                                          background: "none",
                                          border: "none",
                                          cursor: "pointer",
                                          padding: "8px",
                                          borderRadius: "50%",
                                          color: B.textColor + "60",
                                        },
                                        title: "Clear messages",
                                        children: jsxRuntimeExports.jsx(
                                          Trash2,
                                          { size: 20 }
                                        ),
                                      }),
                                    jsxRuntimeExports.jsx("button", {
                                      onClick: (We) => {
                                        We.stopPropagation(), ae(!ne);
                                      },
                                      style: {
                                        background: "none",
                                        border: "none",
                                        cursor: "pointer",
                                        padding: "4px",
                                        borderRadius: "4px",
                                        color: B.textColor + "60",
                                      },
                                      children: ne
                                        ? jsxRuntimeExports.jsx(Maximize2, {
                                            size: 16,
                                          })
                                        : jsxRuntimeExports.jsx(Minimize2, {
                                            size: 16,
                                          }),
                                    }),
                                  ],
                                }),
                              ],
                            }),
                            Fe &&
                              jsxRuntimeExports.jsx(EmailCollector, {
                                onEmailCollected: He,
                                theme: B,
                              }),
                            jsxRuntimeExports.jsx(motion.div, {
                              style: {
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "space-between",
                                gap: "4px",
                                fontSize: "12px",
                                opacity: 0.8,
                                color: B.textColor,
                                position: "sticky",
                                top: 60,
                                zIndex: 2,
                                padding: "4px 0",
                              },
                              children:
                                !Fe &&
                                jsxRuntimeExports.jsxs("div", {
                                  style: {
                                    display: "flex",
                                    backgroundColor: "S{theme.primaryColor}15",
                                    alignItems: "center",
                                    justifyContent: "space-around",
                                    borderRadius: "12px",
                                    padding: "4px",
                                    width: "100%",
                                    marginRight: "8px",
                                  },
                                  children: [
                                    jsxRuntimeExports.jsxs(motion.button, {
                                      whileHover: { scale: 1.05 },
                                      whileTap: { scale: 0.95 },
                                      onClick: () => pe("chat"),
                                      style: {
                                        padding: "8px 12px",
                                        borderRadius: "8px",
                                        backgroundColor:
                                          be === "chat"
                                            ? B.primaryColor
                                            : "transparent",
                                        color:
                                          be === "chat" ? "white" : B.textColor,
                                        border: "none",
                                        cursor: "pointer",
                                        fontSize: "12px",
                                        fontWeight: "600",
                                        transition: "all 0.2s ease",
                                        display: "flex",
                                        alignItems: "center",
                                        gap: "4px",
                                      },
                                      title: "Chat Mode",
                                      children: [
                                        jsxRuntimeExports.jsx(MessageCircle, {
                                          size: 14,
                                        }),
                                        "Chat",
                                      ],
                                    }),
                                    B.voiceEnabled &&
                                      jsxRuntimeExports.jsxs(motion.button, {
                                        whileHover: { scale: 1.05 },
                                        whileTap: { scale: 0.95 },
                                        onClick: () => pe("voice"),
                                        style: {
                                          padding: "8px 12px",
                                          borderRadius: "8px",
                                          backgroundColor:
                                            be === "voice"
                                              ? B.primaryColor
                                              : "transparent",
                                          color:
                                            be === "voice"
                                              ? "white"
                                              : B.textColor,
                                          border: "none",
                                          cursor: "pointer",
                                          fontSize: "12px",
                                          fontWeight: "600",
                                          transition: "all 0.2s ease",
                                          display: "flex",
                                          alignItems: "center",
                                          gap: "4px",
                                        },
                                        title: "Voice Mode",
                                        children: [
                                          jsxRuntimeExports.jsx(Phone, {
                                            size: 14,
                                          }),
                                          "Voice",
                                        ],
                                      }),
                                    B.videoEnabled &&
                                      jsxRuntimeExports.jsxs(motion.button, {
                                        whileHover: { scale: 1.05 },
                                        whileTap: { scale: 0.95 },
                                        onClick: () => pe("video"),
                                        style: {
                                          padding: "8px 12px",
                                          borderRadius: "8px",
                                          backgroundColor:
                                            be === "video"
                                              ? B.primaryColor
                                              : "transparent",
                                          color:
                                            be === "video"
                                              ? "white"
                                              : B.textColor,
                                          border: "none",
                                          cursor: "pointer",
                                          fontSize: "12px",
                                          fontWeight: "600",
                                          transition: "all 0.2s ease",
                                          display: "flex",
                                          alignItems: "center",
                                          gap: "4px",
                                        },
                                        title: "Video Mode",
                                        children: [
                                          jsxRuntimeExports.jsx(Video, {
                                            size: 14,
                                          }),
                                          "Video",
                                        ],
                                      }),
                                  ],
                                }),
                            }),
                            !ne &&
                              jsxRuntimeExports.jsxs(
                                jsxRuntimeExports.Fragment,
                                {
                                  children: [
                                    be === "chat" &&
                                      jsxRuntimeExports.jsx("div", {
                                        className: "chat-messages",
                                        style: {
                                          flex: 1,
                                          minHeight: 0,
                                          overflowY: "auto",
                                          padding: "14px",
                                          backgroundColor: B.backgroundColor,
                                          maxHeight: "none",
                                        },
                                        children: jsxRuntimeExports.jsxs(
                                          "div",
                                          {
                                            className: "chat-messages",
                                            style: {
                                              display: "flex",
                                              flexDirection: "column",
                                              gap: "20px",
                                            },
                                            children: [
                                              jsxRuntimeExports.jsxs(
                                                AnimatePresence,
                                                {
                                                  children: [
                                                    $.length === 0 &&
                                                      jsxRuntimeExports.jsxs(
                                                        motion.div,
                                                        {
                                                          initial: {
                                                            opacity: 0,
                                                            y: 20,
                                                          },
                                                          animate: {
                                                            opacity: 1,
                                                            y: 0,
                                                          },
                                                          style: {
                                                            textAlign: "center",
                                                            padding: "40px 0",
                                                          },
                                                          children: [
                                                            jsxRuntimeExports.jsxs(
                                                              motion.div,
                                                              {
                                                                animate: {
                                                                  scale: [
                                                                    1, 1.1, 1,
                                                                  ],
                                                                  rotate: [
                                                                    0, 5, -5, 0,
                                                                  ],
                                                                },
                                                                transition: {
                                                                  duration: 4,
                                                                  repeat: 1 / 0,
                                                                  ease: "easeInOut",
                                                                },
                                                                style: {
                                                                  width: "60px",
                                                                  height:
                                                                    "60px",
                                                                  margin:
                                                                    "0 auto 24px",
                                                                  borderRadius:
                                                                    "50%",
                                                                  display:
                                                                    "flex",
                                                                  alignItems:
                                                                    "center",
                                                                  justifyContent:
                                                                    "center",
                                                                  background: `linear-gradient(135deg, ${B.primaryColor}20, ${B.secondaryColor}20)`,
                                                                  color:
                                                                    B.primaryColor,
                                                                  position:
                                                                    "relative",
                                                                  overflow:
                                                                    "hidden",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsx(
                                                                    Bot,
                                                                    { size: 40 }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    motion.div,
                                                                    {
                                                                      animate: {
                                                                        rotate:
                                                                          [
                                                                            0,
                                                                            360,
                                                                          ],
                                                                      },
                                                                      transition:
                                                                        {
                                                                          duration: 8,
                                                                          repeat:
                                                                            1 /
                                                                            0,
                                                                          ease: "linear",
                                                                        },
                                                                      style: {
                                                                        position:
                                                                          "absolute",
                                                                        inset:
                                                                          "-10px",
                                                                        border: `2px solid ${B.primaryColor}30`,
                                                                        borderTop: `2px solid ${B.primaryColor}`,
                                                                        borderRadius:
                                                                          "50%",
                                                                      },
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "h3",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "18px",
                                                                  fontWeight:
                                                                    "600",
                                                                  color:
                                                                    B.textColor,
                                                                  margin:
                                                                    "0 0 8px 0",
                                                                },
                                                                children:
                                                                  "AI Assistant is Ready",
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "p",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "14px",
                                                                  opacity: 0.7,
                                                                  color:
                                                                    B.textColor,
                                                                  margin: 0,
                                                                  lineHeight: 1.5,
                                                                },
                                                                children:
                                                                  "Start a conversation with our intelligent AI assistant. Ask questions, get help, or just chat!",
                                                              }
                                                            ),
                                                          ],
                                                        }
                                                      ),
                                                    $.map((We, tt) =>
                                                      jsxRuntimeExports.jsx(
                                                        motion.div,
                                                        {
                                                          initial: {
                                                            opacity: 0,
                                                            y: 20,
                                                            scale: 0.95,
                                                          },
                                                          animate: {
                                                            opacity: 1,
                                                            y: 0,
                                                            scale: 1,
                                                          },
                                                          exit: {
                                                            opacity: 0,
                                                            y: -20,
                                                            scale: 0.95,
                                                          },
                                                          transition: {
                                                            duration: 0.3,
                                                            delay: tt * 0.05,
                                                          },
                                                          style: {
                                                            display: "flex",
                                                            justifyContent:
                                                              We.sender ===
                                                              "user"
                                                                ? "flex-end"
                                                                : "flex-start",
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsxs(
                                                              "div",
                                                              {
                                                                style: {
                                                                  maxWidth:
                                                                    "80%",
                                                                  padding:
                                                                    "12px 16px",
                                                                  borderRadius:
                                                                    "18px",
                                                                  backgroundColor:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? B.userMessageBgColor
                                                                      : B.aiMessageBgColor,
                                                                  color:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? "white"
                                                                      : B.textColor,
                                                                  fontSize:
                                                                    B.fontSize,
                                                                  position:
                                                                    "relative",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsxs(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        marginBottom:
                                                                          "4px",
                                                                        display:
                                                                          "flex",
                                                                        alignItems:
                                                                          "center",
                                                                      },
                                                                      children:
                                                                        [
                                                                          We.sender ===
                                                                          "user"
                                                                            ? jsxRuntimeExports.jsx(
                                                                                User,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.headerFooterBgColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              )
                                                                            : jsxRuntimeExports.jsx(
                                                                                Bot,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.primaryColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              ),
                                                                          We.sender ===
                                                                          "user"
                                                                            ? "You"
                                                                            : B.companyName,
                                                                        ],
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    Markdown,
                                                                    {
                                                                      children:
                                                                        We.content,
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        fontSize:
                                                                          "11px",
                                                                        opacity: 0.7,
                                                                        marginTop:
                                                                          "4px",
                                                                      },
                                                                      children:
                                                                        Qe(
                                                                          We.timestamp
                                                                        ),
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                        },
                                                        We.id
                                                      )
                                                    ),
                                                  ],
                                                }
                                              ),
                                              Q &&
                                                jsxRuntimeExports.jsx(
                                                  motion.div,
                                                  {
                                                    initial: {
                                                      opacity: 0,
                                                      y: 10,
                                                    },
                                                    animate: {
                                                      opacity: 1,
                                                      y: 0,
                                                    },
                                                    style: {
                                                      display: "flex",
                                                      alignItems: "center",
                                                      gap: "12px",
                                                    },
                                                    children:
                                                      jsxRuntimeExports.jsx(
                                                        "div",
                                                        {
                                                          style: {
                                                            padding:
                                                              "12px 16px",
                                                            borderRadius:
                                                              "18px",
                                                            backgroundColor:
                                                              B.aiMessageBgColor,
                                                            color: B.textColor,
                                                            fontSize:
                                                              B.fontSize,
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsx(
                                                              ct,
                                                              {}
                                                            ),
                                                        }
                                                      ),
                                                  }
                                                ),
                                              jsxRuntimeExports.jsx("div", {
                                                ref: je,
                                              }),
                                            ],
                                          }
                                        ),
                                      }),
                                    be === "voice" &&
                                      jsxRuntimeExports.jsx("div", {
                                        className: "chat-messages",
                                        style: {
                                          flex: 1,
                                          minHeight: 0,
                                          overflowY: "auto",
                                          padding: "14px",
                                          backgroundColor: B.backgroundColor,
                                          maxHeight: "none",
                                        },
                                        children: jsxRuntimeExports.jsxs(
                                          "div",
                                          {
                                            style: {
                                              display: "flex",
                                              flexDirection: "column",
                                              gap: "20px",
                                            },
                                            children: [
                                              jsxRuntimeExports.jsxs(
                                                AnimatePresence,
                                                {
                                                  children: [
                                                    $.length === 0 &&
                                                      jsxRuntimeExports.jsxs(
                                                        "div",
                                                        {
                                                          style: {
                                                            textAlign: "center",
                                                          },
                                                          children: [
                                                            jsxRuntimeExports.jsxs(
                                                              motion.div,
                                                              {
                                                                animate: {
                                                                  scale: [
                                                                    1, 1.1, 1,
                                                                  ],
                                                                  opacity: [
                                                                    0.8, 1, 0.8,
                                                                  ],
                                                                },
                                                                transition: {
                                                                  duration: 2,
                                                                  repeat: 1 / 0,
                                                                  ease: "easeInOut",
                                                                },
                                                                style: {
                                                                  width:
                                                                    "100px",
                                                                  height:
                                                                    "100px",
                                                                  margin:
                                                                    "36px auto 24px",
                                                                  borderRadius:
                                                                    "50%",
                                                                  display:
                                                                    "flex",
                                                                  alignItems:
                                                                    "center",
                                                                  justifyContent:
                                                                    "center",
                                                                  background: `linear-gradient(135deg, ${B.primaryColor}20, ${B.secondaryColor}20)`,
                                                                  color:
                                                                    B.primaryColor,
                                                                  position:
                                                                    "relative",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsx(
                                                                    Volume2,
                                                                    {}
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    motion.div,
                                                                    {
                                                                      animate: {
                                                                        scale: [
                                                                          1,
                                                                          1.5,
                                                                          1,
                                                                        ],
                                                                        opacity:
                                                                          [
                                                                            0.5,
                                                                            0,
                                                                            0.5,
                                                                          ],
                                                                      },
                                                                      transition:
                                                                        {
                                                                          duration: 2,
                                                                          repeat:
                                                                            1 /
                                                                            0,
                                                                          ease: "easeInOut",
                                                                        },
                                                                      style: {
                                                                        position:
                                                                          "absolute",
                                                                        inset: 0,
                                                                        border: `2px solid ${B.primaryColor}`,
                                                                        borderRadius:
                                                                          "50%",
                                                                      },
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "h3",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "18px",
                                                                  fontWeight:
                                                                    "600",
                                                                  color:
                                                                    B.textColor,
                                                                  margin:
                                                                    "0 0 16px 0",
                                                                },
                                                                children:
                                                                  "Voice Assistant is Ready",
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "p",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "14px",
                                                                  opacity: 0.7,
                                                                  color:
                                                                    B.textColor,
                                                                  margin:
                                                                    "0 0 24px 0",
                                                                },
                                                                children:
                                                                  "Click the microphone to start voice conversation",
                                                              }
                                                            ),
                                                          ],
                                                        }
                                                      ),
                                                    $.map((We, tt) =>
                                                      jsxRuntimeExports.jsx(
                                                        motion.div,
                                                        {
                                                          initial: {
                                                            opacity: 0,
                                                            y: 20,
                                                            scale: 0.95,
                                                          },
                                                          animate: {
                                                            opacity: 1,
                                                            y: 0,
                                                            scale: 1,
                                                          },
                                                          exit: {
                                                            opacity: 0,
                                                            y: -20,
                                                            scale: 0.95,
                                                          },
                                                          transition: {
                                                            duration: 0.3,
                                                            delay: tt * 0.05,
                                                          },
                                                          style: {
                                                            display: "flex",
                                                            width: "100%",
                                                            justifyContent:
                                                              We.sender ===
                                                              "user"
                                                                ? "flex-end"
                                                                : "flex-start",
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsxs(
                                                              "div",
                                                              {
                                                                style: {
                                                                  maxWidth:
                                                                    "80%",
                                                                  padding:
                                                                    "12px 16px",
                                                                  borderRadius:
                                                                    "18px",
                                                                  backgroundColor:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? B.userMessageBgColor
                                                                      : B.aiMessageBgColor,
                                                                  color:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? "white"
                                                                      : B.textColor,
                                                                  fontSize:
                                                                    B.fontSize,
                                                                  position:
                                                                    "relative",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsxs(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        marginBottom:
                                                                          "4px",
                                                                        display:
                                                                          "flex",
                                                                        alignItems:
                                                                          "center",
                                                                      },
                                                                      children:
                                                                        [
                                                                          We.sender ===
                                                                          "user"
                                                                            ? jsxRuntimeExports.jsx(
                                                                                User,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.headerFooterBgColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              )
                                                                            : jsxRuntimeExports.jsx(
                                                                                Bot,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.primaryColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              ),
                                                                          We.sender ===
                                                                          "user"
                                                                            ? "You"
                                                                            : B.companyName,
                                                                        ],
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    Markdown,
                                                                    {
                                                                      children:
                                                                        We.content,
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        fontSize:
                                                                          "11px",
                                                                        opacity: 0.7,
                                                                        marginTop:
                                                                          "4px",
                                                                      },
                                                                      children:
                                                                        Qe(
                                                                          We.timestamp
                                                                        ),
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                        },
                                                        We.id
                                                      )
                                                    ),
                                                  ],
                                                }
                                              ),
                                              Q &&
                                                jsxRuntimeExports.jsx(
                                                  motion.div,
                                                  {
                                                    initial: {
                                                      opacity: 0,
                                                      y: 10,
                                                    },
                                                    animate: {
                                                      opacity: 1,
                                                      y: 0,
                                                    },
                                                    style: {
                                                      display: "flex",
                                                      alignItems: "center",
                                                      gap: "12px",
                                                    },
                                                    children:
                                                      jsxRuntimeExports.jsx(
                                                        "div",
                                                        {
                                                          style: {
                                                            padding:
                                                              "12px 16px",
                                                            borderRadius:
                                                              "18px",
                                                            backgroundColor:
                                                              B.aiMessageBgColor,
                                                            color: B.textColor,
                                                            fontSize:
                                                              B.fontSize,
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsx(
                                                              ct,
                                                              {}
                                                            ),
                                                        }
                                                      ),
                                                  }
                                                ),
                                              jsxRuntimeExports.jsx("div", {
                                                ref: je,
                                              }),
                                            ],
                                          }
                                        ),
                                      }),
                                    be == "video" &&
                                      jsxRuntimeExports.jsx("div", {
                                        className: "chat-messages",
                                        style: {
                                          flex: 1,
                                          minHeight: 0,
                                          overflowY: "auto",
                                          padding: "24px",
                                          backgroundColor: B.backgroundColor,
                                          maxHeight: "none",
                                        },
                                        children: jsxRuntimeExports.jsxs(
                                          "div",
                                          {
                                            style: {
                                              display: "flex",
                                              flexDirection: "column",
                                              gap: "20px",
                                            },
                                            children: [
                                              jsxRuntimeExports.jsxs(
                                                AnimatePresence,
                                                {
                                                  children: [
                                                    $.length === 0 &&
                                                      jsxRuntimeExports.jsxs(
                                                        motion.div,
                                                        {
                                                          initial: {
                                                            opacity: 0,
                                                            y: 20,
                                                          },
                                                          animate: {
                                                            opacity: 1,
                                                            y: 0,
                                                          },
                                                          style: {
                                                            textAlign: "center",
                                                            padding: "40px 0",
                                                          },
                                                          children: [
                                                            jsxRuntimeExports.jsxs(
                                                              motion.div,
                                                              {
                                                                animate: {
                                                                  scale: [
                                                                    1, 1.1, 1,
                                                                  ],
                                                                  rotate: [
                                                                    0, 5, -5, 0,
                                                                  ],
                                                                },
                                                                transition: {
                                                                  duration: 4,
                                                                  repeat: 1 / 0,
                                                                  ease: "easeInOut",
                                                                },
                                                                style: {
                                                                  width: "60px",
                                                                  height:
                                                                    "60px",
                                                                  margin:
                                                                    "0 auto 24px",
                                                                  borderRadius:
                                                                    "50%",
                                                                  display:
                                                                    "flex",
                                                                  alignItems:
                                                                    "center",
                                                                  justifyContent:
                                                                    "center",
                                                                  background: `linear-gradient(135deg, ${B.primaryColor}20, ${B.secondaryColor}20)`,
                                                                  color:
                                                                    B.primaryColor,
                                                                  position:
                                                                    "relative",
                                                                  overflow:
                                                                    "hidden",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsx(
                                                                    Bot,
                                                                    { size: 40 }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    motion.div,
                                                                    {
                                                                      animate: {
                                                                        rotate:
                                                                          [
                                                                            0,
                                                                            360,
                                                                          ],
                                                                      },
                                                                      transition:
                                                                        {
                                                                          duration: 8,
                                                                          repeat:
                                                                            1 /
                                                                            0,
                                                                          ease: "linear",
                                                                        },
                                                                      style: {
                                                                        position:
                                                                          "absolute",
                                                                        inset:
                                                                          "-10px",
                                                                        border: `2px solid ${B.primaryColor}30`,
                                                                        borderTop: `2px solid ${B.primaryColor}`,
                                                                        borderRadius:
                                                                          "50%",
                                                                      },
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "h3",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "18px",
                                                                  fontWeight:
                                                                    "600",
                                                                  color:
                                                                    B.textColor,
                                                                  margin:
                                                                    "0 0 8px 0",
                                                                },
                                                                children:
                                                                  "Video Assistant is Ready",
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              "p",
                                                              {
                                                                style: {
                                                                  fontSize:
                                                                    "14px",
                                                                  opacity: 0.7,
                                                                  color:
                                                                    B.textColor,
                                                                  margin: 0,
                                                                  lineHeight: 1.5,
                                                                },
                                                                children:
                                                                  "Start a conversation with our intelligent AI assistant. Ask questions, get help, or just chat!",
                                                              }
                                                            ),
                                                            jsxRuntimeExports.jsx(
                                                              motion.button,
                                                              {
                                                                whileHover: {
                                                                  scale: 1.08,
                                                                  boxShadow:
                                                                    "0 4px 24px rgba(0,0,0,0.15)",
                                                                },
                                                                whileTap: {
                                                                  scale: 0.96,
                                                                },
                                                                animate: {
                                                                  scale: [
                                                                    1, 1.08, 1,
                                                                  ],
                                                                  boxShadow: [
                                                                    "0 2px 8px rgba(0,0,0,0.10)",
                                                                    "0 6px 24px rgba(0,0,0,0.18)",
                                                                    "0 2px 8px rgba(0,0,0,0.10)",
                                                                  ],
                                                                },
                                                                transition: {
                                                                  duration: 1.5,
                                                                  repeat: 1 / 0,
                                                                  ease: "easeInOut",
                                                                },
                                                                style: {
                                                                  background: `linear-gradient(135deg, ${B.primaryColor}, ${B.secondaryColor})`,
                                                                  color:
                                                                    "white",
                                                                  border:
                                                                    "none",
                                                                  borderRadius:
                                                                    "24px",
                                                                  padding:
                                                                    "12px 32px",
                                                                  fontWeight: 600,
                                                                  fontSize:
                                                                    "16px",
                                                                  cursor:
                                                                    "pointer",
                                                                  marginTop:
                                                                    "18px",
                                                                  boxShadow:
                                                                    "0 2px 8px rgba(0,0,0,0.10)",
                                                                  outline:
                                                                    "none",
                                                                },
                                                                onClick: () =>
                                                                  Ae(!0),
                                                                children:
                                                                  "Start call",
                                                              }
                                                            ),
                                                          ],
                                                        }
                                                      ),
                                                    $.map((We, tt) =>
                                                      jsxRuntimeExports.jsx(
                                                        motion.div,
                                                        {
                                                          initial: {
                                                            opacity: 0,
                                                            y: 20,
                                                            scale: 0.95,
                                                          },
                                                          animate: {
                                                            opacity: 1,
                                                            y: 0,
                                                            scale: 1,
                                                          },
                                                          exit: {
                                                            opacity: 0,
                                                            y: -20,
                                                            scale: 0.95,
                                                          },
                                                          transition: {
                                                            duration: 0.3,
                                                            delay: tt * 0.05,
                                                          },
                                                          style: {
                                                            display: "flex",
                                                            justifyContent:
                                                              We.sender ===
                                                              "user"
                                                                ? "flex-end"
                                                                : "flex-start",
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsxs(
                                                              "div",
                                                              {
                                                                style: {
                                                                  maxWidth:
                                                                    "80%",
                                                                  padding:
                                                                    "12px 16px",
                                                                  borderRadius:
                                                                    "18px",
                                                                  backgroundColor:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? B.userMessageBgColor
                                                                      : B.aiMessageBgColor,
                                                                  color:
                                                                    We.sender ===
                                                                    "user"
                                                                      ? "white"
                                                                      : B.textColor,
                                                                  fontSize:
                                                                    B.fontSize,
                                                                  position:
                                                                    "relative",
                                                                },
                                                                children: [
                                                                  jsxRuntimeExports.jsxs(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        marginBottom:
                                                                          "4px",
                                                                        display:
                                                                          "flex",
                                                                        alignItems:
                                                                          "center",
                                                                      },
                                                                      children:
                                                                        [
                                                                          We.sender ===
                                                                          "user"
                                                                            ? jsxRuntimeExports.jsx(
                                                                                User,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.headerFooterBgColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              )
                                                                            : jsxRuntimeExports.jsx(
                                                                                Bot,
                                                                                {
                                                                                  size: 20,
                                                                                  style:
                                                                                    {
                                                                                      marginRight:
                                                                                        "8px",
                                                                                      color:
                                                                                        "black",
                                                                                      backgroundColor:
                                                                                        B.primaryColor,
                                                                                      padding:
                                                                                        "5px",
                                                                                      borderRadius:
                                                                                        "50%",
                                                                                    },
                                                                                }
                                                                              ),
                                                                          We.sender ===
                                                                          "user"
                                                                            ? "You"
                                                                            : B.companyName,
                                                                        ],
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    Markdown,
                                                                    {
                                                                      children:
                                                                        We.content,
                                                                    }
                                                                  ),
                                                                  jsxRuntimeExports.jsx(
                                                                    "div",
                                                                    {
                                                                      style: {
                                                                        fontSize:
                                                                          "11px",
                                                                        opacity: 0.7,
                                                                        marginTop:
                                                                          "4px",
                                                                      },
                                                                      children:
                                                                        Qe(
                                                                          We.timestamp
                                                                        ),
                                                                    }
                                                                  ),
                                                                ],
                                                              }
                                                            ),
                                                        },
                                                        We.id
                                                      )
                                                    ),
                                                  ],
                                                }
                                              ),
                                              Q &&
                                                jsxRuntimeExports.jsx(
                                                  motion.div,
                                                  {
                                                    initial: {
                                                      opacity: 0,
                                                      y: 10,
                                                    },
                                                    animate: {
                                                      opacity: 1,
                                                      y: 0,
                                                    },
                                                    style: {
                                                      display: "flex",
                                                      alignItems: "center",
                                                      gap: "12px",
                                                    },
                                                    children:
                                                      jsxRuntimeExports.jsx(
                                                        "div",
                                                        {
                                                          style: {
                                                            padding:
                                                              "12px 16px",
                                                            borderRadius:
                                                              "18px",
                                                            backgroundColor:
                                                              B.aiMessageBgColor,
                                                            color: B.textColor,
                                                            fontSize:
                                                              B.fontSize,
                                                          },
                                                          children:
                                                            jsxRuntimeExports.jsx(
                                                              ct,
                                                              {}
                                                            ),
                                                        }
                                                      ),
                                                  }
                                                ),
                                              jsxRuntimeExports.jsx("div", {
                                                ref: je,
                                              }),
                                            ],
                                          }
                                        ),
                                      }),
                                  ],
                                }
                              ),
                            be === "chat" &&
                              !Fe &&
                              jsxRuntimeExports.jsx(motion.div, {
                                initial: { y: 20, opacity: 0 },
                                animate: { y: 0, opacity: 1 },
                                transition: { delay: 0.3 },
                                style: {
                                  borderTop: `1px solid ${B.primaryColor}15`,
                                  background: `linear-gradient(135deg, ${B.inputContainerBgColor}, ${B.inputContainerBgColor}f0)`,
                                  padding: "16px",
                                },
                                children: jsxRuntimeExports.jsx("div", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    gap: "8px",
                                  },
                                  children: jsxRuntimeExports.jsxs("div", {
                                    style: {
                                      position: "relative",
                                      flex: 1,
                                      display: "flex",
                                      alignItems: "center",
                                    },
                                    children: [
                                      jsxRuntimeExports.jsx("input", {
                                        ref: xe,
                                        type: "text",
                                        value: G,
                                        onChange: (We) => Y(We.target.value),
                                        onKeyPress: De,
                                        placeholder: "Type your message...",
                                        disabled: Q,
                                        style: {
                                          width: "100%",
                                          padding: "12px 16px",
                                          paddingRight: "120px",
                                          borderRadius: "24px",
                                          border: `1px solid ${B.primaryColor}20`,
                                          backgroundColor: B.backgroundColor,
                                          color: B.textColor,
                                          fontSize: B.fontSize,
                                          outline: "none",
                                        },
                                      }),
                                      jsxRuntimeExports.jsx("div", {
                                        style: {
                                          position: "absolute",
                                          right: "8px",
                                          display: "flex",
                                          alignItems: "center",
                                          gap: "4px",
                                          border: "none",
                                        },
                                        children: jsxRuntimeExports.jsx(
                                          "button",
                                          {
                                            onClick: Je,
                                            disabled: !G.trim() || Q,
                                            style: {
                                              backgroundColor:
                                                G.trim() && !Q
                                                  ? B.primaryColor
                                                  : B.primaryColor + "70",
                                              border: "none",
                                              cursor:
                                                G.trim() && !Q
                                                  ? "pointer"
                                                  : "not-allowed",
                                              padding: "8px",
                                              borderRadius: "50%",
                                              color: "white",
                                              display: "flex",
                                              alignItems: "center",
                                              justifyContent: "center",
                                            },
                                            children: Q
                                              ? jsxRuntimeExports.jsx(
                                                  LoaderCircle,
                                                  {
                                                    size: 16,
                                                    style: {
                                                      animation:
                                                        "spin 1s linear infinite",
                                                    },
                                                  }
                                                )
                                              : jsxRuntimeExports.jsx(Send, {
                                                  size: 16,
                                                }),
                                          }
                                        ),
                                      }),
                                    ],
                                  }),
                                }),
                              }),
                            be === "voice" &&
                              !Fe &&
                              jsxRuntimeExports.jsx(motion.div, {
                                initial: { y: 20, opacity: 0 },
                                animate: { y: 0, opacity: 1 },
                                transition: { delay: 0.3 },
                                style: {
                                  backgroundColor: B.inputContainerBgColor,
                                  padding: "16px",
                                  borderTop: `1px solid ${B.primaryColor}20`,
                                },
                                children: jsxRuntimeExports.jsx("div", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    gap: "8px",
                                  },
                                  children: jsxRuntimeExports.jsx("div", {
                                    style: {
                                      position: "relative",
                                      flex: 1,
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                    },
                                    children: jsxRuntimeExports.jsx(
                                      VoiceAgent,
                                      {
                                        messages: $,
                                        setMessages: (We) =>
                                          H((tt) => [...tt, We]),
                                        setGenerating: X,
                                        prompt: B.prompt || "",
                                        clientKey: U,
                                        apiUrl: V,
                                        sessionId: ve || void 0,
                                        theme: B,
                                      }
                                    ),
                                  }),
                                }),
                              }),
                            be === "video" &&
                              !Fe &&
                              $.length !== 0 &&
                              jsxRuntimeExports.jsx(motion.div, {
                                initial: { y: 20, opacity: 0 },
                                animate: { y: 0, opacity: 1 },
                                transition: { delay: 0.3 },
                                style: {
                                  backgroundColor: B.inputContainerBgColor,
                                  padding: "16px",
                                  borderTop: `1px solid ${B.primaryColor}20`,
                                },
                                children: jsxRuntimeExports.jsx("div", {
                                  style: {
                                    display: "flex",
                                    alignItems: "center",
                                    gap: "8px",
                                  },
                                  children: jsxRuntimeExports.jsx("div", {
                                    style: {
                                      position: "relative",
                                      flex: 1,
                                      display: "flex",
                                      alignItems: "center",
                                      justifyContent: "center",
                                    },
                                    children: jsxRuntimeExports.jsx(
                                      motion.button,
                                      {
                                        whileHover: {
                                          scale: 1.08,
                                          boxShadow:
                                            "0 4px 24px rgba(0,0,0,0.15)",
                                        },
                                        whileTap: { scale: 0.96 },
                                        animate: {
                                          scale: [1, 1.08, 1],
                                          boxShadow: [
                                            "0 2px 8px rgba(0,0,0,0.10)",
                                            "0 6px 24px rgba(0,0,0,0.18)",
                                            "0 2px 8px rgba(0,0,0,0.10)",
                                          ],
                                        },
                                        transition: {
                                          duration: 1.5,
                                          repeat: 1 / 0,
                                          ease: "easeInOut",
                                        },
                                        style: {
                                          background: `linear-gradient(135deg, ${B.primaryColor}, ${B.secondaryColor})`,
                                          color: "white",
                                          border: "none",
                                          borderRadius: "24px",
                                          padding: "12px 32px",
                                          fontWeight: 600,
                                          fontSize: "16px",
                                          cursor: "pointer",
                                          boxShadow:
                                            "0 2px 8px rgba(0,0,0,0.10)",
                                          outline: "none",
                                        },
                                        onClick: () => Ae(!0),
                                        children: "Restart call",
                                      }
                                    ),
                                  }),
                                }),
                              }),
                            jsxRuntimeExports.jsx(motion.div, {
                              initial: { opacity: 0 },
                              animate: { opacity: 1 },
                              transition: { delay: 0.3 },
                              style: {
                                padding: "8px 16px",
                                textAlign: "center",
                                borderTop: `1px solid ${B.primaryColor}15`,
                                backgroundColor: B.headerFooterBgColor,
                                borderBottomLeftRadius: B.borderRadius,
                                borderBottomRightRadius: B.borderRadius,
                              },
                              children: jsxRuntimeExports.jsxs("div", {
                                style: {
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  gap: "8px",
                                  fontSize: "12px",
                                  opacity: 0.75,
                                  color: B.textColor,
                                },
                                children: [
                                  jsxRuntimeExports.jsx("img", {
                                    src: "https://exthalpy-public-bucket.blr1.cdn.digitaloceanspaces.com/logo-x-white.png",
                                    alt: "Company Logo",
                                    style: { width: "32px", height: "32px" },
                                  }),
                                  jsxRuntimeExports.jsx("span", {
                                    children: "Powered by Exthalpy",
                                  }),
                                ],
                              }),
                            }),
                          ],
                        }),
                    }),
              ],
            }),
            jsxRuntimeExports.jsx("style", {
              children: `
          @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
          }
        `,
            }),
          ],
        })
      : jsxRuntimeExports.jsx("div", {
          style: {
            position: "fixed",
            bottom: "16px",
            right: "16px",
            zIndex: 50,
          },
          children: jsxRuntimeExports.jsx("div", {
            style: {
              width: "64px",
              height: "64px",
              borderRadius: "50%",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              background: "linear-gradient(135deg, #667eea 0%, #764ba2 100%)",
              boxShadow: "0 8px 32px rgba(0, 0, 0, 0.3)",
              border: "2px solid rgba(255, 255, 255, 0.2)",
            },
            children: jsxRuntimeExports.jsx(motion.div, {
              animate: { rotate: 360 },
              transition: { duration: 2, repeat: 1 / 0, ease: "linear" },
              children: jsxRuntimeExports.jsx(Sparkles, {
                size: 28,
                color: "white",
              }),
            }),
          }),
        });
  }
  window.ChatBotWidget = {
    mount: (U, j) => {
      const V = clientExports.createRoot(U);
      return (
        V.render(
          jsxRuntimeExports.jsx(App, {
            clientKey: j.clientKey,
            customUserId: j.customUserId,
          })
        ),
        {
          destroy: () => {
            V.unmount(), U.parentNode && U.parentNode.removeChild(U);
          },
        }
      );
    },
    mountLegacy: (U = "body", j = "123456789") => {
      const V = document.createElement("div");
      (V.id = "chat-bot-widget-root"),
        document.querySelector(U)?.appendChild(V),
        clientExports
          .createRoot(V)
          .render(jsxRuntimeExports.jsx(App, { clientKey: j }));
    },
  };
})();
